WEBVTT

00:00.000 --> 00:01.000
Aiaiai!

00:30.000 --> 00:58.120
So jetzt bin ich da, Pog, oder not Pog, mal gucken, Leute manche lernen es echt nicht,

00:58.120 --> 01:03.700
ja ich bekomme jetzt zum hundertsten Mal eine Anfrage, ob ich nicht an der Opera GX

01:03.700 --> 01:08.400
Campaign teilnehmen will, dabei habe ich mit denen schon vor einer ganzen Weile mal geschrieben

01:08.400 --> 01:17.120
und da sind wir zu dem Schluss gekommen, dass die gar nicht wollen, ich hab die gefragt

01:17.120 --> 01:21.280
wie das ist, ob ich den Kram auch wirklich ausprobieren muss und ob ich dann auch wirklich

01:21.280 --> 01:26.400
sagen darf was ich von halte, weil das letzte Mal wo ich Opera GX ausprobiert hab war ich

01:26.400 --> 01:30.120
jetzt nicht so wahnsinnig überzeugt von, da haben sie gesagt ne ne, dann lieber nicht,

01:30.120 --> 01:34.000
so und jetzt fragen die mich trotzdem die ganze Zeit, als hätte sich das irgendwie

01:34.000 --> 01:41.600
geändert, weiß auch nicht, gut die haben da irgendwie 500 Marketing Agenturen engagiert,

01:41.600 --> 01:49.840
die sind da halt immer sehr hartnäckig, dann hat mich irgendein China Chinesen Hersteller

01:49.840 --> 01:57.480
invited ihr neues Smartphone anzugucken, ein Dogi Smartphone, wenn ihr noch nie was davon

01:57.480 --> 02:09.040
gehört habt, macht nix, ich auch nicht, aber Dogi Smartphone soll ich bewerben, alles klar,

02:09.040 --> 02:10.040
gibt es die überhaupt?

02:10.040 --> 02:20.080
Ich muss mal kurz danach suchen, Dogi Smartphone, China Handys, ok die gibt es tatsächlich,

02:20.080 --> 02:31.520
Dogi Smartphone schon nie gehört, dann irgendwelche anderen, das ist immer der gleiche Kram ey,

02:31.520 --> 02:36.440
bei Hetzner muss ich antworten, die haben ne neue Mail geschrieben seh ich grad, Fockchamp,

02:36.440 --> 02:48.640
ja so siehts aus, wir machen heute n bisschen weiter, ich hab gestern schon einiges aufgefrischt

02:48.640 --> 02:56.520
und gelernt, ist ja nicht so als bin ich der krasse Paarst, Bro, Pro, nicht Bro, Pro und

02:56.520 --> 03:06.640
ich hab mir gestern noch zwei Tutorials angeguckt, nehm ich allgemein und was zu AsyncIO, guck

03:06.640 --> 03:16.120
mal ob ich das jetzt auf die Reihe krieg, es hört sich an wie irgendein Grieche oder

03:16.120 --> 03:33.440
so, ja, Toxy danke für den Zap, so ich mach mal schnell die VM an, aber erst muss ich

03:33.440 --> 03:42.200
auf meinem Vorschaurechner kurz n bisschen Zeug ausmachen, da läuft nämlich zu viel,

03:42.200 --> 03:47.320
das versteh ich auch nicht wie das sein kann, ich versteh eh nicht was da gehyped wurde,

03:47.320 --> 03:52.960
du meinst diese komische Ölplattform Mission, das war die nichts sagende Call of Duty Kampagnen

03:52.960 --> 03:56.720
Mission, die ich je gesehen hab, außer das ist n bisschen halt ein Wettwerk von Modern

03:56.720 --> 04:02.760
Warfare 1 erinnert und das halt pure Absicht ist, weil Nostalgie, Bait und so, ich weiß

04:02.760 --> 04:07.360
nicht was man daran großartig hypen kann, das ist mir unbegreiflicher, oder gibt's

04:07.360 --> 04:12.400
zwar was neueres, was ich noch nicht gesehen hab, ach jetzt weiß ich auch warum man Vorschaurechner

04:12.400 --> 04:16.600
so rumspackt, weil Avira mal wieder die Festplatte scannt, warum hab ich den Scheiß da überhaupt

04:16.600 --> 04:19.440
noch drauf, ja ich weiß, weil ich den vor 10 Jahren mal installiert hab und nicht wieder

04:19.440 --> 04:32.040
runter geschmissen hab, Monka Essen, Avira wer installiert auch so ein Crap, machen wir

04:32.040 --> 04:46.600
hier mal an, Shriger Massive Subscription, ja aber sowas von, wieso der Desktop ist Pock,

04:46.600 --> 04:50.000
ich weiß gar nicht warum das so viele Leute immer schockt, also ersten sind hier noch

04:50.000 --> 04:56.040
mehrere Desktop Icons frei, für potenzielle, ja hier haben wir eine Datei Kekkel, wie wir

04:56.040 --> 05:06.760
ja alle wissen, essenziell, mal erstmal weg, glaubt nix wichtiges, Kekkel, so jetzt haben

05:06.760 --> 05:25.720
wir mal gestern stehen geblieben, Arsch by the way, so also wir haben gestern geübt und

05:25.720 --> 05:29.960
wir sind bei folgender Sache stehen geblieben, wir haben einen Mini Speedtest selbst programmiert,

05:29.960 --> 05:37.360
so und wir sind stehen geblieben hierbei, bei einem Speedtest, der, au Moment, hab ich

05:37.360 --> 05:41.920
noch, ja ich hab noch Bandbreite gedrosselt, ich muss die Bandbreite drosseln in der VM,

05:41.920 --> 05:48.560
weil ansonsten der Stream abkackt, also wir können maximal 40 Mbit durchbekommen durch

05:48.560 --> 05:56.280
den Speedtest, reicht ja zum testen aus, ja also wir haben Speedtest gebastelt, der misst

05:56.280 --> 06:00.880
wie schnell der Download, wie schnell die Downloadgeschwindigkeit ist, aber ich bin

06:00.880 --> 06:06.600
jetzt nochmal in mich gegangen, also wir kriegen auch aktuell 35 Mbit durch, ich bin nochmal

06:06.600 --> 06:12.080
in mich gegangen und hab mir überlegt, das ist viel zu kompliziert meine Implementierung

06:12.080 --> 06:19.040
und hat's geruckelt, es hat geruckelt, ne, weil ich grad den, ne, hat nicht geruckelt,

06:19.040 --> 06:24.920
ich muss sagen, ich hab doch die Downloadbegrenzung drin und weil ich gucken will, wie das mit

06:24.920 --> 06:31.360
Async.io auch funktioniert, deswegen werden wir den Kram nochmal zum größten Teil, naja

06:31.360 --> 06:41.560
gut, es ist ja nicht viel, es sind ja im Prinzip, was jetzt, ich glaube es möchte mal neu

06:41.560 --> 06:53.720
gestartet werden oder, wenn schon die Zeilenanzahl rumspackt, anscheinend nicht, genau also das

06:53.720 --> 06:57.000
haben wir gestern gemacht, ein Speedtest, der dann den Download messen kann und ich hab

06:57.000 --> 06:59.920
mir jetzt überlegt, wir machen heute folgendes, weil ich muss ja auch mal ein bisschen was

06:59.920 --> 07:06.440
sinnvolles lernen, was ich dann auch benutzen kann und zwar, wie du die los wirst, ja gar

07:06.440 --> 07:10.240
nicht so wirklich, oh Leute ich hab echt ein Problem, ich hab es ja gestern Abend, ich

07:10.240 --> 07:16.280
glaube ich hatte zu lange Headset auf gestern oder so, wie tut das Ohr links weh, das sticht

07:16.280 --> 07:28.800
so, ab und zu mal links im Ohr, ich geh jetzt aber, Chat sagt nicht, ich soll zum Arzt gehen

07:28.800 --> 07:32.440
oder so, das ist immer das gleiche, der Chat sagt immer, Max geht zum Arzt und ich geh

07:32.440 --> 07:37.160
nicht zum Arzt, Gag weight Alter, ich erwarte auch nicht, dass der Twitch Chat das jetzt

07:37.160 --> 07:41.600
in Remote diagnostizieren kann, aber es ist mir gerade eingefallen wieder, weil es mir,

07:41.600 --> 07:52.480
aha das ist wirklich nervig, es sticht so richtig ins Ohr, der aktuelle ist ja hauptsächlich

07:52.480 --> 07:58.480
Home Office, der sitzt gar nicht neben mir, so also, wisst ihr was mir eingefallen ist,

07:58.480 --> 08:03.080
meine Implementierung ist richtig bescheuert, also für alle die gestern nicht da war, ich

08:03.080 --> 08:08.120
zeige euch mal was wir gemacht haben, mach gar nichts, warte bis es besser wird, ja das

08:08.120 --> 08:18.880
mach ich wahrscheinlich auch, also wir starten, wir starten 4 Threads, 4 Speedtest Threads

08:18.880 --> 08:27.000
und dann messen wir einmal in der Sekunde, wie schnell das ist und dann fassen wir es

08:27.000 --> 08:33.880
hier zusammen, ey ja Ohrschmerz, das ist wirklich nervig, das ist nicht permanent, das ist nur

08:33.880 --> 08:40.200
ab und zu mal, aber dann sticht es so richtig im Ohr, also wenn das echt am Headset liegt,

08:40.200 --> 08:42.800
dann hänge ich es mir heute irgendwie so, keine Ahnung, dann hänge ich es mir irgendwie

08:42.800 --> 08:48.400
um den Hals, aber das ist auch nicht so geil, Drawboard PDF, nein Windows, ich will diesen

08:48.400 --> 09:08.360
Kack, Turn Off All Suggestions, ja wo, wo geht das, hier Bullshit da, braucht kein Mensch,

09:08.360 --> 09:12.040
so also was wir jetzt, also was wir überlegt haben, was wir probieren, wir basteln das um

09:12.040 --> 09:21.480
zu essen und dann habe ich auf, jetzt habe ich noch etwas cooles gefunden und zwar, das

09:21.480 --> 09:28.680
ist eine Python Library mit der man heifheadige Kommando Zeilen Tools machen kann, somit mit

09:28.680 --> 09:37.840
Farbe und Progress Bar und Tabellen und Zeug, ja exellent, da machen wir irgendwie so eine

09:37.840 --> 09:43.000
Anzeige, ich meine es ist ja ziemlich noobig, dass das Ding einmal in der Sekunde einfach

09:43.000 --> 09:49.960
hier irgendwas ausgibt ohne was, das muss schön formatiert sein, das muss schön formatiert

09:49.960 --> 09:58.920
sein, als erstes muss ich aber mal gucken wie man den Krempel umstricken kann zu Async.io,

09:58.920 --> 10:03.000
ich habe mir da gestern extra ein Tutorial angeguckt, dass ich das halbwegs checke wie

10:03.000 --> 10:08.960
es funktioniert und ich glaube ich habe es halbwegs gecheckt, es ist im Endeffekt mehr

10:08.960 --> 10:16.760
oder weniger wie C Sharp Task Async Await nur mit dem Unterschied, dass es standardmäßig

10:16.760 --> 10:23.920
nur einen Thread gibt, also in.NET ist es ja so, da kann ich sagen Thread Run und dann

10:23.920 --> 10:29.400
geht das automatisch in Thread Pool und ich kann das Awaiten, das hier ist eher wie JavaScript,

10:29.400 --> 10:40.560
es gibt nur einen Thread und ich muss meine Tasks sleepen lassen oder Awaiten lassen,

10:40.560 --> 10:45.920
dass es quasi das zurück gibt an die Event Loop und dann der nächste läuft, soweit habe

10:45.920 --> 10:52.040
ich das gestern in dem Tutorial glaube ich verstanden, das heißt von der Idee her, kann

10:52.040 --> 10:57.400
man diesen ganzen Threading Krempel hier rausschmeißen, weil ich habe gelesen das macht man eigentlich

10:57.400 --> 11:03.720
gar nicht mehr, das machen nur noch Python Noobs und wir wollen ja kein Python Noob sein

11:03.720 --> 11:08.320
und selbstverständlich wird das ganze mit RGB deutlich schneller, guckt euch das mal

11:08.320 --> 11:14.800
an, wir haben aktuell 40, kriegen wir 40 MBit durch und wenn man hier oben sowas hat, dann

11:14.800 --> 11:25.400
sollten es locker 45 sein denke ich, ja so ich muss jetzt mal kurz überlegen wie wir

11:25.400 --> 11:30.840
das machen, also das hier ist doch das ganze Zeug, was ich hier programmiert habe, ist

11:30.840 --> 11:36.200
doch eigentlich viel zu kompliziert, ich baue das mal kurz um, das ist mir nämlich

11:36.200 --> 11:40.800
gestern Abend, als ich mir noch mal Gedanken gemacht habe über den Stream eingefallen,

11:40.800 --> 11:46.880
ich habe das viel zu kompliziert gemacht, guckt mal, hier frage ich einmal in der Sekunde

11:46.880 --> 11:52.720
ab, wie hoch die Downloadgeschwindigkeit ist und hier messe ich einmal in der Sekunde

11:52.720 --> 11:59.040
die Downloadgeschwindigkeit, das ist total bescheuert, warum time ich zweimal eine Sekunde,

11:59.040 --> 12:07.080
also von der Idee her könnte man das eigentlich deutlich einfacher machen, also ich versuche

12:07.080 --> 12:20.480
das mal, wir machen sowas wie self, int, müsste das, oder ist das ein float, keine Ahnung,

12:20.480 --> 12:29.720
die Startzeit, so und dann kann ich nämlich theoretisch diesen ganzen Krämpel hier unten,

12:29.720 --> 12:34.120
also wenn ich mir das richtig überlege, ich kann den ganzen Krämpel hier unten eigentlich

12:34.120 --> 12:46.160
rausschmeißen und das hier auch rausschmeißen und das dann alles hier oben reinpacken, soweit

12:46.160 --> 12:58.920
von der Idee her und dann sollte das gleiche wieder funktionieren, wenn ich das richtig

12:58.920 --> 13:02.960
mache, so gucken wir mal, gucken wir mal ob das funktioniert, was ich mir da überlegt

13:02.960 --> 13:08.320
habe, ne raid berechnen muss ich noch, ich noob jetzt habe ich das gelöscht, das brauche

13:08.320 --> 13:19.680
ich da noch, null, hier, so, zack, so raid berechnen, start, ist self start, mal gucken

13:19.680 --> 13:22.520
wir nämlich mal ob das funktioniert, weil das ist jetzt deutlich einfacher zu lesen

13:22.520 --> 13:30.920
als mein verkomplizierter Kram, den ich gestern da irgendwie gebaut habe, so self, size, durch

13:30.920 --> 13:54.800
Zeit, also und dann so, und wenn das jetzt, ich hoffe es funktioniert noch, ah, ah, ah,

13:54.800 --> 14:12.320
ja, jetzt funktioniert das noch und es ist deutlich einfacher zu lesen und ich blicke

14:12.320 --> 14:21.080
jetzt wenigstens halbwegs durch was es macht, der fragt einmal in der Sekunde ab, also folgendermaßen,

14:21.080 --> 14:26.920
der merkt sich die Startzeit, wann ich das hier aufgerufen habe, so, die Startzeit, wenn

14:26.920 --> 14:31.840
ich dann abfrage, wie hoch ist die Downloadrate, dann guckt er, wie viel Zeit ist vergangen,

14:31.840 --> 14:38.640
von der Startzeit bis jetzt und das was er in der Zwischenzeit downloadet hat, geteilt

14:38.640 --> 14:45.480
durch die Zeit, die es lief, ergibt dann natürlich meine Megabytes die Sekunde, dann resette ich

14:45.480 --> 14:51.400
das alles wieder und dann rechne ich das durch 1024, durch 1024, also meine Bytes pro Sekunde,

14:51.400 --> 14:55.480
sorry meine Bytes pro Sekunde ergibt das, dann rechne ich das durch 1024, dann sind

14:55.480 --> 15:01.360
das meine Kilobytes pro Sekunde und hier sind das meine Megabytes pro Sekunde und dann rechne

15:01.360 --> 15:10.240
ich das mal 8 und dann sind das Megabits pro Sekunde, so und das ist deutlich kürzer

15:10.240 --> 15:15.400
als das was ich hier gestern zusammen gewurschtet habe und auch viel besser lesbar finde ich,

15:15.400 --> 15:20.880
so und jetzt probiere ich mal diesen ganzen Krämpel umzuwurschten, von oldschool threading

15:20.880 --> 15:26.520
API, die nur noch Python Noobs verwenden habe ich auf Reddit gelesen, aber wir wissen ja

15:26.520 --> 15:31.920
es gibt auf zwei Sachen, auf die kann man sich immer verlassen, das sind einmal Ratschläge

15:31.920 --> 15:37.800
aus dem Chat und Reddit antworten, das heißt dann hat man prinzipiell immer gewonnen wenn

15:37.800 --> 15:44.400
man das einfach macht was die sagen, moin Patrick, was geht, ich habe ein Tutorial geguckt

15:44.400 --> 15:55.840
wie man AsyncIO verwendet, ich baue das jetzt um von threading zu modernem FyFat Kram, so

15:55.840 --> 16:03.680
deswegen werfe ich mal dieses threading Zeug, alles weg, so hier weg, weg, weg, weg, weiss

16:03.680 --> 16:12.080
ich ob ich das noch brauche, ich denke mal das passt, so also ich habe ein Tutorial geguckt,

16:12.080 --> 16:16.560
ich habe ein Tutorial, ja Stackoverflow ist eh nur zum copypasten da, ob man das glaubt

16:16.560 --> 16:21.560
oder nicht, das ist egal, das muss man nicht glauben, das muss man copypasten und dann

16:21.560 --> 16:26.920
einfach ausführen und sagen es funktioniert, also ich habe mir gestern ein AsyncIO Tutorial

16:26.920 --> 16:36.040
angeguckt, so und der hat das ganz gut gezeigt eben, wen es interessiert, ich habe mir angeguckt,

16:36.040 --> 16:45.480
ok Moment, ich muss mal kurz die Bandbreitenbeschränkung, die Bandbreitenbeschränkung von meinem Interface

16:45.480 --> 16:52.960
wieder aufheben, weil ansonsten ist es im Web so lahm, also ich habe mir angeguckt,

16:52.960 --> 17:01.680
AsyncIO, was ist das so lahm, vielleicht habe ich zu viele Tabs auf, oh ich habe echt

17:01.680 --> 17:20.040
zu viele Tabs auf, oh shit alter, ok wisst ihr was, wisst ihr was, close all Tabs außer

17:20.040 --> 17:33.280
das, was nein, close other Tabs, 950 Tabs alles klar, also ich habe mir das da angeguckt,

17:33.280 --> 17:42.400
das war aber nicht so geil muss ich sagen, wo ist denn das andere Video, ich habe noch

17:42.400 --> 17:54.680
ein Video von 2019 angeguckt, war das das, nee ein Video von 2019 habe ich noch angeguckt,

17:54.680 --> 18:05.040
das fand ich wirklich nicht schlecht, ich habe keine Ahnung wo das Video ist, alter

18:05.040 --> 18:13.600
was ist mit denen los, warum gucken die alle so Gatchibuzz mäßig auf ihren Thumbnails,

18:13.600 --> 18:18.360
nee im Verlauf habe ich das nicht drin, ich habe es ja nicht im Stream angeguckt, das

18:18.360 --> 18:24.800
da, kann das das gewesen sein, nee der Typ kenne ich nicht, ok ich habe keine Ahnung

18:24.800 --> 18:31.080
was das andere Video war, das da, also das war ein Video, der hat AsyncIO gezeigt und

18:31.080 --> 18:40.440
Threading gezeigt und Multiprocessing gezeigt, das da war das glaube ich oder, nee das ist

18:40.440 --> 18:45.320
ja nicht 2019, ich habe legit keine Ahnung mehr was ich mir für ein Video angeguckt

18:45.320 --> 18:56.120
habe, ich dachte mir nur ich könnte euch das zeigen, weil ich fand das Video nicht schlecht,

18:56.120 --> 19:03.480
das hier habe ich mir glaube ich angeguckt, das da, das habe ich mir angeguckt, ich kann

19:03.480 --> 19:08.200
nicht in den Verlauf gucken, das ist nicht mein privates Zeug hier, guck da ist nichts

19:08.200 --> 19:17.840
drin, Manager History, heute habe ich angeblich schon vier Seiten aufgemacht, alles klar ja,

19:17.840 --> 19:21.160
ich glaube das habe ich mir angeguckt und der hat das hier wirklich ganz gut gezeigt,

19:21.160 --> 19:30.520
von AsyncIO bis irgendwie Konkurrent Threadpool und sonstige Geschichten, das war nicht schlecht,

19:30.520 --> 19:36.640
das wird, so und deswegen habe ich jetzt natürlich voll im Plan wie das alles funktioniert oder

19:36.640 --> 19:47.040
auch nicht, also ich habe mir das so gemerkt, AsyncIO in Python ist quasi Async Await aus

19:47.040 --> 20:00.120
JavaScript, es ist wie eine Kombination aus dem Task Modell von.NET und der Event Loop

20:00.120 --> 20:09.240
Geschichte von JavaScript und ich hoffe, dass ich soweit verstanden habe, dass ich das jetzt

20:09.240 --> 20:16.600
umbauen kann von Multithreader zu AsyncIO, so also fangen wir mal an, das erste was

20:16.600 --> 20:20.560
ich gecheckt habe ist, was die auch in den Videos gesagt haben, man muss das wie in.NET

20:20.560 --> 20:26.000
alles was man mit AsyncIO laufen lassen will, Async machen, das heißt ich muss mein Main

20:26.000 --> 20:36.400
auch mit AsyncIO run, runnen, weil sonst funktioniert es nicht, so, das klappt schon mal, hätte

20:36.400 --> 20:41.760
ich das nämlich nicht gemacht, dann hätte er mir jetzt gesagt, could not await oder

20:41.760 --> 20:48.040
nicht, meister kein Fehler, gut, zumindest ich muss auf jeden Fall Async davor schreiben

20:48.040 --> 20:56.840
sonst spackt er irgendwie rum, sonst klappt das nicht, so und jetzt, jetzt tue ich mir

20:56.840 --> 21:05.400
ein bisschen schwer, also was der in dem Video erzählt hat ist folgendes, man muss AsyncIO

21:05.400 --> 21:11.920
create task machen, aber und das fällt mir wahrscheinlich ein bisschen schwer, weil ich

21:11.920 --> 21:19.480
die Tasks aus.NET gewöhnt bin, create task ist nicht das gleiche wie task run in Incy

21:19.480 --> 21:24.760
Sharp, ja Incy Sharp würdest du machen task run und dann was du ausführen willst, der

21:24.760 --> 21:30.000
Unterschied ist, wie gesagt ich beziehe mich da nur auf das Video was ich gestern geguckt

21:30.000 --> 21:37.120
habe, also der Unterschied ist, dass in.NET task run höchstwahrscheinlich ein Thread im

21:37.120 --> 21:46.440
Threadpool ist, das ist nicht immer so, aber es ist höchstwahrscheinlich so, das hier,

21:46.440 --> 21:52.760
das heißt hier drinne kann ich auch Synchronen Code ausführen ohne, dass es den Rest blockt,

21:52.760 --> 21:58.080
das geht in Python nicht, weil das eigentlich nur die JavaScript Event Loop nachgebaut ist

21:58.080 --> 22:04.760
in Python, das heißt, wenn ich jetzt hier, das muss ich auch Async machen, also es hört

22:04.760 --> 22:07.680
sich jetzt vielleicht so an, als würde ich das erklären, aber ich erzähl bloß das was

22:07.680 --> 22:11.280
der Typ gestern im Video erzählt hat, weil ich auch keine Ahnung hab davon, das heißt

22:11.280 --> 22:18.720
wenn ich jetzt hier meinen Download Campbell starte, dann kann das nicht funktionieren,

22:18.720 --> 22:27.560
weil, mal gucken was passiert, nix, es geht einfach nicht, dann kann das nicht funktionieren,

22:27.560 --> 22:34.960
weil das nie läuft, guckt mal, ich mach jetzt hier mal rein, Print, Cackle, so das heißt

22:34.960 --> 22:41.120
eigentlich würde man jetzt erwarten, dass der das hier ausführt, machen wir hier nochmal

22:41.120 --> 22:47.280
an Print, ja, Cack W, eigentlich würde man erwarten, er führt das hier aus, das heißt

22:47.280 --> 22:53.120
es kommt irgendwann Cackle und danach wird Cack W angezeigt, aber, passt auf, es wird

22:53.120 --> 23:01.520
mehrfach Cack W angezeigt, aber nie Cackle, also der läuft hier durch, es stellt mehrere

23:01.520 --> 23:11.760
Tasks, diese Tasks laufen aber nie, weil ich nie Sleepe, weil ich nie dem die Möglichkeit

23:11.760 --> 23:19.080
gebe, hier rauszuspringen in die Event Loop zurück, in.NET wäre das nicht so, hätte

23:19.080 --> 23:28.480
ich in.NET gesagt Task Run, hätte ich in.NET so gemacht, eigentlich müsste ich da

23:28.480 --> 23:35.360
so machen, dass es funktioniert, das hier wäre in.NET dann direkt losgelaufen in einem

23:35.360 --> 23:41.760
extra Thread im Thread Pool, das ist in Python nicht so, das ist alles nur ein Thread und

23:41.760 --> 23:51.720
eine Event Loop und ich muss explizit Yield oder Await machen, hier drinnen, dass das

23:51.720 --> 23:56.480
funktioniert, so habe ich das zumindest gestern in dem Video verstanden, das heißt deswegen

23:56.480 --> 24:00.720
führt der jetzt hier drinnen nichts aus, damit das funktioniert, jetzt muss ich mal

24:00.720 --> 24:05.040
überlegen, was muss ich denn machen damit das funktioniert, wahrscheinlich einfach

24:05.040 --> 24:18.240
irgendwo Sleepen, nicht Time Sleep, sondern Await AsyncIO Sleep, also wenn ich das jetzt

24:18.240 --> 24:25.240
richtig verstanden habe, dann sollte der sobald er an die Stelle kommt, hiermit anfangen

24:25.240 --> 24:29.760
und dann in der Endlosschleife hängen und nie wieder rauskommen, aber dadurch, dass

24:29.760 --> 24:38.200
er hier quasi das Sleep hat, heißt er returnt quasi an der Stelle, führt den nächsten

24:38.200 --> 24:43.480
Task aus, bis der wieder returnt oder bis der wieder Awaitet oder Sleept oder was auch

24:43.480 --> 24:49.080
immer, weil es ist kein Thread Pool, sondern es ist bloß ein Thread und eine Schleife

24:49.080 --> 24:56.000
drum herum, welche Einheit, ich vermute mal Millisekunden, guckt es funktioniert Leute,

24:56.000 --> 25:02.280
der hat es jetzt ausgeführt, ist hier in das Sleep gegangen, hat hier erstmal geprintet,

25:02.280 --> 25:08.320
ist hier in das Sleep gegangen und jetzt hängt er hier in der Weilschleife, weil die Weilschleife

25:08.320 --> 25:13.320
ist nicht Async, die ist Synchron, das heißt ich muss jetzt wahrscheinlich so was machen

25:13.320 --> 25:21.560
wie Await auf den, falls das funktioniert, auf den Network Input und jetzt sollte das

25:21.560 --> 25:36.560
eigentlich klappen oder auch nicht, warum nicht, weil man, Bites can't be used, wie

25:36.560 --> 25:45.680
ich kann response read nicht Awaiten, was ist das für ein Blödsinn, das heißt, das

25:45.680 --> 25:56.440
heißt, die eingebaute HTTP Library ist nicht AsyncIO kompatibel oder wie, oder muss, gibt

25:56.440 --> 26:10.160
es irgendwie Read Async oder sowas, ne, gibt es erst gar nicht, tja, gute Frage, da hört

26:10.160 --> 26:16.600
es meine Python Kenntnisse auf, ne, ne, es sind Millisekunden, es sind nicht Sekunden,

26:16.600 --> 26:23.040
es sind Millisekunden, das Sleep, Sleep ist Millisekunden, deswegen sind es ja auch 1000,

26:23.040 --> 26:30.240
so, Await, warum kann man das nicht Awaiten, da selbst ich bin nicht der erste, der sowas

26:30.240 --> 26:54.680
fragt, wtf, wat, AsyncIO HTTP, ist das StandardLib, ne, das ist nicht StandardLib, ich will jetzt

26:54.680 --> 27:12.760
mal nichts zusätzliches installieren, kann das sein, dass es einfach nicht funktioniert,

27:12.760 --> 27:16.440
kann das sein, dass es einfach nicht geht, einfach Python Request benutzen, ne, das muss

27:16.440 --> 27:20.200
doch mit der StandardLibrary gehen, das kann doch nicht sein, dass die StandardLibrary

27:20.200 --> 27:25.160
nicht Await-fähig gemacht haben, ich mein, was wir theoretisch machen können, ist, ich

27:25.160 --> 27:31.480
könnte hier drinne sagen, Await, Async, also nur mal so von der Idee her, dass es funktioniert,

27:31.480 --> 27:45.920
Sleep, eine Millisekunde oder so, also das, Sleep ist nicht in Sekunden, oder, ist es,

27:45.920 --> 27:58.360
wait a minute, ist es vielleicht doch, okay, Await, oh, ist er, ja, gut, ja, dann, das

27:58.360 --> 28:05.960
sleeps halt ein bisschen, ne, was solls, dann, okay, dann will ich 0,001 sleepen, dann will

28:05.960 --> 28:11.280
ich eine Millisekunde sleepen, das müsste jetzt eigentlich funktionieren, das, dann

28:11.280 --> 28:19.360
klappt, dann stimmt allerdings meine Download-Berechnung nicht mehr so wirklich gut, ja, ja, okay,

28:19.360 --> 28:28.800
aber jetzt startet er den Kram und jetzt sleepen wir hier, Sekunde, ja, guck, meine Download-Berechnung

28:28.800 --> 28:45.880
ist voll für den Arsch jetzt, guck mal mal kurz, Download 10 Megabits pro Sekunde, also

28:45.880 --> 28:51.320
meine Download-Berechnung kann jetzt natürlich schwerlich noch funktionieren, wenn ich in

28:51.320 --> 28:58.480
dem Download zwischendrin einfach mal random sleepe, weil dadurch wird schlicht und ergreifender

28:58.480 --> 29:04.600
download langsamer, meine Download-Berechnung ist ja, downloade so schnell wie du kannst

29:04.600 --> 29:08.280
und dann guck was du in der letzten Sekunde gedownloadet hast und teile das durch die

29:08.280 --> 29:13.040
Zeit und das ist die Geschwindigkeit, nachdem das jetzt hier natürlich ein bisschen gebremst

29:13.040 --> 29:23.720
wird, ist das halt nicht mehr so schnell, gibt's da irgendwie eine Hilfe-Seite zu, je nach

29:23.720 --> 29:31.680
was muss ich gucken, sleep, er singt, ich auch sleep, gibt es vielleicht sowas wie tick

29:31.680 --> 29:40.560
oder sowas anstatt sleep, dass er nur das minimalste macht was sein muss, ne, guck mal

29:40.560 --> 29:53.200
mal in die Hilfe, sleeping, wo ist die Funktions-Shield, haben wir nicht irgendwie noch, hier sleep,

29:53.200 --> 30:05.280
da ist er, block for delay seconds, if result is provided, sleep, always suspend, setting

30:05.280 --> 30:14.920
delay to zero, optimized path, ok, also wir setzen delay to zero, das ist jetzt die schöne

30:14.920 --> 30:18.120
Art ist das zu verwenden, wage ich mal zu bezweifeln, schöner wäre natürlich wenn

30:18.120 --> 30:25.160
das so funktionieren würde, aber das funktioniert ja nicht, ja ok, das funktioniert, download

30:25.160 --> 30:34.120
speed Messung klappt wieder, ich muss traffic beschränken auf dem Interface sonst klappt

30:34.120 --> 30:54.400
das nicht, so, also wirklich, wirklich gut klappt meine download Messung mit dem sleep

30:54.400 --> 31:03.440
jetzt aber nicht oder, warum da ein sleep rein muss, da muss ein sleep rein, damit die

31:03.440 --> 31:09.240
event loop weiter laufen kann, weil das ganze ist nicht multithreaded, das ganze ist quasi

31:09.240 --> 31:16.960
ein thread, wo die aktuelle Aufgabe immer kurz das abgeht, das ist wie ein JavaScript,

31:16.960 --> 31:23.760
es ist wie ein JavaScript, wenn du ein JavaScript eine Endlosschleife macht, hängt dein Browser,

31:23.760 --> 31:30.080
in wirklichkeit passiert an der Stelle quasi ein return und die Methode ist erstmal fertig,

31:30.080 --> 31:34.160
dann werden alle anderen ausgeführt, die auch Arbeit haben und dann gehts an der Stelle

31:34.160 --> 31:48.720
weiter, also es ist quasi kein return, es ist quasi ein return await oder sowas, ne

31:48.720 --> 31:55.920
die Lösung wäre wahrscheinlich eine async await fähige HTTP library zu verwenden, sowas

31:55.920 --> 32:05.920
wie, was stack overflow sagt, das hier ist POG, das soll man verwenden, ich mein theoretisch

32:05.920 --> 32:16.400
können wir das, theoretisch können wir das einfach benutzen, alter was, die Musik passt

32:16.400 --> 32:26.360
ja mal, passt ja mal ganz, ganz vortrefflich zu wir programmieren Python Zeug, so besser,

32:26.360 --> 32:38.480
ja RGB, RGB kommt dann schon noch, guck die empfehlen auch man soll IO Http verwenden,

32:38.480 --> 32:51.600
weiß nicht ob ich das haben will, Kleinexample, hier, hier kannst du sagen, await response,

32:51.600 --> 33:01.240
ich mein wir könnens mal ausprobieren, also pip install IO Http, warum verwendest du

33:01.240 --> 33:05.680
nicht speedtest CLI, weil ich nix lerne, wenn ich einfach speedtest CLI verwende, es ist

33:05.680 --> 33:10.280
nicht Sinn und Zweck der Sache, dass ich jetzt da irgendwas tolles neues erschaffe, was noch

33:10.280 --> 33:20.400
nie da gewesen ist, was nutzt du für ein tool zum programmieren, was meinst du genau, das

33:20.400 --> 33:25.960
Terminal, die IDE, das Betriebssystem, der Winnow Manager, also das hier ist anscheinend

33:25.960 --> 33:38.960
PyCharm Community Edition 22.1.3, hab ich gestern zum ersten Mal installiert, also ich

33:38.960 --> 33:42.800
kann jetzt nicht wirklich sagen, ob das was taugt, aber nachdem ich die ganzen anderen

33:42.800 --> 33:56.640
Jetbrains Dinger häufig verwende, denke ich das taugt, wie würde das unter der Haube

33:56.640 --> 34:05.000
funktionen wenn man die Funktion awaiten kann, naja, so, ohne das Lieb, dann würde das nämlich

34:05.000 --> 34:10.520
das hier schon, dann würde das diese read Funktion intern handeln für mich, indem

34:10.520 --> 34:15.720
es irgendeinen future returns, was dann completed, wenn ich drauf awaite, also im Prinzip das,

34:15.720 --> 34:22.280
was das Ding hier wohl macht, probieren wir jetzt aus, aber das Standard Library Http

34:22.280 --> 34:32.080
Klein kann das anscheinend nicht, also Async Http und jetzt müssen wir was machen, Async

34:32.080 --> 34:44.640
with Session, ich will keine Session, geht das nicht auch einfach ohne Session, also

34:44.640 --> 34:54.680
kann ich nicht einfach sagen, Ayo Http Request oder sowas, oder einfach, einfach, jetzt vielleicht,

34:54.680 --> 35:10.280
ne, ne, ne geht nicht, Request und jetzt, kann ich da jetzt reinschreiben, wow, MonkaS Alter,

35:10.280 --> 35:24.880
kann man das jetzt awaiten, ja, funktioniert das jetzt, also hier, ich brauche ja keine

35:24.880 --> 35:47.160
Session, oder, Client Session, geht das nicht ohne, also einfach einen Request machen geht

35:47.160 --> 35:59.040
nicht, oder wie, also dass ich sowas sage, wie irgendwie, keine Ahnung, Http, Ayo, Request,

35:59.040 --> 36:18.240
ne, ah, Response, ach hier muss ich jetzt wirklich sagen, get oder wie, ah ne installiert

36:18.240 --> 36:28.920
habe ich doch schon, ausführen, Bäm, Lul, was hat er für Schmerzen, Define Add, Task

36:28.920 --> 36:37.960
was never retrieved, what, await, so, ach fuck Alter, keine Ahnung, ok, vielleicht, vielleicht

36:37.960 --> 36:44.800
mache ich es doch einfach mal nach dem Tutorial, ich mache es mal nach dem Tutorial, also, aus

36:44.800 --> 36:49.040
irgendwelchen Gründen, muss es jetzt doppelt eingerückt werden, weil, Pog mehr Einrückung,

36:49.040 --> 37:14.080
so, und jetzt so, und jetzt kann ich sagen, await read, ne, ne, wie ich kann das nicht

37:14.080 --> 37:18.960
schankt lesen, mein Gott, warum ist das immer so kompliziert gemacht, das ist ja, da blickt

37:18.960 --> 37:27.720
doch keiner durch, Response, wie funktioniert das, also das scheint ja nicht zu tun, wie

37:27.720 --> 37:37.720
ich das hier gebaut habe, weil, Bäm, was sagt denn Stagoverflow, ja, ich will, ich will

37:37.720 --> 37:42.640
awaiten, allerdings nicht komplett readen, ich will es ja nicht, ups, ich will den Kram

37:42.640 --> 37:50.000
mir nicht komplett einlesen, ich will es ja der Chunkweise einlesen, also das geht anscheinend

37:50.000 --> 38:02.880
nicht, Response Payload, das will ich nicht, ich will das in Chunks einlesen, ok, Chunks,

38:02.880 --> 38:13.520
streaming API, jetzt wird's, jetzt wird's advanced hier, stream reader, was, ok, Moment,

38:13.520 --> 38:28.240
was, Response, was, Content, aha, ah, hier kann ich jetzt angeben, wieviel ich lesen

38:28.240 --> 38:42.080
will, oder, aha, also so, ok, ich keine Ahnung, was passiert, das ist gut, ah, das schaut

38:42.080 --> 38:50.160
mal besser, ok, funktioniert, easy, einfach, einfach durch, einfach durch die Hilfe, durch

38:50.160 --> 39:00.960
GBA, hier gibt's auch noch mehr, Chunks, kann ich nicht die Chunk-Size einstellen,

39:00.960 --> 39:20.160
data, Async 4, boah, jetzt, jetzt wird's aber 5 header, Async 4, data, end of HTTP-Chunk,

39:20.160 --> 39:29.400
das heißt im Endeffekt, ich brauch meine, meine Wile-Schleife, aber nicht mehr, das

39:29.400 --> 39:39.360
ist 6-headig, alter, ok, nice, aber jetzt weiß man ja gar nicht, wie groß die, wie

39:39.360 --> 39:49.160
groß ist denn jetzt, so eine Chunk-Size, kann man das nicht angeben, ah, ok, die Chunk-Size

39:49.160 --> 39:55.680
ist immer ein bisschen anders, so wie gerade Daten reinkommen, naja, warum nicht, alles

39:55.680 --> 40:03.080
klar, ok, ich lass es jetzt mal so, ich find's halt etwas umständlich, vor allem hier,

40:03.080 --> 40:13.540
dass man jetzt, irgendwann bin ich ja mit Einrückungstiefe irgendwo da hinten, ja,

40:13.540 --> 40:17.680
es wäre mir tatsächlich lieber, wenn ich das mit dieser Session überspringen könnte,

40:17.680 --> 40:42.240
aber vielleicht geht das ja wirklich mit Request, Request, Request, get, ne oder, ah, oder, ah,

40:42.240 --> 40:48.080
doch easy, einfach, also das muss ich sagen, das muss ich den Python-Library-Programmieren

40:48.080 --> 40:55.880
echt lassen, irgendwie ist es doch halbwegs intuitiv wieder Krämpel zu benutzen ist,

40:55.880 --> 41:00.120
nicht dass das jetzt in irgendeiner Art und Weise die gewollte Verwendung ist, das weiß

41:00.120 --> 41:09.640
ich nicht, das müsste man, müsste man schauen, aber es funktioniert in der Tat relativ intuitiv,

41:09.640 --> 41:30.440
ja, Make a Request, was wollen die immer mit ihren Sessions hier eigentlich, ah, was auch

41:30.440 --> 41:53.960
immer, also ich wusste weder, dass das war, noch, würde uns da irgendjemand einladen zu

41:53.960 --> 42:21.200
machen, doch, klar ist, war wird, wenn man, 퀜성대상 Task Force

42:21.200 --> 42:29.840
Das ist wirklich komplett so, eine Ohr rein, andere raus, geht mir voll am Arsch vorbei.

42:29.840 --> 42:46.240
So, aber unser Krempel funktioniert und ist jetzt super krass 5-Headed Async, was auch

42:46.240 --> 42:47.240
immer.

42:47.240 --> 43:00.040
Leute, warum gibt es denn sowas wie, ich bin da echt ein bisschen dran, es gibt IO-HTTP,

43:00.040 --> 43:18.060
es gibt Requests, es gibt HTTPX, es gibt Urlib 2, warum gibt es 50 Milliarden HTTP-Libraries,

43:18.060 --> 43:29.360
das ist ja fast schon wie bei NPM, Versus Requests, da gibt es natürlich auch 30.000

43:29.360 --> 43:52.040
Blogposts, die dir erzählen, was, wie, wo, HTTPX wurde mir gestern auch in einem Blogpost

43:52.040 --> 44:00.880
vorgeschlagen, dass das auch gerade voll angesagt ist, das ist nämlich der Next Generation

44:00.880 --> 44:09.440
HTTP Client, das hier ist anscheinend Old Generation und das ist Next Generation, kann

44:09.440 --> 44:29.680
man das wenigstens erwarten irgendwie, ach, ich lasse das jetzt mal so, das funktioniert

44:29.680 --> 44:30.680
ja.

44:30.680 --> 44:34.160
Warum peißen, ja weil ich es mir angucken will.

44:34.160 --> 44:46.680
Also der Grund ist folgendes, ich mache ja hauptsächlich die Sachen in.NET und für

44:46.680 --> 44:58.200
so Kleinigkeiten bastle ich meistens so 20-30 Zeilen Bash zusammen, aber sobald Bash mehr

44:58.200 --> 45:05.240
ist als eine Seite oder sagen wir mal, sobald es mehr wird als eine Schleife und 1-2 Ifs

45:05.240 --> 45:10.080
und ein paar Grabs gepiped ineinander wird es eklig, deswegen habe ich mir gedacht es

45:10.080 --> 45:17.040
wäre doch nicht verkehrt im Jahr 2022 mal ein bisschen seine Peißenskills zu verbessern,

45:17.040 --> 45:20.880
ich habe ja damit schon Sachen gemacht, so ist das nicht, also so ganz, das hat man denke

45:20.880 --> 45:25.240
ich gestern im Stream auch gesehen, ich bin zwar recht planlos, aber so verwendet habe

45:25.240 --> 45:30.760
ich das ab und zu schon mal, aber wirklich Ahnung von neuen Sachen, wie irgendwie Async

45:30.760 --> 45:36.080
Await in Python oder dass man jetzt in Schleifen direkt Variablen zuweisen kann, sowas habe

45:36.080 --> 45:40.600
ich noch nie verwendet, deswegen habe ich mir gedacht ich bastle mir einfach ein Speedtest

45:40.600 --> 45:45.600
und wenn das gut funktioniert dann habe ich mir ein bisschen mehr Ahnung, gibt es eigentlich

45:45.600 --> 45:56.280
was cooles womit man Bundle zu Single File oder sowas machen kann, also das was du bei

45:56.280 --> 46:05.240
.NET eingebaut mittlerweile mit Standalone machst, gibt es da irgendwelche coolen Sachen

46:05.240 --> 46:22.000
oder ist da vielleicht auch etwas eingebaut mittlerweile, nee Flatpacks ganz bestimmt

46:22.000 --> 46:32.880
nicht, Single Executable, was gibt es denn da so, irgendwelche aktuellen Posts please

46:32.880 --> 46:57.680
nicht von 2011, Pie Installer, Pie Installer, Pie Installer Standalone, Pie Installer und

46:57.680 --> 47:07.240
der Bundle und der Bundle den Interpreter dann mit rein oder sowas wahrscheinlich, in

47:07.240 --> 47:14.600
der Berufsschule haben wir C gemacht und später ein bisschen C sharp, das weiß ich noch,

47:14.600 --> 47:19.480
das war easy, der Lehrer war aber auch komplett unfähig und hatte keinen Bock, zumal man

47:19.480 --> 47:27.000
aber auch sagen muss, die Leute in der Berufsschulklasse waren auch richtig extrem Three Head, also

47:27.000 --> 47:34.600
das war so nach dem Motto, nach 2 Jahren Ausbildung, ja Moment, wo muss ich bei Print F jetzt das

47:34.600 --> 47:51.400
Simikolon machen, das war wirklich typische Frankfurter Low IQ Geschichte, so und jetzt

47:51.400 --> 47:55.320
machen wir das ein bisschen schöner, also wir haben jetzt dafür gesorgt, dass das alles

47:55.320 --> 48:02.680
Essen läuft und super modern und Five Headig ist, Import Time können wir raus machen, ah

48:02.680 --> 48:12.120
nee Moment, brauchen wir Perfcounter, das brauchen wir, so und jetzt probieren wir das

48:12.120 --> 48:28.360
mal hier mit aus, was hältst du von C++, ich bin mir nicht sicher Käsekuchen, ich hab dich

48:28.360 --> 48:33.680
hier noch nie gesehen, deswegen bin ich mir nicht sicher, ob es ein Heechi Bait ist, he

48:33.680 --> 48:38.840
doesn't know, he lacks critical information oder ob du das wirklich wissen willst, weil

48:38.840 --> 48:45.000
das Problem ist, das ist hier ein wiederkehrendes Meme schon fast im Stream, in der Regel fragen

48:45.000 --> 48:49.040
mich die Leute nach meiner Meinung zu C++, wenn sie wollen, dass ich mich 20 Minuten

48:49.040 --> 48:54.680
über C++ aufrege und nichts anderes mache dann in der Zeit, also meine Meinung, also

48:54.680 --> 48:57.720
ganz kurz für dich, weil wie gesagt, ich hab dich hier noch nicht gesehen, ich finde

48:57.720 --> 49:03.320
C++ ist eines der abscheulichsten Ausgeburten, die sich jemals jemand ausgedacht hat und

49:03.320 --> 49:14.480
ein modernes C++ frickelt an so vielen Stellen rum und macht das ganze so unglaublich wir

49:14.480 --> 49:20.240
und noch viel mehr komplexer, dass ich mich ernsthaft frage, was das C++ Gremium jetzt

49:20.240 --> 49:21.680
die letzten 10 Jahre gemacht hat.

49:21.680 --> 49:34.200
Nein, C++ ist nicht beste Chat, machst du sowas öfters, ich mach sowas fast jeden Stream

49:34.200 --> 49:35.200
ja.

49:35.200 --> 49:51.040
Da mach ich kein Video zu, warum soll ich ein Video zu machen, was C++ sagt?

49:51.040 --> 49:56.920
Das passt doch nicht, auf YouTube ist dein Video Content was komplett anderes als hier,

49:56.920 --> 50:03.360
ne ne, aber C++ geht mir einfach von Anfang bis Ende auf den Sack, also wenn ich die

50:03.360 --> 50:12.280
Auswahl hätte, ob C oder C++, dann tatsächlich keins von beiden, aber wenn es unbedingt sein

50:12.280 --> 50:21.880
muss, dann fast schon lieber Raw C, leider hast du dann halt, naja manche Funktionalität

50:21.880 --> 50:26.320
ist schon nicht verkehrt, die Standard Library von C++ ist halt kacke gemacht, aber es ist

50:26.320 --> 50:36.640
immerhin eine Standard Library, mit der du was anfangen kannst, aber ansonsten, ich mein

50:36.640 --> 50:43.200
allein schon, allein schon wenn ich mir angucke, dass C++ jahrzehntelang keine String to Upper

50:43.200 --> 50:50.360
oder to Lowercase Methode hatte und du in C++ sowas machen musstest, also mittlerweile

50:50.360 --> 50:56.200
kannst du in C++ sowas machen glaube ich, ich glaube sowas gibt es mittlerweile auch

50:56.200 --> 51:04.520
in C++, aber du musstest in C++, wenn du einen String von klein in Großbuchstaben machen

51:04.520 --> 51:12.120
wolltest, musstest du vorher sowas machen, Standard Transform, fragt mich nicht, Beginn,

51:12.120 --> 51:19.480
End, Start, to Upper oder so, was zum Teufel ist bei denen los, wer denkt sich sowas aus

51:19.480 --> 51:36.320
zu machen, also wenn ich die Auswahl hätte, naja, es kommt halt drauf an was du machst,

51:36.320 --> 51:42.160
das ist halt so die Sache, ich mach die meisten Sachen zumindest aktuell, hauptsächlich in

51:42.160 --> 51:48.720
.NET, was super ist auch zum Einstieg, C-Sharp ist eine super Sprache, Microsoft macht sinnvolle

51:48.720 --> 51:53.280
Sachen mit ihrer Sprache nicht wie das C++-Cremium, was alles eigentlich nur verschlimmbessert

51:53.280 --> 51:59.320
und C++ ist ja an Komplexität, also mir fällt ehrlich gesagt keine Programmiersprache ein,

51:59.320 --> 52:07.480
die komplexitätstechnisch in einer Liga spielt wie C++, das ist nichts Gutes, die Sprache

52:07.480 --> 52:14.680
versteht keiner mehr, es gibt in C++ 30 Varianten was zu machen, von Templates fange ich erstmal

52:14.680 --> 52:20.360
gar nicht an, Templates sind tatsächlich, muss ich sagen, nein, Assembler ist deutlich

52:20.360 --> 52:28.480
einfacher als C++, Assembler ist die Komplexität, dass du, sag mal, deine Logik komplex wird

52:28.480 --> 52:38.200
bzw. du den Überblick behältst, so wie ist jetzt der State von deinem Programm, aber

52:38.200 --> 52:46.840
von sich ist das recht überschaubar von den Funktionen her, bei C++ ist halt so die Sache,

52:46.840 --> 52:53.200
du weißt im Endeffekt eigentlich gar nicht was es macht, dass dann musst du an manchen

52:53.200 --> 52:57.760
Stellen musst du drauf achten, irgendwas zu freeen, dann sollst du es wieder nicht freeen,

52:57.760 --> 53:03.280
dann sagen sie, ja nimm Unic oder Smart Pointers, es ist wir, C++ ist einfach komplett wir.

53:03.280 --> 53:13.800
C++ ist was für masochistisch veranlagte Programmierer, C++ kannst du eigentlich getrost

53:13.800 --> 53:18.600
in die Tonne kloppen, leider kommst du in manchen Bereichen um C++ nicht drum herum,

53:18.600 --> 53:25.160
sei es beispielsweise, wenn du Arduino Zeug programmieren willst oder einen ESP32 oder

53:25.160 --> 53:31.680
sowas, das ist C++, man kann es theoretisch auch in C machen, aber gerade Arduino ist

53:31.680 --> 53:39.200
da sehr C++ lastig, ja es gibt auch ein Python Interpret, aber es ist alles Müll außer C

53:39.200 --> 53:54.080
und C++ drauf, es gibt auch Rust als Versuchsprojekt für ESP32, ist aber auch nicht so das wahre,

53:54.080 --> 53:58.400
also eigentlich kannst du den Kram nur sinnvoll in C und C++ programmieren und gerade wenn

53:58.400 --> 54:06.040
es Arduino ist, Arduino mag C++, in manchen Bereichen der Spieleentwicklung kommst du

54:06.040 --> 54:10.040
wahrscheinlich auch nicht dabei, also ich denke gerade wenn man Unreal Engine verwendet

54:10.040 --> 54:16.240
und dort selbst Funktionen hinzufügen will, dann wirst du wahrscheinlich an C++ nicht

54:16.240 --> 54:26.480
vorbeikommen und sowas wie WebAssembly, da gibt es eigentlich nur sinnvollerweise Rust,

54:26.480 --> 54:36.720
C oder C++ oder vielleicht Go, tja die mögen es wahrscheinlich auch nicht, wahrscheinlich

54:36.720 --> 54:42.240
finden die es genauso kacke, aber Arduino ist sehr C++ affin so was die Libraries angeht.

54:42.240 --> 55:06.240
Also ganz ehrlich C++ ist einfach abfuck, aber jetzt machen wir mal weiter und zwar

55:06.240 --> 55:13.000
was ich gefunden habe ist hier auf GitHub, so eine Konsolenformat Library für Python,

55:13.000 --> 55:17.160
du hast nie eine IDE verwendet, Ritual Studio plus Extensions regelt, da muss ich dir jetzt

55:17.160 --> 55:24.720
leider beibringen oder nahelegen, dass Ritual Studio plus Extensions quasi eine IDE sind,

55:24.720 --> 55:31.040
also ich mein wenn du einen Text Editor soweit mit Extensions aufbohrst, dass es mehr oder

55:31.040 --> 55:41.000
weniger alle Funktionen einer IDE hat, dann ist das eine IDE, ach so Arduino, ja die Arduino

55:41.000 --> 55:45.760
IDE finde ich ist auch Crap, ich benutze nur Platform.io, Platform.io ist wirklich nice,

55:45.760 --> 55:50.800
das einzige dumme an Platform.io ist, dass du die Microsoft C++ Extensions verwenden

55:50.800 --> 56:00.400
musst, da wäre mir was anderes lieber, aber mein, alle mal besser als die komische Arduino

56:00.400 --> 56:05.680
IDE, hat die Arduino IDE mittlerweile eigentlich Autocomplete, die hatten irgendwie 20 Jahre

56:05.680 --> 56:13.360
lang kein Autocomplete, wo jeder da hergelaufene Editor zumindest minimales Autocomplete hatte,

56:13.360 --> 56:21.920
haben sie nicht oder, haben sie nicht, oder?

56:21.920 --> 56:30.680
Kein Autocomplete Feature, ah das ist irgendein Beta, irgendein Beta Ding, haben sie nicht?

56:30.680 --> 56:43.800
Ne, Arduino IDE ist Müll, deswegen, Platform, also für Arduino Kram, Platform.io beste,

56:43.800 --> 56:55.160
probier mal, was CIC, was soll denn das sein, CIC, CIC was, Github, eine Programmi, ne noch

56:55.160 --> 56:58.760
eine Programmiersprache, das brauche ich jetzt auch nicht, aber Platform.io ist ziemlich

56:58.760 --> 57:06.040
POG, also ich muss sagen, ich sehe überhaupt keine Daseinsberechtigung für mich zumindest

57:06.040 --> 57:13.040
mehr, was die Arduino IDE angeht, also nur, wie ich das benutze ja, seit es Platform.io

57:13.040 --> 57:14.040
gibt.

57:14.040 --> 57:20.600
Warum nicht, weil ich jetzt erstmal ein bisschen Peißenzweich lernen will, ich kann nicht

57:20.600 --> 57:24.880
20 Programmiersprachen, was, als nächstes kommen die Leute dann mit Cobol oder Haskell

57:24.880 --> 57:33.520
oder Scala, Erlang um die Ecke, ja gut, unter Windows ist ja alles schlimmer.

57:33.520 --> 57:40.040
Ich überlege gerade, ich überlege gerade, was von dem Zeug, was ich hier offen habe,

57:40.040 --> 57:45.080
was ich davon produzieren würde, profitieren würde, wenn ich es unter Windows machen würde,

57:45.080 --> 57:54.800
also weder, nix, nix, also von dem her würde wirklich, ich meine, überlegt euch mal, ich

57:54.800 --> 57:59.200
würde mein ordentliches Terminal, was ich hier habe, ernsthaft durch sowas hier ersetzen,

57:59.200 --> 58:00.200
Alter.

58:00.200 --> 58:03.200
Gut, ich meine, ich könnte das Windows Terminal benutzen.

58:03.200 --> 58:12.640
Das Neue, das da, aber es ist auch alles Müll gegen ein ordentliches Terminal mit ordentlicher

58:12.640 --> 58:13.640
Shell.

58:13.640 --> 58:23.280
Jaja, kannst du, ich mach alles, was mit dem ESP32 mache ich über Platform.io, du kannst

58:23.280 --> 58:33.160
sogar die ESP-Sonderlocken verwenden, du kannst sogar den Ultra Low Power Prozessor direkt

58:33.160 --> 58:39.440
über Platform.io programmieren oder du kannst die Partitionstabelle auf deinem ESP32 ändern

58:39.440 --> 58:46.920
und flaschen über ein CSV-File, das ist ziemlich pfeifert.

58:46.920 --> 58:56.520
Wo wir gerade dabei sind, haben die schon das neue Arduino 2 gedönst in, schon drinnen?

58:56.520 --> 59:03.480
Ah, anscheinend, ja, da muss ich jetzt gerade mal was schauen.

59:03.480 --> 59:17.880
GitHub, Platform, IOS, ESP32, da muss ich nämlich gerade mal was schauen, ob die schon

59:17.880 --> 59:31.760
ihre Examples aktualisiert haben für das da, ah, das funktioniert jetzt, cool, da müssen

59:31.760 --> 59:36.720
wir demnächst mal ein bisschen ESP32 basteln, die haben ihr Projekt anscheinend jetzt soweit

59:36.720 --> 59:44.200
angepasst, dass du Arduino 2 mit ESP, also ESP-EDF ist das Framework von Espressif, Espressif

59:44.200 --> 59:50.600
ist der China-Chinesen Hersteller vom ESP32 Controller und Arduino ist quasi nur ein Aufsatz,

59:50.600 --> 59:55.040
aber beides in Kombination zu verwenden hat seinen Vorteil, weil du kannst Arduino und

59:55.040 --> 01:00:00.760
Arduino Libraries verwenden und du kannst aber mit ESP-EDF an den grundunterliegenden

01:00:00.760 --> 01:00:06.120
Sachen rumbasteln, was du mit dem statisch kompilierten Arduino sonst nicht kannst.

01:00:06.120 --> 01:00:11.120
Aber da waren wir eigentlich gar nicht stehen geblieben, ich wollte mein Python Zeug weiter

01:00:11.120 --> 01:00:12.120
basteln.

01:00:12.120 --> 01:00:19.640
Also, ich hab folgendes gefunden auf GitHub und damit kann man richtig High-IQ-Konsole-Anwendung

01:00:19.640 --> 01:00:20.640
machen.

01:00:20.640 --> 01:00:30.600
Ich hab gedacht, das probieren wir mal aus, ja das stimmt, die Plattform IO-INI ist erst

01:00:30.600 --> 01:00:34.320
ein bisschen gewöhnungsbedürftig, aber an sich finde ich das richtig geil, du kannst

01:00:34.320 --> 01:00:46.160
ja sogar diesen ESP32, oh wie heißt denn das Ding, was dir die Fehlermeldung decoded, dass

01:00:46.160 --> 01:00:48.440
du besser weißt, wo was kaputt ist.

01:00:48.440 --> 01:00:54.720
Es gibt so einen ESP32 Stack Trace Analyzer und so, das kannst du da automatisch mit einbinden,

01:00:54.720 --> 01:00:58.240
dass du bei den Fehlermeldungen nicht einfach mehr nur irgendwelche RAM-Adressen um die

01:00:58.240 --> 01:01:02.960
Ohren geschmissen kriegst, sondern, meinst du den Dump, kann sein, ich weiß es aus dem

01:01:02.960 --> 01:01:08.480
Kopf kann ich, das kriegst du zumindest nicht mehr nur random Speicher-Adressen gegen Kopf

01:01:08.480 --> 01:01:11.960
geschmissen, sondern so ungefähr ein bisschen was, was es sein könnte.

01:01:11.960 --> 01:01:22.600
Ja, das Video haben wir uns auch ganz kurz angeguckt, aber das hab ich als zu langweilig

01:01:22.600 --> 01:01:27.080
im Stream eingeschätzt und hab's wieder ausgemacht, kann ich mich noch dran erinnern, das muss

01:01:27.080 --> 01:01:29.200
man sagen, das ist tatsächlich relativ banal.

01:01:29.200 --> 01:01:36.400
Ich bin mir nicht ganz sicher, wie er's gemacht hat, aber ich vermute mal, im Endeffekt hat

01:01:36.400 --> 01:01:42.640
er ein Relay dran gemacht und einen Spannungswandler und dann über irgendeinen GPIO Pin geguckt,

01:01:42.640 --> 01:01:43.640
ob's geklingelt hat.

01:01:43.640 --> 01:01:51.880
Oder aber er hat einen Analog-Digital-Converter dran gemacht und hat den Input irgendwie ausgelesen

01:01:51.880 --> 01:01:52.880
oder so.

01:01:52.880 --> 01:01:59.080
Ja, das ist tatsächlich relativ banal, so was zu machen, wenn man ein bisschen was damit

01:01:59.080 --> 01:02:00.080
gemacht hat.

01:02:00.080 --> 01:02:03.160
Ich sag nicht, dass es banal ist, insgesamt so was zu machen, sondern nur, weil man ein

01:02:03.160 --> 01:02:05.680
bisschen was damit gemacht hat, ist es relativ simpel, so was zu bauen.

01:02:05.680 --> 01:02:15.520
Aber unser bestes Projekt, das meinte ich, genau, das da, das meinte ich, ja genau, der

01:02:15.520 --> 01:02:23.120
der dann, anstatt diesen Krempel so was hier ausspuckt.

01:02:23.120 --> 01:02:31.560
Moment, wenn du denkst, das sind viele Tabs, ich hab noch einen zweiten Browser offen mit

01:02:31.560 --> 01:02:32.560
Tabs.

01:02:32.560 --> 01:02:35.600
Und hier auch, aber hier hab ich vorhin schon irgendwie 80 Tabs zugemacht.

01:02:35.600 --> 01:02:55.160
Ja, das ist gut, das ist schön, wenn das Leute inspiriert hat, weil das sollten mehr

01:02:55.160 --> 01:02:56.160
machen.

01:02:56.160 --> 01:03:01.160
Also ich bin der Meinung, jeder, der mit seiner Kohle auskommt, also auch mal ausgerechnet

01:03:01.160 --> 01:03:06.440
mal vier Tagen auskommen würde, sollte das machen.

01:03:06.440 --> 01:03:10.520
Freizeit oder halt Zeit, wo man machen kann, was man will, ist durch nichts zu ersetzen.

01:03:10.520 --> 01:03:15.920
Niemand wird, wenn er irgendwann 80 ist oder 90 ist und so an sein Leben zurückdenkt,

01:03:15.920 --> 01:03:19.800
wird er sagen, oh, ich hätte mal unbedingt mehr arbeiten sollen, auch hätte ich mal

01:03:19.800 --> 01:03:21.840
mehr gearbeitet, das wäre geil gewesen.

01:03:21.840 --> 01:03:30.400
Ist nicht so, deswegen, am besten ist, man hat mehr Zeit, das zu machen, worauf man Bock

01:03:30.400 --> 01:03:33.320
hat, das ist das, wo es am Endeffekt drauf ankommt.

01:03:33.320 --> 01:03:38.480
Und auf was man Bock hat, kann halt die unterschiedlichsten Sachen sein, soll jeder machen, was er will.

01:03:38.480 --> 01:03:45.320
Also 32 Stunden sind wirklich super, bei mir sind es 30 Stunden, also einfach einen Tag

01:03:45.320 --> 01:03:46.320
die Woche weniger.

01:03:46.320 --> 01:03:54.360
Das kommt einem erstmal auf dem Papier nicht viel vor, nee, nee, das kannst du einfach

01:03:54.360 --> 01:03:58.600
in den Plattformen auch konfigurieren, also einen Tag weniger arbeiten kommt einem erstmal

01:03:58.600 --> 01:04:04.640
gar nicht so viel vor, denkste was, nur einen Tag, aber im umgedrehten Fall ist es so, dir

01:04:04.640 --> 01:04:10.080
kommt alles andere auch dementsprechend viel kürzer vor, also 4 Tage die Woche arbeiten

01:04:10.080 --> 01:04:19.760
ist viel, viel schneller rum als 5 Tage die Woche arbeiten und 3 Tage am Stück Wochenende

01:04:19.760 --> 01:04:24.480
haben ist viel, viel erholsamer als nur 2 Tage am Stück Wochen haben.

01:04:24.480 --> 01:04:33.480
Weil ihr kennt das bestimmt, also Freitags seid ihr auf der Arbeit, denkt euch ah cool

01:04:33.480 --> 01:04:37.320
Wochenende, Freitags macht man wahrscheinlich erstmal nicht mehr so viel, weil Freitags

01:04:37.320 --> 01:04:41.920
ist man müde, wenn man 8 Stunden gearbeitet hat bzw. hat nicht mehr so viel Power, ja

01:04:41.920 --> 01:04:46.440
gut vielleicht noch 20 jährige oder so, keine Ahnung, aber ich bin Freitags immer müde,

01:04:46.440 --> 01:04:50.720
habt da irgendwie keinen Bock großartig was zu machen, so, dann ist Samstag, Samstag schläft

01:04:50.720 --> 01:04:56.000
man erstmal aus, weil man die Woche ein bisschen nachholen muss, dann kann man Samstag vielleicht

01:04:56.000 --> 01:04:59.800
noch ein paar Dinge, die man erledigen muss, bis einkaufen, bis aufräumen, bis sonst was,

01:04:59.800 --> 01:05:04.320
so dass man im Endeffekt ab Freitagnachmittag dran denken kann das zu machen worauf man Bock

01:05:04.320 --> 01:05:11.320
hat, dann kann man, äh Samstag, ab Samstagnachmittag anzufangen das worauf man Bock hat, dann

01:05:11.320 --> 01:05:15.400
macht man Samstagnachmittag das worauf man Bock hat, dann schläft man Sonntag aus und

01:05:15.400 --> 01:05:22.040
ab Sonntagmittag denkt man sich eigentlich schon, äh morgen geht ja schon wieder die

01:05:22.040 --> 01:05:26.480
Arbeit los und dann kann man sich auch gar nicht mehr so richtig auf den restlichen halben

01:05:26.480 --> 01:05:33.040
Sonntag den es gibt konzentrieren, weil man sich immer denkt, äh jetzt noch duschen gehen,

01:05:33.040 --> 01:05:35.920
dann muss ich hier das Teusch zurechtlegen, dann muss ich überlegen ob ich morgen noch

01:05:35.920 --> 01:05:47.560
was mitnehmen muss und sonst was, ja, genau, das kommt auch dazu, zumal wenn man den Montag

01:05:47.560 --> 01:05:50.880
frei hat, ich habe ja den Montag frei, ich habe ja drei Tage am Stück, dann ist es nämlich

01:05:50.880 --> 01:05:56.880
so, Freitags denkst du so ja gut, ausschlafen Samstags, dann machst du Samstag was du willst,

01:05:56.880 --> 01:06:02.520
Sonntags komplett was du willst und Montags komplett was du willst, weil am Montagmittag,

01:06:02.520 --> 01:06:05.400
selbst wenn ich jetzt dran denke, ach morgen musst du wieder arbeiten, das juckt mich gar

01:06:05.400 --> 01:06:08.760
nicht, weil ich mir denke nö, eigentlich bin ich jetzt super entspannt erholt, hab

01:06:08.760 --> 01:06:17.320
genug gemacht worauf ich Bock hab und die nächsten vier Tage halte ich auch easy durch,

01:06:17.320 --> 01:06:22.720
also das ist, kann ich echt nur jedem empfehlen Teilzeit zu arbeiten, aber jetzt mal weiter,

01:06:22.720 --> 01:06:33.840
hier wo sind wir stehen geblieben, was muss ich installieren, rich install, bam, du machst

01:06:33.840 --> 01:06:39.960
vier mal sechs Stunden, heute zwölf, beste, also ich mache es mittlerweile so, ich habe

01:06:39.960 --> 01:06:46.000
drei Tage Homeoffice, einen Tag Arbeit nach Frankfurt und ich mache es nach Möglichkeit

01:06:46.000 --> 01:06:52.080
so, dass ich dann an dem Tag Frankfurt nicht total früh aufstehe und nicht total spät

01:06:52.080 --> 01:06:55.600
heim gehe, sodass ich irgendwie eins, eineinhalb Stunden Minus mache und das hole ich dann

01:06:55.600 --> 01:07:00.040
über die anderen drei Tage wieder locker auf, was ich gerade mache, ehrlich gesagt mache

01:07:00.040 --> 01:07:04.760
ich gerade nichts, sondern schwätz hauptsächlich, ursprünglich war mal die Idee, ich baue einen

01:07:04.760 --> 01:07:09.160
Speedtest und das funktioniert auch schon, aber noch nicht so schön wie ich mir das

01:07:09.160 --> 01:07:14.200
vorgestellt hab, aber mit modernen Python Sachen hier zum Beispiel Async und sonst

01:07:14.200 --> 01:07:21.240
was, rein zum üben ja, weil ich selbst nicht so viel Ahnung davon hab, so und jetzt wollte

01:07:21.240 --> 01:07:31.480
ich mal gucken, wie man die Konsolenausgabe schöner machen kann, Console Print, kann

01:07:31.480 --> 01:07:38.920
man irgendwie die Farben, ach hier guck mal, Console Print, das testen wir jetzt mal,

01:07:38.920 --> 01:07:47.680
Console Print erinnere mich fast schon ein bisschen an.NET, nee, ist es rich, Console,

01:07:47.680 --> 01:08:03.040
nee, ach ich hab's gar nicht importiert oder, import rich, is rich, rich, äh das ist aber

01:08:03.040 --> 01:08:11.880
nicht, Print haben wir hier, ah guck mal, jetzt hat es Farbe und ist unterstrichen,

01:08:11.880 --> 01:08:20.280
so will ich das haben, worauf ich eigentlich viel mehr abschiele ist, ob man Progress Bars

01:08:20.280 --> 01:08:35.080
schöne Progress Bars machen kann, sowas da, sowas will ich machen, hier guck mal, ja,

01:08:35.080 --> 01:08:49.000
progress progress bar, time, sleep, ja, guck mal hier, jetzt haben wir, advanced to progress

01:08:49.000 --> 01:09:01.640
bars, so und ich hab mir jetzt überlegt den Speed Test, den Speed Test, den könnte man

01:09:01.640 --> 01:09:08.080
ja mit progress bar machen, also das der quasi, das ist ja hier nur das default Ding, das

01:09:08.080 --> 01:09:15.400
dann hier steht, keine Ahnung, testing und die bar machen wir weg, Kommandozeilen Argumente

01:09:15.400 --> 01:09:20.080
muss ich mir auch noch angucken, wie man das mit Python gescheit macht, Leute taugt die

01:09:20.080 --> 01:09:28.240
Standard Python Kommandozeilen Option Parser Library, die dabei ist oder ist da auch empfohlen

01:09:28.240 --> 01:09:36.880
irgendwelche GitHub-Dinger zu verwenden, ArcPars, ja ist das das was dabei ist, taugt

01:09:36.880 --> 01:09:43.000
das, weil ich bin eigentlich kein Fan davon, für Gott und die Welt immer, also das ist

01:09:43.000 --> 01:09:48.080
das was mir bei JavaScript ein bisschen auf den Keks geht, dass du dann erstmal 500 NPM

01:09:48.080 --> 01:09:53.080
Packages hast, bei simplen Projekten und da ist dann so tolle NPM Packages drinne wie

01:09:53.080 --> 01:10:04.640
ist odd und is even und sowas, ansonsten Typer, 8 Sterne, an den ganzen Python Projekten haben

01:10:04.640 --> 01:10:13.600
ultra krasse GitHub, massive GitHub Sterne, Typer, build real, ne build great CLIs, easy

01:10:13.600 --> 01:10:20.400
to code based on Python type hints, mit Rust, wir haben doch letztens was mit Rust gemacht

01:10:20.400 --> 01:10:26.200
und komplett versagt, ich hab doch das letzte Mal versucht mit Rust FFmpeg WebAssembly zu

01:10:26.200 --> 01:10:32.800
machen und festgestellt das hat nicht funktioniert, ja kannst ruhig schicken, ich kann da kein

01:10:32.800 --> 01:10:37.400
Code Review machen, ich kann garantiert kein Rust Code Review machen, ich hab von Rust

01:10:37.400 --> 01:10:42.160
keine Ahnung, also Code Review sollte ja schon irgendjemand machen, der ein bisschen Ahnung

01:10:42.160 --> 01:10:48.600
hat wie man die jeweilige Sprache, Standard Libraries und so die best practice Sachen

01:10:48.600 --> 01:10:55.320
in dieser Sprache macht, kommt dir öfters vor bei NPM, hat doch erst vor einem halben

01:10:55.320 --> 01:10:58.480
Jahr oder so oder vor ein paar Wochen, ich glaube gar nicht so lange her, wo wieder irgendwas

01:10:58.480 --> 01:11:04.680
war bei irgendeinem NPM Package, aber ja wir können tatsächlich was mit Rust machen, wenn

01:11:04.680 --> 01:11:10.800
ihr eine gute Idee habt, so für mini, wir könnten theoretisch einfach den Speedtest

01:11:10.800 --> 01:11:15.840
auch in Rust programmieren, wisst ihr vielleicht sollten wir so einen Speedtest mal etablieren

01:11:15.840 --> 01:11:21.000
als Standardtest für neue Sachen, wir bauen einfach einen kleinen Speedtest, wenn der Speedtest

01:11:21.000 --> 01:11:25.120
dann quasi die Features hat wie die anderen Versionen, dann kann man die Sprache halbwegs

01:11:25.120 --> 01:11:38.120
so, ja Sys, Rqv, das muss ich ja selbst parsen alles, ja das guck ich mir dann später mal

01:11:38.120 --> 01:11:52.160
an hier, ja sowas, sowas, also im Prinzip sowas wie, sowas hier, das benutze ich für

01:11:52.160 --> 01:12:04.160
DT Sachen gerne, was alles mögliche mit Terminals zu tun hat, das hast du gemacht, ja offensichtlich

01:12:04.160 --> 01:12:10.000
man sieht den Namen, ein arithmetic parser in Rust, das heißt man kann einen String übergeben

01:12:10.000 --> 01:12:15.000
zum Beispiel irgendwie 1 plus 1 mal 2 und der guckt, dass es richtig gepasst wird oder

01:12:15.000 --> 01:12:36.760
wie, ja anscheinend, oh 5 hat time hier, high IQ, ja Spectre ist ein bisschen gewöhnungsbedürftig

01:12:36.760 --> 01:12:48.400
aber ich finde es eigentlich ganz nice, alter Rust, Rust ist einfach high IQ, wie sonst

01:12:48.400 --> 01:12:56.960
was, guckt euch das an hier, Function, Pars, Mutable, Reference, Self, Return Type, Reference

01:12:56.960 --> 01:13:06.560
Box, 5 hat, Rust ist einfach way too smart alles, aber der Unterschied zwischen Rust

01:13:06.560 --> 01:13:20.160
und C++ ist, dass Rust irgendwie sinnvoll, sinnig in sich ist und C++ nicht, Pog, ich

01:13:20.160 --> 01:13:25.680
kanns mir nicht wirklich, ich hab keine Ahnung von Rust, ich kann das nicht reviewen, meine

01:13:25.680 --> 01:13:30.160
dumme Frage, für was wird man, wird Rust verwendet als Spiel, ja das hat ja damit, das eine hat

01:13:30.160 --> 01:13:34.200
mit dem anderen nichts zu tun, was lustig ist, wenn du nach Rust Reddits suchst, findest du

01:13:34.200 --> 01:13:38.520
als erstes anscheinend mittlerweile die, früher hast du als erstes die, das Spiel gefunden,

01:13:38.520 --> 01:13:46.600
wofür du das verwendest, frag mal die Leute von Mozilla, Firefox sind einige Teile in

01:13:46.600 --> 01:13:57.080
Rust programmiert, der Vorteil von Rust, ganz, ganz simpel gesagt ist, dass du, dass die

01:13:57.080 --> 01:14:07.200
versucht haben, die, guck mal, Sicherheit von managen Sprachen mit der, also Sicherheit

01:14:07.200 --> 01:14:11.880
in Form von, dass es macht was du denkst, dass es macht und nicht crasht und sowas,

01:14:11.880 --> 01:14:17.560
du kannst, du kannst in Rust selbstverständlich auch unsicher programmieren in Form von, du

01:14:17.560 --> 01:14:24.560
passt Input nicht richtig oder sowas, ja, aber Rust versucht quasi die Geschwindigkeit

01:14:24.560 --> 01:14:32.840
von C zu kombinieren mit der Sicherheit von irgendeiner managen Sprache, das klappt nicht

01:14:32.840 --> 01:14:38.240
so hundertprozentig, also performanstechnisch schon, performanstechnisch nimmt sich Rust

01:14:38.240 --> 01:14:46.040
und C nicht wirklich was, mal ist das eine schneller, mal ist das andere schneller, aber

01:14:46.040 --> 01:14:52.560
so mit der Sicherheit, das ist zum größten Teil klappt das, ja, genau, ja, also sowas

01:14:52.560 --> 01:14:59.920
wie Stack Overflows passieren dir in Rust erstmal nicht so einfach, ja, also, man könnte sogar

01:14:59.920 --> 01:15:04.560
so weit gehen sagen, eigentlich so gut wie gar nicht, Rust, der Rust Compiler meckert

01:15:04.560 --> 01:15:10.840
dich schon an, ja, ich meine, du kannst natürlich immer noch drauf anlegen, du kannst immer

01:15:10.840 --> 01:15:18.200
noch sagen, lese ein User Input und nehme das als Index für einen Array, aber selbst

01:15:18.200 --> 01:15:26.200
dann macht Rust irgendeinen Runtime Check, der natürlich dann Performance frisst, ja,

01:15:26.200 --> 01:15:38.560
aber, ja, besser als Overflow, ja, aber Rust ist ziemlich gute Kombination aus so ziemlich

01:15:38.560 --> 01:15:46.080
die krasseste Performance, die du neben C kriegen kannst, plus deutlich sicherer in

01:15:46.080 --> 01:15:51.080
Puncto, dass es halt das macht, was du erwartest, also wenn du dein Rust Programm so gebaut

01:15:51.080 --> 01:15:56.160
hast, dass der Compiler dich nicht anmeckert, kannst du relativ sicher sein, dass es auch

01:15:56.160 --> 01:16:01.880
wirklich das macht, was da steht, das kannst du ja bei C++ und C nicht so unbedingt sein.

01:16:01.880 --> 01:16:21.480
Das einfachste Beispiel dürfte sein, du greifst halt auf irgendeinen Speicher zu, der, sagen

01:16:21.480 --> 01:16:27.960
wir mal, nicht bei Initialisiert ist oder so, was weiß ich, du legst einen Array an und

01:16:27.960 --> 01:16:37.920
denkst 100 Stellen reichen dir aus, aber in deiner Schleife zählst du bis 101 und greifst

01:16:37.920 --> 01:16:50.240
dann auf den 101. Index zu. Und das ist halt nicht definiert, was dann bei rauskommt,

01:16:50.240 --> 01:16:56.600
zumindest in C und C++ nicht. Du greifst halt auf den Speicherbereich zu, eins höher als

01:16:56.600 --> 01:17:04.560
von deinem Array. Wenn du Glück hast, crash das nur. Wenn du Pech hast, liegt dann dort

01:17:04.560 --> 01:17:08.940
irgendwelche anderen Dinger, wo du dann vielleicht gar nicht drauf zugreifen willst oder du

01:17:08.940 --> 01:17:13.760
benutzt das als Abbruchsbedingung und in Wirklichkeit steht dann da nicht Fault, sondern True, weil

01:17:13.760 --> 01:17:17.840
irgendein Wert drin steht und es läuft weiter und es macht an anderen Stellen weiter, wo

01:17:17.840 --> 01:17:25.520
es gar nicht weiter machen sollte. Also, das kann dir bei Rust nicht so ohne weiteres passieren.

01:17:25.520 --> 01:17:33.560
Das ist richtig, Rust macht es halt kompliziert. Aber gut, dafür kannst du bei Rust relativ

01:17:33.560 --> 01:17:39.440
sicher davon ausgehen, dass wenn das kompiliert, dass das das macht, was da steht. Das heißt

01:17:39.440 --> 01:17:43.680
nicht, dass deine Logik richtig ist, aber es macht wenigstens das, was da steht. Das

01:17:43.680 --> 01:17:48.560
ist ja bei C und C++ nicht so. Und bei C++ hast du den Nachteil, du verstehst noch nicht

01:17:48.560 --> 01:17:53.440
mal auf den ersten Blick, was eigentlich da steht. Bei C kannst du wenigstens erkennen,

01:17:53.440 --> 01:17:57.840
was da steht und was es machen soll. Ob es das dann wirklich macht, das ist wieder was

01:17:57.840 --> 01:18:03.000
anderes. Also, das macht es, aber es kackt halt auch an den Stellen nicht ab, wo es was

01:18:03.000 --> 01:18:07.600
macht, was es nicht machen sollte. Bei C++ liest du das und denkst dir, fuck, was passiert

01:18:07.600 --> 01:18:20.320
hier überhaupt? Das ist richtig. Ja, du hast Recht, wo hier war es? Da ist er. Er hat Recht,

01:18:20.320 --> 01:18:31.720
das ist so. Also ein Buffer-Overflow, korrekt, kein Stack-Overflow. Äh, wüsste ich jetzt

01:18:31.720 --> 01:18:47.880
nicht, was ich dazu sagen soll. Die Error-Messages vom Rust-Compiler sind tatsächlich nicht verkehrt,

01:18:47.880 --> 01:18:53.960
ja, das stimmt. Also ganz anders zum C++-Compiler, wo du in Zeile 78 in Semikolon vergisst und

01:18:53.960 --> 01:19:12.120
er meckert dir drei Seiten an, die angeblich in Zeile 5 falsch sind. FFZ. So, fertig. Nein,

01:19:12.120 --> 01:19:24.560
ich habe keine Ahnung von Webpack. Das ist schwarze Magie für mich. Okay, weiter geht's.

01:19:24.560 --> 01:19:31.360
Also, wo sind wir stehen geblieben? Ich wollte eine Progress Bar machen. Eine Progress Bar.

01:19:31.360 --> 01:19:43.560
Also, Progress Bar, Progress Bar. Sowas da, Progress, Progress Bars. Nur mit dem Unterschied,

01:19:43.560 --> 01:19:50.200
dass ich nicht die Standard-Progress Bar haben will, sondern eine Progress Bar, wo ich selbst

01:19:50.200 --> 01:20:03.200
sowas hier reinschreibe. Haben die eine Hilfe-Seite? Da. Bam. Probier mal GitHub Copilot aus. Ja,

01:20:03.200 --> 01:20:06.960
könnte ich echt. Das ist tatsächlich eine gute Idee. Wir haben es glaube ich schon mal

01:20:06.960 --> 01:20:19.280
ganz kurz Just for Fun ausprobiert. Aber das können wir uns wirklich mal angucken. Progress

01:20:19.280 --> 01:20:36.320
Display. Auf geht's. Basic Usage. Advanced Usage. Okay. Also, Import. Progress, ich kopiere

01:20:36.320 --> 01:20:41.800
mir den Kram mal und dann gucken wir, wie wir das anpassen. Ich natsche das jetzt einfach

01:20:41.800 --> 01:20:49.200
mal hier rein zum ausprobieren. Okay, nice. Also, die Standard-Progress-Bars funktionieren

01:20:49.200 --> 01:20:54.240
schon mal. Aber ich will ja diese Progress Bars in dieser Art nicht haben. Also, ich brauche

01:20:54.240 --> 01:20:59.560
eigentlich nur einen Task. Und zwar nur einen Task für, keine Ahnung, einfach Speedtest.

01:20:59.560 --> 01:21:13.960
Der Desktop, klar, ich blick da durch. Guck, easy. Sag was, sag was, was ich suchen soll.

01:21:13.960 --> 01:21:34.800
Ich finde es sofort. Hot. Ach, hier in der Mitte ist es, ja. Warum hast du zweimal Firefox?

01:21:34.800 --> 01:21:42.440
Weil der Firefox Installer gebaited hat. Das ist der gleiche Firefox. Leute, es ist mega

01:21:42.440 --> 01:21:53.560
easy hier was zu finden. Hier unten hat es das sehr laut. Ob, kein Problem. Ah, Progress,

01:21:53.560 --> 01:22:00.960
Progress Bars. Progress Bars. Wie kriege ich jetzt eine Progress Bar, in der ich selbst

01:22:00.960 --> 01:22:28.360
Text reinschreiben kann? Updating tasks, hiding tasks. Columns, das klingt gut. Text

01:22:28.360 --> 01:22:35.560
Column. Ja, sowas, sowas will ich. Time Remaining Column, nee, das brauchen wir nicht. Time

01:22:35.560 --> 01:22:47.240
Elapsed Column. Spinner, sowas, sowas will ich haben, genau. So, zeigt mal her. Und weg.

01:22:47.240 --> 01:23:02.560
Import, Import. Ah, guck mal. Jetzt haben wir einen Spinner und wir haben die Zeit, die

01:23:02.560 --> 01:23:08.880
das ganze schon läuft. Das ist doch schon mal nicht schlecht. So, was brauchen wir als

01:23:08.880 --> 01:23:26.600
anderes noch? Text Column oder was war das? Text Column. Oh, warte. Text Column. So.

01:23:26.600 --> 01:23:51.560
E, was hat der hier kopiert? E, OnKS. Da, da. Text Column Import. Speed Tests, ok. Ja und

01:23:51.560 --> 01:23:56.640
jetzt müssen wir eigentlich nur noch hinschreiben, wie schnell, wie schneller denn ist. Aber

01:23:56.640 --> 01:24:02.720
wie kriege ich denn jetzt hier was rein, was ich, wie kriege ich da jetzt Text von mir

01:24:02.720 --> 01:24:19.720
rein? Advance bringt mir nicht so viel, ich will da den Text ändern. Update. Update. Update.

01:24:19.720 --> 01:24:28.920
Ach, ich kann die Description ändern? Das ist gut, wenn ich die Description ändern kann.

01:24:28.920 --> 01:24:49.480
Description gleich Kekl. Ah, ok, verstehe. Das ist gut. Das heißt, hier schreibe ich

01:24:49.480 --> 01:24:58.640
jetzt rein, wie schnell das ganze ist. So. Progress Task Description. Magenta Bold will

01:24:58.640 --> 01:25:11.400
ich haben, unbedingt. Bäm. Das muss unbedingt in Magenta und Dick sein. Oh, was für einem

01:25:11.400 --> 01:25:19.480
US Arch, by the way. Nee, Arch, das ist ein Manjaro mit I3WM. Man darf ja als Manjaro-Benutzer

01:25:19.480 --> 01:25:28.320
nicht, nicht Arch, by the way sagen, habe ich gehört. Das ist verpönt. Aber die neue

01:25:28.320 --> 01:25:33.040
Arch Linux VM steht schon in den Startlöchern. Arch, by the way. Die müssen wir nur noch

01:25:33.040 --> 01:26:00.480
irgendwann fertig einrichten. So. Ok, wie kriege ich denn das jetzt hin? Also, ich will

01:26:00.480 --> 01:26:06.960
ja das nicht hier drinne machen, sondern eigentlich in meinem Download-Test, also nämlich hier

01:26:06.960 --> 01:26:20.120
will ich das machen. So. Progress. So, progress. Lass mal kurz erlegen. Total ist mir wurscht.

01:26:20.120 --> 01:26:45.360
Progress. Ich glaube, die Schleife muss da rein. Das kann alles weg. Ja. Oh nee, was

01:26:45.360 --> 01:26:56.120
war das jetzt mit dem Update? Progress-Update. Und jetzt mache ich einfach nur hier die Raid

01:26:56.120 --> 01:27:16.640
oder hier Raid-Zum. Zum Raid. So. Und das ganze als Ring. Und jetzt. Hey! Ok, das sieht

01:27:16.640 --> 01:27:22.000
hässlich aus. Das muss ich, das muss ich rounden. Wie roundet man gescheit? Gibt's

01:27:22.000 --> 01:27:33.040
eben was wie round? Das ist bestimmt nicht so gedacht. Kann man da round drum herumschreiben?

01:27:33.040 --> 01:27:50.960
Round. Aha. Und jetzt, und jetzt please auf zwei Stellen? Nee, auf zwei Stellen? Ah nee,

01:27:50.960 --> 01:28:00.360
hier muss ich hin. Ich hab zu wenig. Auf zwei Stellen? Nee. Moment, ich bin verwirrt.

01:28:00.360 --> 01:28:07.840
Wo sind wir denn hier überhaupt? Round. So. Auf. Nee, man kann hier gar keine Stellen

01:28:07.840 --> 01:28:26.040
eingeben, oder? Doch. Aber es gibt kein Autokomplete dafür. Wie macht man da jetzt eigentlich

01:28:26.040 --> 01:28:43.760
einen String draus? Gibt's doch irgendwie Two-String oder so? String? Ich hab, ich hab,

01:28:43.760 --> 01:28:48.640
ich hab nur andere Ideen, Leute. Es gibt doch jetzt ein neues Feature. Da kann man doch

01:28:48.640 --> 01:28:53.480
irgendwie, irgendwie im Moment, das ging doch irgendwie so F, kann man doch Format-Strings

01:28:53.480 --> 01:28:56.720
machen. Das ist ein bisschen wie in C Sharp die Format-Strings. Das hab ich auch in einem

01:28:56.720 --> 01:29:11.000
Video gesehen. So. So. Und wie kann ich da jetzt den, kann ich da irgendwie das Format

01:29:11.000 --> 01:29:27.040
für angeben heißen? F-Strings float. Jaja, so war's da. Oh, Ultra-Five-Hat. Ultra-Five-Hat,

01:29:27.040 --> 01:29:45.280
was zum? Das funktioniert? Okay. Alter, Pog. Hi-IQ-Shit. Guckt euch das mal an. Es wird

01:29:45.280 --> 01:30:07.040
morgen abgefragt, Chat. So. Und das ist jetzt M-Bit-Pro-Sekunde. M-Bit. Ah, das mag er anscheinend.

01:30:07.040 --> 01:30:12.040
Okay. Wirst du den Code ver... Nee, oder? Also, man kann nicht, aber das ist ziemlich

01:30:12.040 --> 01:30:16.760
unsinnig. Also, es gibt, es gibt zum, also ganz ehrlich, du kannst einfach Speedtest-CLI

01:30:16.760 --> 01:30:21.280
verwenden, wenn du sowas handelst. Also ja, kann ich machen, aber ich glaube, es ist ziemlich

01:30:21.280 --> 01:30:30.360
unsinnig, dass man, das, das sind ja auch nur 5 Zeilen oder so. Das ist einfach nur

01:30:30.360 --> 01:30:36.000
zum Üben für mich. Das sieht tatsächlich jetzt ziemlich cool aus, muss ich mal sagen,

01:30:36.000 --> 01:30:54.000
oder? Das hat was. Das hat irgendwie was. Du kannst zugucken, wie schnell, also wie schnell

01:30:54.000 --> 01:30:59.640
das Speedtest läuft. Vor allem, im Vergleich zu den anderen Speedtests läuft das kontinuierlich.

01:30:59.640 --> 01:31:07.400
Machen wir B-Top auf und gucken, was der gerade macht. Warte mal. Menu, Opti... Ah, das sieht

01:31:07.400 --> 01:31:13.280
aus wie irgendwie ein uraltes, uraltes Game, oder? Das Overlay von, von B-Top. Options

01:31:13.280 --> 01:31:25.240
Help. So. Update. Alle 100 Millisekunden. Jawoll. So muss es sein. B-Top. Also, wenn

01:31:25.240 --> 01:31:30.440
mein Resource-Monitor nicht mindestens 50% CPU-Lust verursacht, dann ist ja irgendwas

01:31:30.440 --> 01:31:56.200
falsch. Ah. Exzellent. Also, wir verbrauchen 5 Megabytes die Sekunde. Also, wir verbrauchen

01:31:56.200 --> 01:32:18.720
5 Megabytes die Sekunde. Also, irgendwie 34 MBit. Okay, passt. Wartet mal, die Katze

01:32:18.720 --> 01:32:48.640
soll rein. Das ist... IP League. Oh nein. Jetzt vorbei, Leute. Oh mein Gott. Oh Gott.

01:32:48.640 --> 01:33:10.040
IP League. Fuck, Alter. Seid ihr... Chat? Seid ihr schon drin? Seid ihr schon drin,

01:33:10.040 --> 01:33:23.760
Leute? Wer ist schon drin? War mir klar. War mir klar. Der Chat ist immer schnell drinne.

01:33:23.760 --> 01:33:48.280
Reverse-Shell ist ab. Ja, alles klar. Passt. So. Okay, nice. Unser Speedtest sieht sogar

01:33:48.280 --> 01:34:00.080
jetzt eigentlich ganz hübsch auf der Kommandozeile aus, oder? 35 MBits pro Sekunde. So, und jetzt

01:34:00.080 --> 01:34:08.000
Kommandozeilen. Kommandozeilen. Arguments. Ich überlege gerade auch, ob das sinnvoll

01:34:08.000 --> 01:34:19.440
gemacht ist hier. Aber ich glaube, es ist ganz, ganz okay. Ach. Wisst ihr, was mir da

01:34:19.440 --> 01:34:34.280
gerade auffällt? Das ist Chrome-Terminal, ja. Ich hatte doch irgendwie so ein Hetzner-Speedtest

01:34:34.280 --> 01:34:40.280
letztens da. Wisst ihr, was mir gerade einfällt? Ich habe keinerlei Error-Handling, gell? Also

01:34:40.280 --> 01:34:48.280
guckt, wenn ich mich hier verschreibe, dann bam. Dann kackt es einfach komplett ab und

01:34:48.280 --> 01:34:58.280
bleibt hängen. Und was passiert... Was anderes? Was passiert, wenn die Datei fertig... Was

01:34:58.280 --> 01:35:11.800
passiert, wenn die Datei fertig runtergeladen ist? 100 MB oder so? 100 MB. Datei. Dann zeigt

01:35:11.800 --> 01:35:23.560
es wahrscheinlich immer nur das letzte an. Alter, warum ist das so langsam? Na gut, ich

01:35:23.560 --> 01:35:33.680
meine, er lädt nur mit 5 MB die Sekunde oder so. Da brauchen 100 MB ein bisschen. Normalerweise

01:35:33.680 --> 01:35:51.160
ist 100 MB mit den normalen 400 MBit. Also, der müsste aber doch schon längst fertig

01:35:51.160 --> 01:36:01.120
sein. Ah, ich lade das ja auch mal vier runter. Tatsächlich. Richtig. Ja, weil normalerweise

01:36:01.120 --> 01:36:06.760
müsste er in 20 Sekunden oder so ja fertig sein. Aber der ist in einer Minute ungefähr

01:36:06.760 --> 01:36:14.280
fertig. Ich frage mich... Mal gucken, was passiert. Mal gucken, was passiert, wenn der

01:36:14.280 --> 01:36:24.160
Datei fertig ist. Ob es dann Fehler schmeißt oder? Jetzt müsste er aber doch so langsam

01:36:24.160 --> 01:36:33.000
aber sicher mal durch sein, oder? Ich meine, 5 MB die Sekunde sind 50 MB in 10 Sekunden.

01:36:33.000 --> 01:36:37.600
In 20 Sekunden ist die Datei fertig und das Ganze jetzt mal vier. In einer Minute ist

01:36:37.600 --> 01:36:46.040
er durch. Ah, er ist auch durch. Okay, der kackt nicht ab. Der kackt nicht ab. Der geht

01:36:46.040 --> 01:36:51.640
einfach auf Null runter, weil der Download fertig ist. Okay, damit kann ich leben. Das

01:36:51.640 --> 01:37:02.520
ist durchaus ein sinnvolles... Solange er nicht abkackt, ist das ja in Ordnung. Wir

01:37:02.520 --> 01:37:08.560
bleiben mal bei den 100G. Ich meine, ich könnte hier noch einbauen, dass er das neu

01:37:08.560 --> 01:37:13.040
startet, sobald das fertig ist. Aber kommt, wir wollen es mal nicht übertreiben jetzt.

01:37:13.040 --> 01:37:17.000
Also wir haben jetzt ein ganz ordentliches, ganz ordentlich Kommandozeilen-Output hier.

01:37:17.000 --> 01:37:33.040
Okay, nice. Standard Task Description ist 0.0 MBit pro Sekunde. Dass standardmäßig

01:37:33.040 --> 01:37:56.000
schon was da steht. Genau, excellent. Gut, sehr schön. So, und jetzt Kommandozeilen-Argumente.

01:37:56.000 --> 01:38:03.440
Wie macht man Kommandozeilen-Argumente gescheit? Also der Chat hat gesagt, das hier taugt.

01:38:03.440 --> 01:38:16.920
Oder? Arg... Was heißt das? Arg... Pass. Arg Pass. Import, Arg Pass, Passer, Arg Pass,

01:38:16.920 --> 01:38:25.960
Argument, Passer. Was? Description. Das ist quasi auch... Macht er auch Hilfetext standardmäßig

01:38:25.960 --> 01:38:46.160
sich? Also mal angenommen, ich mache jetzt hier sowas. Help? Nee. Ach so, ja. Was schreibt

01:38:46.160 --> 01:39:10.720
man da rein? Kann ich einfach so reinschreiben? Okay, nee, das macht er nicht. Der macht nicht

01:39:10.720 --> 01:39:19.320
standardmäßig irgendwie einen Hilfetext oder so. Ah, nee, man muss, man muss auch

01:39:19.320 --> 01:39:28.800
sagen... Moment, was? Sekunde, Sekunde. Aha. War das jetzt, weil ich Help eingegeben habe?

01:39:28.800 --> 01:39:46.680
Ach so. Okay. Das brauche ich wahrscheinlich gar nicht. Ach guck mal, der macht auch schon

01:39:46.680 --> 01:39:53.400
standardmäßig einen Hilfetext. Ja, ist doch eigentlich gar nicht verkehrt. Das finde ich

01:39:53.400 --> 01:39:59.000
krass. Und wie macht man das jetzt korrekterweise? Weil ich meine, hier unten in meinem Main...

01:39:59.000 --> 01:40:07.040
Nicht wirklich, oder? Was ist eigentlich jetzt mal doof, blöde Pullefahrer? Warum brauche

01:40:07.040 --> 01:40:12.320
ich das da überhaupt? Ich weiß, weil es der Chat gesagt hat, dass in jeder Anleitung drin

01:40:12.320 --> 01:40:16.600
steht, aber brauchen tue ich das ja nicht wirklich. Ich meine, das ist ein Kommandozeilenprogramm

01:40:16.600 --> 01:40:45.560
und das war's. Das ist halt ein Kommandozeilenprogramm. Was soll ich da machen? Okay. Also ihr sagt,

01:40:45.560 --> 01:40:52.720
das ist doch sinnvoll. Ich importiere das ja nicht, aber... So, und an welche Stelle würde

01:40:52.720 --> 01:40:57.920
man das hier denn jetzt schreiben? Also den Import hier oben, okay, das verstehe ich.

01:40:57.920 --> 01:41:12.640
Und wo würde man jetzt dieses Argument Parsing machen? Hier? Rein? Oder irgendwie eine Funktion,

01:41:12.640 --> 01:41:36.000
irgendwie Def, Pars, Arcs oder sowas? Sowas? Das gehört in Main? Warum sollte ich das in

01:41:36.000 --> 01:41:41.840
Main machen? Ich meine, wenn ich das in Main mache, dann habe ich hier unsinnig viel in

01:41:41.840 --> 01:41:46.680
Main drin stehen, was ja eigentlich keinen interessiert in Main. Wenn Main ausgeführt

01:41:46.680 --> 01:41:52.320
wird, weiß ich, passt alles. Ach wobei, nee, ihr habt recht, das muss nach Main rein, weil

01:41:52.320 --> 01:41:56.760
ansonsten kann ich ja auf meine Sachen gar nicht zugreifen. Wenn ich hier irgendwelche

01:41:56.760 --> 01:42:00.000
Variablen drin setze, dann kann ich ja, wenn ich das hier drin mache, gar nicht drauf

01:42:00.000 --> 01:42:09.360
zugreifen in Main. Das muss tatsächlich in Main, ja, das klingt sinnig. Muss ich das

01:42:09.360 --> 01:42:18.800
jetzt Main irgendwie übergeben? Irgendwie Arcs oder sowas? Oder geht das jetzt so einfach

01:42:18.800 --> 01:42:40.080
so in Main? Einfach so, oder? Ok, ja, Kunst. Ok, Cute Chats Speed Test ist das. Also,

01:42:40.080 --> 01:42:47.200
Add Argument. Er sagt mir, man kann hier Nummern angeben. Ok, was, was sind denn sinnvolle,

01:42:47.200 --> 01:42:52.800
beleg mal, was sind denn überhaupt sinnvolle Kommando-Zeilen-Argumente dafür? Äh, ja,

01:42:52.800 --> 01:43:10.040
wie viele Threads? Single oder? Ok, also, ähm, Add Argument. So, Add Argument irgendwie,

01:43:10.040 --> 01:43:22.880
ähm, keine Ahnung. T? T? Description? Nee, Destination? Was? Action? Was zum? Was passiert

01:43:22.880 --> 01:43:44.840
da überhaupt? Also, das ist das Argument. Das ist, das ist die Hilfe. Und das hier sind

01:43:44.840 --> 01:43:54.760
irgendwelche Variablen dann, oder wie, oder? Das check ich nicht, wie es funktioniert.

01:43:54.760 --> 01:44:15.720
Des? Ach nee, danach steht das dann da drinnen, oder was? Summ? Nee. Äh? Also, nur mal, nur

01:44:15.720 --> 01:44:26.880
mal, dass ich das check. Dest? Was muss in Dest rein? Dest? Action? Ich check überhaupt

01:44:26.880 --> 01:44:56.840
nicht, was mir das sagen soll. Action kann zum Beispiel auch Tru? Ja, aber, was, was

01:44:56.840 --> 01:44:59.920
sagt mir das denn jetzt hier? Das muss doch irgendwo beschrieben werden, was zum Beispiel

01:44:59.920 --> 01:45:17.200
Konst? Was, was soll mir das jetzt? Ok, Type. Also, ok, ich, ich, ich mach mal kurz, mach

01:45:17.200 --> 01:45:23.040
mal kurz, kurz weg. Ok, das ist die Fault-Welt. Also, was, aber was? Hier, hier steht's doch.

01:45:23.040 --> 01:45:30.000
Dest? Name of the attribute to be added to returned object. Also, sprich, das, was hier

01:45:30.000 --> 01:45:39.400
drinne. Also, das, das ist quasi, wie es hier drinne gespeichert wird, oder wie, oder?

01:45:39.400 --> 01:45:53.000
Also, quasi, ist das hier required? Ok. Also, ich, ich sag, default ist 1. So, type is int.

01:45:53.000 --> 01:46:07.440
Dann, wie es heißen soll, irgendwie keine thread count. Oder con count oder so, oder

01:46:07.440 --> 01:46:15.120
was weiß ich. Action? Macht was? Basic type of action. Wie denken wir an das Argument

01:46:15.120 --> 01:46:22.400
des LK? Ok, Action bedeutet, was er damit machen soll. Also, dass er das da drinne speichern

01:46:22.400 --> 01:46:41.440
soll. Was? Ich dachte aber bei, bei Dest, ist es schon. Verstehe ich, das lasse ich

01:46:41.440 --> 01:46:52.360
mal weg. Verstehe ich jetzt den Sinn? Grad nicht so genau. So. Jetzt, T, achso, da muss

01:46:52.360 --> 01:47:05.320
ich nicht. N? Ne, das ist einfach nur, wie es hier heißen soll, oder? Also, wenn ich

01:47:05.320 --> 01:47:23.280
jetzt hier sowas angebe, wie T1, kann ich dann sagen arts N? Ne, oder? Doch. Hä? Ja,

01:47:23.280 --> 01:47:46.280
aber ich will nicht, dass es N heißt. N ist ja mal richtig bescheuerter Name. Ja, irgendwie

01:47:46.280 --> 01:47:55.560
parallel connections. Oh, ich kann dieses Kackwort nicht schreiben. Fixed Hypo, ja wunderbar.

01:47:55.560 --> 01:48:11.600
So, default. Default 1. Help? Parallel connections default 1. Aber ich will nicht, dass es N

01:48:11.600 --> 01:48:19.280
heißt. Das soll irgendwie so oder irgendwas heißen. Moment, das ist der Name nur. Das

01:48:19.280 --> 01:48:46.760
heißt, wenn ich jetzt. Kunst. Action? This store has the values, but.

01:48:46.760 --> 01:49:11.200
Ich checke nicht so genau, wofür das da sein soll, wenn ich ehrlich bin. Ah, Metawar brauche

01:49:11.200 --> 01:49:20.120
ich noch. OK, Metawar, das soll einfach nur N sein. Dann sollte das nämlich. Ja, ja,

01:49:20.120 --> 01:49:24.920
das ist gut. OK, das ist, wofür ich das mit Action brauche, das verstehe ich noch nicht

01:49:24.920 --> 01:49:34.840
so genau, weil Default kann ich ja so angeben. OK, das keine Ahnung, das lasse ich. Ich

01:49:34.840 --> 01:49:44.520
lasse es erst mal weg. Wozu? Ah, brechen wir das mal um. So, also Destination ist irgendwie

01:49:44.520 --> 01:50:01.720
Parcon. Cons? Wie nenne ich das Ding gescheit? Num. Con? Irgendwie so. Das Action ist für

01:50:01.720 --> 01:50:07.800
Bullion Flex, aber wozu man es braucht, habe ich immer nicht verstanden. Es ist ja nicht

01:50:07.800 --> 01:50:21.120
wirklich thread count. Gibt es da irgendwie so eine Convention, ob man das groß schreiben

01:50:21.120 --> 01:50:29.400
sollte oder klein schreiben? OK, wenn es weg, wenn ich jetzt weglasse, dann ist es eins

01:50:29.400 --> 01:50:37.560
und wenn ich hier zwei angebe, ist es zwei. OK, wunderbar. Das funktioniert. So, das bedeutet

01:50:37.560 --> 01:50:53.720
im Endeffekt das da. Lass es jetzt mal weg. Und ich kann an der Stelle sagen, ich will

01:50:53.720 --> 01:50:59.840
nur so viele Threads starten, wie ich angebe. Das heißt, standardmäßig startet er einen

01:50:59.840 --> 01:51:05.960
Thread, was in dem Fall wurscht ist, weil ich muss mal kurz das Limit von meinem Interface

01:51:05.960 --> 01:51:13.440
runternehmen. Das könnte sein, dass der Stream kurz ruckelt. Also mit einer Connection kommt

01:51:13.440 --> 01:51:19.960
er nicht wirklich ans Limit, weil Wodafone oder so. Keine Ahnung. Guck, da ist er irgendwie

01:51:19.960 --> 01:51:30.000
bei 20 MB und schwankt. Also mit einer Connection ist er nicht sonderlich gut. So, machen wir

01:51:30.000 --> 01:51:41.320
mal Thread. Acht Connections. Bam, volle Pulle. Max 400 MBit. Wow. Und jetzt muss ich aber

01:51:41.320 --> 01:51:45.640
aufpassen, weil mein Stream ruckelt. Guck, da hat er schon Packages, hat schon Frames

01:51:45.640 --> 01:51:53.320
gedroppt. Dann ruckelt das Stream, wenn ich das zu übertrieben benutze. Deswegen limitiere

01:51:53.320 --> 01:52:04.680
ich gerade nochmal kurz auf... Ja gut, das sind 400 MBit. 200 MBit. Was ist denn die

01:52:04.680 --> 01:52:10.640
Hälfte? Was ist denn die Hälfte von... Nee, da wurscht er rein. 2048, was denn sonst?

01:52:10.640 --> 01:52:23.280
Ja klar, lul. Das hätte ich jetzt auch selbst drauf kommen können. Limit auf... Wie viel

01:52:23.280 --> 01:52:39.800
kriegen wir jetzt maximal da durch? 16. Wie viel kriegen wir maximal durch? 15. Was?

01:52:39.800 --> 01:53:05.040
15? Ach, Megabyte, das ist wieder was anderes. Einhalten, Kegweight. So. Also ich habe jetzt

01:53:05.040 --> 01:53:19.080
aus irgendwelchen Gründen limitiert mein Interface auf 120 MBit oder so. So, und eins

01:53:19.080 --> 01:53:27.920
standardmäßig ist langsamer. Ja, ok. Ok, ja dann sieht man, dass es schon was bringt.

01:53:27.920 --> 01:53:38.800
Mehrere Threads aufzumachen, auf jeden Fall. Also es ist eindeutig ausgelasteter. Wie gut

01:53:38.800 --> 01:53:43.440
sollte man eigentlich Englisch können, wenn man in der IT arbeiten will? Das kommt ein

01:53:43.440 --> 01:53:47.760
bisschen drauf an. Also beim normalen 0815 deutschen Unternehmen ist das jetzt nicht

01:53:47.760 --> 01:53:53.560
so wichtig. Aber was du können musst, ist du musst den Kram auf Englisch lesen können.

01:53:53.560 --> 01:53:58.960
Sprechen ist jetzt nicht so wild, je nachdem was es ist. Aber du musst es auf jeden Fall

01:53:58.960 --> 01:54:03.240
lesen. Und dementsprechend, ich kann es auch nur empfehlen, stell dein Betriebssystem und

01:54:03.240 --> 01:54:07.400
stell deine Programme, die du verwendest, komplett auf Englisch. Erstens, weil man dann vielleicht

01:54:07.400 --> 01:54:11.120
die einen oder anderen Begriffe lernt und hauptsächlich, weil du besser nach Fehlermeldungen suchen

01:54:11.120 --> 01:54:32.440
kannst. Ja, wenn du, aber gut, das weiß man ja, wenn man zu so einem Unternehmen geht,

01:54:32.440 --> 01:54:35.960
dann ist was anderes. Bei der 0815 Klitsche um die Ecke ist es nicht so wichtig, dass

01:54:35.960 --> 01:54:40.360
du Englisch reden kannst, aber Englisch verstehen musst du auf jeden Fall. Also ich wusste beispielsweise

01:54:40.360 --> 01:54:47.360
letzte Woche mit einem rein englischsprachigen Telekom-Techniker zusammen was installieren

01:54:47.360 --> 01:54:54.460
auf irgendeiner Cloud-VM von uns. Das ging erstaunlich gut, also ich bin nicht wirklich

01:54:54.460 --> 01:55:01.000
geübt was Englisch sprechen angeht, einfach weil zu wenig Gelegenheit ist. Und ich werde

01:55:01.000 --> 01:55:04.280
jetzt auch nicht anfangen den Stream in Englisch zu machen, da rennen mir die Leute reihenweise

01:55:04.280 --> 01:55:12.240
weg. Aber das ging, das war kein großes Problem. Ich hab mich mit dem jetzt aber auch nicht

01:55:12.240 --> 01:55:16.120
über irgendwelche aktuellen Ereignisse der Zeitgeschichte unterhalten, sondern über

01:55:16.120 --> 01:55:20.480
wir sind auf der Kommandozeile und klicken den Installer durch. Oder tippen den Installer

01:55:20.480 --> 01:55:27.120
durch. Das war relativ einfach. Aber sprechen nicht so sehr, aber verstehen musst du die

01:55:27.120 --> 01:55:32.760
Sachen schon. Also guck mal, es ist ja auch alles mehr oder weniger auf Englisch. Die

01:55:32.760 --> 01:55:36.920
Hilfeseiten sind, guck mal hier, die ganzen Sachen die man zahlt, das ist alles, das ist

01:55:36.920 --> 01:55:43.960
komplett Englisch. Also das hier musste eigentlich alles verstehen was in sowas drinne steht.

01:55:43.960 --> 01:55:48.760
Das geht aber, weil es ein Unterschied ist, ob Technik Englisch oder ob dir jetzt einer

01:55:48.760 --> 01:55:53.440
erzählt, wenn dir jetzt irgendein Ami erzählt wie geil sein letztes Footballspiel war, da

01:55:53.440 --> 01:55:57.880
werde ich wahrscheinlich auch nicht alles verstehen was er mir da sagt. Einfach weil

01:55:57.880 --> 01:56:10.440
ich keine Ahnung hab was es für geile Footballbegriffe gibt. Aber sowas hier schon. Zumal mich das

01:56:10.440 --> 01:56:28.600
Footballspiel überhaupt nicht interessieren würde.

01:39:53.380 --> 01:56:46.000
also das muss ich sagen, das funktioniert eigentlich als Kommandozeilen-Parser relativ

01:56:46.000 --> 01:56:50.640
brauchbar. Was ich persönlich gut finde ist, dass Minus Minus Help drinne ist, standardmäßig

01:56:50.640 --> 01:56:58.280
eingebaut. Wer sowas mal in Bash selbst gemacht hat, der bekommt Anfälle. Jetzt kann ich die

01:56:58.280 --> 01:57:05.000
parallelen Connections eingeben, wie viele haben soll, wie viele er benutzen soll. Was

01:57:05.000 --> 01:57:13.960
wäre denn noch ein gutes Kommandozeilen-Argument, was wir testen können. Ob er Continuous sein

01:57:13.960 --> 01:57:22.920
soll oder ob er Endless, ob es Endless sein soll oder, keine Ahnung, einfach nach 5 Sekunden,

01:57:22.920 --> 01:57:37.120
ja Url, Url können wir da auch noch machen. Ob es Endless sein soll oder True, 0W, ne Default

01:57:37.120 --> 01:57:52.360
ist False, Endless oder Infinite oder Continuous nennen wir das. Das ist so ein geiles Wort,

01:57:52.360 --> 01:58:14.240
das kann ich nie schreiben. Continuous, Help, Fault, False, Speedtesting, Help oder Minus

01:58:14.240 --> 01:58:26.280
Minus C oder? Default, False. Also das heißt, wenn ich Minus C angebe, was? Expected One

01:58:26.280 --> 01:58:49.560
Argument. Wie kann ich einen Bool Flag machen? True? Flag, wie macht man hier einfach nur

01:58:49.560 --> 01:59:14.840
einen Flag? Name of Flags? Ach Typ ist noch auf Int, ah. Ne, Expected One Argument. Name

01:59:14.840 --> 01:59:44.000
of Flags. Distort a Value Special. Ich checke ehrlich gesagt nichts.

01:59:44.000 --> 01:59:49.960
Was das bringen soll, was es macht, aber anscheinend.

02:00:14.000 --> 02:00:31.400
Was willst du von mir? Was Type is Unexpected, ok. Warum? Ok. Ich blicke nicht so wirklich

02:00:31.400 --> 02:00:37.960
durch, was ich hier gerade mache, muss ich ehrlich sagen. False? Aber es sollte doch

02:00:37.960 --> 02:00:44.320
True sein jetzt. Oder muss das so gemacht werden? Es ist True und wenn es nicht gesetzt

02:00:44.320 --> 02:01:12.320
ist. Ach so. Ach so geht das auch. Dann kann ich mir das hier sperren. Ne. Faults doch nicht.

02:01:12.320 --> 02:01:30.120
Etabar ist. False. True, ok. Das ist ein bisschen kompliziert gemacht. Ok, das heißt, wenn

02:01:30.120 --> 02:01:36.920
ich jetzt Minus C angebe, macht er, von der Theorie her, macht er unendlich langes, nie

02:01:36.920 --> 02:01:46.120
enden wollenden Dauerspeedtest. Und den kann ich jetzt auch starten mit 4 Threads oder so.

02:01:46.120 --> 02:02:01.720
Und jetzt gibt er, jetzt gibt er alles. Jetzt gibt er alles. Volle Pulle. 130 MBit. Watt

02:02:01.720 --> 02:02:08.520
C erst eigentlich für den Sub. Machen wir mal noch ein Stückchen höher hier. Wir wollen

02:02:08.520 --> 02:02:23.880
Minus C. Ups. Jaja, ist ja gut. Minus D. Drei. Immer. Wie viel haben wir jetzt? Maximum

02:02:23.880 --> 02:02:30.160
Speed. Also die Einheiten von diesem Traffic Shaper check ich nicht so wirklich. Machst

02:02:30.160 --> 02:02:34.320
du damit? Ich kann damit nur einen Downloadtest machen, weil für den Upload Test bräuchte

02:02:34.320 --> 02:02:41.600
ich irgendeinen Server, worauf ich was uploade und es dann wegwerfe. Also der Traffic Shaper

02:02:41.600 --> 02:02:48.960
ist nicht so ganz korrekt mit seinen Einheiten hier, würde ich sagen. Der sagt nämlich,

02:02:48.960 --> 02:03:01.840
die Einheiten sind in Kilobits pro Sekunde. Also sprich, ich könnte jetzt zum Beispiel

02:03:01.840 --> 02:03:18.520
200 MBits, 2 Kilobits sind, ja genau und das ergibt überhaupt keinen Sinn. Also die

02:03:18.520 --> 02:03:25.560
Einheiten sind ziemlich pepega, was der Traffic Shaper da macht. Aber es funktioniert zumindest

02:03:25.560 --> 02:03:36.920
so weit. Guck, ich hab gesagt, mach 200 Kilobits die Sekunde und er macht 200.000 Kilobits

02:03:36.920 --> 02:03:43.160
die Sekunde und er macht genau 100 noch was. In dem Fall ist es beides Bits. Also im Prinzip

02:03:43.160 --> 02:03:57.200
kann ich das eins zu eins so umrechnen. Guckt, er macht auch irgendwie, also der Traffic Shaper

02:03:57.200 --> 02:04:06.360
ist nicht so genau, was der da Traffic Shaped. Ne, das ist nur der Download Speed Test und

02:04:06.360 --> 02:04:08.760
eigentlich ist es auch nur zum Peißen üben. Aber ich muss sagen, ich finde das eigentlich

02:04:08.760 --> 02:04:13.600
ganz schick, so wie das jetzt ist. Jetzt ist natürlich die Funktion noch nicht so ganz

02:04:13.600 --> 02:04:23.000
korrekt, weil ich checke ja gar nicht, ob es continuous ist. Ich müsste in Wirklichkeit

02:04:23.000 --> 02:04:39.280
gucken, irgendwie while, while true, wenn es continuous ist, kann man hier sowas machen?

02:04:39.280 --> 02:04:48.960
Moment, continuous, args, ja gut, Moment, Moment, das würde jetzt funktionieren, aber

02:04:48.960 --> 02:04:53.120
der würde dann gar nicht laufen. Normal muss der, normal soll er ja nur irgendwie mal ein

02:04:53.120 --> 02:05:00.640
paar Sekunden laufen oder so. Das könnte KiBibit oder Ki, es ist aber wie auch immer,

02:05:00.640 --> 02:05:05.920
es ist zu, zu, zu wenig. Ich glaube dieser Traffic Shaper ist, zeigt Mülleinheiten an.

02:05:05.920 --> 02:05:28.240
Aber es soll mir recht sein, solange, solange es nicht kaputt geht, ist in Ordnung. Ich

02:05:28.240 --> 02:05:36.760
bin mir nicht sicher, ob was die beste Variante ist jetzt zu machen mit einem if und quasi,

02:05:36.760 --> 02:05:53.680
wenn ich so und ansonsten, nee, und ansonsten dann einfach einen Test mit, also wenn, also

02:05:53.680 --> 02:05:58.360
wenn ich Minus C angebe, ist es zumindest schonmal easy, dann mache ich einfach unendlich

02:05:58.360 --> 02:06:04.800
meinen Download Geschwindigkeiten Speedtest und gut ist. So, was ist denn, wenn ich jetzt

02:06:04.800 --> 02:06:13.680
24 Threads angebe? Außer, dass er kurzzeitig massig CPU Last verursacht, ist alles in Ordnung.

02:06:13.680 --> 02:06:25.800
Nee, nee, nee, nee, nee. Der Overhead für HTTP ist garantiert nicht das Problem. Weil,

02:06:25.800 --> 02:06:32.320
der macht ein Getrequest, einmal Headers und der Rest ist ja quasi der Response Stream.

02:06:32.320 --> 02:06:39.040
Nee, nee. Es funktioniert ja auch, wenn ich die Limits weg mache, kriege ich meine, ein

02:06:39.040 --> 02:06:43.520
bisschen über 400 MBit vom Vodafone Anschluss. Also entweder checke ich die Einheiten vom

02:06:43.520 --> 02:06:50.960
Traffic Shaper, nicht? Wir können es ja mal so machen, wir können ja mal MBit zu Ki, Ki-Bit

02:06:50.960 --> 02:07:09.680
oder wie das heißt. Nee, das ist ja noch weniger. Oder soll ich Me, Me-Bit, Me-Bit, du. Ah,

02:07:09.680 --> 02:07:24.520
diese Einheiten, Null. 24 Threads, nee, das macht keinen großen Unterschied. Also die

02:07:24.520 --> 02:07:34.240
Einheiten sind merkwürdig auf jeden Fall. Wir können ja mal, also wir können ja mal

02:07:34.240 --> 02:07:40.400
gucken, was ich machen muss, dass ich ungefähr an 200 MBit komme. Machen wir mal hier irgendwie

02:07:40.400 --> 02:07:52.000
400. Das ist eigentlich mehr, mehr als mein normaler Download, aber okay. Okay, also mein

02:07:52.000 --> 02:07:57.920
normaler Download ist gleich die Hälfte von meinem normalen Download, alles klar. Hört

02:07:57.920 --> 02:08:02.800
sich logisch an. Übrigens, ich glaube 24 Threads sind ein bisschen viel. Ich glaube,

02:08:02.800 --> 02:08:10.360
24 Threads ist wunderbar. Nee, das ist jetzt einheitlich benannt. Früher, mittlerweile

02:08:10.360 --> 02:08:17.200
ist es eigentlich besser als früher. Früher hattest du die Sache so was wie MBit. Und da

02:08:17.200 --> 02:08:23.240
musstest du sagen, streng genommen ist es ja eigentlich 1000, aber es hat jeder mit 1024

02:08:23.240 --> 02:08:29.800
gerechnet. Also mega wäre ja eigentlich rein von der Mengen. Einheit wäre das 1000, aber

02:08:29.800 --> 02:08:35.760
das hat eigentlich jeder, weil es Base 2 ist, das hat eigentlich jeder 1024 gerechnet. Und

02:08:35.760 --> 02:08:42.560
jetzt gibt es Maybe und Mega. Maybe ist 1024 und Mega ist 1000. Nur, dass es das Ganze

02:08:42.560 --> 02:08:50.200
irgendwie nicht viel klarer gemacht hat. Das wird übrigens in der EHK Prüfung abgefragt.

02:08:50.200 --> 02:09:16.240
Sollen wir vielleicht noch ein Maximum Einheit machen? Also zum Beispiel hier, wir können

02:09:16.240 --> 02:09:41.160
Maximum Max. Könnte man Maximum angeben? Wie mache ich denn da jetzt ein Custom Check?

02:09:41.160 --> 02:09:58.200
Also ich will gucken, ob die Range zwischen 1 und 8 ist. Range? Ach so, guck mal da. Choices.

02:09:58.200 --> 02:10:05.920
Ich muss sagen, die haben mitgedacht. Die haben mitgedacht. Choices, Range, die haben

02:10:05.920 --> 02:10:28.280
schon mitgedacht. Das ist nicht, das ist nicht verkehrt. 8. Ups. Was? Ach. Also muss ich

02:10:28.280 --> 02:10:37.720
sagen, 9. So, okay, jetzt mache ich hier minus 9. Invalid Choice. Choose from 1, 2, 3, 4,

02:10:37.720 --> 02:10:44.720
5, 6, 7, 8. Das ist cool, dass das funktioniert. Ich meine, es wäre cooler, wenn da steht

02:10:44.720 --> 02:10:59.280
1 bis 8, weil ich ja noch nicht mehr vorhabe. Da steht jetzt Choice 128 drinne. So, bisschen

02:10:59.280 --> 02:11:06.440
viel Hilfetext vielleicht. Aber es ist schon in Ordnung. Das gefällt mir. Also der Kommando

02:11:06.440 --> 02:11:16.000
Zeilenpasa, der da eingebaut ist, macht einen auf mich durchdachten Eindruck. Ruhig sagen,

02:11:16.000 --> 02:11:31.120
finde ich nicht schlecht. Pogge. Welchen Editor? Das ist PyCharm. PyCharm Community Edition.

02:11:31.120 --> 02:11:42.480
Mit dem Rider-Theme, weil ich irgendwas bekannt Aussehendes gebraucht habe. Ja, das gefällt

02:11:42.480 --> 02:11:48.360
mir. Das hat was. Das können wir so lassen. So, jetzt ist nur bloß die Frage, was machen

02:11:48.360 --> 02:11:58.640
wir, wenn er eben nicht minus C angibt? Dann soll er das Gleiche machen, nur vor E in

02:11:58.640 --> 02:12:12.160
Range. Irgendwie, keine Ahnung, 5 Sekunden oder so. Nur 3, 4, 5. Ja, das ist jetzt vielleicht

02:12:12.160 --> 02:12:25.560
kein super cleverer Test, aber ja. Wobei, doch, doch, wir machen das, wir machen das.

02:12:25.560 --> 02:12:42.400
Max Rate. So, und wir setzen das jetzt nur, wenn das hier größer ist. If Sum größer

02:12:42.400 --> 02:12:56.280
Max Rate, dann Sum Rate. Genau, dann machen wir hier die Rate und unten drunter, wenn

02:12:56.280 --> 02:13:12.720
der fertig ist, wenn der fertig ist, geben wir nochmal aus. Print, Download, Speed, Magenta,

02:13:12.720 --> 02:13:20.320
Bold, weil wir haben ja letztens gelernt, lauter, Alter, es ist lauter Telekom, jeder Tag auch

02:13:20.320 --> 02:13:31.840
für uns ein Magenta Tag, Paynes Champ, wenn die Telekom das sagt. So, jetzt misst er den

02:13:31.840 --> 02:13:38.880
Download Speed, zeigt ihn an und am Ende zeigt er den schnellsten Speed an. What? Wait a

02:13:38.880 --> 02:13:43.320
minute, warum ist der Download Speed da jetzt oben drüber und das nochmal unten drunter?

02:13:43.320 --> 02:13:51.680
Das ergibt jetzt aber keinen Sinn, oder? Muss ich, muss ich da vorher vielleicht noch

02:13:51.680 --> 02:13:59.240
ein paar, noch ein paar New Lines oder so machen? Oder muss man das stoppen irgendwie? Progress

02:13:59.240 --> 02:14:22.320
stopp? Progress cancel oder so stopp? Ah ja, ok, ok, schon besser, weil das mit dem Progress

02:14:22.320 --> 02:14:26.400
stopp kann ich eigentlich immer machen, aber hier brauche ich nicht, hier geht er danach

02:14:26.400 --> 02:14:45.440
direkt raus. So, der misst das jetzt und dann sagt er Max, Max Download Speed in Blue, weil

02:14:45.440 --> 02:14:56.360
wir die ganzen Terminal Farben verwenden müssen. Blue Max Download Speed 17972. So, da sagt

02:14:56.360 --> 02:15:04.280
immer, der sagt nicht das letzte, der sagt das höchste, also 192. Ok, gut, ja, kann

02:15:04.280 --> 02:15:10.400
man doch mitleben. Nasi Schneiderman Diagramme sind das Unsinnigste, was es gibt, hat sogar

02:15:10.400 --> 02:15:22.600
der Erfinder selbst mal gesagt. Was für ein Ding. Chat hat irgendjemand eine Ahnung, was

02:15:22.600 --> 02:15:37.760
ein Pseidocode, ach Pseidocode. Alter, willst du mich jebaiten oder was? Pseidocode meinst

02:15:37.760 --> 02:15:54.720
du? Ich hab jetzt gedacht, was zum Teufel ist das? Hab ich noch nie gehört. Ganz ehrlich,

02:15:54.720 --> 02:16:04.600
meine ehrliche Meinung dazu ist, kein Struktogramm und auch kein komischer Pseidocode, sondern

02:16:04.600 --> 02:16:12.920
einfach ein Prototyp basteln. Einfach ein Prototyp basteln, am besten in der Sprache,

02:16:12.920 --> 02:16:17.120
in der du es später auch machen willst, aber muss nicht zwangsläufig sein. Irgendwie so

02:16:17.120 --> 02:16:23.160
mal Miniprototyp, irgendwie so grob, geht das überhaupt, was ich mir vorgestellt habe

02:16:23.160 --> 02:16:29.080
und spätestens, wenn es so Sprachen wie Paisen und sowas gibt, kann man doch auch relativ

02:16:29.080 --> 02:16:33.280
schnell was zusammen vorstellen. Ich würde es halt bevorzugt in der Sprache machen, in

02:16:33.280 --> 02:16:39.120
der ich das später auch umsetzen will, also nee. Ja, glaube ich dir sofort, du hast bestimmt

02:16:39.120 --> 02:16:43.920
auch geplant für deine Placementmaschine, wo man die am besten hinstellt und wie das

02:16:43.920 --> 02:16:51.640
am besten Tools aufpickt über das Nasi Schneiderman Struktogramm, gibs zu. Die mussten erstmal

02:16:51.640 --> 02:16:55.320
deine Leute, mussten erstmal Nasi Schneiderman Struktogramme malen, bevor diese Maschine

02:16:55.320 --> 02:17:15.280
hingestellt wurde. Und bestimmt auch alles noch mit UML Zeug. Du hast eine SWOT-Analyse

02:17:15.280 --> 02:17:22.160
gemacht. Weiß nicht, was eine SWOT-Analyse, aber Leute, wisst ihr, was auch nicht schlecht

02:17:22.160 --> 02:17:34.600
ist? Das wohl kam in meiner IHK Prüfung dran, ein Ishikawa Diagramm. Guckt euch diesen Mist

02:17:34.600 --> 02:17:40.640
mal an, Alter. Das wolltet ihr mir wirklich wissen in der Abschlussprüfung, das weiß

02:17:40.640 --> 02:17:55.360
ich noch. Problem, schlechte Druckqualität. Material-Maschine-Milieu-Mensch-Methode. Problem,

02:17:55.360 --> 02:18:08.640
schlechte Druckqualität. Ja, cringe. Cringe, wer das nicht täglich macht. Und jetzt kommen

02:18:08.640 --> 02:18:26.560
irgendwelche Marketing-Leute und machen da noch so nen Fischt raus. Können wir noch

02:18:26.560 --> 02:18:41.400
was Five-Headiges einbauen? Immer noch ne Big Brain-Idee. Hab ne Idee, wir machen was

02:18:41.400 --> 02:18:49.920
anderes. Zack, wir müssen noch kurz was verbessern. So, Procress, Procress-Stop brauchen wir gar

02:18:49.920 --> 02:19:01.120
nicht mehr. Wir machen jetzt Four-E-In-Track, nee, Procress, Procress-Track-Range-Fünf-ah,

02:19:01.120 --> 02:19:25.600
guck mal, viel stylischer, oder? Dann weiß man, wenn der Speedtest vorbei ist. Nee, ehrlich

02:19:25.600 --> 02:19:33.000
gesagt war das vorher besser. Ehrlich gesagt war das vorher schöner. Jetzt siehts zwar

02:19:33.000 --> 02:19:54.400
fancier besser aus, aber. So und jetzt kommt die Preisfrage. So sagen wir mal, das funktioniert

02:19:54.400 --> 02:20:03.840
jetzt. Vorher war besser, ja, finde ich auch. So und jetzt kann man continuous Speed-Monitoren.

02:20:03.840 --> 02:20:13.120
So, aber, jetzt mal was ganz anderes. Wie würde man sowas denn jetzt gescheit deployen?

02:20:13.120 --> 02:20:26.720
Also ich hab irgendwas mit Pi-Installer vorhin gefunden. Nee, wie man da, nee, mal angenommen,

02:20:26.720 --> 02:20:30.520
das wäre jetzt ein Kommando-Zeilen-Tool, was ich irgendjemand schicken will. Ja, wenn

02:20:30.520 --> 02:20:34.520
ich das deployen will, ist das das falsche Wort. Wenn ich das deployen will auf irgendwas,

02:20:34.520 --> 02:20:37.840
wo ich selbst in Pi ist ein Interpreter und sonst was, ist jetzt alles klar. Aber ich

02:20:37.840 --> 02:20:53.000
hab vorhin irgendwas mit Pi-Installer, Standalone, irgendwo gesehen auf Shithub. Ich will keine

02:20:53.000 --> 02:21:10.540
Exe. What the fuck? Creating Standalone, Pi-Installer, one file, genau, das will ich haben. Also

02:21:10.540 --> 02:21:23.400
pip install Pi-Installer. Also ich hab jetzt ja nur meine Pakete in Virtual Enf installiert.

02:21:23.400 --> 02:21:27.320
Und jetzt kann ich es danach dann auch auf dem Host ausfüllen. Also nicht Exe, ganz

02:21:27.320 --> 02:21:38.800
bestimmt nicht Exe. Pi-Installer m main.pi. Oh, er macht was. Es lebt. Es macht Dinger.

02:21:38.800 --> 02:21:52.680
What the fuck? Okay. Pi-Charm-Projects. Und da liegt jetzt Dist wahrscheinlich Main rum.

02:21:52.680 --> 02:22:00.240
11 MB ist es. Naja, ich mein, das ist jetzt nicht super klein, aber auch nicht super groß,

02:22:00.240 --> 02:22:05.200
das ist schon in Ordnung. So, mal gucken, ob ich das jetzt ausführen kann. Hey, es

02:22:05.200 --> 02:22:11.120
funktioniert. 11 MB ist vollkommen in Ordnung. Das ist richtig gut, da ist ein kompletter

02:22:11.120 --> 02:22:24.520
Pi-Interpreter gebundelt. Das ist nicht verkehrt. Warum keine Exe? Das ist eine Exe. Das ist

02:22:24.520 --> 02:22:48.280
eine Exe. Guck. Das ist eine Exe. Das ist eine Exe. Funktioniert einfach. Kann Pi-Installer,

02:22:48.280 --> 02:22:56.440
okay Five Head Frage. Kann Pi-Installer Cross-Plattform bundlen? Also kann ich mit Pi-Installer unter

02:22:56.440 --> 02:23:09.240
Linux bundlen für Windows? Guck mal, schon schon die erste Frage, da ist am Start. Alles

02:23:09.240 --> 02:23:23.240
klar. Hä? Was will der Typ? Das ist doch eine vollkommen legitive Frage. Come back when

02:23:23.240 --> 02:23:29.560
you have completed Computer Science 50. Ich mein, der will wahrscheinlich schlau tun,

02:23:29.560 --> 02:23:34.840
so nach dem Motto, haha, eine Linux-Exe kann nur nicht unter Windows laufen, aber da geht

02:23:34.840 --> 02:23:41.800
es überhaupt nicht drum. Du kannst ohne Probleme Cross-Executables erstellen. Das ist überhaupt

02:23:41.800 --> 02:24:01.000
kein Ding. Was ein dummes Schwärze, Alter. Was das für ein Spaß, Mann. Was ein wichtig

02:24:01.000 --> 02:24:08.040
Tour, Alter. Was ein dummer Sack, Mann. Was ein, Alter, solche Leute gehen mir aufs Sack.

02:24:08.040 --> 02:24:13.440
Wisst ihr, großkotzig tun und dann noch nicht mehr Ahnung haben, wovon sie sprechen. Ich

02:24:13.440 --> 02:24:19.440
bin nicht eingeloggt, oder? Selbstverständlich kannst du unter Linux Binaries für Windows

02:24:19.440 --> 02:24:33.640
erstellen. Also, du kannst sogar noch abgedrehtere Sachen machen. Du kannst theoretisch sogar

02:24:33.640 --> 02:24:41.360
unter dem x8664 Linux Binaries für einen ARM 7 Raspberry Pi erstellen und das funktioniert.

02:24:41.360 --> 02:24:53.360
Das ist doch überhaupt kein Problem. Die Architektur und das Betriebssystem des Ursprungsrechners

02:24:53.360 --> 02:25:05.800
hat unbedingt was mit dem Target-Binary zu tun. Ich mein, wenn du das statisch, ja,

02:25:05.800 --> 02:25:09.960
scheint nicht so, als könnte man. Ja, vielleicht kann das Pi Installer nicht, aber gehen tut

02:25:09.960 --> 02:25:17.320
das. Wenn du das dynamisch linken willst, dann ist natürlich die Frage, okay, funktioniert

02:25:17.320 --> 02:25:22.560
das dann? Weil, es hat ja keinen Sinn, wenn ich das gegen irgendwelche G-Lib-C-Dinger linke

02:25:22.560 --> 02:25:27.680
und unter Windows dann komplett anders auf. Das ist was anderes, ja. Aber ich kann ohne

02:25:27.680 --> 02:25:33.080
Probleme Windows Binaries erzeugen von Linux aus. Letztendlich, was macht ein Compiler?

02:25:33.080 --> 02:25:40.760
Ein Compiler haut irgendwelchen zur jeweiligen Plattform kompatiblen Byte-Code raus und wenn

02:25:40.760 --> 02:25:47.680
ich einen Compiler habe für ARM Architektur, der selbst lauffähig ist unter x8664, kann

02:25:47.680 --> 02:25:57.000
ich unter x8664 ohne Probleme ARM Binaries erzeugen. Alter, was ist das für ein ultra

02:25:57.000 --> 02:26:18.120
wichtig Tour, man? Der Typ geht mir auf den Keks, also wenn ich das schon lese. Oh Gott,

02:26:18.120 --> 02:26:38.400
Alter. Nee, das ist ja der Wahnsinn, Alter. Was soll das über Wine machen? Nee, nicht

02:26:38.400 --> 02:26:53.240
wirklich, oder? Mit Wein. Jetzt wird's aber abgedreht. Pie-Installer plus Wein in Docker.

02:26:53.240 --> 02:27:02.840
Ja, ist klar. Ich mein, gehen tut bestimmt vieles, wenn der Tag lang ist, ja. Man muss

02:27:02.840 --> 02:27:14.240
es aber nicht machen. Ich mein, die Idee ist nicht schlecht, ja. Die Idee finde ich gut

02:27:14.240 --> 02:27:21.440
hier. Da musst du dir dein System nicht vollsauen. Ich finde die Idee nicht schlecht, aber das

02:27:21.440 --> 02:27:30.360
ist mir schon zu übertrieben, Sixhead. Was gibt's denn für andere Varianten, Python Single

02:27:30.360 --> 02:27:59.200
Executable Files zu machen? Er hat aber Recht, er hat aber Recht.

02:27:59.200 --> 02:28:11.160
Okay, aktuell ist anscheinend Geflame angesagt gegen den Typ. Warum du das willst? Warum

02:28:11.160 --> 02:28:15.080
nicht? Es wäre doch cool, wenn ich jetzt hier beispielsweise sagen könnte, ich bilde

02:28:15.080 --> 02:28:19.520
davon. Mal in genommen, ich habe jetzt das Next Level Kommando Zeilen Tool erstellt,

02:28:19.520 --> 02:28:24.520
was die ganze Welt verwenden will. Was in dem Fall nicht der Fall ist, aber könnte

02:28:24.520 --> 02:28:32.240
doch sein, könnte doch sein. Und ich könnte es direkt mit einem Befehl Executables raushauen

02:28:32.240 --> 02:28:40.720
für Windows, Mac und Linux. Das wäre doch nice. Wäre doch praktisch, oder? Geht anscheinend

02:28:40.720 --> 02:29:01.640
nicht. Wie kann man dafür sorgen, dass es nicht abbricht? Wenn ich das interrupte, wenn

02:29:01.640 --> 02:29:06.640
ich das interrupte mit dem Keyboard, wie kann ich dafür sorgen, dass es keine Exception

02:29:06.640 --> 02:29:14.640
gibt am Ende? Ich meine, ich könnte die Exception catchen und einfach ignorieren. Das würde

02:29:14.640 --> 02:29:37.400
funktionieren. Einfach ein Batch und eine Batch. Nee, nee, nee, nee, nee. Das checkt

02:29:37.400 --> 02:29:49.360
keiner. Okay, also einfach abbrechen ist... Ja, aber es kann doch nicht sein, dass ich

02:29:49.360 --> 02:29:55.840
die Exception da catchen muss. Kann man nicht sagen... Na wobei, es ist ja eigentlich nur

02:29:55.840 --> 02:29:59.880
eine Cancel. Es ist ja eigentlich nur eine Cancel Notification, die ich wahrscheinlich

02:29:59.880 --> 02:30:05.840
nicht richtig handle. Das ist unter.net auch so. Wenn ich in.net das Sleep Await und es

02:30:05.840 --> 02:30:14.200
gecancelt wird, dann gibt es auch eine Exception. Und wo muss ich das catchen? Hier jetzt? Try.

02:30:14.200 --> 02:30:28.880
Accept. So. Hey! So und jetzt soll ich bestimmt noch irgendwas, nichts, alles, sondern Keyboard

02:30:28.880 --> 02:30:40.800
Interrupt. Ist das die Exception? Keyboard Interrupt. Ja, nice! Okay, das ist tatsächlich

02:30:40.800 --> 02:30:46.440
relativ easy. Ich hätte gedacht, es gibt vielleicht ein Parameter, das man sagen kann. Hier Keyboard

02:30:46.440 --> 02:30:57.800
Cancel, keine Exception, aber okay. Jetzt wird dieser Thread ausgebuddelt, nur um den

02:30:57.800 --> 02:31:05.000
Typ noch ein bisschen zu dessen. Alter, wie sieht Flame? Jetzt flippen sie aber aus.

02:31:27.800 --> 02:31:46.560
Warum sind die Leute alle so aggro drauf in diesem Thread? Was ist denn da los, man?

02:31:46.560 --> 02:31:52.760
Mit Wine? Nee, mit Wine mache ich das nicht. Ich meine, klar, es gibt ein fertiges Docker

02:31:52.760 --> 02:31:57.240
Image. Das ist sogar eine relativ gute Anwendung für Docker Images in dem Fall.

02:31:57.240 --> 02:32:03.800
Oh man. Norma?

02:32:27.240 --> 02:32:46.320
Also anscheinend hat das Py Installer nicht eingebaut. Force Compile. Richtig gut, ich

02:32:46.320 --> 02:32:53.400
meine, das wäre jetzt natürlich nicht so wild, aber es wäre halt cool, wenn es irgend

02:32:53.400 --> 02:32:57.840
so ein Build-Tool gäbe. Ich meine, unter.NET kannst du es relativ easy machen. Wenn du

02:32:57.840 --> 02:33:03.240
unter.NET was Supportedes haben möchtest, also wenn du irgendwie eine Architektur hast,

02:33:03.240 --> 02:33:09.280
die standardmäßig Supported ist, also sei es Windows, Linux, Mac oder X86 und ARM, kannst

02:33:09.280 --> 02:33:12.400
du das direkt über das Commando-Zeilen-Tool bilden und das geht einfach.

02:33:12.400 --> 02:33:39.840
Ja gut, unter Windows könnte ich das. Ach, den haben die, das haben die entfernt.

02:33:39.840 --> 02:33:58.280
Nee, okay, dann nicht. Es war jetzt aber auch, war jetzt ja im Prinzip nur Bonus. Ich meine,

02:33:58.280 --> 02:34:15.800
Linux reicht ja. Jetzt kann man den Krampel hier ausfinden. Main. Massive Next Level

02:34:15.800 --> 02:34:26.440
Speed Test am Start. Startup ist schon gegründet. Man könnte jetzt sogar noch weiter gehen,

02:34:26.440 --> 02:34:39.600
ich weiß nicht, ob, kann, können die irgendwelche Graphen zeichnen? Crafts oder so? Dann könnte

02:34:39.600 --> 02:34:43.840
man, dann könnte man noch so, dann könnte man noch so einen Craft malen für die Übertragungsgeschwindigkeit

02:34:43.840 --> 02:34:58.360
hier hinten. Plot a Chart in Terminal. Aber über GitHub Actions brauche ich ja auch irgendwas,

02:34:58.360 --> 02:35:04.040
was den Build macht. Ich meine, nur GitHub Actions alleine bildet mir das ja nicht für

02:35:04.040 --> 02:35:11.520
mehrere Plattformen. Dort brauche ich auch was und das, was ich auf GitHub Actions ausführen

02:35:11.520 --> 02:35:36.120
könnte, könnte ich auch lokal ausführen. Boah, nee, nee, nee. Das, das, das, das,

02:35:36.120 --> 02:35:51.160
das Fuzz mache ich jetzt nicht auf. Das Fuzz mache ich jetzt nicht auf. Nee, ich glaube,

02:35:51.160 --> 02:36:06.720
da lassen wir das jetzt hier bei der Stelle, mit der würde Tool mal gut sein, ne? LVMB

02:36:06.720 --> 02:36:36.280
hier. Das mit dem Exception Catchen hat nicht so ganz funktioniert. Ah, nee. Ach so, hier

02:36:36.280 --> 02:36:40.960
kommen jetzt, hier kommen jetzt die Exception, weil die Tasks abbrechen, ja, ja. Blablabla,

02:36:40.960 --> 02:36:47.040
ja. Weißt du was? Ich bin jetzt, ich bin jetzt mal ganz fies. Bam. Einfach, einfach

02:36:47.040 --> 02:37:01.880
komplette Exception. Alle, alle Exceptions, die es gibt, wenn gecatcht gut ist. Ach so

02:37:01.880 --> 02:37:06.560
meinst du das mit irgendwie so einer, nennen wir es mal einfach Vm? Ja, das stimmt. Es

02:37:06.560 --> 02:37:12.040
wäre aber cool, wenn es irgendein Tool gibt, was das Cross-Compile könnte oder Cross-Plattform-Executables

02:37:12.040 --> 02:37:20.280
machen könnte. Gibt es bestimmt. Ich meine, es gibt bei Puzzle im Prinzip alles. Bam.

02:37:20.280 --> 02:37:36.960
Leute, jetzt wird alles, alles gecatcht. Ja, das bricht ab, passt schon. Oh nee, doch

02:37:36.960 --> 02:37:44.440
nicht. Fuck. Ja, scheiß drauf. Kann ich jetzt mitleben, interessiert mich nicht. Ich müsste

02:37:44.440 --> 02:37:50.400
wahrscheinlich ordentlich, ich müsste wahrscheinlich das ordentlich awaiten und auf Cancel checken

02:37:50.400 --> 02:37:56.960
oder was auch immer. Juckt mich jetzt nicht. Ja, es gibt, wahrscheinlich gibt es sowas

02:37:56.960 --> 02:38:01.960
wie Cancel Talks, aber ich will es jetzt nicht übertreiben, weil ich mein, ich hab das ja

02:38:01.960 --> 02:38:07.040
eigentlich vor, für einfache Scriptingsachen zu verwenden. Ich will ja da gar keine super

02:38:07.040 --> 02:38:10.440
krasen Commando-Zahlen-Tools mitbauen. Das war jetzt nur zum Üben und zum bisschen

02:38:10.440 --> 02:38:32.320
lernen. Ich denke, ich denke dafür ist es durchaus in Ordnung. Ja. Ja, Chat, das wars

02:38:32.320 --> 02:38:44.600
für heute. Ich hab alles ausprobiert, was ich ausprobieren wollte. Nee, ich geh jetzt

02:38:44.600 --> 02:38:51.120
aufs Klo. Das mach ich im nächsten Stream. Ich muss jetzt mal. Wohin? Wir sehen uns im

02:38:51.120 --> 02:39:06.440
nächsten Stream, Leute. Macht's gut. Bis dann. See you.

