WEBVTT

01:30.000 --> 01:58.560
so da bin ich

01:58.560 --> 02:11.880
kurz klimaanlage ausmachen bis sie kühl sind nur 24,1 grad das geht ja nicht schnellste

02:11.880 --> 02:21.360
teil was hat er gemacht er hat nix er hat channel points eingelöst was das denn er hat channel

02:21.360 --> 02:28.960
points eingelöst ok verstehe weeps in heute wie es aussieht

02:28.960 --> 02:58.360
oder weeps nein heute heute ist heute ist in so also ich habe was gesehen heute und zwar

02:58.360 --> 03:05.160
dachte mir das müssen wir ausprobieren und zwar es gibt jede menge cooler neue features mit dotnet

03:05.160 --> 03:13.800
7 und c sharp 11 aber es gibt eins neuer compiler genau aber es gibt eins das habe ich vor jahren mal

03:13.800 --> 03:22.480
mitbekommen bei microsoft und zwar kommt das jetzt mit dotnet 7 zum ersten mal richtig offiziell

03:22.480 --> 03:31.360
raus ich meine sie sagen es ist nur was für konsolenanwendungen und und also sachen die

03:31.360 --> 03:38.880
nicht so kompliziert sind aber die haben zum ersten mal jetzt einen ahead of time compiler

03:38.880 --> 03:44.560
also sprich ich zeige euch mal die seite von microsoft ich mache mal kurz die vm an die vm

03:44.560 --> 03:54.720
wir sind ja cooler heckermans wir sagen bm wir sind so hier vm sagen nur die nups so machen wir

03:54.720 --> 04:04.800
das mal an ich zeige euch mal die seite von microsoft gleich ja so ist es habe ich euch

04:04.800 --> 04:09.600
übrigens schon den daily heckermann trick des tages gezeigt ja ich habe ihn euch gezeigt weil

04:09.600 --> 04:16.840
ihr den auf twitter sehen konntet aber wusstet ihr dass ihr so eure public ip adresse rausbekommen

04:16.840 --> 04:20.840
könnt und ich habe das absichtlich so gemacht natürlich gab es dann wieder leute die haben

04:20.840 --> 04:27.640
drauf geschrieben max macht auch karl if konfig punkt mir karl amazon irgendwas aber der witz

04:27.640 --> 04:35.480
hier dran ist doch gerade dass du deine public ip über ein dns query rausbekommen kannst nicht

04:35.480 --> 04:40.880
http das alias ist falsch ja ich habe mich verschrieben ich habe hier ein p gemacht aber

04:40.880 --> 04:49.840
das alias ich habe das alias ja schon in meiner zsh ac deswegen ging das so so das gibt ein service

04:49.840 --> 04:55.760
von open dns da kann man seine eigene wenn man den queried seine eigene public ip auslösen

04:55.760 --> 05:01.520
lassen und warum ist das besser als http ganz einfach weil dns in der regel immer geht und

05:01.520 --> 05:07.160
http je nachdem wo man ist auch mal gut und gern geblockt sein kann ohne proxy und mit proxy ist

05:07.160 --> 05:15.040
dann wieder die frage ob es eigentlich die public ip ist die du wissen willst so ja abuse das nicht

05:15.040 --> 05:25.640
etwas das ups das protokoll auch ja ein bisschen es macht zumindest nicht das was dns machen

05:25.640 --> 05:33.520
sollte aber gut ich mein warum auch nicht ja ich meine wenn du so willst ist auch diese ganze geo

05:33.520 --> 05:40.160
dns geschichte nicht im sinne des erfinders gab mir mal zeiten da war ein ip adressen unic

05:40.160 --> 05:44.480
weltweit aber das ist halt auch so nicht mehr ich muss mal schnell ein update machen ich zeige

05:44.480 --> 05:50.560
euch während das ding updated ich so eine firefox ja dann geht das ja wobei ich ich starte mal neu

05:50.560 --> 05:55.920
man weiß ja nie sondern zeige ich euch nämlich mal die seite von microsoft die ich gefunden

05:55.920 --> 06:05.800
habe wo sie sich über das neue dotnet feature auslassen postman unbedingt postman nicht post

06:05.800 --> 06:11.440
woman in dem fall weil kein kein dreger sein witz wo twitter jetzt über mich herfallen kann

06:11.440 --> 06:17.520
es gibt wirklich das programm post woman weil sie irgendjemand gedacht haben postman ist zu alter

06:17.520 --> 06:22.880
weißer mann das geht nicht da brauchen wir noch einen extra fork der post woman heißt den

06:22.880 --> 06:27.440
haben sie jetzt aber wieder umbenannt wahrscheinlich kam der namen dann doch nicht so gut an oder so

06:27.440 --> 06:36.200
ja das thema egal wo wir sind das gibt es überall auch im open source umfeld wir sind heute besonders

06:36.200 --> 06:42.720
kappa pride sehe ich gerade im hintergrund das ist das bing image of the day ist das ist das die

06:42.720 --> 06:47.280
pride fahren oder ist das irgendwie marokko oder sowas ne glaub schon dass das regenbogen stellt sein

06:47.280 --> 06:53.600
soll wer witzig wenn es marokko wäre ich meine gerade marokko sieht ja nur mit rechte für schwulen

06:53.600 --> 07:02.120
und so nicht gerade soll nicht rosig aus man soll es postperson nennen genau also ich zeige euch

07:02.120 --> 07:07.320
jetzt mal die seite von microsoft die ich gefunden habe dort net 7 aot ich hoffe ich finde die seite

07:07.320 --> 07:16.520
auf den ersten blick ja nie den heiße artikel mal meine ich nicht nein

07:27.720 --> 07:31.400
ich muss die seite mal kurz finden dann sei zeige ich euch ich habe mir das

07:31.400 --> 07:38.200
natürlich in weißer voraussicht nicht sollt keine marium marium und ich brauche was entspannend

07:38.200 --> 07:50.280
spannenderes hier vielleicht hacker news ja ready to run ist gut es ist zwar nicht ready to run aber

07:50.280 --> 08:18.120
es ist in der in den docs wo auch ready to run drinne steht ready to run hier systemeigenes

08:18.120 --> 08:23.440
aot bereitstellung wenn ich die überschriften von den microsoft seiten auf deutsch schon wieder

08:23.440 --> 08:27.480
sehe kriege ich kriege ich wieder anfälle ja wenn ich dann wenn ich mir das hier angucken

08:27.480 --> 08:36.000
so gleich mal umschalten gut das meine ich und zwar das habe ich gefunden es ist auch ganz neu

08:36.000 --> 08:43.280
die seite ist vom 17.06. also die ist gerade mal 14 tage alt ungefähr und zwar mit dort net 7

08:43.280 --> 08:51.560
da steht auch hier mit dort net 7 wird offiziell native aot das ist ahead of time compilation

08:51.560 --> 08:59.840
supported ahead of time compilation ist ein super fancy wird für das was jeder compiler macht also

08:59.840 --> 09:06.360
das ist nix anderes was sonst jeder compiler macht nur mit dem unterschied dass der dort net

09:06.360 --> 09:11.720
compiler ja eigentlich kein compiler im klassischen sinne ist da kommt also kein fertiges binary raus

09:11.720 --> 09:18.040
da kommt ein binary raus mit dort net runtime und das wird quasi zur laufzeit dann etwas mal

09:18.040 --> 09:26.840
kompiliert ja so macht das dort net bisher das hat vorteile dass er nachteile ein nachteil davon ist

09:26.840 --> 09:33.960
zum beispiel so wie das dort net aktuell macht dass die das können wir gleich mal vergleichen wenn

09:33.960 --> 09:42.960
wir die die features wenn wir das feature ausprobieren dass die startzeit von dort net anwendung ein

09:42.960 --> 09:51.280
ticken wir reden hier nicht von sekunden oder so aber ein tick langsamer ist als von native sagen

09:51.280 --> 09:59.440
wir cc plus plus oder ja wahrscheinlich auch von irgend von irgendeinem payson zeug wo wobei

09:59.440 --> 10:09.640
na da wäre ich mir nicht so sicher was performance angeht eigentlich nie wirklich gut also go go ist

10:09.640 --> 10:16.440
ein gutes beispiel ja go auch also im prinzip ist fast alles bisschen schneller beim starten als dort

10:16.440 --> 10:24.600
net so und das wollen die jetzt ändern indem sie nämlich nicht mehr ihr komisches jit modell

10:24.600 --> 10:30.920
machen was nichts mit git zu tun hat sondern hier geht es um just in time sondern sie kompilieren

10:30.920 --> 10:39.680
noch mehr ahead of time also das was jeder normale compile auch macht und kurz dort nicht sie raussuchen

10:39.680 --> 10:50.680
wo gibt es das denn da und das machen die jetzt auch was heißt dass damit theoretisch dort net

10:50.680 --> 10:56.280
anwendung ich bin mir nicht sicher ob die kleiner werden am ende sie sollten zumindest deutlich

10:56.280 --> 11:02.360
schneller starten an der performance macht das nix also die performance ist ja von dort net

11:02.360 --> 11:06.520
eh schon ziemlich gut aber die performance wird dadurch nicht besser nur das starten wird ein

11:06.520 --> 11:12.440
bisschen beschleunigt was aber wirklich cool ist gerade für kleine kommando zeilen anwendung also

11:12.440 --> 11:18.640
wir reden hier von also wenn ich was weiß ich wenn ihr jetzt zum beispiel so was aufruft wie ls ja

11:18.640 --> 11:26.800
beim das ist instant in ls von in ls mit dort net ist ungefähr weiß gar nicht man sleepen kann 0,3

11:26.800 --> 11:36.800
ja also das ist ungefähr der unterschied also ein native native ls ahead of time kompilation ist so

11:36.800 --> 11:44.920
instant ausgeführt und dort net kommando zeilen anwendung ist ungefähr so also es ist jetzt nicht

11:44.920 --> 11:51.520
wirklich krass und bei programm die ein bisschen mehr machen als als einfach nur kleinen status

11:51.520 --> 11:57.600
ausgeben ist das eigentlich zu vernachlässigen aber es wäre ja cool wenn dort net programme auch

11:57.600 --> 12:04.600
einfach so starten würden und nicht so also sind 300 millisekunden also ich denke mal es wird sich

12:04.600 --> 12:09.040
im bereich von 300 millisekunden bewegen so was die normalen dort net programme so ungefähr auf

12:09.040 --> 12:16.360
halbe sekunde vielleicht also es ist nix nix großartiges so und warum ja genau gut gut hier

12:16.360 --> 12:24.640
dass du das mit dem titel anspricht und zwar ein riesen vorteil den man ja go so nach sagt ist oder

12:24.640 --> 12:30.600
was das gar nicht so kompliziert formulieren ein riesen vorteil von go ist oder was go gemacht hat

12:30.600 --> 12:36.680
go hat jegliche deployment probleme einfach auf einschlag gelöst mit statischen binaries du

12:36.680 --> 12:43.000
kannst go du kannst ein go binary kompilieren du kannst das hinschieben wo du willst rückwirkend

12:43.000 --> 12:55.120
bis zu linux kernel 26 35 oder so das ist jahrzehnte alt und das läuft ich weiß ich weiß ich weiß gar

12:55.120 --> 13:11.400
nicht ob das stimmt was ich erzähle das go minimum linux kernel komm mal hier 26 32 ist go

13:11.400 --> 13:26.400
oh nee moment nee nee nee 26 23 vom februar 2008 also du kannst go binaries kompilieren

13:26.400 --> 13:36.560
und das läuft rückwirkend auf jedem x beliebigen linux system wo die cpu architektur stimmt und

13:36.560 --> 13:46.600
es ein neueren kernel ist als 26 23 26 23 wirklich uralt go hat ein paar andere dinger die ich

13:46.600 --> 13:52.400
persönlich nicht so ja aber das ist ein unglaublicher vorteil von go go hat jegliche

13:52.400 --> 14:00.400
deployment probleme gelöst weil du ein statisches binaries hast das schiebst du hin und gut ist klar

14:00.400 --> 14:06.840
das kann man wenn für web anwendung lösen mit irgendwelchen docker container oder sonst was dass

14:06.840 --> 14:12.360
man seine dependencies und alles mitbringt kein problem aber gerade im bereich von stand alone

14:12.360 --> 14:17.400
kommando zeilen tools oder sowas ist go einfach richtig gut weil du kannst das auf irgendeinem

14:17.400 --> 14:23.440
x beliebigen linux programmieren du kompilierst das als statisches binaries und jeder auf der

14:23.440 --> 14:31.320
welt der irgendwie linux hat der letzten 20 jahre kann es verwenden letzten 15 jahre das

14:31.320 --> 14:38.280
ist halt nicht schlecht so und bei dort net es ist aktuell so du kannst stand alone kompilieren

14:38.280 --> 14:53.640
und das wandelt aber im endeffekt nur die runtime und den die die ganzen dort net dependencies

14:53.640 --> 15:05.120
zusammen das ist aber auch relativ lange rückwärts kommen also ich glaube wir können mal kurz gucken

15:05.120 --> 15:12.780
also ich glaube dort net unterstützt aktuell in version 7 als mindestversion cento s7 also das

15:12.780 --> 15:21.680
was cento s7 hatte guck mal dort net supported versions das ist auch ziemlich alt supported

15:21.680 --> 15:32.120
linux versions müssen wir gucken supported os also man muss sagen dort net fünf das ist die

15:32.120 --> 15:40.280
aktuelle lts version die supported als mindest guck mal die haben ubuntu 1604 noch drinne

15:40.280 --> 15:50.000
ubuntu 1604 das ist auch schon acht jahre alt sechs jahre alt erzähl ich denn noch schon sechs

15:50.000 --> 15:57.360
jahre alt also das ist auch nicht auch nicht so ja gucken wir mal was mit dort net 7 ist ja ich

15:57.360 --> 16:02.880
habe fünf genommen weil es die google suche ausgespuckt hat und dass die in fünf war ist die aktuelle lts version so

16:02.880 --> 16:11.640
und mit supported us bei sieben ist es glaube ich ubuntu 1804 wobei diese ach sechs ist lts

16:11.640 --> 16:21.320
ach ja nee fünf war die dort net umbenennung voll core nach dort net und sechs ist die erste lts

16:21.320 --> 16:30.080
version jaja stimmt hast recht da die benahmung bei microsoft ist echt so für komplett abfall ich

16:30.080 --> 16:36.040
sage immer noch dort net core teilweise so und hier haben sie mindestversion 1804 wobei das hier

16:36.040 --> 16:42.680
oben ist alles ohne eigentlich ist das ziemlich egal was hier oben steht das interessante ist dass sie

16:42.680 --> 17:02.280
als einzige library brauchen glibc 2.17 so gucken wir mal glibc release date also die brauchen was

17:02.280 --> 17:12.640
von 2012 also man könnte sagen dass dort net auf allen linuxen der letzten zehn jahre ungefähr

17:12.640 --> 17:21.520
lauffähig ist also das ist auch net schlecht es ist zwar nicht so krass wie mit go was zurückgeht

17:21.520 --> 17:26.920
bis systemen bei 2008 aber das ist schon ganz ok man muss sagen das geht hier um systeme die

17:26.920 --> 17:36.600
2012 rausgekommen sind also wenn jetzt einer ankommt mit nem ubuntu 1204 weiß ich nicht was

17:36.600 --> 17:44.040
das für eine glibc version hat wenn ich ehrlich bin wahrscheinlich wahrscheinlich noch ein

17:44.040 --> 17:52.120
bisschen älter zumindest allein schon allein schon dass das zento s7 noch supportet sollte

17:52.120 --> 17:57.720
ein indikator sein dafür dass das eigentlich auf nahezu jedem linux was man heute so findet

17:57.720 --> 18:06.720
läuft ich meine man muss sich angucken zento s7 released in release date war juli 2014 das sind

18:06.720 --> 18:14.800
acht jahre das wird zehn jahre insgesamt supportet also ich was übrigens auch bedeutet dass die

18:14.800 --> 18:21.000
nächste dort net version und die ist dann lts version glaube ich da noch rein fällt und

18:21.000 --> 18:25.120
hoffentlich auch noch zento s7 kann das heißt man kann dann wirklich zehn jahre alte linux

18:25.120 --> 18:31.400
supporten das reicht so und mit diesem neuen ahead of time feature hätte man dann was was

18:31.400 --> 18:41.480
zumindest mal in die nähe von go kommt wenn das was taugt also sprich du hättest relativ

18:41.480 --> 18:50.000
statisch kompilierte binaries die irgendeine glibc version brauchen der letzten zehn jahre und die

18:50.000 --> 18:55.520
schnell starten so und das wollte ich mal ausbrühen ob das funktioniert wir können das ja mal

18:55.520 --> 19:00.840
vergleichen wir machen irgend so eine minimal konsolenanwendung und dann probieren wir mal

19:00.840 --> 19:09.440
aus wie schnell das startet mit normal kompiliert mit stand alone kompiliert und dann mit und dann

19:09.440 --> 19:15.600
mit diesem neuen compiler feature kompiliert also mit diesem neuen ahead of time compiler feature

19:15.600 --> 19:24.240
kompiliert ja wir können speedtest machen ja eigentlich eigentlich ist speedtest ja mittlerweile

19:24.240 --> 19:33.360
schon so der standard schnell starten tut mit dort net alles das probieren wir aus das probieren

19:33.360 --> 19:36.640
wir auch vielleicht braucht man das ja auch gar nicht mehr die größe ist mir gar nicht so wichtig

19:36.640 --> 19:50.640
muss man das irgendwie angeben muss man das irgendwie angehen angeben oder geht das automatisch

19:50.640 --> 20:02.520
muss man das irgendwie eintragen ihr iel mit enable oder das geht automatisch ok vielleicht

20:02.520 --> 20:06.720
braucht man das ja auch gar nicht müssen wir mal ausprobieren ich muss jetzt erstmal ein

20:06.720 --> 20:14.680
aktuelles dort net installieren so weil ich glaube ich download ich habe hier nix also wo

20:14.680 --> 20:19.040
haben wir es dann ja wir machen wieder irgendwie so simple simple kommando zeilen anwendung ich

20:19.040 --> 20:24.600
habe übrigens ein richtig progress command line framework gefunden für dort net das heißt

20:24.600 --> 20:27.920
gefunden ich habe das in dem video gesehen ich finde das wirklich gut es gibt tausend dieser

20:27.920 --> 20:36.640
frameworks aber das macht wirklich guten eindruck und wisst ihr wie das heißt kokona aber man

20:36.640 --> 20:49.280
schreibt es so es ist falsch geschrieben offensichtlich ja also es ist jetzt ja auch

20:49.280 --> 20:58.400
in der vergangenheit so gewesen dass dort net wenn du das als wie heißt das framework dependent

20:58.400 --> 21:05.680
bild gemacht hast dann startet das ist ja schon immer schneller als stand alone ich bin mir

21:05.680 --> 21:10.120
ehrlich gesagt gar nicht warum gar nicht weiß gar nicht warum ich mein gepackaged ist ja beides

21:10.120 --> 21:16.360
zusammen wir probieren das jetzt einfach mal aus so und das wollte ich in einem der nächsten

21:16.360 --> 21:22.600
steams auch mal ausprobieren das ist ein kommando zeilen framework und zwar kann man damit relativ

21:22.600 --> 21:32.800
easy alles mögliche machen von von argumenten pasen also parameter pasen das hat control

21:32.800 --> 21:39.880
c cancellation support es hat dependency injection support das macht wirklich einen ganz guten

21:39.880 --> 21:47.160
eindruck und es sieht griffig aus ja was man es sieht selbst erklären aus was ich auch

21:47.160 --> 21:51.560
immer gut finde wenn die libraries an sich so aufgebaut sind dass man versteht was das

21:51.560 --> 21:57.320
was das macht hast du jemals ja ich habe nachgedacht aber ich habe nie darüber ernsthaft mir

21:57.320 --> 22:03.960
gedanken gemacht zu machen ich finde es immer noch nicht super dass wpf nicht auf linux

22:03.960 --> 22:11.480
will es gibt zwar abalone aber ja ja also abalone ist eine gute idee ich muss sagen ich habe

22:11.480 --> 22:16.480
mir abalone lange nicht mehr angeguckt mittlerweile ich habe letztens mal ein reddit post über

22:16.480 --> 22:21.480
abalone gelesen wo irgendwie was einer geschrieben hat über oder nee hacker news post in den

22:21.480 --> 22:26.160
post casual gamer danke für den zapp sorry falls ich irgendjemand noch übersehen habe

22:26.160 --> 22:35.720
der irgendwas über die interne ränder architektur mit xia von abalone ja geschrieben hat übelstes

22:35.720 --> 22:40.800
feifehrer zeug kein schimmer aber zumindest abalone ja finde ich im prinzip gut weil abalone

22:40.800 --> 22:46.400
ja macht es richtig abalone macht nicht diesen blöden ansatz wie das das heißt ja nicht

22:46.400 --> 22:51.800
mehr xamarin das heißt ja maui macht abalone macht es richtig als gui framework abalone

22:51.800 --> 22:57.000
malt ihre controls selbst das ist ich habe schon oft gesagt das ist aus meiner sicht

22:57.000 --> 23:01.640
der einzig sinnvolle ansatz für eine für ein ui framework fallen für ein cross platform

23:01.640 --> 23:09.200
ui framework ist die controls selber zu malen eto forms nutzt aber auch nicht malt aber

23:09.200 --> 23:12.800
auch nicht die controls selbst eto forms ist quasi so ein bisschen was wie maui in die

23:12.800 --> 23:18.640
richtung nur dass sie glaube ich linux support haben so zumindest abalone ja habe ich mir

23:18.640 --> 23:23.120
vor längerer zeit angeguckt da gab es auch ein paar probleme da gab es beispielsweise

23:23.120 --> 23:33.720
kein gescheite kein gescheite kein gescheites browser widget und es gab kein keine gescheite

23:33.720 --> 23:37.800
möglichkeit eigene sachen rein zu rendern und so was da sind ja immer so die zwei sachen

23:37.800 --> 23:42.960
die finde ich jedes ordentliche gui framework neben den controls braucht weil ein browser

23:42.960 --> 23:47.360
brauchst du immer mal und ab und zu brauchst auch die möglichkeit einen content rein zu

23:47.360 --> 23:57.520
rendern und ich meine damit jetzt nicht dass man sagt hier und malen recht deck sondern

23:57.520 --> 24:02.240
irgendwas wie open gl x context irgendwo ins fenster malen und so dass da tun sich außer

24:02.240 --> 24:10.520
windows forms lustiger weise unter windows auch alle schwer so zumindest abalone ist

24:10.520 --> 24:14.280
eine gute idee die machen das auch besser als microsoft mit maui weil maui bis das mal

24:14.280 --> 24:20.200
linux support hat weiß ich nicht aber cross platform ist eh pains jam ich gucke mir noch

24:20.200 --> 24:24.480
mal kurz den chat an bevor wir anfangen ist sie scharpe immer noch so langsam vergleicht

24:24.480 --> 24:32.200
zu z plus plus weil es interpretiert ist also sie war noch nie interpretiert und ja es

24:32.200 --> 24:38.960
ist ein ticken langsamer als z plus plus aber das ist jetzt nicht irgendwie in wahnsinnigen

24:38.960 --> 24:45.640
größenordnungen oder so und je nachdem was du machst gerade was web framework sachen

24:45.640 --> 24:54.200
angeht ist das somit das schnellste was du verwenden kannst also asp.net core gerade

24:54.200 --> 24:58.600
seit der dotnet version seit der dotnet 6 version steckt so ziemlich alles in die tasche

24:58.600 --> 25:03.440
was es sonst noch an frameworks gibt also node.js ist ja komplett abgehängt aber auch

25:03.440 --> 25:10.880
sachen wie die ganzen go frameworks oder frag mich was gibt es denn was gibt es denn da

25:10.880 --> 25:17.880
sonst noch keine ahnung also asp.net core ist saumäßig schnell das dürfte eines der

25:17.880 --> 25:23.000
schnellsten web framework sein die du aktuell verwenden kannst natürlich du kannst es auch

25:23.000 --> 25:28.440
so weit aufbauen dass es langsam ist aber die normalen features wenn du die verwendest

25:28.440 --> 25:36.400
sind saumäßig schnell also das ist auch eine coole funktion oder was funktion funktion

25:36.400 --> 25:40.800
es war das ist auch eine eine einschalt eine eigenschaft die ich an dort net beziehungsweise

25:40.800 --> 25:48.760
an sich hat mag die sprache ist nice und es ist man kann jetzt nicht sagen das schnellste

25:48.760 --> 25:55.680
der schnellsten aber man kann sagen es ist schneller als das meiste was es sonst so gibt

25:55.680 --> 26:01.320
und die kombination gibt es finde ich selten du hast so sachen wie pyson und ruby wobei

26:01.320 --> 26:05.040
ruby eine ganze ecke schneller ist als pyson aber trotzdem ist pyson deutlich beliebter

26:05.040 --> 26:12.800
die mögen zwar gut ausschauen gut lesbar sein sich schnell programmieren aber wenn

26:12.800 --> 26:18.400
es richtig wums haben muss musste halt hoffen dass es irgendein c-modul gibt was das macht

26:18.400 --> 26:24.120
was du machen willst so und dann hast du so sachen wie javascript die sind für das was

26:24.120 --> 26:28.840
es ist auch ziemlich schnell mittlerweile aber können halt überhaupt nicht mithalten mit

26:28.840 --> 26:34.800
sagen wir mal rust oder sowas in der richtung und das ist halt das schöne an c-sharp c-sharp

26:34.800 --> 26:39.960
ist schön zu programmieren finde ich persönlich relativ lesbar finde ich als generell eines

26:39.960 --> 26:44.840
der besten sprachen die es gibt und es ist auch noch saumäßig schnell und das ist eine

26:44.840 --> 26:52.560
schöne kombination und es ist halt unglaublich universell du kannst in c-sharp nahezu alles

26:52.560 --> 27:00.040
machen was du machen willst also du von ich mein guck mal so sachen wie von web anwendungs

27:00.040 --> 27:05.680
backends bis zu web ich mein ich bin kein fan von blazer ja das habe ich schon oft genug

27:05.680 --> 27:14.120
gesagt aber man sieht in welche richtung sich das entwickelt web assembly frontend anwendung

27:14.120 --> 27:20.080
alles mögliche also das ist tatsächlich sehr nice und osu ist auch in c-sharp programmiert

27:20.080 --> 27:27.200
ja osu ja unity und sowas osu ist glaube ich kein unity game aber unity hat hat unity

27:27.200 --> 27:38.080
immer noch irgendwie diese uralt mono version also c-sharp war schon das ist war noch nie

27:38.080 --> 27:46.160
interpretiert das weiß ich werde wer das erzählen hat aber das stimmt nicht ja flutter

27:46.160 --> 27:51.520
frontend läuft überall solange überall mobile ist auf dem desktop ist das grausam also flutter

27:51.520 --> 28:04.360
desktop ist noch sehr sehr pains champ gerade auf linux

28:04.360 --> 28:09.600
microsoft verkackt das leute ich kann euch nicht empfehlen microsoft frontends microsoft

28:09.600 --> 28:14.880
gui frameworks zu lernen ich persönlich bin der ansicht wpf ist das einzig sinnvolle was

28:14.880 --> 28:21.520
es gibt nicht wpf windows forms ist das einzig sinnvolle was es gibt weil nicht wegen den

28:21.520 --> 28:27.720
features oder so weil du damit ziemlich gut integration mit anderen technologien hinkriegst

28:27.720 --> 28:31.000
falls du halt einfach nur was brauchst was deine fenster managt und den rest selbst machen

28:31.000 --> 28:36.560
willst das ist das ist ok rest von dem was windows forms eigentlich ausmacht kann sie

28:36.560 --> 28:41.600
windows forms komplett in die tonne kloppen da kommst du dir vor wie 1995 wpf ist zwar

28:41.600 --> 28:49.680
neuer aber wpf ist auch nicht so viel moderner die haben zwar vielleicht deutlich moderne

28:49.680 --> 28:55.320
ansätze als windows forms aber von dem was da an technik unterstützt wird ist auch uralt

28:55.320 --> 29:00.240
das heißt microsoft hat nichts auf dem desktop die haben eine zeit lang versucht uwp zu

29:00.240 --> 29:06.600
pushen uwp hat nicht funktioniert und jetzt gibt es intern irgendwie den halben framework

29:06.600 --> 29:12.720
die kriegbar microsoft was sich jetzt durchsetzt eigentlich müsste es winui sein weil winui

29:12.720 --> 29:18.320
die logische konsequenz die logische konsequenz ist aus dem was sie mit wpf mal ursprünglich

29:18.320 --> 29:24.260
vor hatten nämlich ein ordentliches desktop framework allerdings für alle anwendungsformen

29:24.260 --> 29:29.800
das problem ist nur dass sie mit winui absolut nicht hier in an start kommen kriegen kriegen

29:29.800 --> 29:34.520
das seit jahren nicht hin und ich weiß ehrlich gesagt gar nicht was da was der aktuelle

29:34.520 --> 29:39.120
stand mit winui 3 ist das letzte mal wo ich geguckt habe winui 3 dann haben sie geschrieben

29:39.120 --> 29:45.640
hoho ihr könnt jetzt native desktop applications machen also kein uwp aber immer noch mit

29:45.640 --> 29:51.400
packaging und clientzertifikat oder habe ich mir gedacht also wenn ich ein clientzertifikat

29:51.400 --> 29:56.040
also kein clientzertifikat mit codesignzertifikat habe ich mir gedacht also wenn ich ernsthaft

29:56.040 --> 30:02.400
für irgendeine publische drei fenster open source anwendung die ich auf github pushen

30:02.400 --> 30:08.200
will für irgendwie in den nischenkreis an leute wenn ich mir dafür ernsthaft ein codesignzertifikat

30:08.200 --> 30:15.280
kaufen soll dass der installer nicht meckert beziehungsweise der es sich überhaupt installieren

30:15.280 --> 30:22.400
lässt oder ausführen lässt dann weiß ich auch nicht was das soll ja ich meine du kannst

30:22.400 --> 30:27.640
natürlich immer noch sagen hey bitte bitte lieber download installiere noch einen kleinen

30:27.640 --> 30:32.640
clientzertifikat von mir was ich selbst sein habe aber bis du es den leute erklärt hast

30:32.640 --> 30:37.040
zeige ich dir doch den vorrl also das ist das ist müll bisher gewesen

30:37.040 --> 30:49.240
spree pies sind megateil benchmark ich glaube das ist das was auch die was auch die microsoft

30:49.240 --> 30:59.720
leute immer ganz gerne zeigen weil sie da gut gut dastehen was dort net dort net angeht

30:59.720 --> 31:10.200
guck mal hier also web framework web framework web framework benchmark asp.net core ist auf

31:10.200 --> 31:15.480
platz ich sag jetzt mal eins von denen die ich kenne actix ist das nicht in den rust

31:15.480 --> 31:25.640
framework ja ok also es ist ok ein ein framework in rust ist schneller ganz ehrlich das obendrüber

31:25.640 --> 31:30.120
habe ich alles noch nie gehört ich habe weder von lithium noch von just noch von droga noch

31:30.120 --> 31:40.840
von may mini htp n text oder sonst was gehört außer in meinem chat ja also asp.net core

31:40.840 --> 31:45.560
ist das schnellste web framework neben actix wovon ich zumindest mal also actix habe ich

31:45.560 --> 31:49.400
zumindest schon mal gehört wenigstens ja und wenn man sich das mal anguckt die üblichen

31:49.400 --> 31:55.600
bekannten müsste mal runter scrollen hier wann wann da was kommt guck mal hier php nginx

31:55.600 --> 32:02.040
cacquade halb so schnell und wenn wir jetzt mal irgendwie node oder so gucken node.js

32:02.040 --> 32:10.680
ist da ohne irgendwo oder wo ist hier gin von go ist auch da ohne irgendwo wo ist express

32:10.680 --> 32:18.560
express ist hier komplett am arsch der welt pass mal auf django django ist halt eh eng

32:18.560 --> 32:32.600
vorher oh rails rails ist noch langsamer als django cacquade ja gut das hätte ich gar

32:32.600 --> 32:37.320
nicht gedacht ruby ist im prinzip schneller als python ich meine wir reden hier von doppelt

32:37.320 --> 32:42.920
so schnell und es ist immer noch wahnsinnig langsam rails ist halt der abfang dafür muss

32:42.920 --> 32:47.480
man sagen eins muss man halt wirklich rails lassen es ist entwickeln in rails ist mega

32:47.480 --> 32:52.560
angenehm zumindest war es das damals ich denke mal mittlerweile nimmt sich das nicht so viel

32:52.560 --> 32:59.120
flask ist schneller gut das wundert mich nicht das ist ja auch minimalistischer ja also man

32:59.120 --> 33:06.120
sieht hier schon die jetzt genießt das war mit so ein bisschen portion skeptisch ja das

33:06.120 --> 33:10.280
sind ja wahrscheinlich auch super optimierte sachen für die einzelnen dinger aber trotzdem

33:10.280 --> 33:16.120
ich finde ein combined score bei den frameworks zeigt schon das asp.net core wirklich ziemlich

33:16.120 --> 33:22.080
schnell ist übrigens gibt es den c++ framework oh nein igitt c++ frameworks sind auf platz

33:22.080 --> 33:30.560
eins ok zeig mal habe ich noch nie was von gehört high performance attp server ja das

33:30.560 --> 33:36.640
ist kein web framework das ist web server oder immerhin halbwegs halbwegs beliebt es

33:36.640 --> 33:42.600
ist web server ja was ist das für ein komischer benchmark wenn der web server drin sind dann

33:42.600 --> 33:47.120
ist wahrscheinlich engine x auch dabei und engine x ist halt der kann das gut weil er

33:47.120 --> 34:02.680
kann gut web surfen für was ist dieses t hier neben was ist was ist denn das t ja ein plan

34:02.680 --> 34:28.680
dass das sein soll ich ich kenne überhaupt nicht ja das ist nicht ganz so ah

34:28.680 --> 34:42.840
ach so die sind noch meinem extra benchmark drinne ok da ist auch rails dabei ja also

34:42.840 --> 34:53.160
das immer wieder dabei c++ first rast danach aber in naja man kann nicht sagen ähnlichen

34:53.160 --> 34:58.560
gefilm aber doch ganz weit vor dem rest noch asp.net core und ich finde das macht es dazu

34:58.560 --> 35:06.560
wirklich super kombination aus der sprache die super ist und es ist auch schnell was

35:06.560 --> 35:11.160
war noch mal deine meinung zu self house und nextcloud ich mag nextcloud nicht alternative

35:11.160 --> 35:22.280
fällt mir jetzt gerade nichts ein ok weiter wo ist arpeggio gut es ist kein web framework

35:22.280 --> 35:29.600
das ist dann nicht drin aber pap engine x ist drinne pap pap mit engine x ist drinne

35:29.600 --> 35:36.080
oder kumbia pap da sieht man mal pap ist besser als sein ruf ja guck mal es gibt fife hat

35:36.080 --> 35:43.000
fife hat cpp und der große unterschied zwischen dem und den da oben könnte vielleicht auch

35:43.000 --> 35:48.320
der feature umfang sein keine ahnung aber es ist schon saumäßig schnell so jetzt kommen

35:48.320 --> 35:53.960
wir zur eigentlichen sache weil sonst wären wir heute nicht fertig ja das wollte ich gerade

35:53.960 --> 35:57.560
sagen das ist wahrscheinlich abartig erst fack in c++ zu entwickeln aber ich kenne

35:57.560 --> 36:01.680
das framework nicht deswegen keine ahnung so jetzt fangen wir mit der eigentliche sache

36:01.680 --> 36:10.000
an die wir machen wollten jetzt die klima nach dem wieder einschalten also ich wollte

36:10.000 --> 36:21.840
eine dotnet version runterladen download da wo sind wir download dotnet 7 also dotnet 7

36:21.840 --> 36:34.280
kommt im november raus wir gucken wann irgendwann zu ihrer komischen dotnet konferenz 7 übrigens

36:34.280 --> 36:41.520
wer jetzt da nicht so auf zack ist mit den dotnet versionen man könnte jetzt denken dotnet

36:41.520 --> 36:50.120
1 wurde 13 februar 2002 veröffentlicht und dotnet 7 erscheint im november 2022 das würde

36:50.120 --> 37:00.040
bedeuten es gab über 20 jahre nur sieben framework releases das stimmt aber nicht

37:00.040 --> 37:05.840
weil die microsoft benahmung komplett für den arsch ist das war dotnet framework und

37:05.840 --> 37:11.080
das hier ist die dotnet das ist der siebte release von dotnet core der unbeland wurde

37:11.080 --> 37:17.920
in dotnet 5 und jetzt weiterentwickelt zu dotnet 6 und dotnet 7 weil microsoft sich gedacht

37:17.920 --> 37:28.360
hat wir müssen mal alle gebaden und das darf keiner mehr durchblicken bei unserer benahmung

37:28.360 --> 37:43.800
wie ist das eigentlich moment was wie ist das csharp ekosystem gibt es sowas wie cradle

37:43.800 --> 37:49.080
nachdem ich weder maven noch cradle verwendet habe und genau weiß was die machen also ich

37:49.080 --> 37:53.160
weiß so grob dass du mit cradle irgendwie was baust und mit maven irgendwie dann die

37:53.160 --> 37:57.240
artefaktes stores oder so aber ich habe vom java ekosystem ehrlich gesagt relativ wenig

37:57.240 --> 38:01.800
plan du kannst von ausgehen dass es sowas gibt ich kann es dir aber nicht genau sagen

38:01.800 --> 38:08.880
weil ich nicht weiß was die zwei dinger genau machen also ich muss jetzt endlich mal den

38:08.880 --> 38:25.800
graben downloaden hier dotnet 7 preview 5 für x64 also wegett bam

38:25.800 --> 38:33.560
moment das finde das mag ich ja immer wenn man irgendwo download links macht und die

38:33.560 --> 38:39.480
nicht wegettbar sind weil sie noch irgendwie redirecten mit javascript und so komisch im

38:39.480 --> 38:56.120
krempel ja guck abbrechen so zack das da brauen wir wegett cradle ist ein tool welches mit

38:56.120 --> 39:03.240
mir komfortabel die dependencies also das macht das macht das dotnet cli das macht das dotnet

39:03.240 --> 39:08.440
cli und nuke standardmäßig schon dependency management ist dabei da brauchst du kein

39:08.440 --> 39:14.600
extra tool und du kannst dann die meisten sachen einfach mit dotnet publish raushauen

39:14.600 --> 39:22.080
wenn du extra wirste brauchst brauchst du eh unterm strich entweder irgendeinen automatischen

39:22.080 --> 39:27.560
bild task der das macht oder halt irgendwelche containers aber gut ich kann es nicht vergleichen

39:27.560 --> 39:32.640
weil ich den graben nicht kenne aus dem java umfeld kann ich das mich trauen das aufzumachen

39:32.640 --> 39:42.600
ja ok 18 jahre dotnet genau 2002 framework framework framework framework und hier und

39:42.600 --> 39:47.520
man sieht schon das hat das hat noch zu ballmer zeiten glaube ich ursprünglich mal angefangen

39:47.520 --> 39:52.960
oder wurde in die wege geleitet aber dotnet core seit dem dotnet core release geht microsoft

39:52.960 --> 40:03.400
richtig ab die am jeli releases sowohl von c-sharp major version als auch dotnet major

40:03.400 --> 40:07.360
version wobei nicht unbedingt major version es können auch kleinere sprünge sein aber

40:07.360 --> 40:10.480
die letzten sachen waren immer major version ich glaube das werden sie jetzt beibehalten

40:10.480 --> 40:15.960
weil sich das einfach marketing technisch besser anhört und ich kann mir ehrlich gesagt

40:15.960 --> 40:21.480
auch dotnet 567 besser merken als sind wir jetzt bei dotnet core 30 31 32 oder schon

40:21.480 --> 40:31.600
37 dotnet core 1 muss ich muss ich dir sagen habe ich nicht ausprobiert ich weiß dotnet

40:31.600 --> 40:38.560
core 1 ich habe da mal ganz ich habe ja ich mache ja schon seit 2002 hier 2002 2003 dotnet

40:38.560 --> 40:44.520
sagen ich mache schon lange was ich habe mir das angeguckt als es neu war ich habe festgestellt

40:44.520 --> 40:49.600
es hat irgendwelche jason run konfig gehabt habe ich mir schon gedacht ok dieses xml zeug

40:49.600 --> 40:54.600
ist zwar nicht so geil aber das neue jason konfig format hat mir gar nicht gefallen und

40:54.600 --> 40:59.000
was mich bei dotnet core 1 und 2 übelst abgefuckt hat ist dass die hälfte der klassen gefehlt

40:59.000 --> 41:05.520
hat und microsoft damals gesagt hat das ist doch nicht schlimm das braucht man eh nicht

41:05.520 --> 41:13.400
und dann kamen so dinge wie man möchte support einstellen für windows forms und wpf aber

41:13.400 --> 41:19.640
hatte noch das nicht laufweg in dotnet core und solche dinge also microsoft hat sich schon

41:19.640 --> 41:24.200
ziemlich da verrannt zwischenzeitlich aber mittlerweile haben sie ganz haben sie es eigentlich

41:24.200 --> 41:33.520
ganz gut ganz ganz gut im griff das war auch die geschichte wie asp dotnet core lief ja

41:33.520 --> 41:38.680
eine zeit lang auch parallel auf dotnet core und dem normalen dotnet framework nur mit

41:38.680 --> 41:42.040
dem unterschied dass manche sachen die man machen wollte nur mit dem framework ging das

41:42.040 --> 41:47.960
war auch ganz ganz wir und ich glaube stand alone anwendung kann das sein ich weiß es

41:47.960 --> 41:55.440
nicht mehr genau was es war und es war ganz ganz mir also ich muss sagen so richtig regelmäßig

41:55.440 --> 42:06.760
dotnet core verwende ich seit ja so ich denke mal so seit 21 in dem dreh irgendwie hier

42:06.760 --> 42:17.600
so ja und ab da wurde es halbwegs benutzbar das stimmt so also runter geladen irgendwie

42:17.600 --> 42:41.280
das hat es nicht downloaded dotnet core wird weiterentwickelt heißt jetzt plus dotnet also

42:41.280 --> 42:54.440
hier guckt mal man sieht es ja auch hier dotnet 5 ist dotnet core microsoft hat sich nur gedacht

42:54.440 --> 43:02.160
wir müssen die leute verwirren und man hat es witzigerweise dotnet 5 genannt und eigentlich

43:02.160 --> 43:08.880
eigentlich leute eigentlich hätte man es dotnet core 4 nennen müssen bzw dotnet 4 das

43:08.880 --> 43:13.480
wollten sie aber nicht weil die leute dann zu konfus werden wir dotnet framework 4.8 was

43:13.480 --> 43:19.720
eigentlich viel älter ist deswegen hat man das übersprungen hat es dotnet 5 genannt was

43:19.720 --> 43:26.360
trotzdem irgendwie nahe liegt dass es eine weite entwicklung von dotnet framework 4.8

43:26.360 --> 43:40.240
ist ist es aber nicht weil es ist von dotnet core also ist microsoft und benahmung wissen

43:40.240 --> 43:46.000
wir seli was ist mit discord link wenn du discord link ausrufe zeichnen discord gibt

43:46.000 --> 43:54.640
es einen invite link so weiter gehts was ist denn mit dem microsoft download server los

43:54.640 --> 44:01.160
wollen die mich wollen die mich rollen oder was ich will einfach dotnet downloaden das

44:01.160 --> 44:05.240
ist nicht dotnet framework gemerkt aus dem dotnet framework ist da nix davon drinne das

44:05.240 --> 44:09.560
ist dotnet core was sie gemacht haben bei dotnet 5 ist ja gut doch du hast schon du

44:09.560 --> 44:13.800
hast in gewisser weise schon recht bei dotnet 5 haben sie zum ersten mal offiziell winnows

44:13.800 --> 44:17.840
forms und gedöns unterstützt da haben sie bestimmt ein paar sachen aus dem framework

44:17.840 --> 44:32.800
copy pasted einfach mehrfach ausführen dann funktioniert's mic microsoft microsoft logik

44:32.800 --> 44:49.240
ok mk dir dotnet sieben mv dotnet dotnet sieben dotnet sieben yes excellent so ta xfz

44:49.240 --> 44:59.920
v dotnet ok dann machen wir rider mal auf und stellen das um oder fügen das mal hinzu

44:59.920 --> 45:12.160
in meine wie heißt es bei rider environments oder sowas build execution deployment tool

45:12.160 --> 45:30.520
set und bild heißt genau nope wir wollen download dotnet sieben hallo dotnet wie sieht

45:30.520 --> 45:37.760
deine entwicklungsumgebung für linux aus benutzen ja rider korrekt also visual studio

45:37.760 --> 45:47.920
code reicht wobei ganz ehrlich ich mag ich mag visual studio code nicht für dotnet kram

45:47.920 --> 45:57.680
so safe die haben jetzt auch schon ein bisschen dotnet sieben support drinne das reicht für

45:57.680 --> 46:02.520
das was wir machen die drei zeilen kommando zeilen anwendung zum testen so also console

46:02.520 --> 46:12.400
application komm hier speed test light wir machen wieder ein speed test speed test ist

46:12.400 --> 46:17.400
jetzt unser neues hallo world programm weil wir machen gar kein speed test ich nenne das

46:17.400 --> 46:24.560
einfach speed test copy paste drei kommando zeilen dinge rein kackel pock cute chat in

46:24.560 --> 46:35.080
der ausgabe und dann ist gut so docker support brauche man nicht language kalson danke für

46:35.080 --> 46:39.400
den sub visual studios beste für dotnet sagen nee ganz ehrlich ich muss sagen ich habe

46:39.400 --> 46:44.760
deswegen habe ich den kram mittlerweile auch unter windows ich muss sagen ich mag tatsächlich

46:44.760 --> 46:48.960
rider mittlerweile ich habe auch auf visual studio geschworen früher einfach aus dem

46:48.960 --> 46:54.160
grund weil die alternativen für dotnet eklig waren aber seit es rider gibt oder sagen wir

46:54.160 --> 47:00.840
in den letzten paar jahren ist mir rider deutlich lieber geworden als visual studio vor allem

47:00.840 --> 47:05.320
der grund sollte aber offensichtlich sein bei mir weil ich das ordentlich unter linux

47:05.320 --> 47:14.480
verwenden kann und bei dem anderen kram muss ich es unter windows machen das heißt es ist

47:14.480 --> 47:20.840
für mich sogar richtig nice für mich ist es die beste idee in der besten entwicklungs

47:20.840 --> 47:30.720
umgebung also die beste entwicklungs umgebung in der besten entwicklungs umgebung so gut

47:30.720 --> 47:37.680
löschen wir das mal wir machen jetzt irgendwann hallo world programm so what the fuck ich

47:37.680 --> 47:46.880
wollte command line schreiben darf ich nicht ok console right line kackel cute chat so

47:46.880 --> 47:51.440
besser bestes kommando zeilen tut wobei ich ich habe doch hier ich mache jetzt die ich

47:51.440 --> 47:57.560
mache die die kona standard anwendung da jetzt rein weil das wollte ich mir immer angucken

47:57.560 --> 48:05.200
aber das war jetzt nicht heute im stream ich will einfach nur mal jetzt hinzufügen ich

48:05.200 --> 48:14.200
habe youtube videos gesehen von einem auf ich habe auf youtube videos gesehen von einem

48:14.200 --> 48:20.720
der dort net in wim programmiert ich bin fast vom glauben abgefallen habe gedacht wtf was

48:20.720 --> 48:32.000
ist was mit euch los aber anscheinend wo genau ist dein problem

48:32.000 --> 48:57.200
also kann sie mich kohle und lull so was ist hier download dot net sieben dot net run

48:57.200 --> 49:07.520
ach ich habe nicht angeklickt dass der das im gleichen verzeichnis machen soll naja gut

49:07.520 --> 49:17.800
gibt schlimmeres so dort net sieben run option error option name is required ok option übrigens

49:17.800 --> 49:27.440
als kleiner als kleiner trick wenn ihr sachen mit dort net run ausführen wollt was kommando

49:27.440 --> 49:35.600
zeilen argumente braucht dann macht einfach minus minus und dann die kommando zeilen argumente

49:35.600 --> 49:40.000
dahinter und dann gelten die kommando zeilen argumente für eure app und nicht für dort

49:40.000 --> 49:44.560
net run also ihr könnt jetzt sogar machen minus minus help und dann gehen die kommando

49:44.560 --> 49:49.200
zeilen argumente an euer programm was nachdem es dort net run ausgeführt hat guckt jetzt

49:49.200 --> 49:53.040
kriege ich die hilfe jetzt kriege ich die hilfe hier für den speed test light also

49:53.040 --> 50:01.160
das hier das reicht als hello world programm zum ausprobieren heute warum wishell studio

50:01.160 --> 50:08.360
versus rider noch mal ganz einfach weil rider unter linux läuft wishell studio nicht das

50:08.360 --> 50:11.480
kann ich nicht beurteilen ich habe noch nie an projekten gearbeitet mit 200 projektmappen

50:11.480 --> 50:18.760
drinnen rider frisst ram wie sau wishell studio aber auch also ich würde ganz ehrlich

50:18.760 --> 50:23.640
sagen performance technisch ist es noch nicht mal so der unterschied der für mich jetzt

50:23.640 --> 50:42.320
den ausschlag gibt der witz hat so ein bad mittlerweile arrow danke für den sub jaja

50:42.320 --> 50:48.160
natürlich also resharper ist eingebaut in rider das ist ja vom gleichen hersteller rust

50:48.160 --> 50:57.480
ist auch ziemlich pock also rider ist von jet planes genauso wie resharper nur das angeblich

50:57.480 --> 51:03.240
wie sharper wishell studio komplett zugleistet und ist unbenutzbar langsam macht in manchen

51:03.240 --> 51:08.360
fällen und rider eigentlich ganz gut benutzt bleibt so jetzt haben wir unsere super high

51:08.360 --> 51:15.120
end kommando zeilen anwendung fertig und achso es gibt noch übrigens was cooles also das

51:15.120 --> 51:20.000
ich kann ihr könnt sagen dort net watch run also wahrgenommen entwickelt jetzt daran habe

51:20.000 --> 51:23.840
keinen bock das immer wieder neu auszuführen mit irgendeinem shortcut dann macht ihr einfach

51:23.840 --> 51:35.200
dort net watch keine ahnung minus minus name keckel dann führt er das aus startet emojis

51:35.200 --> 51:40.720
gehen bei mir hier nicht drinnen ganz fatal hallo keckel und jetzt kann ich hier was ändern

51:40.720 --> 51:49.120
guck mal und ich drücke jetzt einfach save oder oder führt das neu aus lulvee blub blub

51:49.120 --> 51:57.600
save oder führt es automatisch neu aus das geht mittlerweile auch für web anwendung und

51:57.600 --> 52:06.640
sogar je nachdem was es für web anwendungen sind so feinfühlig dass sie nicht komplett

52:06.640 --> 52:14.880
neu gestartet werden muss das ist praktisch so also keckel name das unsere konsolen anwendung

52:14.880 --> 52:19.080
so und jetzt machen wir mal eine hot reload genau jetzt machen wir mal eine klassische

52:19.080 --> 52:33.600
dort net anwendung und zwar also eine excel draus windows speak also ein binary draus

52:33.600 --> 52:36.720
da muss ich mal gucken ob ich das jetzt richtig zusammen kriege publish habe ich noch was

52:36.720 --> 52:44.480
im hintergrund also genau dort net publish allerdings mit dem richtigen dort net dort

52:44.480 --> 52:50.640
net 7 dort net publish config release das muss man machen dass er alle compile optimierung

52:50.640 --> 52:56.800
anmacht wir wollen es für alle linien und wir wollen es generik für linux bilden self

52:56.800 --> 53:02.240
contained dass er alles an dependencies mit reinbaut und single file das am ende eine

53:02.240 --> 53:07.880
excel oder ein binary rauskommt und das in bild ordner so das ist das was man die ganze

53:07.880 --> 53:13.680
zeit schon machen konnte mit dort net kein kein ding so und dann hatten wir den bild

53:13.680 --> 53:23.320
ordner und dann kann man hier reingucken und da liegt ein 64 megabyte massive massive

53:23.320 --> 53:31.880
chunker binary rum das kriegt man mit tricks auch noch kleiner und wenn man das jetzt ausführt

53:31.880 --> 53:43.520
dann sieht man schon guckt mal es ist name kecke oder name cute chat also man sieht schon

53:43.520 --> 53:51.280
also ihr merkt den kleinen delay beim ausführen ja und das ist halt einfach was so typisch

53:51.280 --> 53:58.880
für ein bisschen komplexere dort net kommando zeilenprogramme sind die wenden sind nicht

53:58.880 --> 54:03.200
instant ausgeführt einfach weil die erstmal anfangen müssen zu starten und zu jitten

54:03.200 --> 54:08.600
und dann dass es läuft und das ist das was die ganze ahead of time compilation deutlich

54:08.600 --> 54:13.480
verbessern soll natürlich macht dieses framework hier das bestimmt jetzt auch noch mal ein

54:13.480 --> 54:20.840
bisschen langsamer das ist tatsächlich eine relativ komplexe anwendung für dort net was

54:20.840 --> 54:25.680
meinste was der krempel hier unter der haube macht das macht bestimmt irgendwelche reflection

54:25.680 --> 54:29.200
damit es die kommandos findet und was auch immer das ist wahrscheinlich gar nicht so

54:29.200 --> 54:38.080
einfach was passiert so wir mit mir teilen das jetzt mal user bin teilen minus v gibt

54:38.080 --> 54:49.120
es net bsd teilen please teilen ich brauche bsd teil ich brauche ordentliches teilen nicht

54:49.120 --> 55:06.200
dieses zsh krepp krepp teilen ach du scheiße wie heißt das

55:06.200 --> 55:17.520
teilen also das normale teilen ist halt müll ne das normale teilen ist müll das zeigt

55:17.520 --> 55:23.240
jetzt war schon so grob an was ist aber der output von dem anderen ist viel besser der

55:23.240 --> 55:29.320
misst auch noch speicherverbrauch und alles mit und der zählt auch nicht nur die zeit

55:29.320 --> 55:33.280
hier zusammen sondern zeigt dir an wieviel wirklich echtzeit vergangen ist und sowas

55:33.280 --> 55:40.320
ne ne wir können sie best ich will das bsd teilen haben aber ich weiß nicht wie das

55:40.320 --> 55:55.760
package heißt auch geil alda elisa kann ich installieren ich will teilen installieren

55:55.760 --> 56:18.400
2300 oder ist das überhaupt das bsd teilen user bin teilen hyper hyper fein kenne ich

56:18.400 --> 56:22.140
das habe ich schon ein paar mal benutzt ich weiß aber gerade nicht mehr aus war das das

56:22.140 --> 56:26.200
war benchmark geschichte oder ne ne ne das meine ich nicht das haben wir sogar installiert

56:26.200 --> 56:38.480
kannst du kannst du aber ne ne ne das meine ich nicht arsch wie kriege ich das user bin

56:38.480 --> 56:49.120
missing was muss ich installieren was muss ich installieren leute sagt es mir user bin

56:49.120 --> 57:00.360
teilen habe ich net bsd utils hast schon fleet ausprobiert nein und habe ich auch nicht

57:00.360 --> 57:09.320
mehr vor weil es der da moment sorry ich habe es mit swarm verwechselt wo ist das wie

57:09.320 --> 57:35.480
kriege ich das installiert also ja ok einfach teilen installieren mit pack man alles klar

57:35.480 --> 57:46.160
mache ich pack man teilen installieren user bin teilen jawoll perfekt so das will ich

57:46.160 --> 57:54.440
haben user bin teilen minus v so das will ich haben so das zeigt dir nämlich ramauslastung

57:54.440 --> 58:10.680
an und das insgesamt 31 also 310 310 millisekunden also 0,3 sekunden kennst du ja kenn ich das

58:10.680 --> 58:16.320
kann man mit steuerung weh gar nicht löschen ok also wir haben eine verzögerung von von

58:16.320 --> 58:23.320
300 millisekunden beim start das ist nicht wirklich wild aber bei kommando zeilen tools

58:23.320 --> 58:26.920
gerade welche die man in scripts ausführt oder schnell ausführen möchte ist das natürlich

58:26.920 --> 58:38.280
doof so und jetzt machen wir das was wir ausprobieren wollten also die der bild von dort net hat

58:38.280 --> 58:44.760
ein binary rausgehauen mit 64 megabyte man kann das ganze jetzt noch ein bisschen ich

58:44.760 --> 58:48.760
zeige euch mal wie man den kram noch ein bisschen kleiner machen kann es gibt es gibt

58:48.760 --> 58:53.520
ein paar tricks und das hat jetzt mit ahead of time kompilierung noch gar nichts zu tun

58:53.520 --> 59:00.960
man kann sagen wie viel schneller ist ready to run das eine gute das eine gute frage

59:00.960 --> 59:08.720
das probieren wir gleich aus wahrscheinlich wahrscheinlich ein bisschen die ready to run

59:08.720 --> 59:15.800
sache ist es gibt ja aber es gibt ja alle hallo so es gibt ja bei microsoft wie üblich

59:15.800 --> 59:25.720
wieder 50 verschiedene muss ja noch etwas anderes einstellen ach nee gleich true muss

59:25.720 --> 59:32.920
ich machen es gibt ja wieder bei microsoft 150 verschiedene sachen was man machen kann

59:32.920 --> 59:40.840
diese publish ready to run ist so ein hybrid aus ahead of time kompilierung und jit die

59:40.840 --> 59:47.560
liefern wohl irgendwelche vor kompilierten run times aus die schneller starten aber dann

59:47.560 --> 59:52.000
sobald euer programm anfängt zu laufen doch jitten oder ach keine ahnung genau es ist

59:52.000 --> 59:56.960
microsoft zeug so ganz genau im detaill blick ich da auch nicht durch so jetzt noch mal

59:56.960 --> 01:00:04.680
ein mb größer gucken wir mal wie schnell das startet das startet schon mal noch ein

01:00:04.680 --> 01:00:09.960
bisschen schneller guckt mal das hat jetzt nur noch 200 millisekunden verzögern aber

01:00:09.960 --> 01:00:24.560
es ist natürlich kein vergleich zu ls oder so ls hat einfach ist einfach instant da also

01:00:24.560 --> 01:00:28.360
ready to run ist schon mal ein bisschen schneller also wir machen jetzt erstmal die binaries

01:00:28.360 --> 01:00:33.400
kleiner damit ihr das auch mal gesehen habt ich hoffe ich krieg die passenden kommandos

01:00:33.400 --> 01:00:40.160
aus dem aus dem kopf hin also 65 mb ist viel zu fett finde ich für so ein mini hello world

01:00:40.160 --> 01:00:48.440
binary das liegt aber daran dass es komplett unoptimiert also sprich da wenn nichts unused

01:00:48.440 --> 01:00:54.360
rausgekürzt oder sonst wie als er mit nichts getrimmt da wird auch sonst nichts großartig

01:00:54.360 --> 01:00:58.400
komprimiert oder so also man kriegt das mit ein paar einfachen befehlen doch der ganze

01:00:58.400 --> 01:01:04.640
ecke kleiner also zum beispiel kann man machen dafür bräuchte man mal was dafür bräuchte

01:01:04.640 --> 01:01:12.240
man markt tepp completion jetzt weil ich kann mir das immer nicht merken dort net trim trimmig

01:01:12.240 --> 01:01:24.840
jawoll minus p im public trimm kann man angeben das macht jetzt schon mal eine ganze ecke

01:01:24.840 --> 01:01:35.280
kleiner werdet ihr gleich sehen so und dann gibt es noch irgendwas mit compresseds das

01:01:35.280 --> 01:01:41.440
ist irgendwie enable compression oder sowas so guck mal jetzt sehen wir schon ein paar

01:01:41.440 --> 01:01:46.160
14 mb also sieh du mal was für ein krasser unterschied das ist oder das hier ist also

01:01:46.160 --> 01:01:53.400
14 mb finde ich ist für das binary durchaus ok 65 mb ist massif massif jonker binary ich

01:01:53.400 --> 01:01:58.040
meine da ist die komplette runtime drin und alles was du sonst so inkludiert hast einfach

01:01:58.040 --> 01:02:04.760
alles und hier streich da schon mal die sachen raus die du gar nicht verwendest das macht

01:02:04.760 --> 01:02:10.160
aber bei der startzeit gar keinen wirklichen großen unterschied guckt es immer noch ob

01:02:10.160 --> 01:02:14.880
es ist sogar langsamer geworden guckt mal warum ist ein getrimmtes bein das muss mir

01:02:14.880 --> 01:02:20.600
jetzt mal auch einer von microsoft erklären warum ist ein getrimmtes binary 80 prozent

01:02:20.600 --> 01:02:24.960
langsamer im start als er nicht getrimmtes binary sollte er nicht einfach nur die sachen

01:02:24.960 --> 01:02:35.160
löschen die ähnlich verwendet werden microsoft wieder also keine ahnung das kann ich mir

01:02:35.160 --> 01:02:42.680
jetzt nicht erklären warum ein getrimmtes binary so viel so viel kleiner so so viel

01:02:42.680 --> 01:02:49.600
langsamer startet so und dann gibt es noch was irgendwas mit compression oder so net

01:02:49.600 --> 01:02:56.960
enable compression ich habe ready to run rausgeschmissen ja also ich kann es auch noch mal mit ready

01:02:56.960 --> 01:03:03.760
to run machen aber das hat es vorher ja schon langsamer gemacht also ohne ready to run

01:03:03.760 --> 01:03:14.880
war es nur 30 millisekunden und jetzt sind 56 300 millisekunden jetzt sind es 560 ok

01:03:14.880 --> 01:03:22.440
noch mal mit ready to run da ist es wieder schneller und das binary ist nur ein bisschen

01:03:22.440 --> 01:03:27.400
größer also es gibt wieder 1000 varianten wie man das machen kann enable compression

01:03:27.400 --> 01:03:45.080
wie ging das denn enable compression ich ganz ehrlich ok dotnet build all options da gibt

01:03:45.080 --> 01:03:53.760
es auch bestimmt so eine man page oder sowas minus p ms build befehlt zeilen referenz da

01:03:53.760 --> 01:03:59.360
wollen wir jetzt reinkommen kompress gibt's net ich weiß aber dass es eins mit kompress

01:03:59.360 --> 01:04:08.060
gibt man enable compression in single file ist es das wahrscheinlich ist das jetzt so

01:04:08.060 --> 01:04:14.280
schnell gefunden enable compression ja das meine ich also microsoft hat ein händchen

01:04:14.280 --> 01:04:21.360
dafür die dinger besonders pock zu nennen ich meine wer wer würde nicht drauf kommen

01:04:21.360 --> 01:04:29.760
dass diese option dass ich die wollte ja bild ist fewer hat den IQ aber er hat nicht er

01:04:29.760 --> 01:04:33.920
hat nicht primes ab mit primes ab ist der IQ nochmal höher so und jetzt haben wir jetzt

01:04:33.920 --> 01:04:38.440
haben wir noch ein paar mb jetzt haben wir da noch ein paar mb raus raus komprimiert

01:04:38.440 --> 01:04:42.680
so und es startet immer noch halbwegs schnell so aber das hat alles nix mit der neuen ahead

01:04:42.680 --> 01:04:47.040
of time compilation zu tun die ich mir heute angucken wollte so jetzt lassen wir nochmal

01:04:47.040 --> 01:04:54.480
ready to run weg du hast das vor ein paar monaten gebraucht hast du das gemerkt ich

01:04:54.480 --> 01:05:04.480
habe das auch schon gebraucht aber dass du dir das gemerkt hast und jetzt ist das binary

01:05:04.480 --> 01:05:09.800
12 mb also das ist so ziemlich das kleinste was du mit dotnet bordmittel relativ easy

01:05:09.800 --> 01:05:15.520
hinbekommst ja man könnte jetzt noch die symbols rausstrippen wobei ich mir da nicht

01:05:15.520 --> 01:05:21.680
sicher bin ob das dann überhaupt noch lauffähig ist weil mit reflection und so und dann kommen

01:05:21.680 --> 01:05:31.160
sogar nur noch 10 mb es funktioniert auch nicht mehr funktioniert das wohl nicht wahrscheinlich

01:05:31.160 --> 01:05:39.120
weil irgendwelche reflection falfett shit macht oder so keine ahnung so und jetzt machen

01:05:39.120 --> 01:05:52.440
wir das was ich eigentlich ausprobieren wollte nämlich ahead of time compilation

01:05:52.440 --> 01:06:16.240
ubuntu 1804 also was muss ich machen ich muss publisch aot reinschreiben muss ich nicht

01:06:16.240 --> 01:06:22.440
irgendwelche nougat packages installieren ich habe nämlich heise einen heise artikel

01:06:22.440 --> 01:06:30.160
gelesen und laut dem heise artikel muss ich noch ein nougat package installieren mal gucken

01:06:30.160 --> 01:06:34.680
wir vertrauen mal der micro den microsoft docs dass es ein dass es so funktioniert

01:06:34.680 --> 01:06:47.360
so publisch ahead of time reload project gucken wir mal ob er das jetzt macht kein schimmer

01:06:47.360 --> 01:07:16.080
build publisch single file trim enable compression build ok der macht dinger ok ok ok er ist schon

01:07:16.080 --> 01:07:20.720
mal deutlich langsamer und er schreibt doch irgendwas von native warum warum sagt er dass

01:07:20.720 --> 01:07:31.880
das ein dotnet 6 projekt ist habe ich oh oh monka ist alter watte oh das ist schlecht

01:07:31.880 --> 01:07:40.720
mal ich stelle das mal auf dotnet 7 target framework dotnet 7 warum erzählt er mir hier

01:07:40.720 --> 01:07:51.560
irgendwas von dotnet 6 ach weil die library noch selbst ja das ist kein ding ok wo exakt

01:07:51.560 --> 01:08:04.040
ist das problem jetzt wenn ich frage fragen darf microsoft wie macht das microsoft denn

01:08:04.040 --> 01:08:13.240
die machen das so die machen einfach nur die machen das ohne jegliche options die machen

01:08:13.240 --> 01:08:20.920
das ohne jegliche options die sagen die machen das raus die machen trimmt raus die machen

01:08:20.920 --> 01:08:34.240
single file raus die machen einfach nur so ob das jetzt funktioniert so jetzt easy 41

01:08:34.240 --> 01:08:43.440
mb ok schon mal eine ganze ecke fetter aber guck mal das startet einfach instant jetzt

01:08:43.440 --> 01:08:51.000
guck mal irgendwie 30 millisekunden für die für das gesamte programm also das ist das

01:08:51.000 --> 01:08:59.760
ist startzeit plus ausführungszeit das ist quasi in regionen von einem ls um den ls

01:08:59.760 --> 01:09:06.560
ist noch mal eine ganze ecke schneller aber ok also 30 millisekunden ausführungszeit

01:09:06.560 --> 01:09:11.680
insgesamt das behaupte ich mal ist jetzt nicht nicht spürbar beim starten das ist einfach

01:09:11.680 --> 01:09:29.120
sofort da geht das native auto ja das steht auch irgendwo drin dass es automatisch implied

01:09:29.120 --> 01:09:38.000
single file zu sein wenn man das nicht angibt das natürlich schon mal cool ich mein 41

01:09:38.000 --> 01:09:43.520
mb ist immer noch ziemlich ziemlich chunky ich weiß gar nicht ob es dieses wort gibt

01:09:43.520 --> 01:09:49.960
klingt aber übelst cringe vielleicht muss man hier single file raus machen dass es funktioniert

01:09:49.960 --> 01:10:03.360
publish trimmed enable compression ist das jetzt ist es jetzt kleiner geworden ähnlich

01:10:03.360 --> 01:10:11.760
wirklich vielleicht muss ich noch was ändern hier drin keckel keckew also man muss halt

01:10:11.760 --> 01:10:20.240
sagen das kompilieren an sich ist relativ langsam ich meine eine zeile c oder c++ kompiliert

01:10:20.240 --> 01:10:24.440
deutlich schneller als das da der muss aber auch im hintergrund ja noch das halbe framework

01:10:24.440 --> 01:10:35.080
kompilieren aber ehrlich gesagt damit kann ich leben das geht halbwegs 41 mb b test wir

01:10:35.080 --> 01:10:39.800
probieren es auf der strippen noch mal binaries äh nicht beinahe was leih wir strippen noch

01:10:39.800 --> 01:10:45.360
mal debug symbols aus dem binary raus wäre cool wenn das dotnet irgendwie standardmäßig

01:10:45.360 --> 01:11:04.560
könnte speed test light bam strip 14 mb alter von 41 auf 14 mb ist da ist da der halbe windows

01:11:04.560 --> 01:11:12.440
source code mit drin als docs oder was das entfernen von debug symbols bringt einfach

01:11:12.440 --> 01:11:19.800
noch 30 mb mal gucken ob es noch ausführbar ist wahrscheinlich geht es jetzt nicht nee

01:11:19.800 --> 01:11:28.960
moment das geht noch guck mal da das funzt einfach noch debug symbols entfernt das funktioniert

01:11:28.960 --> 01:11:34.680
noch ja dann sollten wir noch immer einen strip hinterher hauen im bild hast du release

01:11:34.680 --> 01:11:59.080
angegeben ja debug symbols dotnet public oder dotnet bild symbol daten mann schreibt es

01:11:59.080 --> 01:12:22.920
mal kann man das nicht auf englisch haben trimmen trimmen will remove steht da vielleicht

01:12:22.920 --> 01:12:46.440
hier was zu drinnen ne symbol dann weiß ich auch nicht so und jetzt ist natürlich die

01:12:46.440 --> 01:12:55.480
große preisfrage wie kompatibel ist das ganze weil also meiner vermutung nach nicht sonderlich

01:12:55.480 --> 01:13:02.880
kompatibel weil ich hab das auf einem super neuen linux kompiliert hier guck mal mal

01:13:02.880 --> 01:13:23.760
strengs strengs warte mal strengs speed champ light grap lib c 229 ist glaube ich relativ

01:13:23.760 --> 01:13:35.080
nahe 234 ok das läuft nur auf alle alle neu aller neuesten linux dingern also schlussfolge

01:13:35.080 --> 01:13:40.720
echt das können wir mal ausprobieren machen einfach ein docker container wir machen einfach

01:13:40.720 --> 01:13:49.200
ein docker container mit ubuntu ubuntu 16 16 04 oder so was und gucken ob es läuft

01:13:49.200 --> 01:13:59.360
oder 1804 docker genau hi ich fange bald eine ausbildung mit csharp oder dotnet dann darf

01:13:59.360 --> 01:14:04.040
ich mich freuen oder hyped sein wenn du sowas gerne machst schon ich finde gerade csharp

01:14:04.040 --> 01:14:09.720
ist eines der schönsten und angenehmsten sprachen die es gibt und dotnet plattform

01:14:09.720 --> 01:14:13.660
kannst du theoretisch so wie es jetzt aussieht dein restliches entwickler leben lang machen

01:14:13.660 --> 01:14:17.800
wenn du da bock drauf hast ich mein ich würde es nicht empfehlen einfach sich gar so sehr

01:14:17.800 --> 01:14:22.000
auf eine sache gerade wenn das die erste ist hier macht zu versteifen bis hin links und

01:14:22.000 --> 01:14:25.480
rechts gucken ist immer gut aber wie gesagt ich habe auch mit dotnet angefangen ich mache

01:14:25.480 --> 01:14:30.520
dotnet immer noch gerne auch 2022 ich habe 2002 angefangen und 20 jahre später mache

01:14:30.520 --> 01:14:49.680
es immer noch gern ja docker machen wir mal ein docker container guck mal hier docker

01:14:49.680 --> 01:14:53.000
docker ran komplettes verzeichnis da einfach rein mappen passt schon auf slash bild auch

01:14:53.000 --> 01:15:02.680
gut docker ran was machen ubuntu wollen wir mal kommen nach 1804 1804 wird ja offiziell

01:15:02.680 --> 01:15:07.240
noch supportet aber ich gehe mal davon aus dass das nicht funktioniert weil das mal ein

01:15:07.240 --> 01:15:13.480
system zu neu ist auf dem ich gerade bin probieren wir das mal aus wie geht das minus minus

01:15:13.480 --> 01:15:20.040
m minus it für eine shell docker kommandos merken oder muss ich noch bin bash hinten

01:15:20.040 --> 01:15:30.240
dran machen ne jetzt so so also sind wir jetzt sind wir offiziell in einem ubuntu 1804 und

01:15:30.240 --> 01:15:52.240
das lash bild sollte meine an nett warum nett deswegen

01:15:52.240 --> 01:16:07.800
so also cd bild

01:16:07.800 --> 01:16:19.400
ne die unterschied ist der unterschied in dem fall ist nicht docker oder docker komposed

01:16:19.400 --> 01:16:24.720
der unterschied ist mit geschweiften klammern wird das in einer subshell ausgeführt bevor

01:16:24.720 --> 01:16:31.920
das kommando läuft wird dann eingesetzt und mit mit sowas hier wird es in der aktuellen

01:16:31.920 --> 01:16:43.160
shell aus was eigentlich keinen unterschied machen dürfte ach keine ahnung ach nee nee

01:16:43.160 --> 01:16:47.960
nee quatsch ich erzähle mist geschweifte klammern ist variable einsetzen die variable pwd gibt

01:16:47.960 --> 01:16:55.080
es nicht pwd ist ein chat der chat ist ja gut ich habe chat ich habe es vor euch auch

01:16:55.080 --> 01:17:06.080
schon gemerkt ja also guck mal speed speed test light das ist ja für uns nicht das heißt

01:17:06.080 --> 01:17:14.600
wenn wir alte betriebssysteme supporten wollen müssten wir das unter einem altem ubuntu

01:17:14.600 --> 01:17:22.400
kompilieren dass es funktioniert na das schreit doch gerade nach irgendeinem bild script und

01:17:22.400 --> 01:17:30.520
im docker file was sind die besten tools und programmier sprachen ja also das ist so sehr

01:17:30.520 --> 01:17:39.640
allgemein das kommt die frage kommt kommt drauf an was du machen willst willst du wissen was

01:17:39.640 --> 01:17:45.400
die beste programmier sprache zum einstieg ist oder willst du wissen wirklich was da steht was

01:17:45.400 --> 01:17:50.520
die besten tools sind um programmier sprachen zu lernen also sprich welche plattformen mit

01:17:50.520 --> 01:17:59.280
kursen sind die besten oder oder was also die beste einsteiger programmier sprache ist meiner

01:17:59.280 --> 01:18:05.440
meinung nach javascript ich weiß jetzt schreien die ganzen payasen fans und und go fans und dot

01:18:05.440 --> 01:18:13.280
net fans aber javascript hat un unbestreitbare vorteile jeder kann javascript verwenden den

01:18:13.280 --> 01:18:17.880
browser installiert hat und du brauchst nichts anderes als ein text editor das heißt die

01:18:17.880 --> 01:18:24.640
einstiegshürden für javascript sind mit abstand die geringsten was es gibt und das nächste ist du

01:18:24.640 --> 01:18:32.560
kommst eh an an javascript und frontend sachen nie vorbei das heißt ein bisschen css html und

01:18:32.560 --> 01:18:42.000
javascript intos haben schadet nichts weil du brauchst eh früher oder später also ich

01:18:42.000 --> 01:18:57.440
finde zum einstieg ist javascript das beste das ist schwierig das für fünfjährige zu erklären

01:18:57.440 --> 01:19:08.240
also im prinzip muss man zwei sachen trennen auch wenn es ungern getrennt wird aber es eine hat

01:19:08.240 --> 01:19:16.560
eigentlich mit dem anderen jetzt zwar was zu tun aber es ist es nicht also was ich meine ist du

01:19:16.560 --> 01:19:20.480
musst zwei sachen trennen bei docker du musst linux container trennen und du musst docker trennen

01:19:20.480 --> 01:19:27.400
linux container ist eine funktionalität im linux kernel die erste mal nix mit docker zu tun hat

01:19:27.400 --> 01:19:36.160
linux container setzen sich zusammen aus lxc im kernel namespaces cgroups was im endeffekt dazu

01:19:36.160 --> 01:19:44.120
führt dass du ein prozess dass du ein programm starten kannst in einer äußerst leichtgewichtigen

01:19:44.120 --> 01:19:50.560
sandbox wobei man sagen muss sandbox ist vielleicht das falsche wort in einer etwas

01:19:50.560 --> 01:19:58.520
abgeschirmteren umgebung sandbox ist vielleicht bisschen zu hart ne vm ist eher eine sandbox

01:19:58.520 --> 01:20:06.480
das triffts bei container vielleicht nicht wirklich also du hast im linux kernel funktionalität wo du

01:20:06.480 --> 01:20:12.360
einem prozess bestimmte sachen vorgaukeln kannst ja zum beispiel er hatte er hätte eine andere

01:20:12.360 --> 01:20:16.720
netzwerkkarte als in einem haus drin oder er hat einen anderen haus namen und du kannst

01:20:16.720 --> 01:20:22.160
ihn ein bisschen besser isolieren vom restlichen system und nein das hat mit einer vm nichts zu

01:20:22.160 --> 01:20:33.360
tun weil eine vm bis auf deine cpu quasi alles emuliert deswegen ist auch die cpu performance

01:20:33.360 --> 01:20:40.520
in vms gut vms sind mehr oder weniger 99 prozent native cpu performance aber alles andere ist

01:20:40.520 --> 01:20:50.720
emuliert und in der vm hast du aber auch mittlerweile den vorteil dass du die ganzen hardware vm

01:20:50.720 --> 01:21:00.240
extensions und sowas hast also du hast einmal linux container im köln so und nachdem linux

01:21:00.240 --> 01:21:07.680
container im köln relativ sagen wir mal anspruchsvoll zu benutzen sind brauchst du

01:21:07.680 --> 01:21:15.080
irgendwelche tools dafür die dir das einfacher machen also du kannst relativ einfach ich sag

01:21:15.080 --> 01:21:18.400
jetzt mal relativ einfach weil es sind nur fünf zeilen oder so aber dann kann der noch

01:21:18.400 --> 01:21:23.440
nichts also kannst relativ einfach einen linux container starten mit fünf fünf oder sechs

01:21:23.440 --> 01:21:29.080
zeilen c++ oder c oder was auch immer wenn du die richtigen die richtigen körner aufrufe hast

01:21:29.080 --> 01:21:34.480
kannst mit fünf zeilen c in container starten wobei es wie gesagt container ich persönlich

01:21:34.480 --> 01:21:39.880
finde das wort container nicht so schön weil container im kopf sich anhört wie irgendwie

01:21:39.880 --> 01:21:47.680
isoliert in richtung vm das ist es nicht also es ist linux container ist nichts anderes wie

01:21:47.680 --> 01:21:59.080
ein prozess den du ganz normal startest nur dass ein paar zusätzliche abschirmung noch drumherum

01:21:59.080 --> 01:22:06.160
sind also wenn du jetzt wenn du in den prozess also wenn uns lieb startest hier auf der kommando

01:22:06.160 --> 01:22:16.040
zeile oder ob du ein sleep im docker container startest das ist kein großer unterschied beides

01:22:16.040 --> 01:22:22.680
ist ein ganz normaler prozess den du auch mit ps siehst übrigens also wenn du mit ps guckst

01:22:22.680 --> 01:22:30.400
was läuft wenn du mit docker sachen ausführst du siehst das also ob du ein sleep im container

01:22:30.400 --> 01:22:38.000
ausführst oder ein sleep auf deinem host ist ziemlich egal so und der einzige unterschied

01:22:38.000 --> 01:22:42.960
ist dass wenn du einen sleep im container ausführst dass du dann die möglichkeiten

01:22:42.960 --> 01:22:47.800
hast diesem sleep noch verschiedene sachen vorzugaukeln die nicht der realität entsprechend

01:22:47.800 --> 01:22:53.280
ja zum beispiel oder sagen wir mal so du machst ein if konfig so if konfig gibt dir die die

01:22:53.280 --> 01:23:00.400
netzwerk konfig von von deinem linux system raus so wenn ich ein if konfig bei mir im host

01:23:00.400 --> 01:23:05.280
ausführe oder if konfig im container ausführe können die zwei unterschiedliche sachen anzeigen

01:23:05.280 --> 01:23:12.880
weil das eine sachen was der linux container macht ist in name spaces und name spaces gibt

01:23:12.880 --> 01:23:19.080
zum beispiel auch für netzwerk konfig das heißt dass if konfig was du im container startest

01:23:19.080 --> 01:23:25.360
denkt du hättest andere netzwerk konfig nicht dass du trotz ist das im container wie wenn

01:23:25.360 --> 01:23:32.760
du es direkt in der kommando zeile ausführst ein ganz normaler neuer prozess nix anderes

01:23:32.760 --> 01:23:43.760
es ist keine vm es ist keine große sendbox es ist ein weiterer prozess mit nur ein paar

01:23:43.760 --> 01:23:54.800
kleinen isolationsschichten drum herum dementsprechend ist es auch ressourcentechnisch und performenstechnisch

01:23:54.800 --> 01:23:59.240
kein unterschied ob du den prozess auf deinem host ausführst oder im container ausführst

01:23:59.240 --> 01:24:05.240
ich sage keiner theoretisch gibt es natürlich welche aber ich weiß gar nicht ob die überhaupt

01:24:05.240 --> 01:24:10.520
messbar sind gescheit also es macht keinen unterschied ob du den prozess auf dem host

01:24:10.520 --> 01:24:14.560
oder im container ausführst performenstechnisch deswegen sind ja container im vergleich zu

01:24:14.560 --> 01:24:24.560
vms auch so beliebt bei vms hast du zwar gute cpu performance aber vms brauchen ram das

01:24:24.560 --> 01:24:30.720
ist übrigens das was vms unattraktiv macht der speicherplatz und vor allem der ram das

01:24:30.720 --> 01:24:36.240
ist auch das was docker container besser machen wenn es rein um die cpu performance ging dann

01:24:36.240 --> 01:24:41.960
werden vms vollkommen ok cpu performance ist in der vm nahezu native wenn ich in cpu benchmark

01:24:41.960 --> 01:24:45.560
machen würde in meiner vm und auf dem host würdest du das gleiche mehr oder weniger das

01:24:45.560 --> 01:24:56.760
gleiche ergebnis bekommen und die ramauslastung ist halt der große vorteil weil überlegt

01:24:56.760 --> 01:25:04.320
euch mal ich ich will jetzt ein sleep ausführen weil sleep bald bedgetime ist in 40 minuten

01:25:04.320 --> 01:25:08.520
sleep das beste kommando jetzt wenn ich ein sleep ausführe hier auf der kommando zeile

01:25:08.520 --> 01:25:14.280
oder im container dann braucht das was wird es brauchen ich sage jetzt einfach mal 10

01:25:14.280 --> 01:25:23.400
kilobyte ram wenn ich diese sleep in der vm ausführen will dann müsste ich ein komplett

01:25:23.400 --> 01:25:29.240
neues linux booten in der vm das bedeutet nicht einfach nur linux kernel starten sondern

01:25:29.240 --> 01:25:36.080
alles was drumherum gehört das ist systemd starten der mich dann einlog eine shell starten

01:25:36.080 --> 01:25:42.320
und in der shell dann sleep 5 machen das dauert erstmal 10 sekunden bis es überhaupt anfängt

01:25:42.320 --> 01:25:49.160
fertig gebootet ist und das braucht von den 10 kilobyte ram die das normalerweise braucht

01:25:49.160 --> 01:25:56.800
zum ausführen lokal oder im container braucht das zu ich sage jetzt einfach mal 250 mb ram

01:25:56.800 --> 01:26:06.280
in der vm und das ist halt natürlich ein unterschied die vm braucht einfach viel mehr ram als

01:26:06.280 --> 01:26:10.080
wenn du einen stink normalen prozess ausführst nichts anderes ist ja ein container so und

01:26:10.080 --> 01:26:15.640
jetzt kommen wir zu docker das war die lino das war die container funktionalität die du

01:26:15.640 --> 01:26:25.680
erst mal im linux kernel drin hast und alles was drumherum gehört docker ist ein frontend

01:26:25.680 --> 01:26:33.860
für die funktion im linux kernel und docker ist bei weitem nicht das einzige frontend

01:26:33.860 --> 01:26:41.760
dafür es gibt lxd die userland variante dann gibt es diese lxd geschichte von den ubuntu

01:26:41.760 --> 01:26:49.240
leuten es gibt docker es gibt diesen komischen potman docker fake von redhead es gibt kubernetes

01:26:49.240 --> 01:26:56.240
es gibt rancher noch hattest du noch coos und flatcar und es gibt oder wie heißt das

01:26:56.240 --> 01:27:07.640
andere ding mini ach was auch immer es gibt zig tools um die container funktionalität

01:27:07.640 --> 01:27:12.640
im linux kernel besser zu managen diese tools liegen unterschiedliche schwerpunkt ansporn

01:27:12.640 --> 01:27:18.320
natürlich ansporn gibt es auch noch genau diese tools haben unterschiedliche schwerpunkte

01:27:18.320 --> 01:27:25.040
und auch zu die gründe aus welchen sie entstanden sind warum docker oftmals synonym für linux

01:27:25.040 --> 01:27:29.640
container verwendet wird ist folgendes ja snap gibt es natürlich auch noch genau so

01:27:29.640 --> 01:27:36.520
und warum docker oftmals synonym mit linux container verwendet wird ist docker war die

01:27:36.520 --> 01:27:45.800
erste mainstream linux container management das erste linux container management tool

01:27:45.800 --> 01:27:51.680
flatpack sind glaube ich keine container bin ich mir nicht ganz sicher also sprich es gab

01:27:51.680 --> 01:27:59.040
die linux kernel container funktionalität und dann gab es irgendwann danach docker was

01:27:59.040 --> 01:28:05.240
diese funktionalität relativ einfach benutzbar gemacht hat für jedermann und deswegen wird

01:28:05.240 --> 01:28:10.080
docker und linux container oftmals so in einem atemzug genannt aber es sind zwei unterschiedliche

01:28:10.080 --> 01:28:16.000
paar schuhe linux container ist die kernel funktionalität und das was man unter namespaces

01:28:16.000 --> 01:28:23.960
und cgroups alles so hat und docker ist eigentlich nur das frontend für diese kernel funktionalität

01:28:23.960 --> 01:28:29.840
und kubernetes und alles andere auch und diese tool ich meine man muss sich überlegen natürlich

01:28:29.840 --> 01:28:33.760
gehört zu so einem container mehr es gehört ein image dazu und alles und um solche sachen

01:28:33.760 --> 01:28:41.320
kümmert sich docker auch also docker ist ein management tool für die linux container funktionalität

01:28:41.320 --> 01:28:58.560
im kernel eines von vielen ja genau das ist auch der unterschied ich glaube das hat man

01:28:58.560 --> 01:29:04.480
jetzt verstanden also der unterschied dazu zu einem befehl ausführen lokal oder im container

01:29:04.480 --> 01:29:12.200
das ist kein unterschied also kein großer unterschied versus eine vm das heißt im endeffekt

01:29:12.200 --> 01:29:18.800
wenn mein kernel bestimmte sachen nicht supportet also mal angenommen ich will ein filesystem

01:29:18.800 --> 01:29:22.920
benutzen was mein kernel nicht kann dann kann ich das auch nicht im container benutzen selbst

01:29:22.920 --> 01:29:29.200
wenn ich da für alles installiere was ich brauche in der vm sieht das anders aus in

01:29:29.200 --> 01:29:40.440
dem vm booted ein komplett neuer kernel richtig ja das ist aber auch logisch es ist nicht

01:29:40.440 --> 01:29:44.520
so container nutzt den host kernel es ist nicht so als hätten die container irgendwie

01:29:44.520 --> 01:29:51.200
eine wahl was sie benutzen können das ist ein stink normaler prozess den ich starte

01:29:51.200 --> 01:29:59.400
sowie alles andere was ich auch starte nur mit ein paar kleinen sonder sachen kernel funktionalität

01:29:59.400 --> 01:30:07.040
drum herum ja und ich rede hier nur von linux container windows container und geschützt

01:30:07.040 --> 01:30:13.400
das ist noch was anderes und das kommt übrigens auch aus dem linux umfeld das microsoft hat

01:30:13.400 --> 01:30:18.000
es ja irgendwie nachgebaut mit top weiß gar nicht auf was laufen denn windows container

01:30:18.000 --> 01:30:28.200
auf wsl oder was also ist docker eine art api für linux container umgedreht docker

01:30:28.200 --> 01:30:37.440
ist das frontend was die ap im linux kernel für container verwenden an das thema du hast

01:30:37.440 --> 01:30:44.160
doch ein ap aus amerika nee ich habe auf ebay deutschland gekauft aber ja ach so ja ich

01:30:44.160 --> 01:30:52.320
habe den uss kam ursprünglich aus usa ja nee nee nee nee nee ich habe das umgestellt und

01:30:52.320 --> 01:30:56.760
das ist die reichweite ist die gleiche das ist aber auch ein trugschluss dass die reichweite

01:30:56.760 --> 01:31:01.080
größer wird weil deine geräte müssen ja auch zum access point kommen und deine geräte

01:31:01.080 --> 01:31:05.280
sind auf jeden fall auf deutsch eingestellt also es würde dir gar nichts bringen wenn

01:31:05.280 --> 01:31:08.320
dein access point eine größere reichweite hätte weil deine geräte da nicht zum access

01:31:08.320 --> 01:31:15.200
point kommen zurück der grund warum das eine höhere reichweite das liegt nicht daran

01:31:15.200 --> 01:31:23.280
weil es aus amerika ist sondern weil es schlicht ergreifend bessere access point ist docker

01:31:23.280 --> 01:31:28.360
hat eine zukunft docker wird weiter relevant bleiben keine frage für lokale builds und

01:31:28.360 --> 01:31:32.360
lokale sachen machen wir jetzt ja auch gleich ist doch das mittel der wahl was will ich

01:31:32.360 --> 01:31:39.320
mit kubernetes cluster lokal bei mir komplett unsinnig kubernetes der riesen vorteil von

01:31:39.320 --> 01:31:44.320
kubernetes ist sowas wie skalierung zum beispiel dass du sagen kannst hey ich habe eine web

01:31:44.320 --> 01:31:54.560
anwendung die ist relativ stateless und die kann ich halt bei fünf usern auf einem container

01:31:54.560 --> 01:32:03.560
laufen lassen und wenn ich auf einmal keine ahnung in dem pewdiepie video drin bin und

01:32:03.560 --> 01:32:08.040
300.000 leute darauf zugreifen wollen dann skaliere ich das hoch auf ganz viele container

01:32:08.040 --> 01:32:13.320
über mehrere hardware kisten und das kannst du mit kubernetes sogar on the fly machen

01:32:13.320 --> 01:32:18.440
ohne dass du irgendwas von merkst und du kannst sogar automatisch machen das ging übrigens

01:32:18.440 --> 01:32:22.820
vorher vor kubernetes auch alles schon aber mit kubernetes ist es deutlich einfacher

01:32:22.820 --> 01:32:27.120
und schöner im handling du konntest du konntest früher auch schon laut balancer davor packen

01:32:27.120 --> 01:32:30.480
und anhand der auslastung dann irgendwelche sachen anstoßen die backends hoch gefahren

01:32:30.480 --> 01:32:45.120
haben also das ist einfach nur in mode gekommen die letzten die letzten jahre aber docker

01:32:45.120 --> 01:32:51.440
wird es weiterhin geben docker ist nicht was anderes als lxd ja aber es gibt zwei sachen

01:32:51.440 --> 01:32:57.880
also lxd diese linux container geschichte im kernel die nennen auch manche lxd das

01:32:57.880 --> 01:33:04.880
ist für alles das gleiche es gibt noch ein kommando zeilen tool lxd das ist sowas wie

01:33:04.880 --> 01:33:09.240
docker also ein management tool für container aber es ist nicht docker es ist ein anderes

01:33:09.240 --> 01:33:16.120
management tool lxd ist eine container das ist dann von den ubuntu leuten das gibt es

01:33:16.120 --> 01:33:22.960
auch noch das ist ein gepatchtes lxd mit ein paar sonderfunktionen und einem demon der

01:33:22.960 --> 01:33:28.400
irgendwelche sachen automatisch machen kann keine ahnung wie gesagt docker unter windows

01:33:28.400 --> 01:33:43.760
ist eh fake windows container ist irgendwas komisch dahin gewurzeltes

01:33:43.760 --> 01:33:49.320
konnte man docker da nicht nutzen dafür und doch unter anderem unter anderem dafür wird

01:33:49.320 --> 01:33:54.120
es ja auch benutzt das ist eigentlich das ist glaube ich so eines der beliebtesten tools

01:33:54.120 --> 01:34:01.400
um genau sowas zu machen außer mit mech ja mit mech ist es ein bisschen schwierig weil

01:34:01.400 --> 01:34:05.000
mech geht immer nur unter mech und ich weiß nicht wie es mit docker unter mech mittlerweile

01:34:05.000 --> 01:34:12.200
aussieht ja gut der typ hat es auch nicht mehr alle mit seinen 30.000 notes daheim

01:34:12.200 --> 01:34:24.240
genau so jetzt müssen wir mal weitermachen also wir können unser tolles kommando zeilen

01:34:24.240 --> 01:34:28.880
tool nicht ausführen wo wir jetzt dabei sind wir machen jetzt einfach eine runde docker

01:34:28.880 --> 01:34:34.000
also ihr seht mein kommando zeilen tool funktioniert nicht unter einem alten ubuntu und warum funktioniert

01:34:34.000 --> 01:34:39.880
das nicht unter dem alten ubuntu naja weil das keine aktuelle den satz muss ich anders

01:34:39.880 --> 01:34:47.200
anfangen weil ich das kompiliert habe auf meinem aktuellen manjaro und das hat deutlich

01:34:47.200 --> 01:34:51.640
neuere libraries als das uralte ubuntu das heißt eigentlich müsste ich das auf einem

01:34:51.640 --> 01:34:59.200
uralt linux am besten kompilieren dass es von dort an auf allen linuxen und neuer funktioniert

01:34:59.200 --> 01:35:03.440
und nachdem ich mir garantiert jetzt keine vm mache mit ubuntu 1804 oder noch schlimmer

01:35:03.440 --> 01:35:10.200
cento s7 machen wir das mit docker container wo wir gerade dabei sind können wir ein bisschen

01:35:10.200 --> 01:35:20.520
docker stills machen also ein neues neues file docker file und dann hoffe ich mal dass

01:35:20.520 --> 01:35:26.760
es funktioniert ich bin mir da nicht wirklich sicher jetzt aber man weiß ja nicht so und

01:35:26.760 --> 01:35:40.200
wir machen uns die defops lite geschichte bild.sh das muss reichen bash k8 ads setzt

01:35:40.200 --> 01:35:45.320
jetzt ich glaube du kannst auswählen was du machen willst ich bin nicht so der krasse

01:35:45.320 --> 01:35:52.000
kubanier des profi aber ich glaube du kannst bei docker auswählen was du für eine runtime

01:35:52.000 --> 01:35:56.640
verwenden willst letztendlich sind die images unter der haube ja eh alles mehr oder weniger

01:35:56.640 --> 01:36:11.200
das gleiche das sind ja wir sind die oc dingsbums container images oic container images 1804

01:36:11.200 --> 01:36:17.800
ist richtig alt guck mal das sind vier jahre schon ist schon was und wenn wir cento s7 das

01:36:17.800 --> 01:36:24.360
von 2014 noch schlimmer acht jahre wir machen es cento s7 wir machen leute wir machen cento

01:36:24.360 --> 01:36:30.920
s7 docker file wo wir das drin bilden kann man arm docker container auf x86 host machen

01:36:30.920 --> 01:36:43.240
eh ne aber die meisten container gibt es für arm und x86 also es ist ja nicht so sehr

01:36:43.240 --> 01:36:51.320
die frage gibt es docker für x86 oder arm das gibt es sondern das was da drinne ist

01:36:51.320 --> 01:36:58.840
in dem jeweiligen image ist das in arm oder x86 software und die gängigen betriebssysteme

01:36:58.840 --> 01:37:04.520
von ubuntu debian besonst was gibt es als arm und x86 varianten auch für docker und

01:37:04.520 --> 01:37:14.600
die meisten images werden dank dem raspberry pi auch für arm gebaut mittlerweile und wenn

01:37:14.600 --> 01:37:19.280
du jetzt meinst ob du das irgendwie cross compilen kannst auch wenn das nicht die frage

01:37:19.280 --> 01:37:25.880
hier ist ja du kannst von x86 host cross compilen für arm das geht also du kannst also ich

01:37:25.880 --> 01:37:30.960
könnte jetzt zum beispiel wo wir gerade hier dabei sind ich könnte jetzt zum beispiel

01:37:30.960 --> 01:37:41.240
bei dotnet ist es halt besonders einfach ich könnte einfach ein arm bild machen hier arm

01:37:41.240 --> 01:37:55.560
ich bin mir gar nicht sicher ist es arm es ist arm 64 ah ne arm 64 alter nein es ist es

01:37:55.560 --> 01:38:02.200
ist linux arm so rum ja dann käme ein binary raus was ich auf raspberry pi kopieren kann

01:38:02.200 --> 01:38:07.320
und direkt ausführen das wird funktionieren ja das hängt aber ein bisschen von der jeweiligen

01:38:07.320 --> 01:38:13.360
runtime und den tools ab also in c++ geht das auch ist aber eklig eklig aber es geht

01:38:13.360 --> 01:38:20.960
bei anderen sachen beißt man sich da die zähne dran aus das kommt eher auf die tools

01:38:20.960 --> 01:38:25.600
an wenn ja das kannst du dann auch am ende im docker container machen aber ja also wir

01:38:25.600 --> 01:38:30.280
machen mal ein bild punkt sh was was müssen wir dann machen um unsere software zu bilden

01:38:30.280 --> 01:38:39.320
also wir brauchen die erste mal unser unseren bild bild befehl so lass mal lass mal kurz

01:38:39.320 --> 01:38:43.920
in mich gehen bevor mein docker feil docker feil machen muss ich muss ich muss ich muss

01:38:43.920 --> 01:38:50.440
mal kurz überlegen also wir löschen erstmal den bild ordner weil klinis bild ist immer

01:38:50.440 --> 01:38:55.040
gut und wir machen neuen bild ordner das ist auf jeden fall auch schon mal nicht verkehrt

01:38:55.040 --> 01:39:02.640
ich mache kein make feil aber bevor ich ein make feil macht da muss schon was passieren

01:39:02.640 --> 01:39:06.200
zum beispiel c++ web assembly im browser muss passieren was wir letztendlich gemacht haben

01:39:06.200 --> 01:39:10.560
da hatten wir ein make feil aber so und jetzt kommt ganz viel docker geschiss würde ich

01:39:10.560 --> 01:39:16.360
sagen ja dass ich sage wie gesagt das ist def ob slide jetzt ich würde aber sagen das reicht

01:39:16.360 --> 01:39:22.840
für die kleine geschichte hier also machen wir mal ein docker feil also from send os

01:39:22.840 --> 01:39:35.940
7 ich bin mir da nicht sicher ob das richtig ist docker run from send os 7 ok das scheint

01:39:35.940 --> 01:39:45.280
richtig zu sein ok nice also from send os 7 das ist das base image was man verwenden

01:39:45.280 --> 01:39:52.160
will für seinen container und da drinne will ich jetzt machen run boah ich hab keine ahnung

01:39:52.160 --> 01:39:56.480
das muss ich erstmal ausprobieren in einem send os 7 container also erstmal will ich

01:39:56.480 --> 01:40:06.600
ein yum update machen da bin ich mir relativ sicher ja also yum update minus y jetzt sieht

01:40:06.600 --> 01:40:12.920
man auch eines der großen vorteile von container also in diesem anwendungsgebiet wenn ich mein

01:40:12.920 --> 01:40:19.100
docker feil und mein bildscript habe jeder der dieses repo sich auscheckt auf git kann

01:40:19.100 --> 01:40:23.880
damit in bild durchführen es kommt exakt das gleiche binary oder es ist exakt das gleiche

01:40:23.880 --> 01:40:28.440
bild womit ich das auch mache der muss sich nichts auf seiner ledungskiste installieren

01:40:28.440 --> 01:40:31.520
was vielleicht irgendeine andere version ist und es dann wieder nicht funktioniert und

01:40:31.520 --> 01:40:34.920
erst mal drei tage am gucken wo ist denn jetzt die unterschiedliche version der führt das

01:40:34.920 --> 01:40:40.360
bildscript aus braucht docker installiert und es funktioniert einfach und wenn man da

01:40:40.360 --> 01:40:48.120
noch einen schritt weitergehen will wenn man super super agile continuous integration pipelines

01:40:48.120 --> 01:40:54.680
machen will von jenkins bis github action oder oder was gibt es da sonst noch drone

01:40:54.680 --> 01:41:00.200
und und git lab ci und was auch immer also wenn man sowas machen will bietet sich das

01:41:00.200 --> 01:41:07.160
auch an das reproduzierbar in containern zu machen so also ich will ich will in update

01:41:07.160 --> 01:41:15.600
yum update machen ok nice dann muss ich dann muss ich dort net installieren wo war dann

01:41:15.600 --> 01:41:23.120
hier der download link jetzt habe ich das doch im hintergrund htp download weget weget ist

01:41:23.120 --> 01:41:34.400
nicht ok jam install weget will ich als nächstes machen jam install weget und wir machen auch

01:41:34.400 --> 01:41:41.600
gleich bild essentials wie heißt denn das unter unter kann install bild essentials wie

01:41:41.600 --> 01:41:48.640
heißen dieser krempel jam group install development tools habe ich schon mal gesagt dass ich

01:41:48.640 --> 01:41:53.840
cento s nicht beziehungsweise die paketverwaltung in cento s nicht nicht mag wir verwenden auf

01:41:53.840 --> 01:41:58.880
der arbeit hauptsächlich cento s beziehungsweise ist eigentlich red hat sieben nehm doch einfach

01:41:58.880 --> 01:42:07.120
das dort net image es gibt kein dort net image für cento s sieben

01:42:07.120 --> 01:42:21.880
dort net docker heißt der krempel source sdk sieben guck es gibt bloß ubuntu dieses

01:42:21.880 --> 01:42:43.360
komische microsoft ding debian und alpine

01:42:43.360 --> 01:42:53.160
cento s wir müssen das selbst machen ok weget ist installiert also weget wir installieren

01:42:53.160 --> 01:43:02.960
uns dort net das base image ist doch egal ne ne das base image ist nicht egal ich will

01:43:02.960 --> 01:43:10.080
ja ein uraltes cento s sieben haben dass ich den kleinstmöglichsten nennen habe für meine

01:43:10.080 --> 01:43:16.360
dependencies also wenn ich jetzt in ubuntu guck mal ich hab doch das binary gerade bei

01:43:16.360 --> 01:43:20.920
mir lokal kompilieren aktuelles ubuntu wird auch nicht so viel älter sein ich kann keine

01:43:20.920 --> 01:43:26.840
ich kann kein binary kompilieren gegen den ubuntu 22 04 und es dann auf ein 1804 kompilieren

01:43:26.840 --> 01:43:31.800
das mag er nicht deswegen bauen wir jetzt einfach ein uralt cento s kompilieren das

01:43:31.800 --> 01:43:35.360
da drauf kopieren uns das binary runter und es funktioniert auf den letzten linungssystem

01:43:35.360 --> 01:43:42.600
der letzten acht jahre zumindest soweit die idee so also wir haben dort net runtergeladen

01:43:42.600 --> 01:43:48.680
wir haben dort net nach ruhr runtergeladen das vielleicht nicht so nicht so clever nie

01:43:48.680 --> 01:44:03.560
wohin habe ich dort net runtergeladen oder so war nach ruhr komm scheiß drauf da xfz

01:44:03.560 --> 01:44:15.840
dort net sdk ok also das muss ich als nächstes machen wegett wir haben install wegett run

01:44:15.840 --> 01:44:19.680
wir machen was anderes mkdir slash dort net das weiß ich wenigstens wo der camp liegt

01:44:19.680 --> 01:44:31.960
später und dann habe ich das runtergeladen in das da wegett so wir laden das runter

01:44:31.960 --> 01:44:40.880
nach slash dort net slash dort net punkt ah punkt gz wegett weiß jemand aus dem kopf

01:44:40.880 --> 01:44:46.640
ob es groß oder klein o ist ich glaube es ist groß und parkerl ist es standardmäßig

01:44:46.640 --> 01:44:54.480
auf standard out das ist immer man weiß es nicht genau aus dem kopf so jetzt gehen wir

01:44:54.480 --> 01:45:03.600
nach jetzt gehen wir nach slash dort net und machen da drinnen dann ein xfz v dort net

01:45:03.600 --> 01:45:08.480
da punkt gz also ich mache jetzt im prinzip im docker fall das was ich hier gerade von

01:45:08.480 --> 01:45:18.440
hand mache nur damit ich dann reproduzierbar bilden kann also dort net da ist es und wir

01:45:18.440 --> 01:45:35.960
haben guckt etc rettet release wir haben ein cento s79 leute das ist uralt julie 2007 also

01:45:35.960 --> 01:45:49.680
da also ich glaube älteres system müssen wir wirklich nicht supporten ok weiter weiter

01:45:49.680 --> 01:46:00.280
im text was muss ich jetzt als nächstes machen also ich habe jetzt dort net runter ich habe

01:46:00.280 --> 01:46:13.320
jam install ich habe die weddaubertools ich habe den kram runtergeladen wir machen noch

01:46:13.320 --> 01:46:27.160
ein bildverzeichnis oder output dann am ende reinkommt was war wir denn jetzt wir kopieren

01:46:27.160 --> 01:46:43.680
unser gar unser komplettes projekt nach slash bild ich weiß nicht ob man das so oder so

01:46:43.680 --> 01:46:51.280
schreiben muss ich bin mir jetzt nicht sicher ob das funktioniert ehrlich gesagt schau

01:46:51.280 --> 01:46:57.320
wir mal schauen wir mal gucken wir mal ob das docker filets funktioniert also und als skript

01:46:57.320 --> 01:47:05.880
zum starten brauchen wir jetzt irgendwas wie docker run dann geben wir dem ding in den

01:47:05.880 --> 01:47:22.400
namen speed yes das ding speed champ speed test die musik ist vorbei seg danke für den

01:47:22.400 --> 01:47:32.800
sub mario speed test light bild oder so warum sind du es weil ich brauche das älteste die

01:47:32.800 --> 01:47:42.520
älteste plattform die von dort net noch supportet wird damit es auf allen neueren plattformen

01:47:42.520 --> 01:48:05.360
läuft pains champ cd dependency mist so als wir geben den dingen namen bild ne minus

01:48:05.360 --> 01:48:14.200
minus no dependencies bringt nix der hat auf jeden fall dependencies auf die standard c

01:48:14.200 --> 01:48:20.520
library ok ich muss mal kurz in mich gehen also wir füllen das ding aus docker run wir

01:48:20.520 --> 01:48:25.320
müssen es vorher noch bilden habe ich ja ganz vergessen docker bild ok das kriege ich so

01:48:25.320 --> 01:48:28.800
nicht in einem stück hin da muss ich das muss ich jetzt erstmal ein paar mal ausprobieren

01:48:28.800 --> 01:48:36.760
gehen wir mal hier raus und gucken was passiert also docker bild punkt bildet das docker

01:48:36.760 --> 01:48:44.640
feil im aktuellen verzeichnis so docker bild und jetzt gucke ich erstmal ob es funktioniert

01:48:44.640 --> 01:48:53.000
keine ahnung ich bin mir da und und schlüssig ob das tut was ich da gerade basteln plus

01:48:53.000 --> 01:49:06.640
nix bild punkt sr ok nein ok run das funktioniert schon mal also das der nimmt das docker feilen

01:49:06.640 --> 01:49:16.760
im cento s installiert was auch immer hat ein jam update gemacht der macht gerade in

01:49:16.760 --> 01:49:23.640
jam update im container ok das schöne ist der cache das das muss man nur einmal machen

01:49:23.640 --> 01:49:42.480
so als nächstes sollte er weget installieren und developer tools installieren stimmt wir

01:49:42.480 --> 01:49:52.080
sollten dem namen wir sollten dem ding noch ein name geben oder ja wir sollten dem ding

01:49:52.080 --> 01:49:55.440
noch ein name geben aktuell hat es einen eigenen haschwert das ist nicht so nicht so

01:49:55.440 --> 01:50:03.800
geil glaube vielleicht vielleicht nicht so nicht so schlau so und jetzt installiert er

01:50:03.800 --> 01:50:09.400
sich die developer dependencies alles nice so weit so weit so gut danach sollte er dort

01:50:09.400 --> 01:50:22.800
nicht runterladen

01:50:22.800 --> 01:50:38.000
jetzt mach mal hinne wir haben nur so eine viertel stunde Zeit das wird jetzt hier spresiert

01:50:38.000 --> 01:50:51.560
jam ist so ein rotz alter kannst du mal dein bild command pasten hier bild punkt ok er

01:50:51.560 --> 01:51:02.160
downloaded gerade dotnet das ist das weget das ist das dotnet weget er unpack dotnet

01:51:02.160 --> 01:51:07.120
das ist auch schon mal gut das ist devops light speedrun was wir hier machen ja genau

01:51:07.120 --> 01:51:23.880
und jetzt ist er fertig oder docker run requires an argument ok also das was ich hier gemacht

01:51:23.880 --> 01:51:33.120
habe das funktioniert schon mal prinzipiell so docker run name bild gibt das nicht den

01:51:33.120 --> 01:51:38.520
hasch aus da muss ich leute wir machen fai ich habe die feife der idee schlechthin passt

01:51:38.520 --> 01:51:44.680
mal auf pass mal auf messer feife ideen das habe ich nämlich letztes gemacht aber für

01:51:44.680 --> 01:51:50.880
was ganz was anderes aber das wollte ich zeige ich euch mal pass mal feife also benutzt habe

01:51:50.880 --> 01:51:56.040
ich das für einen script was eschers cli gerappt hat was ganz was anderes aber ich

01:51:56.040 --> 01:52:07.040
habe high iq idee wir machen jetzt docker bild ich glaube wir könnten dem ein name geben

01:52:07.040 --> 01:52:12.560
den bild ja null oder könnten wir einfach sagen docker starten null wollen wir nicht

01:52:12.560 --> 01:52:18.320
wollen wir nicht pass mal auf der gibt doch am ende hier die id von dem bild raus so

01:52:18.320 --> 01:52:28.160
passt mal auf pass mal auf docker bild punkt so das sollte jetzt easy funktionieren weil

01:52:28.160 --> 01:52:31.840
das ja schon gecasht ist das dauert jetzt plus zehn sekunden oder so so passt mal auf

01:52:31.840 --> 01:52:56.720
da sollte jetzt die aldi rauskommen so und jetzt jetzt kommt das was ich euch zeigen

01:52:56.720 --> 01:53:01.720
wollte was ich schon was ich was ich letztes mal verwendet habe also man könnte jetzt zum

01:53:01.720 --> 01:53:09.720
beispiel man könnte jetzt zum beispiel hier sowas machen man könnte jetzt hier zum beispiel

01:53:09.720 --> 01:53:16.360
sowas machen und jetzt hätte ich hier drinnen den haschwert stehen von dem container bild

01:53:16.360 --> 01:53:22.600
und könnte den jetzt quasi hier einfügen aber jetzt passt mal auf pass mal auf docker

01:53:22.600 --> 01:53:27.160
bild minus ku nein ich will kein ku ich will kein ku ich will euch jetzt nämlich was zeigen

01:53:27.160 --> 01:53:32.320
pass mal auf das problem wenn ich das so ausführe ist jetzt ich fühle es mal hier aus dem best

01:53:32.320 --> 01:53:37.520
script aus auf der kommando zeite ich sehe den output ich sehe den output nicht vom docker

01:53:37.520 --> 01:53:48.680
bild ach das ist standard error ich sehe den output nicht vom docker bild seht ihr

01:53:48.680 --> 01:53:53.480
die sub shell verschluckt den output und schreibt schreibt in die variable rein ich habe letztens

01:53:53.480 --> 01:54:01.680
einen richtig coolen trick gefunden auf stacker overflow man macht einfach sowas hier und

01:54:01.680 --> 01:54:09.400
dann funktioniert es nicht geil jetzt wollte ich euch das zeigen man kann nämlich das in

01:54:09.400 --> 01:54:14.280
den output in die variable schreiben ist das vielleicht irgendwas was nur in bash funktioniert

01:54:14.280 --> 01:54:28.160
aber vielleicht funktioniert das vielleicht funktioniert das nur in bash

01:54:28.160 --> 01:54:35.960
ach minus t muss natürlich minus t hat ja überhaupt nichts zu suchen guckt und jetzt

01:54:35.960 --> 01:54:42.680
und jetzt sehe ich den output auf der kommando zeile und ich habe in meiner variable den

01:54:42.680 --> 01:54:50.400
output drinstehen mit dem hash das ist massive big brain oder wie gesagt ich habe das letztens

01:54:50.400 --> 01:54:56.320
für was verwendet wo man wo man es hier auf ruft und unter der haube aber den output trotzdem

01:54:56.320 --> 01:55:09.160
sehen will das ist das ist next level shit oder wenn man zwei titi wise hat dann musst

01:55:09.160 --> 01:55:14.200
du wahrscheinlich irgendwie die den channel angeben oder so das ist das ist wirklich das

01:55:14.200 --> 01:55:21.760
ist wirklich feifett hier so jetzt starten wir den docker container dann lassen wir kurz

01:55:21.760 --> 01:55:31.400
nämlich gehen dann müssen wir irgendwas kopieren wie docker docker c was nervt nicht rum docker

01:55:31.400 --> 01:55:40.400
cp aus dem speed bild wo machen wir den bild überhaupt nach slash bild alter leute wenn

01:55:40.400 --> 01:55:48.720
das funktioniert dann also von slash bild wollen wir das wollen wir den speed test light rüber

01:55:48.720 --> 01:56:01.120
kopieren in bild lokal warum nicht einfach mit dem namen weil es kein namen hat weil

01:56:01.120 --> 01:56:08.600
es wir sind wir sind next level wir brauchen keine namen haschwerte haschwerte only cringe

01:56:08.600 --> 01:56:17.480
wenn auch namen verwendet also rüber kopieren weiß das nicht ob das ist so oder also rüber

01:56:17.480 --> 01:56:30.720
kopieren den output und danach den speed bild löschen und wenn wir super mutig sind machen

01:56:30.720 --> 01:56:42.760
wir noch am ende docker image hasch löschen so kann man über das kann das bestimmt ja

01:56:42.760 --> 01:56:54.120
ja ich weiß man kann minus t und namen machen aber wie gesagt hasch beste wenn das fast

01:56:54.120 --> 01:57:03.480
so also das hier müsste jetzt eigentlich soweit schon funktionieren außer der bild

01:57:03.480 --> 01:57:10.960
der bild der dürfte noch nicht funktionieren ich führ noch mal kurz bild punkt sh aus

01:57:10.960 --> 01:57:19.600
ja da funktioniert natürlich nicht da gibt es jetzt grad nichts zum bilden aber erlöscht

01:57:19.600 --> 01:57:24.800
danach den container und wenn ich jetzt richtig advanced bin könnte ich danach sogar den

01:57:24.800 --> 01:57:34.040
kompletten container wieder den kompletten container wieder löschen guck mal da hat

01:57:34.040 --> 01:57:38.720
es sogar das image gelöscht wir bilden das jetzt ohne rückstände ich sag ja defops

01:57:38.720 --> 01:57:43.200
any percent speedrun aber das mache ich weg weil ansonsten wird es nur unnötig unnötig

01:57:43.200 --> 01:57:50.840
langsam ok jetzt müssen wir uns um unser docker file kümmern also wir kopieren uns den

01:57:50.840 --> 01:58:04.280
graben nach bild was machen wir jetzt wir ob wie war das noch mal docker file command

01:58:04.280 --> 01:58:17.880
warte mal command multiline runde fifa 1 gegen 1 tja kaufst du mir eine fifa lizenz und und

01:58:17.880 --> 01:58:24.640
und die nötigen fifa points als ich ein ordentliches team bekomme ich gebe dir mein paypal account

01:58:24.640 --> 01:58:38.120
easy dann spiele ich mit dir auch fifa 1 vs 1 entry point das war doch irgendwas mit breaking

01:58:38.120 --> 01:58:46.820
up long lines in your docker file ich will wissen was command run war mensch war das

01:58:46.820 --> 01:58:55.680
einfach command ich copy mein problem ist ich copy paste einfach immer aus bestehenden

01:58:55.680 --> 01:59:01.200
docker files ich schreibe so gut wie nie neue docker files ich copy paste immer nur welche

01:59:01.200 --> 01:59:22.640
run run oder cmd cmd einfach cmd was ist der unterschied zwischen entry point cmd und

01:59:22.640 --> 01:59:34.560
und run also cmd wir gehen nach slash bild dann führen wir unser dotnet dotnet bild aus

01:59:34.560 --> 01:59:45.560
das da ich glaube so für die nächste zeile so wir sind in bild wir haben kein dotnet

01:59:45.560 --> 01:59:54.320
kommandos zur verfügung wir müssen slash dotnet da liegt unser dotnet rum wozu du das

01:59:54.320 --> 01:59:58.920
script verwenden kannst dass wir unser programm kompilieren können in einem ural cento s7

01:59:58.920 --> 02:00:06.840
ohne dass ich mir ein cento s7 lokal installieren muss also in der vm und es dann immer reproduzierbar

02:00:06.840 --> 02:00:17.480
machen kann also cd bild dotnet publish config release also ich würde sagen chat was meint

02:00:17.480 --> 02:00:22.000
ihr funktioniert das oder funktioniert das jetzt nicht also irgendwas habe ich garantiert

02:00:22.000 --> 02:00:29.120
vergessen tausendprozentig aber ich ich ich fühle maus schon nee ich glaube nicht dass

02:00:29.120 --> 02:00:40.360
es läuft ich bin nicht zuversichtlich dotnet installieren vergessen hier ist dotnet installieren

02:00:40.360 --> 02:00:55.080
drauf dabei ok bild aber er versucht schon mal was zu kompilieren

02:00:55.080 --> 02:00:59.840
musst du das binary nicht aus dem container rausholen doch das mache ich hier guck mal

02:00:59.840 --> 02:01:07.640
docker cp das ist copy docker cp von speedtest lite bild slash bild slash dessa bild nach

02:01:07.640 --> 02:01:15.520
in den bild ordner lokal doch doch

02:01:15.520 --> 02:01:25.040
was hat er denn für schmerzen couldn't find any valid eco package i was interessiert

02:01:25.040 --> 02:01:31.440
mich denn irgendwelche übersetzungen alternatively you can set configuration flag ach so ja das

02:01:31.440 --> 02:01:43.120
muss die schon mal machen zeigt mal was gibt's dafür hast du eigentlich ein dual boot system

02:01:43.120 --> 02:01:54.560
oder worauf läuft jeder linux windows windows das ist eine vm was zum ah man kann eine environment

02:01:54.560 --> 02:01:59.440
variable setzen ok leute ich ich bevorzuge die environment variable das können wir nämlich

02:01:59.440 --> 02:02:14.240
einfach in unser docker feil reinhauen haben wir hier unten hin entf hallo gleich eins so

02:02:14.240 --> 02:02:25.680
build prege leute prege es ist schon spät wir haben immer viel zeit aha aha das sieht

02:02:25.680 --> 02:02:40.880
nach einem dotnet bild aus schon mal oh fuck was wurde nicht gefunden klang das habe ich

02:02:40.880 --> 02:02:45.000
das bin ich ausgerichtet ich habe das eigentlich immer sie lang ausgesprochen aber ich habe

02:02:45.000 --> 02:02:49.600
letztens ein talk gehört auf youtube von irgendeinem der klang entwickler und die sprechen es

02:02:49.600 --> 02:02:57.240
klang aus nicht sie lang klang not found stand das nicht sogar freund hier irgendwo drinnen

02:02:57.240 --> 02:03:10.120
was man als dependencies braucht aha man braucht z lang und set lip set lip eins gef gibt es

02:03:10.120 --> 02:03:20.960
den kram wie heißen der kram unter cento s überhaupt install wenn er das sagt muss

02:03:20.960 --> 02:03:29.720
das stimmen ganz klar das ist wie das ist wie btr fs leute ist es btr fs ist es butter

02:03:29.720 --> 02:03:39.800
fs ist es betta fs ist es was auch immer man hat keine ahnung aber set lip gibt es nicht

02:03:39.800 --> 02:03:54.400
guck mal hier set lip set lip search set lip devil will ich wahrscheinlich haben vermute

02:03:54.400 --> 02:04:12.000
ich jetzt mal also weget das und set lip devil soll mir recht sein noch mal mein bild ausführen

02:04:12.000 --> 02:04:25.520
bild.sh das geht jetzt ein bisschen langsamer weil er die restlichen schritte noch mal neu

02:04:25.520 --> 02:04:34.600
machen muss

02:04:34.600 --> 02:04:54.760
ich habe keine ahnung was mir jam mit teilen will muss man nicht verstehen oder auf cento

02:04:54.760 --> 02:05:02.080
s komm gib alles wir haben nur noch zwanzig minuten höchstens zeit hier warum warum installiert

02:05:02.080 --> 02:05:10.480
er mir boost also es ist mir suspekt wenn er c++ shit braucht das machts in der regel

02:05:10.480 --> 02:05:23.560
nicht besser auf cento s mach hinne warum ist jam eigentlich so ein müll ich weiß ich

02:05:23.560 --> 02:05:30.560
hab schon öfters gesagt aber warum ist jam eigentlich so kacke so net installation noch

02:05:30.560 --> 02:05:39.400
mal und dnf ist auch nicht viel schöner das ganze rpm ökosystem fuck mich übelst ab

02:05:39.400 --> 02:05:54.560
es wird set lip nee ich glaub boost ist eher für base development package ok leute prege

02:05:54.560 --> 02:06:12.800
prege ob der bild geht prege project to restore prege prege ja wir benutzen cento s7 auf der

02:06:12.800 --> 02:06:30.560
arbeit aha aha ok der bild scheint zu laufen wenn er jetzt nicht noch abkackt fertig fertig

02:06:30.560 --> 02:06:54.080
bild das ist nix drin no such pass irgendwas habe ich falsch falsch geschrieben leute irgendwas

02:06:54.080 --> 02:07:15.720
habe ich falsch falsch geschrieben speed test light bild slash bild achso moment

02:07:15.720 --> 02:07:35.160
ich mach output bild ich mach output output bild das heißt genau es ist doppelt es ist

02:07:35.160 --> 02:07:47.280
doppelt bild das muss ja mal einer dran denken so noch mal geht jetzt schneller weil du noch

02:07:47.280 --> 02:07:53.320
das dotnet programm übersetzen muss ach stand das noch mal da das habe ich jetzt gar nicht

02:07:53.320 --> 02:07:57.520
gesehen ach hier oben guck nee nee noch anzuhören wir sehen jetzt ja ob es jetzt funktioniert

02:07:57.520 --> 02:08:27.480
aha aha auf aha aha oh guck mal da bild speed test light und wir haben ein binary was funktioniert

02:08:27.480 --> 02:08:41.880
kackel wobei ach h gibt's nicht h war in dem anderen projekt drinne ja funst so jetzt eine

02:08:41.880 --> 02:08:52.680
sache haben wir noch vergessen eine sache haben wir noch richtige chonk champ eine sache

02:08:52.680 --> 02:09:10.400
haben wir noch vergessen zum zum schluss strip und uns strip slash bild slash bild es ist

02:09:10.400 --> 02:09:27.000
im container aus slash bild slash bild ja oder slash bild slash bild so ach ich habe oben

02:09:27.000 --> 02:09:41.480
schon cd cd bild also muss ich jetzt eigentlich nur noch so machen so und da sollte jetzt

02:09:41.480 --> 02:09:46.840
ein binary rauskommen was irgendwie 14 mb groß ist und funktioniert und kackel auf der

02:09:46.840 --> 02:09:58.480
comando zeile ausgibt also das ist ja eh huge programm hier was wir da was wir am start

02:09:58.480 --> 02:10:25.560
Leute doch chanel aber ich hab's vergessen ich weiß nicht mal was es war irgendwas den

02:10:25.560 --> 02:10:38.000
heckermann kick sind groß kann das sein bild komm mal hier 14 mb binary so und es läuft

02:10:38.000 --> 02:10:43.080
wenn das bei mir läuft muss ich das jetzt auch nicht mehr auf dem ubuntu wir sind wir

02:10:43.080 --> 02:11:04.040
sind mal so frei leute wir sind mal so frei ubuntu 1804 bild speed build build speed test

02:11:04.040 --> 02:11:24.040
valid ecopackage wait a minute wir haben doch gesagt er soll nix ecopackage machen

02:11:24.040 --> 02:11:38.320
habe ich ihm nicht gesagt er soll er soll dort net system globalization invariant 1 machen

02:11:38.320 --> 02:12:01.520
die endvariable zum bild doch nicht fertig gleich ist ein bug das ist eine runtime variabler

02:12:01.520 --> 02:12:16.440
ich kann die nicht zur bild time ausstellen oder was ist aber ziemlich dumm checkt doch

02:12:16.440 --> 02:12:39.360
wieder keiner dann man kann es zur bild time ausstellen ja wenn ich nur wüsste wenn ich

02:12:39.360 --> 02:13:01.520
nur wüsste wie das bild das aber dann keine da müsste man sich jetzt raussuchen

02:13:01.520 --> 02:13:23.600
das da muss muss das da rein oder ich mache das in die oder ich mache das in die projekt

02:13:23.600 --> 02:13:37.640
ich mache das hier in das projekting rein und gut ist unload project ich machs uns da

02:13:37.640 --> 02:13:43.520
muss ich noch mal bilden aber jetzt seht ihr guckt mal wie gut das mit dem bild jetzt funktioniert

02:13:43.520 --> 02:13:49.880
ich kann jetzt reproduzierbar auf einem fucking uralt system einfach ein aktuelles binary

02:13:49.880 --> 02:13:55.160
bilden und ich muss nix mehr dafür machen außer mein bild script anpassen und vor allem

02:13:55.160 --> 02:13:59.520
muss ich mir nicht diesen ganzen müll lokal installieren und jeder andere der sich das

02:13:59.520 --> 02:14:10.640
git repo klont könnte es gleich jetzt auch machen auf was stellt ihr von sento es um

02:14:10.640 --> 02:14:19.080
wahrscheinlich ubuntu was ich schon seit jahren befürworte

02:14:19.080 --> 02:14:23.960
das kann dort net jetzt was go kann ahead of time kompilieren und zwar rückwirkend

02:14:23.960 --> 02:14:28.720
für relativ viele betriebssysteme wenn man es auf dem auf auf der passenden kiste

02:14:28.720 --> 02:14:49.640
kommt halt so ist es im bild bild ordner drin 228 bettgetheim angesagt leute gleich bettgetheim

02:14:49.640 --> 02:15:05.920
cd bild cd bild speed test jawoll funktioniert name keckel alles klar ok nice wisst ihr was

02:15:05.920 --> 02:15:10.000
mich wisst ihr was jetzt mal ausprobieren leute wir testen mal wollen wir gucken ob

02:15:10.000 --> 02:15:18.520
es mit ubuntu 16 16 04 funktioniert wahrscheinlich nicht ich glaube so alt so alt ist es nicht

02:15:18.520 --> 02:15:24.520
ich meine wobei vielleicht funktioniert was denkt ihr leute funktioniert auf 16 04 wir

02:15:24.520 --> 02:15:33.240
haben es auf dem cento s7 gebildet cento s7 kam vor ubuntu 16 04 raus ich meine das ist

02:15:33.240 --> 02:15:45.400
jetzt bettel oft the oldest sozusagen hey es funktioniert sogar um ubuntu 16 04 guck mal

02:15:45.400 --> 02:15:52.560
das doch nice also jetzt mal im ernst was älteres als ein ubuntu 16 04 muss man nur

02:15:52.560 --> 02:15:58.000
wirklich nicht mehr supporten das ist ein das ist ein über sechs jahre altes betriebssystem

02:15:58.000 --> 02:16:05.880
wollen wir mal wollen wir mal 14 04 ausprobieren wir machen das jetzt schrittweit schrittweise

02:16:05.880 --> 02:16:25.280
15 15 10 habe ich 3000 dumme ubuntu images 15 10 ok cd bild bild speed test light achso

02:16:25.280 --> 02:16:41.160
nicht cd würde auch funktionieren name keckel von wann ist der älteste lts kornel ubuntu

02:16:41.160 --> 02:17:02.160
504 ich habe keine wort die wort die worthog war das erste ubuntu glaube ich 2004 das

02:17:02.160 --> 02:17:10.760
glaube ich aber nicht dass es das unterstützt ok was haben wir da noch 15 04 14 04 ist

02:17:10.760 --> 02:17:17.960
glaube ich das nächste lts dann wieder linux können dann nicht das ist alles schon ewig

02:17:17.960 --> 02:17:26.920
end of life achso ubuntu support ist 1804 also extended support 16 04 das hat aber keiner

02:17:26.920 --> 02:17:40.720
ubuntu lts geht immer fünf jahre also 16 04 1804 ist das das letzte ubuntu gerade das

02:17:40.720 --> 02:18:02.600
funktioniert immer noch 14 ok kaum 14 04 das 14 04 genau 8 jahre altes ubuntu also ich

02:18:02.600 --> 02:18:11.040
glaube das ist abwärts kompatibilität genug wir machen jetzt mal wir machen das mal wir

02:18:11.040 --> 02:18:16.600
gucken mal kleines bettke kleines bettke ne ich mach die mach die schrittweise ich mach

02:18:16.600 --> 02:18:22.400
die schrittweise du weißt guck mal die downloads sind schon mega langsam weil das keiner runter

02:18:22.400 --> 02:18:48.360
geht muss ich da eben bin basch angeben oder so geht auch 13 10 geht auch noch 1304

02:18:52.400 --> 02:18:58.840
ok

02:19:03.320 --> 02:19:12.920
warum sollte ich rebooten ok also leute 13 04 ist schluss

02:19:12.920 --> 02:19:29.840
weil library zu alt aber ganz im ernst 13.10 als letztes ubuntu also

02:19:29.840 --> 02:19:42.840
was docker system remove unused data ja das ist gut ja weg damit

02:19:48.360 --> 02:19:51.960
achso wir gehen gleich ja und gleich ab

02:19:51.960 --> 02:20:06.240
was macht er denn so lange der lot der löscht images postchamp

02:20:06.240 --> 02:20:22.640
laufen keine container gerade ich habe ein paar containers am start hier

02:20:22.640 --> 02:20:29.560
er macht dinger so und jetzt machen wir noch eine sache zum schluss weil wir jetzt wissen

02:20:29.560 --> 02:20:34.560
dass es funktioniert wir machen das image wir löschen das image das heißt im endeffekt

02:20:34.560 --> 02:20:49.400
der sollte bilden binary raus kopieren und dann das image wieder löschen braucht das immer so

02:20:49.400 --> 02:21:06.120
lang nicht dass der jetzt mal ein halbes system das jetzt mal ein halbes system löscht java

02:21:06.120 --> 02:21:28.560
java ach das die idee lull ich wollte gerade sagen aber das ist die idee wie heißt das

02:21:28.560 --> 02:21:38.320
programm was das hier b top das nervt mich aber weil weil das sagt es braucht eine mindestgröße

02:21:45.120 --> 02:21:51.040
ja hartop ist immer noch beste hartop ist auch auf vielen seufern standmäßig drauf also

02:21:51.040 --> 02:21:58.320
ich finde zum einfach über sie hartop ist top ja poc die haben auch eine outtap jetzt das ist relativ

02:21:58.320 --> 02:22:10.360
neu kann auch b top b top hat halt sie dann fancy aus wie lange läuft dann die bitteschön

02:22:10.360 --> 02:22:27.040
dieses docker aufräumen ding was macht es denn da b top gibt es auch noch her akustik

02:22:27.040 --> 02:22:33.960
b top c top gibt es auch noch das irgendwelche container anzeigen das dauert ich muss jetzt

02:22:33.960 --> 02:22:40.520
gleich bettke aber gut ich kann die vm ja einfach einfrieren kann man was ausführen in der

02:22:40.520 --> 02:22:53.320
zwischenzeit naja aber das war doch wirklich defops any percent heute ging doch ging doch

02:22:53.320 --> 02:23:01.280
zag ich hatte auch ganz gut funktioniert das können wir übrigens rausschmeißen weil es jetzt

02:23:01.280 --> 02:23:11.320
im in der projekt mappe da drinne ist docker ist ist durch ok was hatten die alles gelöscht

02:23:18.440 --> 02:23:25.840
docker images aber wieder alles runterschmeißen hier oder guck mal das ganze ubuntu zeug man

02:23:25.840 --> 02:23:41.880
warum ist das doch docker images ja ubuntu ubuntu ubuntu ist gar zu ural zeugs man alles weg hier

02:23:41.880 --> 02:24:01.400
ane es ist rmi nicht docker images rem bg das ist zum background entfernen von bildern hat aber

02:24:01.400 --> 02:24:11.200
nicht so gut funktioniert so docker images aber der chat wieder mit massive 5 hat commands so

02:24:11.200 --> 02:24:15.080
jetzt mal abschließend noch mal ein bild um zu beweisen es funktioniert alles und er löscht

02:24:15.080 --> 02:24:31.320
alles also so hier nix da bild punkt sh bäm das ist jetzt wie wenn ich mir das konnten wie wenn

02:24:31.320 --> 02:24:36.400
ich mir das repo frisch geklont hätte so er lädt sich in cento es image runter

02:24:36.400 --> 02:24:46.080
er machten ja am update er sagt service not available das ist schlecht was macht die uni

02:24:46.080 --> 02:24:56.080
bei reut da wieder warum ist die not available ich hatte eine idee wir könnten für diesen speed

02:24:56.080 --> 02:25:03.080
für diese speed test tool was was ich was ich ja so ein bisschen will dass das so unser hallo

02:25:03.080 --> 02:25:06.960
well stream projekt wird dass man das immer wenn man was ausprobiert machen wir so drei

02:25:06.960 --> 02:25:14.080
zeilen speed test man könnte anstatt irgendwelche speed testing seiten anzuzapfen einfach

02:25:14.080 --> 02:25:24.960
linux isos runterladen einfach fünf verschiedene mirros nehmen und gucken wo es schnell ist groß

02:25:24.960 --> 02:25:44.040
genug sind die dinger so er installiert lvm lvm oder l wie sagen sie lvm so installiert

02:25:44.040 --> 02:26:04.080
developer tools alles automatisch wohlgemerkt muss nichts dafür machen also wenn man quasi

02:26:04.080 --> 02:26:09.880
eine neue version des tools release n will würde man das einmalig ausführen und dann

02:26:09.880 --> 02:26:16.720
kann man das binary distributen man könnte natürlich das bildskript noch erweitern das

02:26:16.720 --> 02:26:21.840
ist das dann automatisch auf github als neue release version also man könnte das bild man

02:26:21.840 --> 02:26:30.200
könnte einen tag machen lassen zu dem zeitpunkt auf das repo dann pushen lassen und das am ende

02:26:30.200 --> 02:26:35.240
das fertiggebildete binary hochladen oder man macht das gar nicht lokal sondern über github

02:26:35.240 --> 02:26:46.680
actions bei einem push von einem neuen tag das wäre auch eine möglichkeit oder man macht

02:26:46.680 --> 02:26:51.280
ein prot branch und da bei einem neuen push oder was auch immer gibt es ja gibt es ja zig

02:26:51.280 --> 02:26:58.760
möglichkeiten so er entpackt das dotnet framework er kopiert die anwendung rüber er führt ein bild

02:26:58.760 --> 02:27:14.880
also muss ich doch das environment muss ich doch die environment variable drin stehen lassen das

02:27:14.880 --> 02:27:20.080
ist eher ein bug oder so ha bild und jetzt macht er das ganze noch mal da habe ich jetzt keinen

02:27:20.080 --> 02:27:29.800
bock drauf da das noch mal gucke ich mir das jetzt nicht an okay man braucht die n und man

02:27:29.800 --> 02:27:35.160
braucht im projekt warum auch immer muss man nicht verstehen aber soll mir soll mir recht sein

02:27:35.160 --> 02:27:41.400
ach wisst ihr was sein kann dass der den bildvorgang erst gar nicht starten kann das liegt gar nicht an

02:27:41.400 --> 02:27:54.080
meinem programm sondern der kann der kann dort das dotnet CLI gar nicht starten ohne dass das

02:27:54.080 --> 02:28:04.920
installiert ist was damit gemeint ist zum beispiel dass du jetzt seit dotnet sieben ist das auch was

02:28:04.920 --> 02:28:11.560
wofür der container im hintergrund auch gerade bildet dass du seit dotnet sieben jetzt offiziellen support für

02:28:11.560 --> 02:28:18.640
ahead of time compilation hast du kannst binaries machen die schnell starten und die rückwärts

02:28:18.640 --> 02:28:26.160
kompatibel sind vorausgesetzt die wurden auf dem richtigen system gebaut bis ubuntu 13.10 haben wir

02:28:26.160 --> 02:28:33.840
gerade ausprobiert und ich würde mal behaupten binaries die bis rückwirkend 13.10 laufen sind

02:28:33.840 --> 02:28:42.200
99,9 aller linke systeme und es ist gar nicht so groß ich meine es sind 14 mb binaries wie groß

02:28:42.200 --> 02:28:48.880
ist so ein standard hello world go binaries 4 mb 3 mb es ist kleiner auf jeden fall aber nicht so

02:28:48.880 --> 02:29:06.920
viel kleiner immerhin 60 mb war schon ein bisschen heftig ja na komm ich lasse den bild noch durch

02:29:06.920 --> 02:29:12.840
laufen leute weil ihr seid ich wollte jetzt eigentlich auf orne jetzt hängt aber im studio

02:29:12.840 --> 02:29:20.040
da habe ich keinen bock macht dann funktioniert es dann aus wozu braucht man hier die dev tools

02:29:20.040 --> 02:29:27.800
weil der zeug kompilieren muss gegen glibc

02:29:27.800 --> 02:29:43.640
haben die mich gerät limited oder was ist das problem bei microsoft dass der download so kacke

02:29:43.640 --> 02:29:56.600
ist wann gibt es das ungefähr instable november also juli august september oktober also in vier

02:29:56.600 --> 02:30:12.440
monaten kommt dort nicht sie raus hat er eigentlich für jetzt geht es was ist das bei microsoft denn

02:30:12.440 --> 02:30:19.320
für komisches zeug der offizielle dort net download hängt man muss man zweimal ausführen dann geht

02:30:19.320 --> 02:30:32.480
es alter was ist das denn krepp ist sie schafft nun wie go nähe go ist noch länger go läuft

02:30:32.480 --> 02:30:39.720
rückwirkend rückwirkend bis karnel 26 23 oder so mein ganz so war was hatten ok warte mal

02:30:39.720 --> 02:30:57.560
ubuntu ubuntu 13.10 körner was hatten es für körner noch ok 3.8 ja also 2013 versus 2008 aber

02:30:57.560 --> 02:31:05.480
ganz ehrlich so wirklich relevant ist das nicht also ein system von ende 2013 ist voll und ganz

02:31:05.480 --> 02:31:17.480
auch immer er hat gebildet sagt perfekt wunderbar ich bin äußerst zufrieden

02:31:17.480 --> 02:31:26.360
ich kenne mich nicht richtig entscheiden ich würde gerne eine programmiersprache lernen

02:31:26.360 --> 02:31:30.640
kann mich aber wirklich entscheiden irgendwelche tips ja in welcher richtung willst du denn was

02:31:30.640 --> 02:31:37.000
machen am besten was man wie es kommt dann ist es ganz einfach wenn du noch nicht genau weißt was

02:31:37.000 --> 02:31:43.280
du machen willst und du am liebsten studio code verwenden willst javascript text editor browser

02:31:43.280 --> 02:31:50.040
auf geht's und es hat noch weitere vorteile erstens ist die einstiegshürde bei javascript mit

02:31:50.040 --> 02:31:57.320
abstand die kleinste und du kommst eh nicht es sei denn du bist cobalt mainframe entwickler du

02:31:57.320 --> 02:32:05.700
kommst eh nicht in irgendeine art und weise an html css und javascript vorbei ich auch wenn du

02:32:05.700 --> 02:32:10.080
backends sachen machst ein bisschen ahnung von frontend braucht man immer und sei es nur dass

02:32:10.080 --> 02:32:14.760
du mal irgendwie ein web interface für irgendwas basteln willst nicht halb skript javascript mit

02:32:14.760 --> 02:32:24.760
halb skript würde ich nicht anfangen als erstes im studio code und im browser deiner wahl und

02:32:24.760 --> 02:32:35.720
bastel javascript sachen zum einstieg du brauchst ja in javascript nichts zu machen die reicht in

02:32:35.720 --> 02:32:41.480
text editor und browser ansonsten wenn du dann weiter guckst also was du nicht machen darfst

02:32:41.480 --> 02:32:47.320
es auf reddit gehen weil auf reddit sagen die dir ja erst einmal not installieren dann machst du

02:32:47.320 --> 02:32:54.600
die neuesten linting addons in visual studio code und dann brauchst du natürlich auch noch webpack

02:32:54.600 --> 02:33:04.000
was du erstmal ordentlich konfigurieren musst am besten auch gleich react dabei weil vanilla

02:33:04.000 --> 02:33:08.720
javascript und so macht ja keiner mehr und bei react brauchst du natürlich da noch die passende

02:33:08.720 --> 02:33:12.400
state management library wenn du die state management library hast ist natürlich die

02:33:12.400 --> 02:33:17.360
frage ob nicht auch noch tailwind cs obendrauf packst und dann am ende muss natürlich auch noch gucken

02:33:17.360 --> 02:33:23.600
was du für ui frameworks nimmst weil von hand css machen und javascript components macht ja

02:33:23.600 --> 02:33:28.400
keiner mehr dann brauchst du noch irgendwelche task runner und aber dass sie schwach sind die

02:33:28.400 --> 02:33:38.960
javascript leute übertreiben massiv mit dem ganzen zeug genau das muss trishakeable sein

02:33:38.960 --> 02:33:45.920
das hört gar nicht mehr das hört nicht auf nehmen den browser nehmen den text editor und fangen mit

02:33:45.920 --> 02:33:54.800
javascript an javascript gibt es auch einfach und endlich viele tutorials ne ist es nicht bei

02:33:54.800 --> 02:34:01.080
python plus gerade wer braucht denn jupiter jupiter war gar nicht richtig notebooks am anfangen das

02:34:01.080 --> 02:34:07.480
ist wenn die hier krasse eine physik studierst meinetwegen oder so aber das zum einstieg doch

02:34:07.480 --> 02:34:15.280
nix heißt an sich ist eine super einstiegssprache keine frage aber die hürde sich da irgendwie was

02:34:15.280 --> 02:34:22.480
runterzuladen dass ich finde es am besten editor browser auf fertig mehr muss man nicht machen du

02:34:22.480 --> 02:34:34.800
hast du hast schon alles was du brauchst auf dem rechner korrekt er hat recht es ist nicht

02:34:34.800 --> 02:34:41.640
arch beide wey ok leute 22 23 es wird mal richtig massiv zeit für betke

02:34:41.640 --> 02:34:55.960
feil ist in jazz leider schlechter feil geht in jazz gar nicht also du kannst über formulare

02:34:55.960 --> 02:35:01.840
was hochladen und so aber feil geht nicht in javascript also in node schon im browser nicht

02:35:01.840 --> 02:35:05.440
aber browser wäre fatal wenn ein browser zugriff auf feilsystem hätte

02:35:17.440 --> 02:35:23.240
was verstehst du unter system näher du kannst in javascript alles machen was du machen willst

02:35:23.240 --> 02:35:30.240
sogar desktop anwendung dann halt mit elektron und note deswegen ich dachte ja wenn du javascript

02:35:30.240 --> 02:35:36.120
kennst ist das auf jeden fall immer ein gewinn du kommst um frontend sachen ähnlich drum herum

02:35:36.120 --> 02:35:43.560
egal was du machst und du kannst dann potenziell mit javascript auch alles mögliche andere machen

02:35:43.560 --> 02:35:54.960
ich meine du kannst mit javascript vielleicht kein bios updater programmieren oder so oder

02:35:54.960 --> 02:36:01.200
kein bootloader sogar das würde ja theoretisch noch funktionieren du kannst ja theoretisch sogar

02:36:01.200 --> 02:36:08.680
ein javascript ein bootloader programmieren du bräuchte brauchst halt ein paar assembler befehle

02:36:08.680 --> 02:36:13.760
um auf die richtige adresse zu springen da sind ja so hart hard codete adressen wurde ein bootloader

02:36:13.760 --> 02:36:18.960
hinspringen müssen und so was und wenn du schaffst dort auf den javascript interpreter zu springen

02:36:18.960 --> 02:36:23.000
kannst du den restlichen bootloader bestimmt auch in javascript programmieren aber das ist

02:36:23.000 --> 02:36:27.160
schwachsinn also ein bootloader wirst du wahrscheinlich nicht in javascript programmieren können aber

02:36:27.160 --> 02:36:32.240
ansonsten kannst du alles in javascript machen was du willst ob sich dann alles das dafür auch

02:36:32.240 --> 02:36:38.080
gut eignet ja es gibt immer spezielle sprachen und frameworks die so ihre schwerpunkte haben

02:36:38.080 --> 02:36:43.200
wenn du mobile anwendungen machst ja dann ist es heutzutage hauptsächlich mal dart und flatter

02:36:43.200 --> 02:36:50.480
wenn du cross platform desktop anwendungen machst dann ist es ja leider meistens elektron aber es

02:36:50.480 --> 02:36:57.440
gibt auch so was wie c++ mit qt wenn du irgendwelche webseiten backends machst dann ist asp core eine

02:36:57.440 --> 02:37:02.240
wunderbare geschichte oder go oder bei irgendwelchen cloud sachen ist go und python übel ist

02:37:02.240 --> 02:37:11.080
angesagt es kommt einfach drauf an ja das würde ja prinzipiell schon wieder funktionieren so lange

02:37:11.080 --> 02:37:15.440
du ja du musst erstmal laufe in laufenden javascript interpreter haben oder ist ja geil ist ja

02:37:15.440 --> 02:37:23.040
nur so ein halber interpreter aus den laufe javascript runtime dann kannst du da alles

02:37:23.040 --> 02:37:29.320
mögliche mitmachen ob das schön ob das jetzt schön ist einmal dahingestellt

02:37:29.320 --> 02:37:48.320
naja jetzt aber vorbei leute ich gehe ins bett wir sehen uns bis denn macht's gut zu

