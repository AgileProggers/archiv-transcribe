WEBVTT

00:30.000 --> 00:39.440
Hallo, ich bin am Start, wer hätte das gedacht?

00:39.440 --> 00:40.440
Schon wieder!

00:40.440 --> 00:41.440
What?

00:41.440 --> 00:54.320
Und ich sehe, neun Leute haben auch Abobox, elf Leute, ich korriere elf Leute, haben

00:54.320 --> 00:59.920
auch die Sub-Abobox, wie nennt man das in Twitch, den Twitchfeed gecampt, oder hatten

00:59.920 --> 01:04.080
schon den Channel auf, man weiß ja nicht, Leute ich muss mal ganz kurz mein Headset entknoten.

01:04.080 --> 01:20.280
So, also bin wieder da, also wir werden noch nix großartig kompliziertes machen, wir gucken

01:20.280 --> 01:24.360
uns wieder ein paar Sachen, wir erzählen ein bisschen, was so aktuelle Sachen gibt,

01:24.360 --> 01:27.040
wir gucken uns mal ein paar Sachen auf YouTube an, wir gucken uns heute das C-Sharp Video

01:27.040 --> 01:31.000
an, was ich schon ne ganze Weile mir angucken wollte mit euch zusammen, wo kann ich meinen

01:31.000 --> 01:36.080
Senf zugeben, und morgen wird da ein bisschen Hacker-Mensch-Zeug gemacht.

01:36.080 --> 01:49.640
Ich probier jetzt, weil ich hab Urlaub bis 3.

01:49.640 --> 01:54.360
Januar, für alle die es nicht mitbekommen haben ja, also ich hab jetzt erst mal dieses

01:54.360 --> 02:03.440
Jahr, dieses Jahr ist Schluss mit Arbeiten, ich probier jetzt mal so ne Möglichkeit irgendwie

02:03.440 --> 02:07.040
jeden Tag ein bisschen zu streamen, einfach, dass es nicht abreißt.

02:07.040 --> 02:16.680
Warum so viel Urlaub, das ist ganz einfach, ich hatte das restliche Jahr über einfach

02:16.680 --> 02:30.120
kein Urlaub, ist doch ganz logisch, also ich hab 24 Tage im Jahr, weil ich bloß 4 Tage

02:30.120 --> 02:34.960
die Woche arbeite, also weniger Urlaub logischerweise, und ich hatte quasi, ich glaub ich hatte

02:34.960 --> 02:44.560
nur 2 Tage das ganze Jahr über, glaub nur an Ostern, irgendwie, ne nicht an Ostern,

02:44.560 --> 02:50.640
da wo irgendwie die Feiertage gut gefallen sind, Rest hatte ich, hatte ich nix, was aber

02:50.640 --> 02:54.920
auch cool ist, also das fand ich wirklich gut, dort wo ich mich beworben hab, hab ich

02:54.920 --> 02:59.920
euch glaub gar nicht erzählt, dass die gesagt haben, von sich aus so nach dem Motto hier

02:59.920 --> 03:08.720
4 Tage alles kein Problem und ich kann auch Montag weiterhin meinen Teilzeit-Tag machen,

03:08.720 --> 03:11.120
was ich gut finde, weil Montag hab ich ja nicht ohne Grund gewählt.

03:11.120 --> 03:26.800
Hattest du nicht irgendwie 3 Wochen dieses Jahr mal, nö, ich hatte Corona, 2 Wochen,

03:26.800 --> 03:31.720
fehlt dir die Urlaub nicht im Sommer, ne ich arbeite ja nur 4 Tage, ich hab quasi 3 Tage

03:31.720 --> 03:37.960
am Stück immer frei, das reicht mir, also konntest du den Urlaub in den neuen Job mitbringen,

03:37.960 --> 03:43.480
ne, ich arbeite nur 4 Tage, ich wär auch nur für 4 Tage bezahlt, das hat ja mit Urlaub

03:43.480 --> 03:55.560
nix zu tun, ne ne, ne ne, hab ich eigentlich die Kategorie umgestellt, ja es ist, ja ja

03:55.560 --> 04:11.080
just chatting, gute Musik, das ist Stinks Crypt of the Necrodancer Soundtrack, ist auch

04:11.080 --> 04:29.880
schon ein bisschen älter das Game, Pippe please, wie sehen bei dir dann die Arbeitszeiten

04:29.880 --> 04:55.960
aus 4x8, ne, äh 4x7,2 oder sowas, ja wir gucken mal ehrlich das C Sharp Video, da muss

04:55.960 --> 05:00.560
ich ja warten bis Breese Rief da ist, der hat nämlich schon 50 mal gefragt, dann wird

05:00.560 --> 05:12.520
es endlich gucken, gut, wenn er heute nicht da ist, kann man nix ändern, ja also 4x7,2

05:12.520 --> 05:20.760
arbeite ich die Woche, gucken wir uns den jetzt an, in 7 Tagen zum Pro Gamer, selbst

05:20.760 --> 05:26.920
Experiment, da hab ich so meine Zweifel, ob das in 7 Tagen funktioniert, kommt ein bisschen

05:26.920 --> 05:34.600
drauf an welches Game, aber selbst dann in 7 Tagen, in 7 Tagen hast du, ja, also wenn

05:34.600 --> 05:37.720
du dir wirklich viel Mühe gibst, kannst du in 7 Tagen ziemlich gut werden, das bezweifle

05:37.720 --> 05:49.560
ich gar nicht, also du krebst da nicht mehr irgendwie in Silber rum oder so, wie gesagt

05:49.560 --> 06:14.520
kommt auch das Game an, die ekelhafte Werbung von EliasN97, aha, gut, warum ist die ekelhaft,

06:14.520 --> 06:18.720
weil Simplicissimus was sagt oder, was hat er gemacht, ich bin jetzt eigentlich interessiert

06:18.720 --> 06:24.360
mich überhaupt nicht, ganz ehrlich ich guck mir eh kein deutsches YouTube an, ich weiß

06:24.360 --> 06:31.640
nicht wie es euch geht, chat mal ne Frage, guckt ihr deutsches YouTube, also ich hoffe

06:31.640 --> 06:40.400
ihr guckt bei mir ab und zu mal, ja, aber das mal außen vor, guckt ihr deutsches YouTube,

06:40.400 --> 06:47.160
also ich muss sagen ich überleg gerade, was gibt es an deutschen Channels die ich gucke,

06:47.160 --> 06:52.520
also wirklich regelmäßig quasi die meisten Videos, ich guck mir durchaus deutsche Channels

06:52.520 --> 07:08.200
an ab und zu mal, aber was guck ich, ok, ja doch, tatsächlich ich guck regelmäßig deutschsprachige

07:08.200 --> 07:12.880
Videos, stimmt, stimmt, sind aber meistens irgendwelche Technik Sachen, so was mich überhaupt

07:12.880 --> 07:23.640
nicht interessiert ist so diese Sache mit Drama, so TikTokerinnen geht fremd mit, keine

07:23.640 --> 07:31.520
Ahnung, Coach von sonst wie, ey, das juckt mich so überhaupt nicht, YouTube Drama, Alter,

07:31.520 --> 07:36.400
das geht mir so am Arsch vorbei, Seven versus Wild guck ich auch nicht, ich weiß, dass das

07:36.400 --> 07:40.120
ein riesen Erfolg ist, aber es interessiert mich nicht, den Bauer guck ich tatsächlich

07:40.120 --> 07:46.040
ab und zu mal, das ist richtig, ich gucke aber noch ein paar mehr Technik-Channels, aber

07:46.040 --> 08:00.400
das ist teilweise wirklich richtig Big Brain-Gramm, also nichts was wir jetzt hier gucken, GCN

08:00.400 --> 08:09.240
auf Deutsch, ist das nicht das Fahrrad, das Cycling, die Fahrradvideos, guck ich tatsächlich

08:09.240 --> 08:15.600
auch manchmal, aber wusste ich gar nicht, dass es die auf Deutsch gibt, ich hab mich

08:15.600 --> 08:21.560
früher relativ viel interessiert für Radsport, also früher ist wirklich früher, sehr viel

08:21.560 --> 08:26.760
früher gemeint und ich gucke immer noch mal ganz gerne so die ein oder anderen Sachen,

08:26.760 --> 08:33.000
auch wenn ich überhaupt nicht auf dem aktuellen Stand bin, kurz gesagt, ja, kurz gesagt guck

08:33.000 --> 08:37.040
ich tatsächlich ab und zu, sowohl auf Deutsch als auch auf Englisch, meistens auf Englisch

08:37.040 --> 08:43.160
aber auch ab und zu die ein oder anderen Videos auf Deutsch, ja, ich bin ErnoTricksEnjoyer,

08:43.160 --> 08:48.640
muss ich euch ehrlich sagen, ich glaube ich hab noch nicht ein Stream von ErnoTricks geguckt

08:48.640 --> 08:52.760
und auf seinem Channel macht er ja nichts mehr, großartig, da kam ja schon ewig nichts

08:52.760 --> 09:04.560
mehr, zumindest das letzte Mal als ich reingeguckt hab, kamen da nicht viele Videos, aber wie

09:04.560 --> 09:09.480
gesagt, deutsches Twitch guck ich so gut wie gar nicht, ich guck ab und zu mal beim Lost

09:09.480 --> 09:19.760
rein, ich guck mir ab und zu mal ein paar Warzone Streams an, aber ansonsten, ich guck

09:19.760 --> 09:25.600
auf Deutsch keine Twitch-Channels, wenn ich hier durch scrolle, da ist wirklich nichts

09:25.600 --> 09:30.480
dabei gerade, ich hab hier grad mal, hier, du folgst, mal gucken, mal gucken ob da ein

09:30.480 --> 09:34.720
deutschsprachiger Channel, Moment, ich guck mal, man kann doch irgendwie Kanäle sortieren,

09:34.720 --> 09:35.720
oder?

09:35.720 --> 09:40.000
Kann man nicht sagen, du folgst Kanälen auf Deutsch oder sowas, ne, das geht natürlich

09:40.000 --> 09:47.960
nicht, dass man das an der Stelle filtert, ne, nichts dabei, was ich regelmäßig Stundenlang

09:47.960 --> 09:53.840
an hab, ok, doch ein Channel ist dabei, das ist von einem deutschen, allerdings das ist

09:53.840 --> 10:00.600
ein englischsprachiger, englischsprachiger Channel, ansonsten ist nichts dabei, wenn ich

10:00.600 --> 10:19.200
so durch scrolle hier, also das wo ich wirklich viel gucken würde, ne, nix, naja, Live-Aufruf,

10:19.200 --> 10:22.920
da hab ich tatsächlich ab und zu schon reingeguckt, wie findest du den Friseur, der Kerl müsste

10:22.920 --> 10:28.360
mal wieder ein bisschen, war der mal wieder on in letzter Zeit, der müsste mal wieder

10:28.360 --> 10:42.200
ein bisschen, ein bisschen streamen, ne, macht er nicht, letzter hat irgendwelche Weep-Games

10:42.200 --> 11:05.880
gestreamt, und er müsste auch mal Kreisel-Crime machen, richtig, ja, na gut, so, alles klar,

11:05.880 --> 11:09.680
dann, ich würd sagen, komm wir geben uns das hier gleich mal, wir kommen uns das jetzt

11:09.680 --> 11:12.800
gleich mal an, zeig mal hier, wo war's dann, in sieben, das interessiert mich einfach was

11:12.800 --> 11:19.360
da rauskommt, in sieben Tagen, tatsächlich, von ihm hab ich schon ein paar Videos geguckt,

11:19.360 --> 11:27.720
der macht ja oftmals hier solche, ja, Selbstexperiment, es klingt teilweise übelst advanced, aber

11:27.720 --> 11:44.320
Videos in dieser Richtung, find ich meistens tatsächlich ziemlich gut, OnkS, nicht sterben

11:44.320 --> 11:57.160
hier, war das nicht auch der Typ mit der Influencer-Creme, oder war das ein anderer, wer war das mit

11:57.160 --> 12:02.760
der Influencer-Creme, mit dieser Creme vor ein paar Jahren, wisst ihr, da war doch was,

12:02.760 --> 12:08.520
aber das war Mafi, ach ne, das ist ein anderer, stimmt, ihr habt recht, das ist ein anderer,

12:08.520 --> 12:14.640
ja das ist ein anderer, stimmt, stimmt, stimmt, die sehen sich aber ähnlich, oder, oder vielleicht

12:14.640 --> 12:20.800
nur weil ich nicht oft gucke, ja, keine Ahnung, aber das ist das erste, was mir jetzt im Kopf

12:20.800 --> 12:28.520
gekommen ist, die Influencer-Creme, aber gut Chat, gut, ich bin zufrieden mit euch, wenigstens

12:28.520 --> 12:32.240
ihr blickt durch bei dem ganzen Kram, was ich erzähle, das ist ja schonmal was, muss

12:32.240 --> 12:35.560
ich nicht selbst überall durchblicken, so, hören wir uns das mal an, in sieben Tagen

12:35.560 --> 12:43.320
zum Pro Gamer, ein Selbstexperiment, lass mal kurz in die Beschreibung lurken, regelmäßig

12:43.320 --> 12:48.520
es zocken soll viele Vorteile haben, man bekommt eine bessere Reaktion und Konzentrationsfähigkeit,

12:48.520 --> 12:52.560
schnellere Informationsverarbeitung, ja, außer man hat das Uralt-Boomer-Hirn wie ich, da

12:52.560 --> 12:57.560
ist alles verloren, und es soll sogar insgesamt glücklicher machen, ja, ja gut, kommt, kommt

12:57.560 --> 13:02.520
auf das Game an, wenn man Toxic Overwatch ranked, Spiele Toxic Dota ranked, generell

13:02.520 --> 13:07.880
Toxic ranked und verliert, dann bezweifle ich, dass das glücklich macht, wenn man aber

13:07.880 --> 13:12.720
gut die Noobs wegbashed, dann macht es Bock, generell wenn man gewinnt, macht es eigentlich

13:12.720 --> 13:19.840
Herr Bock, MSI Placement Erbe, Leute, man muss gucken, wo man bleibt als Influencer heutzutage,

13:19.840 --> 13:24.360
sogar ich mache mittlerweile Werbung, ich habe eine Woche jeden Tag intensiv gezockt,

13:24.360 --> 13:27.480
um herauszufinden, was Gaming immer, mich würde interessieren, was intensiv gezockt

13:27.480 --> 13:34.560
ist, weil ehrlich gesagt, wenn man wirklich gut werden will in einem Game, also wenn man

13:34.560 --> 13:38.400
wirklich den, den, den, den, den, den, den Crying startet, ne, dann bin ich der Meinung,

13:38.400 --> 13:41.960
musst du eigentlich sechs Stunden plus am Tag des Games spielen, also wenn du wirklich

13:41.960 --> 13:46.640
vor hast, in kurzer Zeit gut zu werden und das alleine reicht wahrscheinlich auch nicht

13:46.640 --> 13:52.240
mal, dann musst du es auch mit einem gewissen, wie soll ich sagen, mit einem gewissen System

13:52.240 --> 13:56.040
machen, ja, wenn man noch einen Coach hat, natürlich noch besser, hat er anscheinend,

13:56.040 --> 14:01.440
habe ich hier gesehen, aus dem Augenwinkel, der hat Highscore Heroes am Start, weiß ich,

14:01.440 --> 14:06.680
was er aktuell für einen Rank hat, den kenne ich noch flüchtig aus der Overwatch Zeit

14:06.680 --> 14:13.080
und der ist bestimmt nicht schlechter als Coach, gerade wenn man anfängt, wenn man anfängt,

14:13.080 --> 14:17.880
braucht man gar nicht den Ultra Pro, der einen irgendwie coacht oder so, so, schauen wir

14:17.880 --> 14:21.440
mal, mal gucken, sieben Tagen, in sieben Tagen zum Pro Gamer, auf geht's Leute.

14:21.440 --> 14:28.000
Das ist so groß wie nie zuvor, allein 2021 wurden 9,7 Milliarden Euro umgesetzt und mittlerweile

14:28.000 --> 14:33.840
zölten in Deutschland 35 Millionen Menschen, das sind 42% der Gesamtbevölkerung, ich muss

14:33.840 --> 14:38.600
sagen, ich gehöre eher zu den anderen 58%, das ist zum Beispiel nicht mal in der Lage,

14:38.600 --> 14:46.520
das richtig einzustellen, okay, er spiel Overwatch ist schon mal gut, okay, auf geht's, fangen

14:46.520 --> 14:48.120
wir von vorne an.

14:48.120 --> 14:54.240
Du bist ab deinem Stück für den Sub, jetzt bin ich mal gespannt, also sieben Tagen zum

14:54.240 --> 15:02.520
Pro Gamer, auf geht's, ich predikte mal OBS Desktop Audio User, warum nicht, ich predikte

15:02.520 --> 15:05.520
Nein, in sieben Tagen bist du kein Pro-Gamer, aber wenn er sich richtig reinhängt,

15:05.520 --> 15:07.520
kann er durchaus ganz gut werden in sieben Tagen.

15:08.520 --> 15:11.520
Der Gaming-Markt in Deutschland ist so groß wie nie zuvor.

15:11.520 --> 15:15.520
Allein 2021 wurden 9,7 Milliarden Euro umgesetzt.

15:15.520 --> 15:19.520
Und mittlerweile zocken in Deutschland knapp 35 Millionen Menschen.

15:19.520 --> 15:21.520
Das sind 42 Prozent der Gesamtbevölkerung.

15:21.520 --> 15:24.520
Ich muss sagen, ich gehöre eher zu den anderen 58 Prozent.

15:24.520 --> 15:27.520
In meiner Jugend habe ich natürlich schon gespielt, aber in den letzten Jahren...

15:27.520 --> 15:31.520
Von den 35 Millionen zocken bestimmt ganz viele auch Mobile-Crap.

15:31.520 --> 15:33.520
Raid Shadow Legends oder...

15:34.520 --> 15:37.520
Wie ist das Ding, was ich letztens beworben habe?

15:38.520 --> 15:40.520
Ich habe es schon wieder vergessen.

15:41.520 --> 15:45.520
Matchmasters gegen irgendwelchen Mobile-Crap.

15:46.520 --> 15:48.520
Mamas mit Candy Crush, genau.

15:49.520 --> 15:52.520
Gut, was auch immer. Ist eine Statistik.

15:52.520 --> 15:54.520
Hat jetzt mit dem Video nichts zu tun.

15:55.520 --> 15:58.520
Eigentlich gar nicht mehr. Und ich bin auch ziemlich schlecht, vor allem in Shootern.

15:58.520 --> 16:01.520
Dabei soll regelmäßiges Zocken ja viele Vorteile haben.

16:01.520 --> 16:04.520
Man bekommt eine verbesserte Reaktions- und Konzentrationsfähigkeit,

16:04.520 --> 16:08.520
schnellere Informationsverarbeitung und es soll insgesamt glücklicher machen.

16:08.520 --> 16:11.520
Deswegen will ich herausfinden, was Gaming mit mir macht.

16:11.520 --> 16:14.520
Ich werde die nächste Woche jeden Tag intensiv zocken,

16:14.520 --> 16:16.520
werde vorher und nachher verschiedene Tests machen...

16:16.520 --> 16:18.520
Gute Maus hat er schon mal. Gute Maus.

16:18.520 --> 16:21.520
Und dann schauen wir mal, wie gut ich in so kurzer Zeit werden kann.

16:23.520 --> 16:27.520
Ich hoffe, ich hoffe, sie erzählen noch ein bisschen, was jetzt intensiv zocken heißt.

16:27.520 --> 16:30.520
Wie gesagt, ich bin der Meinung, sechs Stunden am Tag plus muss das sein,

16:30.520 --> 16:32.520
wenn du wirklich gut werden willst.

16:32.520 --> 16:35.520
Man hat jeder so ein bisschen da durch andere Vorstellungen,

16:35.520 --> 16:36.520
wie viel Zeit er reinstecken will.

16:36.520 --> 16:40.520
Aber wenn du sagst, hey, sieben Tage voll durch, sechs Stunden plus am Tag,

16:40.520 --> 16:43.520
besser acht Stunden plus am Tag, sollte das schon das Mindeste sein.

16:43.520 --> 16:46.520
Weil gerade wenn du neu bist und sonst nicht viel spielt,

16:46.520 --> 16:48.520
du musst einfach so ein bisschen, wie nennt man es so schön,

16:48.520 --> 16:51.520
ein bisschen Muscle-Memory aufbauen, wie man so schön sagt.

16:51.520 --> 16:54.520
Ja, du musst voll im Gameplay drin sein, musst voll so im Plus drin sein.

16:54.520 --> 16:58.520
Am besten ist natürlich auch, wenn du regelmäßig das analysierst, was du machst.

16:58.520 --> 17:03.520
Wenn du richtig Glück hast und noch einen hast dabei, der dich coacht, ist natürlich noch besser.

17:05.520 --> 17:10.520
Und was man machen muss, ist, man muss sich gezielte Punkte zum Verbessern raussuchen.

17:10.520 --> 17:15.520
Also so nach dem Motto, was weiß ich, die nächste Runde versuche ich jetzt dran zu denken,

17:15.520 --> 17:19.520
immer auf meine Cooldowns zu achten und das alle 30 Sekunden einzusetzen und so was,

17:19.520 --> 17:22.520
damit sich ein bisschen Routine aufbaut.

17:22.520 --> 17:28.520
Jetzt sag ich jetzt einfach mal so, ohne der, der je Pro Gamer gewesen ist.

17:28.520 --> 17:31.520
Die Frage, welches Spiel ich denn spielen möchte,

17:31.520 --> 17:35.520
und deswegen habe ich einfach mal geschaut, was gerade so neu und beliebt ist.

17:35.520 --> 17:38.520
Und eines der gehyptesten Spiele scheint gerade Overwatch 2 zu sein,

17:38.520 --> 17:39.520
habe ich noch nie gespielt.

17:39.520 --> 17:43.520
Da haben mir auch ein paar Freunde gesagt, dass das wohl relativ einsteigerfreundlich ist,

17:43.520 --> 17:45.520
was ja auf dem Fall ganz gut für mein Selbstexperiment ist.

17:45.520 --> 17:48.520
Das stimmt, Overwatch ist einsteigerfreundlich, das ist definitiv einsteigerfreundlich.

17:48.520 --> 17:52.520
Ich meine, ich weiß nicht, wie einsteigerfreundlich Overwatch 2 ist,

17:52.520 --> 17:55.520
aber Overwatch 1 war definitiv einsteigerfreundlich.

17:55.520 --> 17:59.520
Es ist übrigens gut, dass er Overwatch spielt, da kann ich wenigstens was zu sagen.

17:59.520 --> 18:05.520
Also ich quasi als ehemaliger deutscher Meister in Overwatch.

18:05.520 --> 18:12.520
Manche Leute tun sich ja immer schwer, das war ein Witz, Leute.

18:12.520 --> 18:17.520
Also wenn jetzt wieder einer ankommt, Alter, der Max erzählt uns hier was anderes.

18:17.520 --> 18:22.520
Nein, ich war nie deutscher Overwatch-Meister, sowas gab es auch gar nicht.

18:22.520 --> 18:26.520
Ich war Season 1 Top 500 als Supportspieler.

18:26.520 --> 18:29.520
Wir haben einmal ein deutsches Weekly gewonnen damals.

18:29.520 --> 18:35.520
Ich würde sagen, wo wir richtig gut dabei waren damals mit meinem Overwatch-Team, waren wir Tier 2.

18:35.520 --> 18:39.520
Nicht wirklich mega gut, aber ganz okay.

18:39.520 --> 18:43.520
Und wir haben auch mal gegen ein paar Pro-Teams gewonnen.

18:43.520 --> 18:46.520
Wir haben gegen, wie hießen die, LG Red oder so, glaube ich, gewonnen damals.

18:46.520 --> 18:48.520
Die waren sogar auf der ersten Offline-Lade.

18:48.520 --> 18:51.520
Die ist die in Deutschland nie gegeben hat, zu Overwatch eingeladen.

18:51.520 --> 18:56.520
Und wir haben damals ganz gut gespielt gegen dieses russische Team von Kula und Cypher.

18:56.520 --> 18:59.520
Da haben wir auch ein paar Matches gewonnen.

18:59.520 --> 19:01.520
Wir waren ganz okay.

19:01.520 --> 19:03.520
Mittlerweile habe ich keinen Plan mehr von dem Game.

19:03.520 --> 19:05.520
Deswegen werde ich jetzt einfach das nehmen.

19:05.520 --> 19:09.520
Da ich ja eigentlich nicht zocke, habe ich auch kein wirkliches Gaming-Setup am Start.

19:09.520 --> 19:12.520
Wobei man halt sagen muss, das muss ich jetzt noch kurz loswerden,

19:12.520 --> 19:20.520
ich finde es gut, dass er Overwatch nimmt, weil Overwatch, da gehört halt ein bisschen mehr dazu als nur Aim.

19:20.520 --> 19:26.520
Also, das ist jetzt nicht so das krasseste Mechanics-Game.

19:26.520 --> 19:29.520
Es gibt wenige so pure Aim-Skill-Hellen.

19:29.520 --> 19:32.520
Man, du hast natürlich sowas wie Widowmaker oder McCree oder...

19:32.520 --> 19:33.520
Nee, wie heißt der jetzt?

19:33.520 --> 19:34.520
Cassidy.

19:34.520 --> 19:37.520
Zum Teil auch sowas wie Soldier als Ana mit Support.

19:37.520 --> 19:39.520
Und er muss schon aim, so ist das nicht.

19:39.520 --> 19:46.520
Aber es gibt halt auch viele, sagen wir mal, so recht ausfrauenfreundlich.

19:46.520 --> 19:48.520
Das darf man wahrscheinlich so nicht sagen.

19:48.520 --> 19:50.520
Ja, Presarif, ich warte auf dich.

19:50.520 --> 19:53.520
Ich habe gesagt, wir können das.NET-Video gucken, wenn du da bist.

19:53.520 --> 19:57.520
Ja, also es gibt schon auch recht einsteigerfreundliche Helden, wo man sich das alles so ein bisschen angucken kann.

19:57.520 --> 20:00.520
Ich meine, das Mercy-Meme ist real.

20:00.520 --> 20:03.520
Das ist aber in Overwatch tatsächlich ganz gut.

20:03.520 --> 20:07.520
Wenn du in CS tatsächlich gar nichts auf die Reihe kriegst, nicht gerade ausschießen kannst,

20:07.520 --> 20:10.520
dann ist es egal, was du spielst, du kriegst nur noch auf den Sack permanent.

20:10.520 --> 20:14.520
In Overwatch kannst du quasi Mercy spielen und der Nase bohren dabei.

20:14.520 --> 20:19.520
Das funktioniert und ein bisschen nur das Spiel und den Spielfluss angucken, dass es nicht verkehrt.

20:19.520 --> 20:21.520
Deswegen ist es ganz gut, dass er Overwatch nimmt.

20:21.520 --> 20:22.520
Ja.

20:22.520 --> 20:27.520
Und Overwatch ist halt auch ein Game, da kommt sehr viel auf Spielverständnis, Map-Kenntnis

20:27.520 --> 20:31.520
und, sagen wir mal, sowas wie Intuition irgendwie an.

20:31.520 --> 20:34.520
Ich möchte mich an dieser Stelle bei MSI bedanken.

20:34.520 --> 20:37.520
Ah, Placement, sehr laut Modus.

20:37.520 --> 20:40.520
Aber gut, easy Placement muss sein.

20:40.520 --> 20:44.520
Auf dem MSI Katana GF66 spielen, das ist ein kompakter Gaming Laptop.

20:44.520 --> 20:47.520
Muss gucken, wo man bleibt.

20:47.520 --> 20:53.520
Das heißt, einer GeForce RTX 3060 Grafikkarte von Nvidia, einem Intel Core i7 Prozessor

20:53.520 --> 20:57.520
und einem 144-Hertz-Bildschirm mit 15,6 Zoll.

20:57.520 --> 20:59.520
Das Katana gibt es aber auch in vielen anderen Ausstattungen.

20:59.520 --> 21:01.520
Wie viel?

21:01.520 --> 21:03.520
Wie viel Herz hat denn das Display?

21:03.520 --> 21:05.520
144, okay.

21:05.520 --> 21:07.520
Ja, da kann man definitiv drauf spielen, denke ich.

21:07.520 --> 21:14.520
Der neuesten Generation und je nach Konfiguration von knapp unter 1000 Euro bis circa 1800 Euro.

21:14.520 --> 21:15.520
Da ist was für alle Ansprüche dabei.

21:15.520 --> 21:18.520
Die aktuell besten Deals habe ich euch in der Videobeschreibung verlinkt.

21:18.520 --> 21:21.520
Damit sollte ich jetzt auf jeden Fall von überall aus bequem zocken können.

21:21.520 --> 21:24.520
Und ich bin mega gespannt, das Ganze jetzt einfach mal auszuprobieren.

21:24.520 --> 21:27.520
Ich werde jetzt das allererste Mal Overwatch 2 spielen.

21:27.520 --> 21:31.520
Ich habe schon so lange keinen Shooter mehr gespielt.

21:31.520 --> 21:34.520
Deswegen bin ich sehr gespannt, wie ich mich da schlagen werde.

21:34.520 --> 21:35.520
Ja, let's go.

21:35.520 --> 21:37.520
Okay, was muss ich jetzt machen?

21:37.520 --> 21:40.520
So geht es jedem am Anfang.

21:40.520 --> 21:42.520
Spielt er mit dem Trackpad?

21:42.520 --> 21:43.520
Nee, oder?

21:43.520 --> 21:47.520
Er spielt schon mit einer Maus.

21:47.520 --> 21:49.520
Ja, geil.

21:49.520 --> 21:52.520
Hey Leute, so geht es jedem am Anfang.

21:52.520 --> 21:54.520
Ich bin immer sehr schnell zu sterben.

21:54.520 --> 21:58.520
Aber ich weiß auch ehrlich gesagt noch gar nicht so richtig, wie dieses Spiel funktioniert.

21:58.520 --> 22:02.520
Okay, also mein Team hat offensichtlich verloren.

22:02.520 --> 22:06.520
Ob er jetzt so viel glücklicher ist, nachdem er gespielt hat?

22:06.520 --> 22:07.520
An mir.

22:07.520 --> 22:09.520
Hier sind die Statistiken von meinem ersten Spiel.

22:09.520 --> 22:13.520
Ich bin insgesamt fünfmal gestorben und habe niemanden eliminiert.

22:13.520 --> 22:16.520
Ich glaube, das ist jetzt schon mal nicht so ganz gut.

22:16.520 --> 22:19.520
Also wenn ich da jetzt nicht in einer Woche besser werde, dann weiß ich auch nicht.

22:19.520 --> 22:23.520
Noch kann ich mir ehrlich gesagt nicht so richtig vorstellen, warum zocken so viele Vorteile haben soll.

22:23.520 --> 22:25.520
Und um mehr darüber zu erfahren.

22:25.520 --> 22:29.520
Jax, hast du die Grafik-Settings gesehen? Der muss auf jeden Fall runter stellen.

22:29.520 --> 22:30.520
Das ist auch ein Ding.

22:30.520 --> 22:35.520
Das erste, was du machen musst, wenn du nur daran denken willst, halbwegs competitive zu spielen.

22:35.520 --> 22:41.520
Settings runter bis bodenlos und dann auch ein Stück weiter runter.

22:41.520 --> 22:44.520
Quasi noch zwei Level unter bodenlosen Grafik-Settings.

22:44.520 --> 22:47.520
Das muss komplett unten sein.

22:49.520 --> 22:53.520
Am besten noch die Konfig von Hand anpassen.

22:53.520 --> 22:56.520
Dass es noch schlechter aussieht.

22:56.520 --> 22:59.520
Und das ist gut. Das ist gerade richtig.

23:00.520 --> 23:02.520
Dr. Jens Junge verabredet.

23:02.520 --> 23:05.520
Das ist der Leiter des Instituts für Ludologie in Berlin.

23:05.520 --> 23:08.520
What? Institut für was?

23:08.520 --> 23:10.520
Er beschäftigt sich wissenschaftlich mit Spielen.

23:10.520 --> 23:13.520
Was würdest du sagen, welche Vorteile haben Videospiele?

23:13.520 --> 23:15.520
Wir haben ja ganz viele Vorteile.

23:15.520 --> 23:18.520
Fangen wir mal damit an, dass sie uns grundsätzlich erfreuen.

23:18.520 --> 23:20.520
Dass sie uns unterhalten, dass sie Spaß bringen.

23:20.520 --> 23:23.520
Neben dem Spaß ist es auch natürlich das Abenteuer.

23:23.520 --> 23:27.520
Die Herausforderung und die Anstrengung, die uns immer an die Grenzen bringt.

23:27.520 --> 23:31.520
Was lernt man denn vielleicht für Fähigkeiten beim Zocken, die man auch so auf das echte Leben übertragen kann?

23:31.520 --> 23:33.520
Teamwork. Teamwork.

23:33.520 --> 23:38.520
Beispiele heraus, dass wenn ich am PC spiele, ich dem irgendwie konfigurieren muss.

23:38.520 --> 23:39.520
Dass ich weiß, was da passiert.

23:39.520 --> 23:45.520
Ich habe ein technisches Grundverständnis, was mich eben auch um einen zukünftigen Beruf an so einer Kiste vorbereitet.

23:45.520 --> 23:51.520
Ich bin, wenn ich dann mit Multiplayer Games unterwegs bin, oft eben mit Teams in der Interaktion.

23:51.520 --> 23:54.520
Ich muss die anderen Rollen kennen. Ich muss halt bereit sein.

23:54.520 --> 23:58.520
Das ist aber ohne Scheiß. Das ist wirklich so. Man merkt das richtig.

23:58.520 --> 24:03.520
Gerade jetzt in der Zeit, wo alle im Homeoffice arbeiten, du merkst das sofort.

24:03.520 --> 24:09.520
Leute mit MMO und Raid-Erfahrung, die können es einfach. Mit denen funktioniert das.

24:09.520 --> 24:12.520
Die wissen, wie man einen Chat bedient. Die wissen Push to Talk.

24:12.520 --> 24:19.520
Leute, der 0815 am PC sitzt Boomer, der sein Mikrofon halb im Popper stecken hat.

24:19.520 --> 24:21.520
Der weiß noch nicht mal, was Push to Talk ist.

24:21.520 --> 24:26.520
Geschweige denn, dass er das irgendwie auf die Reihe kriegt, sich zu muten, wenn im Hintergrund gerade die Frau staubsaugt oder sowas.

24:26.520 --> 24:27.520
Kannste komplett knicken.

24:27.520 --> 24:31.520
Leute mit MMO und Raid-Erfahrung, das sind im Homeoffice die besten Arbeiter.

24:31.520 --> 24:35.520
Du kannst mit denen wunderbar kommunizieren. Die wissen, wie sie was im Chat schreiben müssen.

24:35.520 --> 24:36.520
Die schreiben dann nicht.

24:36.520 --> 24:41.520
Sehr geehrte Damen und Herren, seit gestern nach zwölf gibt es Probleme im System.

24:41.520 --> 24:47.520
Bitte schnellstmöglich die Entstörung einleiten. Mit freundlichen Grüßen ihre Support-Abteilung.

24:47.520 --> 24:52.520
Das schreiben nur die Leute, die keinen Plan haben, wie man online zusammenarbeitet.

24:52.520 --> 25:00.520
Leute mit MMO und Raid-Erfahrung, die sagen, Max bist du gerade da, guck mal please auf System ABC.

25:00.520 --> 25:03.520
Da geht was nicht. Fertig.

25:03.520 --> 25:06.520
Da sag ich, ah ok, ich guck schnell.

25:06.520 --> 25:11.520
Das ist einfach riesen Unterschied wie Tag und Nacht, Leute.

25:11.520 --> 25:14.520
Glaubt's mir. Ich merke das täglich.

25:14.520 --> 25:25.520
Leute, die MMO und Multiplayer generell Teamplay-Erfahrung haben, am Computer mit Online-Spielen, ist wie Tag und Nacht der Unterschied.

25:25.520 --> 25:28.520
Ok, warte mal. Das hab ich vergessen, wo wir aufgehört haben. Wir sind immer stehen geblieben.

25:28.520 --> 25:34.520
Ich muss halt bereit sein, mit einem Trainer zusammenzuarbeiten, mich anzupassen, mein Verhalten zu variieren,

25:34.520 --> 25:39.520
sodass ich in dem Team auch gut funktionieren kann. In jeder Stellenbeschreibung steht heute Teamfähigkeit drin.

25:39.520 --> 25:44.520
Dann haben wir natürlich noch die individuellen persönlichen Skills, dass ich natürlich durch Hand-Auge-Koordination,

25:44.520 --> 25:51.520
durch Reaktionsmöglichkeiten im Spiel auch einfach Fähigkeiten bekomme, die mich auch natürlich für andere Softwareprodukte

25:51.520 --> 25:57.520
oder für andere Sportarten schulen und trainieren. Es gibt eine wunderbare Studie für Counter-Strike,

25:57.520 --> 26:04.520
zum Beispiel das Chirurgen, die dann, bevor sie in eine richtige OP gegangen sind...

26:04.520 --> 26:09.520
Alter, erst mal Rush B. Rush B. im OP.

26:09.520 --> 26:15.520
Die sollen lieber Battlefield spielen, ein paar Leute wieder beleben. Rush B.

26:15.520 --> 26:23.520
...viel, viel besser operieren können. Die nehmen halt diese Hochkonzentrationsphase direkt in den OP mit und sind dann besser.

26:23.520 --> 26:26.520
Bevor ich mit dem Selbstexperiment loslege, werde ich jetzt noch ein paar Tests machen,

26:26.520 --> 26:30.520
um meine Skills zu überprüfen und das Ganze werde ich hinterher nochmal machen.

26:30.520 --> 26:32.520
Dann schauen wir mal, ob ich besser geworden bin.

26:32.520 --> 26:36.520
Ich bin jetzt mit meinem Team verabredet und wir haben vor, einfach mal ein bisschen zusammen zu zocken.

26:36.520 --> 26:40.520
Das macht, glaube ich, schon ein bisschen mehr Spaß, wenn man dabei noch ein bisschen quatschen kann,

26:40.520 --> 26:44.520
als wenn ich hier nur alleine sitze. Ich bin gespannt, wie es wird.

26:44.520 --> 26:48.520
Übrigens finde ich nicht sinnig, direkt am Anfang mit dem Team zu spielen.

26:48.520 --> 26:55.520
Gerade wenn man noch komplett die Basics lernen muss, dann fackt ein eher das Gelaber ab der anderen Leute.

26:55.520 --> 27:01.520
Vor allem, wenn man verliert, dann sind die Leute alle mega tilted und man lernt nichts und fackt sich gegenseitig ab.

27:01.520 --> 27:08.520
Wenn man wirklich noch, wie war das, wenn man die Basics lernen muss, damit man auf den Mold Everest kommt,

27:08.520 --> 27:11.520
dann macht man das erst mal am besten solo. Finde ich.

27:11.520 --> 27:15.520
Die Basics im Spiel am besten erst mal solo lernen. Das ist meine Meinung dazu.

27:15.520 --> 27:17.520
Sehr gut.

27:19.520 --> 27:21.520
Scheiße.

27:22.520 --> 27:23.520
Was ist denn heute los?

27:23.520 --> 27:26.520
Siehst du, die sind komplett alle tilted direkt.

27:26.520 --> 27:28.520
Das darf nicht wahr sein.

27:28.520 --> 27:30.520
Der hat nichts gelernt, nichts gelernt in der Zeit.

27:30.520 --> 27:34.520
Ich habe gerade eine Stunde Overwatch gespielt und ich habe einfach eine Stunde lang am Stück verloren.

27:34.520 --> 27:39.520
Jedes Spiel nur verloren mit unserem Team. Das ist schon ziemlich frustrierend.

27:39.520 --> 27:41.520
Mann ey, das habe ich keinen Bock mehr.

27:41.520 --> 27:43.520
Verstehe, ist normal.

27:43.520 --> 27:49.520
Ich habe das Gefühl, ich stelle mich ja gar nicht super kacke an, aber irgendwie funktioniert es trotzdem noch nicht so richtig.

27:49.520 --> 27:50.520
Salty.

27:50.520 --> 27:53.520
Deswegen habe ich mir professionelle Unterstützung gesucht.

27:53.520 --> 27:55.520
Leute, aber abgefuckt sein ist vollkommen normal.

27:55.520 --> 27:59.520
Ach guck mal, da ist ja der Sascha. Abgefuckt sein ist da vollkommen normal.

27:59.520 --> 28:05.520
Ich bin auch immer gerne mal mega tilted und flamet an Runden, wenn es irgendwie nicht so läuft.

28:05.520 --> 28:07.520
Aber ey, das ist normal.

28:07.520 --> 28:10.520
Deswegen am Anfang die Basics alleine lernen, bin ich der Meinung.

28:10.520 --> 28:16.520
Ich habe mit Sascha verabredet. Der macht auf seinem YouTube-Kanal Highscore Heroes hauptsächlich Content rund um Overwatch.

28:16.520 --> 28:18.520
Das heißt, er kennt sich mega gut mit dem Spiel aus.

28:18.520 --> 28:22.520
Und ich hoffe einfach, dass er den einen oder anderen Tipp für mich hat, damit ich besser werden kann.

28:22.520 --> 28:24.520
Sascha, seit wann spielst du Overwatch?

28:24.520 --> 28:28.520
Ich spiele seit, ich glaube Release war 2016. Ich spiele eigentlich jeden Tag.

28:28.520 --> 28:32.520
Ich ertappe mich dann schon mal wieder, wie ich abends so mal drei, vier Stunden mit Freunden spiele.

28:32.520 --> 28:36.520
Jetzt will ich ja gucken, wie gut ich innerhalb von einer Woche werden kann.

28:36.520 --> 28:43.520
Dazu musst du erst mal sechs bis acht Stunden am besten mehr am Tag den krassen Kreiselcrime starten. Sonst wird das nichts.

28:43.520 --> 28:48.520
Glaubst du, es ist in einer Woche möglich, nur annähernd so gut wie du zu werden?

28:48.520 --> 28:51.520
Es kommt so viel dazu, was wichtiger ist als reines Aim.

28:51.520 --> 28:55.520
Aber ich bin mir sicher, du kannst da relativ gute Fortschritte innerhalb von einer Woche machen.

28:55.520 --> 28:58.520
Okay, cool. Was würdest du sagen, wie kann ich mich verbessern?

28:58.520 --> 29:00.520
Also kannst du mir da irgendwelche Tipps geben für das Spiel?

29:00.520 --> 29:02.520
Wir können gerne mal eine Runde reingehen.

29:02.520 --> 29:07.520
Übrigens, ich finde es gut, ich finde es gut. Ich wette mit euch, wir gucken uns gleich mal die Kommentare an.

29:07.520 --> 29:11.520
Ich wette mit euch, da kommen wieder die super angepissten Leute.

29:11.520 --> 29:15.520
Und ich dachte, Sascha ist doch nur, weiß ich was, er ist Master oder so.

29:15.520 --> 29:18.520
Hättest du mal einen richtig guten Spieler genommen oder irgendwie sowas?

29:18.520 --> 29:21.520
Vollkommen egal. Er ist komplett neu in dem Game.

29:21.520 --> 29:27.520
Und man muss ihm wirklich mal ein bisschen die ganz grundlegenden Sachen coachen und erklären.

29:27.520 --> 29:31.520
Da brauchst du keinen Pro, der ihm krass advances Zeug erzählt.

29:31.520 --> 29:37.520
Deswegen ist es gut, dass er ihn genommen hat und nicht wirklich einen richtig Top Ten Spieler oder sowas,

29:37.520 --> 29:41.520
für sowas in Deutschland überhaupt gerade haben, der ihm dann sonst was erzählt.

29:41.520 --> 29:45.520
Ich glaube, da kann er es nämlich deutlich besser als ein richtiger Pro.

29:45.520 --> 29:48.520
Die Kommentare sind voll, das dachte ich mir.

29:48.520 --> 29:52.520
Leute, ich kenne die Jungs doch in den YouTube Kommentaren.

29:52.520 --> 29:55.520
Wir gucken gleich mal rein dann.

29:55.520 --> 29:58.520
Ich mache den Supporter. Grundsätzlich sollten wir immer beim Team bleiben.

29:58.520 --> 30:03.520
Für uns gerade zählt, dass du einfach positionell ein bisschen vielleicht besser wirst.

30:03.520 --> 30:06.520
Immer in Bewegung bleiben, auch eine ganz wichtige Sache.

30:06.520 --> 30:09.520
Im besten Fall so ein bisschen die Bewegung.

30:09.520 --> 30:11.520
Leute, ich habe es schon wieder vergessen.

30:11.520 --> 30:14.520
Ich kenne die Map. Ich habe die Map-Namen schon wieder vergessen.

30:14.520 --> 30:20.520
Ich habe das fast ein Jahr jeden Tag durchgegrindet.

30:20.520 --> 30:23.520
Das ist dieses Tempel-Ding.

30:23.520 --> 30:27.520
Nepal! Jawoll, Nepal.

30:27.520 --> 30:30.520
Das ist der zweite Punkt.

30:30.520 --> 30:34.520
Der erste ist innen drinnen oder ist der dritte?

30:34.520 --> 30:37.520
Nee, der dritte ist innen.

30:37.520 --> 30:42.520
Der erste ist Outdoor, da wo man rechts runterfallen kann.

30:42.520 --> 30:44.520
Das hier ist der zweite.

30:44.520 --> 30:47.520
Und dann kommt in dem Tempel innen drin, in der Mitte.

30:47.520 --> 30:50.520
Oder? Ich weiß gar nicht mehr genau.

30:50.520 --> 30:53.520
Schon so lange her.

30:57.520 --> 30:59.520
Jetzt gehen wir hierher.

30:59.520 --> 31:01.520
Hier oben haben wir High Ground.

31:01.520 --> 31:04.520
Hier oben kannst du deutlich besser Schaden machen.

31:04.520 --> 31:06.520
Du siehst deutlich besser, wo deine Gegner sind.

31:06.520 --> 31:10.520
Im besten Fall suchst du dir immer die kleinen Ziele.

31:10.520 --> 31:12.520
Zum Beispiel die Heiler.

31:12.520 --> 31:14.520
Als Soldier, ganz wichtig.

31:14.520 --> 31:16.520
Wisst ihr, was er als Soldier machen muss?

31:16.520 --> 31:26.520
Er muss komplett, keine Ahnung, wie als hätte er sich was gespritzt,

31:26.520 --> 31:28.520
muss er AD AD spammen, Leute.

31:28.520 --> 31:32.520
AD AD spammen, das allerwichtigste in Overwatch.

31:32.520 --> 31:37.520
Ihr müsst einfach komplett hirnlos die ganze Zeit AD AD spammen.

31:37.520 --> 31:40.520
Und gerade als Soldier, wie von der Tarantel gestochen, genau.

31:40.520 --> 31:43.520
AD AD spammen.

31:43.520 --> 31:51.520
Und crouchen, und crouchen, nicht vergessen, ja.

31:51.520 --> 31:54.520
Das sind Teamfights zu gewinnen, weil die keine Heilung mehr haben.

31:54.520 --> 31:55.520
Ja, cool.

31:55.520 --> 31:57.520
Was würdest du sagen, wie habe ich mich bisher geschlagen?

31:57.520 --> 32:01.520
Was dir noch aktuell fehlt, ist einfach zu wissen, wo Gegner herkommen.

32:01.520 --> 32:02.520
Einfach mal umdrehen.

32:02.520 --> 32:05.520
Das ist ein Fehler, den machen super viele Overwatch-Spieler, die neu sind.

32:05.520 --> 32:07.520
Wie gesagt, das ist dein zweiter Tag oder sowas.

32:07.520 --> 32:11.520
Dahingehend würde ich da jetzt gar nicht zu hart urteilen.

32:11.520 --> 32:15.520
Du hast gesehen, du hast einige Leute hier und da dann auch wirklich bedrängt mit deinen Schüsten.

32:15.520 --> 32:16.520
Das ist, glaube ich, ganz gut.

32:16.520 --> 32:18.520
Also so ein grundlegendes Aim ist da.

32:18.520 --> 32:22.520
Es ist so viel Content in diesem Spiel einfach schon drin, den du noch nicht kennst.

32:22.520 --> 32:24.520
Ja, gerade die Maps.

32:24.520 --> 32:29.520
Aber glücklicherweise muss man ehrlich sagen, die Overwatch-Maps sind eigentlich ziemlich simpel zum größten Teil.

32:29.520 --> 32:31.520
Schwieriger für dich.

32:31.520 --> 32:36.520
Weil Blizzard ja die Wahnsinnseingebung hatte.

32:36.520 --> 32:43.520
Chokepoint-lastiges Map-Design ist das einzige, was geht für das Game.

32:43.520 --> 32:46.520
Heute werde ich einfach weitermachen und intensiv zocken.

32:46.520 --> 32:49.520
Also ich glaube, ich brauche einfach super viel Training, um besser zu werden.

32:49.520 --> 32:50.520
Das ist richtig.

32:50.520 --> 32:54.520
Das ist richtig.

32:54.520 --> 32:55.520
Das ist doch gut.

32:55.520 --> 32:58.520
Wenn du keinen Bock hast auf sowas, dann klappt es auch nicht.

32:58.520 --> 33:08.520
Ein bisschen ist das vielleicht so.

33:08.520 --> 33:09.520
Ja, gewonnen.

33:09.520 --> 33:11.520
Und jetzt, Moment.

33:11.520 --> 33:15.520
Er hat eine Sache, hat er noch nicht gelernt.

33:15.520 --> 33:22.520
Wenn du gewinnst und umso knapper es war, umso mehr musst du da schreiben, GG Eats.

33:22.520 --> 33:26.520
Also wenn du wirklich nur 1% oder so gewonnen hast, GG Eats.

33:26.520 --> 33:29.520
Es ist prinzipiell, wenn du gewinnst, immer GG Eats.

33:29.520 --> 33:33.520
Aber umso knapper es war, umso easier war das.

33:33.520 --> 33:37.520
Also umso knapper, dann ist es easiest Game of my life.

33:37.520 --> 33:39.520
Das ist das Aller-easieste, umso knapper es ist.

33:39.520 --> 33:43.520
Und wenn du verlierst, kannst du die Gegner beleidigen.

33:43.520 --> 33:50.520
Also von Hacker bis was auch immer, kann man sich irgendwas ausdenken.

33:50.520 --> 33:53.520
Aber prinzipiell, wenn du gewinnst, GG Eats.

33:53.520 --> 33:56.520
Und das muss er als angehender Pro-Gamer auf jeden Fall noch lernen.

33:56.520 --> 33:59.520
Ich habe echt das Gefühl, es wird immer besser.

33:59.520 --> 34:06.520
Naja, wisst ihr warum er jetzt was killt?

34:06.520 --> 34:07.520
Ist ganz einfach.

34:07.520 --> 34:11.520
Erstens, natürlich ist er besser geworden in den paar Tagen.

34:11.520 --> 34:14.520
Ja, mit Sicherheit, er gibt sich ja auch Mühe und strengt sich an.

34:14.520 --> 34:16.520
Wurde ein bisschen gecoacht, definitiv ist er besser geworden.

34:16.520 --> 34:19.520
Aber SBMM, Leute.

34:19.520 --> 34:21.520
Das ist der Hauptpunkt.

34:21.520 --> 34:24.520
Ja, er ist besser geworden, aber SBMM.

34:24.520 --> 34:28.520
Weil auch im Quickplay, das Game hat ihn jetzt ungefähr eingerankt.

34:28.520 --> 34:29.520
Nach 2-3 Tagen.

34:29.520 --> 34:35.520
Das Game weiß jetzt ungefähr so grob, in welches Skillbracket sie ihn stecken können.

34:35.520 --> 34:41.520
Und dementsprechend kriegt er jetzt auch Leute gematcht, die auf ähnlichem Niveau spielen.

34:41.520 --> 34:48.520
Und dann gibt es nicht mal so mega auf den Sack wie die ersten 2 Tage.

34:48.520 --> 34:50.520
Noch jemanden getötet, ganz knapp.

34:50.520 --> 34:52.520
Aber währenddessen auch selber gestorben.

34:52.520 --> 34:54.520
5 Kills und 5 mal gestorben.

34:54.520 --> 34:59.520
So langsam habe ich schon das Gefühl, das Spiel zu verstehen und so leicht besser zu werden.

34:59.520 --> 35:01.520
Aber ich sterbe auch noch ziemlich oft.

35:01.520 --> 35:04.520
Und ich glaube, da ist noch sehr viel Luft nach oben.

35:04.520 --> 35:06.520
Also ich weiß nicht.

35:06.520 --> 35:08.520
Das Game ist jetzt ja auf 5 versus 5.

35:08.520 --> 35:09.520
Aber es macht Spaß.

35:09.520 --> 35:11.520
Und das ist ja eigentlich die Hauptsache.

35:11.520 --> 35:12.520
Was würdest du denn sagen?

35:12.520 --> 35:14.520
Das ist auf 5 versus 5 jetzt.

35:14.520 --> 35:17.520
Die haben das doch umgestellt mit dem Release von Overwatch 2.

35:17.520 --> 35:20.520
Wenn ich das richtig im Kopf habe.

35:20.520 --> 35:22.520
Also wie gesagt, Leute, ich habe keinen Plan von Overwatch 2.

35:22.520 --> 35:24.520
Ich habe Overwatch 2 nicht gespielt.

35:24.520 --> 35:32.520
Das Einzige, was ich in Streams gesehen habe, was mir aufgefallen ist, als jemand, der mal ganz brauchbar Overwatch 1 gespielt hat.

35:32.520 --> 35:35.520
Mir kam das alles ein bisschen langsamer.

35:35.520 --> 35:41.520
Und mir fällt jetzt kein gescheit deutsches Wort.

35:41.520 --> 35:45.520
Also ein bisschen mehr Bullet-Sponge-mäßig vor.

35:45.520 --> 35:47.520
Also ich habe beispielsweise einen Stream gesehen.

35:47.520 --> 35:53.520
Da ist einer mit Reaper auf diesen neuen Tank.

35:53.520 --> 35:56.520
Was ist das? Junker Queen ist das, glaube ich.

35:56.520 --> 36:01.520
Alter, der hat zweimal nachladen müssen, bis der Tank down war.

36:01.520 --> 36:03.520
Okay, entweder hat der Typ einfach nicht getroffen.

36:03.520 --> 36:05.520
Aber ich habe es ja gesehen.

36:05.520 --> 36:07.520
Und das war auch ein guter Spieler.

36:07.520 --> 36:09.520
Also es kam mir so vor, als ist das Spiel Träger.

36:09.520 --> 36:17.520
Und ein bisschen mehr Health und Helden halten mehr aus.

36:17.520 --> 36:22.520
Ein bisschen stationärer, könnte man vielleicht sagen.

36:22.520 --> 36:25.520
Gewonnen im Vergleich zu 1.

36:25.520 --> 36:26.520
Schwer zu sagen.

36:26.520 --> 36:27.520
Ich habe keine Ahnung von Overwatch 2.

36:27.520 --> 36:28.520
Ich habe es nicht gespielt.

36:28.520 --> 36:31.520
Ich habe eigentlich keinen Bock drauf.

36:31.520 --> 36:34.520
Was passiert mit uns, wenn wir Videospiele spielen?

36:34.520 --> 36:37.520
Wir sind dort in einer anderen Realität.

36:37.520 --> 36:41.520
Und blenden alle anderen Dinge um uns herum aus.

36:41.520 --> 36:43.520
Das war eine blöde Frage.

36:43.520 --> 36:47.520
Was genau hat der Psycho-Dude jetzt mit Progamer werden zu tun?

36:47.520 --> 36:50.520
Das ist doch ein komplett anderes Thema.

36:50.520 --> 36:53.520
Ich sage nicht, dass es nicht stimmt oder so.

36:53.520 --> 36:55.520
Und das ist sicherlich auch Fragen, die man sich stellen kann.

36:55.520 --> 36:58.520
Aber was hat er mit Progamer werden uns relativ wenig zu tun.

36:58.520 --> 37:00.520
Das ist eine künstliche Herausforderung,

37:00.520 --> 37:03.520
auf die wir uns so derartig fokussieren,

37:03.520 --> 37:06.520
dass wir alle Probleme und Sorgen gerne ignorieren.

37:06.520 --> 37:07.520
Das brauchen wir Menschen.

37:07.520 --> 37:10.520
Wir müssen halt, und das machen andere Menschen halt auch dadurch,

37:10.520 --> 37:13.520
dass sie vielleicht nur eine Stunde durch den Wald jocken.

37:13.520 --> 37:18.520
Wir machen es immer wieder, dass wir uns einen Zeitraum suchen,

37:18.520 --> 37:21.520
indem wir eben was anderes tun, als eben nur zu malochen.

37:21.520 --> 37:24.520
Was würdest du denn sagen, wann wird spielen problematisch?

37:24.520 --> 37:31.520
Wenn man sein ganzes Erspartes in Microtransactions steckt

37:31.520 --> 37:38.520
oder sein ganzes Erspartes an irgendwelche Pool-Streamer raushaut auf Twitch

37:38.520 --> 37:43.520
oder wie dieser eine Typ früher bei der in irgendwelchen Dota-Streams

37:43.520 --> 37:46.520
und damals Overwatch-Streams, da gab es einen Typ,

37:46.520 --> 37:49.520
ich habe den Namen vergessen, wir müssen mal nachgeben, wie der heißt.

37:49.520 --> 37:54.520
Das war irgendwie einer, der hat gesagt, der ist irgendwie ein reicher Saudi oder so

37:54.520 --> 37:58.520
und hat überall massig getippt und gespendet und sonst was.

37:58.520 --> 38:01.520
Und am Ende kam raus, das ist irgendein Ami,

38:01.520 --> 38:08.520
der sein komplettes Erspartes quasi in so eine Fake-Twitch-Identität gesteckt hat.

38:08.520 --> 38:09.520
Noch nicht mal als Streamer selbst.

38:09.520 --> 38:13.520
Der hat quasi sein ganzes Vermögen gespendet an Streamer

38:13.520 --> 38:17.520
und hat sich dafür feiern lassen, dass er so ein Gönner ist

38:17.520 --> 38:21.520
und hat im Prinzip sein ganzes Vermögen rausgehauen, hat dann sein Haus verloren,

38:21.520 --> 38:25.520
hat, ich weiß nicht, ob ihn die Frau verlassen hat,

38:25.520 --> 38:29.520
sogar seine Versicherung und alles geplündert und so,

38:29.520 --> 38:32.520
nur dass er auf Twitch donaten kann, meine Güte.

38:32.520 --> 38:34.520
Dann hast du echt die Kontrolle verloren.

38:37.520 --> 38:40.520
Apropos mit deinem Wandern, wirst du das auch im Winter durchziehen?

38:40.520 --> 38:43.520
Ich bin quasi seit März täglich Fahrradkann, habe auch viel Gewicht verloren.

38:43.520 --> 38:45.520
Ja, mache ich, ich bin heute auch wieder zwei Stunden gelaufen.

38:45.520 --> 38:50.520
Ich auch die realen Herausforderungen des Lebens komplett vernachlässigen.

38:50.520 --> 38:54.520
Wir werden halt als Menschen immer danach halt auch suchende Balance hinzukriegen.

38:54.520 --> 38:56.520
Wir wissen ja, was uns gut tut.

38:56.520 --> 38:58.520
Und das nennt man dann auch die Kontrolle, die man halt hat

38:58.520 --> 39:02.520
und diese Kontrollüberzeugung, die man halt hat, dass man das im Griff hat.

39:02.520 --> 39:06.520
Deswegen ist es viel besser, wenn wir gerade dabei sind, deswegen ist es viel besser,

39:06.520 --> 39:09.520
anstatt irgendwie großartig zu donaten oder sonst was,

39:09.520 --> 39:13.520
wenn man einen Twitch Prime-Sub hat, den auch einmal im Monat zu verwenden

39:13.520 --> 39:15.520
und nicht vergammeln zu lassen.

39:15.520 --> 39:17.520
Ist so wichtig für unser Leben.

39:17.520 --> 39:21.520
Und solange wir alles unter Kontrolle haben, dann passt es.

39:21.520 --> 39:26.520
Und es ist eine wunderbare Ergänzung und Bestärkung des echten Lebens.

39:26.520 --> 39:29.520
So, letzter Tag, ich gehe einfach sofort und spiele.

39:29.520 --> 39:30.520
Let's go.

39:33.520 --> 39:35.520
Oh, aber trifft schon deutlich besser als am Anfang.

39:38.520 --> 39:40.520
Ich darf ja nichts sagen.

39:40.520 --> 39:43.520
Ihr habt in meinem Pepega-Aim die letzten zwei Tage gesehen.

39:43.520 --> 39:48.520
Ich darf da nichts sagen, aber das ist schon echt ganz brauchbar jetzt im Vergleich zum ersten.

39:48.520 --> 39:50.520
Am ersten Tag war ja gar nichts.

39:50.520 --> 39:53.520
Am ersten Tag war ja, wo man hier gesehen hat,

39:53.520 --> 39:57.520
da hatte ich den Eindruck, er hat quasi seine Sensitivity auf 1% gestellt.

39:57.520 --> 39:59.520
Das hat sich kaum das Fadenkreuz bewegt.

39:59.520 --> 40:01.520
Aber jetzt hat er ja schon so ein bisschen was wie,

40:01.520 --> 40:04.520
so ein bisschen was wie Tracking, könnte man es schon nennen.

40:04.520 --> 40:06.520
Also ist schon in Ordnung.

40:06.520 --> 40:10.520
Boah, man, das geht doch klar jetzt mittlerweile.

40:10.520 --> 40:14.520
Richtig, ich habe das Gefühl, dass mein Spielverständnis einfach deutlich besser geworden ist.

40:14.520 --> 40:16.520
Das ist auch wichtig in Overwatch.

40:16.520 --> 40:21.520
Ich setze mich jetzt von Sascha um und achte voll darauf, wo ich in der Map stehe, welche Ziele ich groß wähle.

40:21.520 --> 40:24.520
Und ich ziehe mich auch mal zurück, wenn mein Team gerade nicht da ist.

40:24.520 --> 40:26.520
Und ich muss sagen, es macht einfach immer mehr Spaß.

40:26.520 --> 40:30.520
Also ich denke auch so voll viel über Overwatch nach, selbst wenn ich gerade nicht spiele.

40:30.520 --> 40:32.520
Das ist schon ein bisschen verrückt.

40:32.520 --> 40:35.520
Jetzt bin ich mega gespannt, ob es auch irgendwelche messbaren Ergebnisse gibt.

40:35.520 --> 40:39.520
Es ist jetzt genau eine Woche her, seitdem ich mit dem Experiment begonnen habe.

40:39.520 --> 40:40.520
Das heißt heute...

40:40.520 --> 40:42.520
Jetzt erst mal zum MLG Open Bracket anmelden.

40:42.520 --> 40:43.520
Auf geht's, in your face.

40:43.520 --> 40:44.520
Ach nee, ich vergaß.

40:44.520 --> 40:47.520
Es gibt ja keine offiziellen Turniere, außer die von Blizzard.

40:47.520 --> 40:49.520
Noch mal die ganzen Tests wiederholen.

40:49.520 --> 40:52.520
Und ich bin mega gespannt, ob sich tatsächlich irgendwas verbessert hat.

40:52.520 --> 40:53.520
Let's go.

40:53.520 --> 40:55.520
Tempelritter, danke schön für den Zap.

40:55.520 --> 40:58.520
Oh guck mal, Human Benchmark.

40:58.520 --> 41:01.520
Da bin ich gespannt, wie er abschneidet, Leute.

41:01.520 --> 41:02.520
Das habe ich nicht geguckt.

41:02.520 --> 41:03.520
Da bin ich gespannt.

41:03.520 --> 41:05.520
Also erinnert euch dran.

41:05.520 --> 41:12.520
Der Ultra-Boomer wie ich hat ungefähr 170 Millisekunden gehabt im Reaction-Test.

41:14.520 --> 41:17.520
229 Millisekunden.

41:17.520 --> 41:19.520
Dann als nächstes der Aim-Test.

41:19.520 --> 41:21.520
Bin sehr gespannt, ob ich mich da zumindest verbessern kann.

41:21.520 --> 41:24.520
Der muss besser sein als 230 Millisekunden.

41:24.520 --> 41:26.520
Das liegt am Notebook.

41:26.520 --> 41:28.520
Oder an irgendwas.

41:28.520 --> 41:31.520
Der muss besser sein als 230 Millisekunden.

41:31.520 --> 41:34.520
Das kann ich mir nicht vorstellen.

41:37.520 --> 41:39.520
Vielleicht eine kabellose Maus.

41:39.520 --> 41:41.520
Ich meine, ich habe auch eine kabellose Maus.

41:41.520 --> 41:43.520
Vielleicht eine alte kabellose Maus.

41:43.520 --> 41:45.520
Wobei es sah aus wie eine Razer-Maus.

41:45.520 --> 41:48.520
Am Anfang sah es nach einer brauchbaren Maus aus.

41:48.520 --> 41:49.520
Das kann nicht sein.

41:49.520 --> 41:52.520
Das glaube ich nicht, dass er 230 Millisekunden hat.

41:53.520 --> 41:55.520
Vielleicht hält er die Maus auch irgendwie komisch,

41:55.520 --> 41:58.520
dass er den Finger nicht schnell genug draufkriegt.

41:58.520 --> 41:59.520
Keine Ahnung.

41:59.520 --> 42:00.520
Das muss am Notebook liegen.

42:00.520 --> 42:03.520
Ich weiß, MSI Placement und sonst wie.

42:03.520 --> 42:05.520
By the way, MSI hat mich immer noch gebannt auf Twitter.

42:05.520 --> 42:06.520
Ich weiß bis heute nicht warum.

42:06.520 --> 42:08.520
Doch indirekt weiß ich warum.

42:08.520 --> 42:11.520
Weil ich habe mich über RGB auf eine Mainboard lustig gemacht.

42:11.520 --> 42:13.520
Und dann haben sie mich instant gebannt danach.

42:13.520 --> 42:15.520
Und bis jetzt wollten sie mich nicht mehr entblocken.

42:15.520 --> 42:18.520
Falls einer von MSI zuguckt, Leute.

42:18.520 --> 42:20.520
Ihr könnt mich ruhig anbannen auf Twitter.

42:20.520 --> 42:24.520
Ich werde nie wieder über eure RGB-Beleuchtung lästern.

42:25.520 --> 42:27.520
Vielleicht über eure LEDs.

42:27.520 --> 42:30.520
Aber ohne sonst was.

42:33.520 --> 42:34.520
Ah ja.

42:34.520 --> 42:37.520
Ich weiß echt nicht warum sie mich gebannt haben.

42:39.520 --> 42:41.520
Kann doch nicht sein.

42:41.520 --> 42:44.520
Dass man erst mal gebannt wird, weil man sich lustig macht über RGB-Beleuchtung.

42:44.520 --> 42:46.520
Gut, wie dem auch sei.

42:46.520 --> 42:49.520
Also 230 Millisekunden ist auf jeden Fall zu schlecht.

42:49.520 --> 42:51.520
Ich mache mich jetzt nicht über die RGB-Beleuchtung lustig.

42:51.520 --> 42:52.520
Ich mache mich höchstens über das Notebook lustig.

42:52.520 --> 42:54.520
Weil das muss am Notebook liegen.

42:54.520 --> 42:57.520
Er hat garantiert bessere Reactions.

42:57.520 --> 42:59.520
Als das.

43:00.520 --> 43:02.520
Liegt von aus.

43:08.520 --> 43:10.520
Aber QDL, ich habe 170.

43:10.520 --> 43:13.520
Ich bin 38.

43:13.520 --> 43:16.520
Er ist, keine Ahnung, 23.

43:19.520 --> 43:21.520
Der muss bessere Reaktionszeit haben.

43:21.520 --> 43:23.520
Also mindestens Reaktionszeit wie ich.

43:23.520 --> 43:25.520
Dann als nächstes der Aim-Test.

43:25.520 --> 43:27.520
Ich bin sehr gespannt.

43:27.520 --> 43:29.520
Aim-Test ist 100 pro besser geworden.

43:29.520 --> 43:31.520
Safe.

43:31.520 --> 43:34.520
Okay, mein Aim ist auf jeden Fall besser geworden.

43:34.520 --> 43:36.520
Hast du 170 im Durchschnitt, ja?

43:36.520 --> 43:39.520
Habe ich euch doch gestern gezeigt.

43:39.520 --> 43:41.520
Sondern hat sich sogar ein klein wenig verschlechtert.

43:41.520 --> 43:43.520
Aber damit liege ich immer noch im Durchschnitt.

43:43.520 --> 43:47.520
Es gibt ein Video von Profi-E-Sportlern, die den gleichen Reaktionstest gemacht haben.

43:47.520 --> 43:50.520
150 ist heftig.

43:50.520 --> 43:54.520
Das heißt, wenn man viel spielt, dann kann man hier wahrscheinlich wirklich schneller werden.

43:54.520 --> 43:57.520
Anders sieht es aus beim Aim, weil da habe ich mich in der Woche wirklich verbessert.

43:57.520 --> 43:59.520
Sicher cheated.

43:59.520 --> 44:02.520
Ich habe es live gestern im Stream gemacht, Mann.

44:02.520 --> 44:04.520
Wie soll ich das cheaten?

44:04.520 --> 44:06.520
Und habe 109 Treffer gemacht.

44:06.520 --> 44:10.520
Und jetzt waren es 93% mit 125 Treffern.

44:10.520 --> 44:12.520
Und dabei war ich auch noch deutlich schneller.

44:12.520 --> 44:14.520
Videoaufzeichnung, alles klar.

44:14.520 --> 44:17.520
Besonders in Overwatch 2 habe ich mich krass verbessert.

44:17.520 --> 44:21.520
Also wenn ich mir mein erstes Spiel anschaue und mein letztes, dann sind das nicht riesige Unterschiede.

44:21.520 --> 44:25.520
Insgesamt kann man sagen, in einer Woche wird man natürlich nicht vom Noob zum Pro-Gamer.

44:25.520 --> 44:27.520
Aber man kann gut werden in einer Woche.

44:27.520 --> 44:29.520
Aber man kann echt krasse Fortschritte machen.

44:29.520 --> 44:31.520
Schreibt mir gerne mal in die Kommentare, wie viel ihr so zockt.

44:31.520 --> 44:34.520
Vielen Dank nochmal an MSI für die Unterstützung bei diesem Video.

44:34.520 --> 44:37.520
Es hat echt Spaß gemacht, auf dem Katana zu zocken.

44:37.520 --> 44:39.520
Und ich bin echt super zufrieden mit der Performance.

44:39.520 --> 44:41.520
Den Link dazu, wie gesagt, in der Videobeschreibung.

44:41.520 --> 44:44.520
Wenn ihr jetzt sehen wollt, wie ich versucht habe, meine getragenen Socken zu verkaufen,

44:44.520 --> 44:46.520
dann schaut euch mein letztes Set...

44:46.520 --> 44:48.520
Was?

44:48.520 --> 44:50.520
...macht, auf dem Katana zu zocken.

44:50.520 --> 44:52.520
Und ich bin echt super zufrieden mit der Performance.

44:52.520 --> 44:54.520
Den Link dazu, wie gesagt, in der Videobeschreibung.

44:54.520 --> 44:58.520
Wenn ihr jetzt sehen wollt, wie ich versucht habe, meine getragenen Socken zu verkaufen, dann schaut...

45:01.520 --> 45:03.520
Was?

45:03.520 --> 45:05.520
Jetzt gucken wir uns jetzt nicht an.

45:05.520 --> 45:12.520
Auch wenn es mich tatsächlich interessieren würde, warum er seine getragenen Socken verkaufen will.

45:12.520 --> 45:14.520
...euch mein letztes Selbstexperiment an.

45:14.520 --> 45:17.520
Abonniert den Kanal, um keine Videos mehr zu verpassen.

45:17.520 --> 45:19.520
Und bis zum nächsten Mal.

45:19.520 --> 45:22.520
Wie reich werde ich mit getragenen Socken?

45:22.520 --> 45:27.520
Ja, wenn die getragenen Socken von ihm sind, ist das wahrscheinlich jetzt nicht so der Wahnsinn.

45:27.520 --> 45:33.520
Wenn er irgendwie Hottes Hottes Gamer Girl wäre, dann würde das anders aussehen.

45:33.520 --> 45:39.520
Passen Fußfotos dabei, da gehen die Leute drauf ab.

45:39.520 --> 45:46.520
Welche Seite war das mit dem Reaktionstest? Human Benchmark.

45:46.520 --> 45:48.520
Das da.

45:48.520 --> 45:51.520
Leute, meine Hände sind kalt, aber ich probiere es jetzt trotzdem nochmal, okay?

45:51.520 --> 45:53.520
Weil es mir keiner glaubt.

45:53.520 --> 45:54.520
Getting started.

45:54.520 --> 45:56.520
Reaction time.

45:58.520 --> 46:01.520
Gestern habe ich das gemacht nach zwei Stunden Spielen.

46:01.520 --> 46:09.520
Gerade die Hand, wo ich auf die Maus drücken muss, ist eiskalt, aber egal, probieren wir es mal.

46:09.520 --> 46:11.520
Guck mal.

46:11.520 --> 46:13.520
Sogar besser als gestern.

46:17.520 --> 46:19.520
Heute geht es ab?

46:25.520 --> 46:27.520
On point.

46:27.520 --> 46:30.520
Okay, der letzte war nicht richtig.

46:30.520 --> 46:33.520
On point, überhaupt kann es nichts sagen.

46:33.520 --> 46:36.520
In human reactions.

46:40.520 --> 46:44.520
Also ich muss sagen, für 38 geht das echt klar.

46:44.520 --> 46:47.520
Trotzdem gutes Video.

46:47.520 --> 46:52.520
Ich hätte mir tatsächlich noch ein bisschen mehr fokussieren aufs Verbessern im Spiel gewünscht.

46:52.520 --> 46:55.520
Wie gesagt, du kannst ja unglaublich viel machen.

46:55.520 --> 46:59.520
Dass er sich coachen lässt, finde ich schon mal gut.

46:59.520 --> 47:03.520
Aber du musst halt wirklich richtig grinden, wenn du gut werden willst.

47:03.520 --> 47:06.520
Und dich dann auch auf gewisse Punkte konzentrieren, wo du dich verbessern willst.

47:06.520 --> 47:07.520
Auf cooldowns achten.

47:07.520 --> 47:09.520
Okay, jetzt achte ich da und da drauf.

47:09.520 --> 47:13.520
So wirklich die anderen Punkte abarbeiten, musst dir selbst auch Notizen machen.

47:13.520 --> 47:17.520
So nach dem Motto, ah mir ist aufgefallen, ich habe hier jetzt beispielsweise die Entscheidung falsch,

47:17.520 --> 47:19.520
war falsch, den Spawn zu pushen, was auch immer.

47:22.520 --> 47:24.520
Und du musst grinden, dir bleibt nichts anderes übrig.

47:24.520 --> 47:27.520
Grinden und analysieren.

47:28.520 --> 47:29.520
Dann wirst du besser.

47:29.520 --> 47:32.520
Also ein bisschen mehr auf die Gaming, auf die Gaming Aspekt.

47:32.520 --> 47:38.520
War ja kaum, obwohl es darum ging, war relativ wenig eigentlich etwas Gaming zu sehen.

47:43.520 --> 47:47.520
Chat, ich bin ja froh, dass ich wenigstens mal eine Sache besser kann als ihr.

47:47.520 --> 47:51.520
Aber ansonsten wissen wir ja, ansonsten kann der Chat prinzipiell alles besser.

47:52.520 --> 47:56.520
Naja, ich glaube CS hätte eher in der Woche absolut keinen Spaß gehabt.

47:56.520 --> 48:01.520
CS kriegst du, gerade wenn du komplett ohne jegliches Aim anfängst,

48:01.520 --> 48:05.520
du kriegst einfach nur unglaublich auf den Sack.

48:05.520 --> 48:07.520
Und du weißt gar nicht, was dir passiert.

48:07.520 --> 48:11.520
In CS läufst du einen Gang lang und auf einmal macht es...

48:11.520 --> 48:17.520
Wisst ihr diesen Headshot auf Armor Sound von CS?

48:17.520 --> 48:19.520
Und du bist tot und denkst dir, hä?

48:19.520 --> 48:21.520
Was?

48:21.520 --> 48:23.520
Ich habe noch nicht mal einen Pixel vom Gegner gesehen.

48:23.520 --> 48:25.520
Was war denn jetzt?

48:25.520 --> 48:27.520
Du respawnst, läufst weiter...

48:29.520 --> 48:31.520
Tot.

48:31.520 --> 48:33.520
Also ich glaube, CS ist gerade an der Stelle nichts.

48:33.520 --> 48:35.520
Ich finde es gut, dass er Overwatch genommen hat.

48:35.520 --> 48:37.520
Overwatch kannst du...

48:37.520 --> 48:44.520
Weil gut, er spielt Soldier, dürfte mit der einsteigerfreundlichsten DPS-Held sein.

48:44.520 --> 48:46.520
So quasi der klassische Call of Duty-Held.

48:46.520 --> 48:48.520
Nur, dass du noch einen Self-Feel hast.

48:48.520 --> 48:50.520
Ich weiß nicht, wie sind Overwatch 2s, by the way,

48:50.520 --> 48:52.520
wie da die Helden-Kids aussehen.

48:54.520 --> 48:57.520
Vielleicht wäre es tatsächlich besser gewesen,

48:57.520 --> 49:00.520
er hätte am Anfang ein bisschen auf Support geguckt.

49:00.520 --> 49:02.520
Weil ich finde, ein Vorteil hat das, wenn man ein bisschen Support spielt.

49:02.520 --> 49:04.520
Man lernt den Fluss aus,

49:04.520 --> 49:07.520
ich nenne es mal so den Flow von Overwatch, finde ich besser,

49:07.520 --> 49:11.520
als wenn man direkt am Anfang DPS spielt und quasi immer drauf rennt

49:11.520 --> 49:13.520
und versucht zu killen und versucht Damage zu machen.

49:13.520 --> 49:16.520
Weil Overwatch hat schon, auch ein bisschen abhängig von den Maps,

49:16.520 --> 49:18.520
so einen gewissen Fluss.

49:18.520 --> 49:20.520
Und gerade Leute, die neu sind in dem Spiel,

49:20.520 --> 49:22.520
tun sich da immer schwer,

49:22.520 --> 49:24.520
sterben beispielsweise noch unnötig,

49:24.520 --> 49:26.520
obwohl man sie jetzt eigentlich bräuchte,

49:26.520 --> 49:28.520
um dann wieder gegenpushen zu können und sowas.

49:28.520 --> 49:30.520
Das ist natürlich ein bisschen ein Problem,

49:30.520 --> 49:34.520
als Support. Als Tank würde ich nicht unbedingt anfangen,

49:34.520 --> 49:37.520
weil gerade, wenn du so ein bisschen was Halbwegs Offensives

49:37.520 --> 49:39.520
wie Winston nimmst und springst dann rein,

49:39.520 --> 49:41.520
hast du keinen Plan, wohin du dich positionierst

49:41.520 --> 49:43.520
und wo du zurück kannst, wo Medipacks sind,

49:43.520 --> 49:45.520
wo du schön deinen Schild stellen kannst,

49:45.520 --> 49:47.520
dass du wieder um die Ecke gingst,

49:47.520 --> 49:49.520
kriegst du ja nur noch auf den Sack.

49:49.520 --> 49:53.520
Und wenn du Tank spielst, ist halt eine Sache ganz extrem,

49:53.520 --> 49:56.520
du wirst von Anfang an lernen, dein Team zu hassen,

49:56.520 --> 49:58.520
weil du gar nicht weißt,

49:58.520 --> 50:00.520
was dein Team macht.

50:00.520 --> 50:02.520
Weil du gleich denkst, alter, was macht mein Team?

50:02.520 --> 50:04.520
Als Tank kannst du in Overwatch,

50:04.520 --> 50:06.520
von Reinhardt aus oder so,

50:06.520 --> 50:08.520
du bist da jetzt nicht unbedingt der,

50:08.520 --> 50:12.520
der das krass carried mit deinem Nahkampfzeug.

50:12.520 --> 50:14.520
Du bist unglaublich wichtig für das Team,

50:14.520 --> 50:16.520
dass es überhaupt pushen kann und funktioniert.

50:16.520 --> 50:19.520
Und gerade wenn Tank gegen Tank ist,

50:19.520 --> 50:21.520
wäre er quasi den anderen Outplayed,

50:21.520 --> 50:23.520
der gewinnt letztendlich den Fight.

50:23.520 --> 50:27.520
Aber im Prinzip bist du darauf angewiesen,

50:27.520 --> 50:29.520
dass dein Team daraus was macht.

50:29.520 --> 50:33.520
Und ich denke gerade im unteren Skillsegment

50:33.520 --> 50:35.520
bist du permanent angepisst auf dein Team.

50:35.520 --> 50:37.520
Deswegen ist vielleicht als DPS

50:37.520 --> 50:40.520
bzw. gerade als Supportstatten gar nicht mal so blöd.

50:40.520 --> 50:42.520
So, also so viel, so viel.

50:42.520 --> 50:44.520
Mein Senf dazu.

50:44.520 --> 50:46.520
Wir gucken uns jetzt nicht,

50:46.520 --> 50:48.520
wie er seine Socken verkauft hat an.

50:49.520 --> 50:51.520
Wieso VR-Games nicht funktionieren?

50:51.520 --> 50:53.520
Funktionieren doch.

50:53.520 --> 50:55.520
Du spielst keine VR-Games, das stimmt,

50:55.520 --> 50:57.520
wenn ich eine VR-Headset habe.

50:57.520 --> 50:59.520
Das ist korrekt.

50:59.520 --> 51:01.520
Oh.

51:12.520 --> 51:14.520
Mal eine technische Frage am Rande.

51:14.520 --> 51:16.520
Auf welche Technologie würdet ihr setzen,

51:16.520 --> 51:18.520
wenn ich ein klassisches MVC benötige?

51:18.520 --> 51:20.520
Alles Internet?

51:20.520 --> 51:23.520
Oder würdet ihr auch PHP im Jahr 2022 empfehlen?

51:23.520 --> 51:25.520
Ich wäre halt schon...

51:25.520 --> 51:27.520
MVC, das kannst du...

51:27.520 --> 51:32.520
Jede Sprache hat doch irgendein MVC-Framework, ja?

51:32.520 --> 51:36.520
Also, das Klassischste dürfte wohl Ruby on Rails sein.

51:36.520 --> 51:38.520
Ansonsten kannst du auch PHP nehmen.

51:38.520 --> 51:40.520
Laravel ist auch MVC.

51:40.520 --> 51:42.520
Ist halt die Frage,

51:42.520 --> 51:45.520
willst du wirklich auch den View in dem Framework machen

51:45.520 --> 51:49.520
oder willst du eigentlich nur quasi Controller haben?

51:49.520 --> 51:52.520
Weil den View machen, ganz ehrlich,

51:52.520 --> 51:55.520
in der heutigen Zeit will man wirklich noch

51:55.520 --> 51:57.520
den View in dem Framework machen?

51:57.520 --> 52:00.520
Will man da nicht irgendwas JavaScript-basiertes nehmen?

52:00.520 --> 52:04.520
Muss ja nicht ein Single-Page-Application sein.

52:04.520 --> 52:07.520
Ja, wobei, kann man ja schon machen.

52:07.520 --> 52:10.520
Also, ich würde es tatsächlich in.NET machen,

52:10.520 --> 52:12.520
weil ich.NET mag.

52:12.520 --> 52:15.520
Und ASP.NET Core, meiner Meinung nach,

52:15.520 --> 52:17.520
auch mit das beste Web-Framework ist.

52:17.520 --> 52:20.520
ASP.NET Core ist außerdem schnell.

52:20.520 --> 52:22.520
Du hast für alle Technologien,

52:22.520 --> 52:25.520
außer für Node.js Eigen-Krempel,

52:25.520 --> 52:29.520
hast du Implementierung von gRPC bis GraphQL und so.

52:29.520 --> 52:32.520
Das heißt, es gibt alle möglichen Sachen dabei.

52:32.520 --> 52:35.520
Man darf sich von einer Sache nicht planten lassen.

52:35.520 --> 52:38.520
Microsoft bewirbt ASP.NET Core immer mit,

52:38.520 --> 52:42.520
dass es quasi das schnellste Web-Framework überhaupt ist.

52:42.520 --> 52:47.520
Guck mal, wir können zum Beispiel.NET Conf-Keynote angucken.

52:47.520 --> 52:53.520
Ich muss kurz mal raussuchen, wo sie das zeigen.

52:53.520 --> 52:56.520
Microsoft erzählt ja auch ein bisschen viel Shit,

52:56.520 --> 52:58.520
wenn der Tag lang ist.

53:06.520 --> 53:09.520
Performance, wo erzählt man was von der Performance?

53:09.520 --> 53:12.520
Performance.

53:12.520 --> 53:14.520
Ja, also, das ist ziemlicher Blödsinn,

53:14.520 --> 53:16.520
was sie da teilweise erzählen.

53:16.520 --> 53:18.520
Blazingly fast, das kann ja schon mal nicht sein.

53:18.520 --> 53:20.520
Das ist nicht written in Rust.

53:20.520 --> 53:22.520
Und alles, was nicht written in Rust ist,

53:22.520 --> 53:24.520
kann ja überhaupt nicht blazingly fast sein.

53:24.520 --> 53:26.520
Das wissen wir ja.

53:26.520 --> 53:28.520
Das ist aber auch ziemlicher Blödsinn.

53:28.520 --> 53:30.520
Die wollen wir noch nicht ernsthaft erzählen.

53:30.520 --> 53:32.520
Ich sage auch gleich, warum das Blödsinn ist.

53:32.520 --> 53:34.520
Die wollen wir noch nicht ernsthaft erzählen,

53:34.520 --> 53:36.520
dass, wenn du eine Web-Anwendung baust

53:36.520 --> 53:38.520
und ein Backend für eine Web-Anwendung,

53:38.520 --> 53:42.520
dass Node.js 0,6 Millionen Requests durchkriegt

53:42.520 --> 53:45.520
und ASP.NET Core 7 Millionen Requests,

53:45.520 --> 53:49.520
wenn man halbwegs vergleichbare Features verwendet.

53:49.520 --> 53:51.520
Das ist ja immer das Wichtigste.

53:51.520 --> 53:53.520
Du kannst ja nicht Äpfel mit Birnen vergleichen.

53:53.520 --> 53:55.520
Du kannst ja nicht auf der einen Seite

53:55.520 --> 53:57.520
Express oder irgendwas verwenden,

53:57.520 --> 53:59.520
was dir das Leben relativ einfach macht,

53:59.520 --> 54:02.520
und auf der anderen Seite Raw Socket programmieren.

54:02.520 --> 54:05.520
Das ist kein Wunder, dass, wenn man Raw Sockets verwendet,

54:05.520 --> 54:08.520
das komplett das andere in die Tasche steckt.

54:08.520 --> 54:11.520
Aber dafür ist es auch 5-mal so viel Code

54:11.520 --> 54:13.520
und keine Sau blickt mehr durch.

54:13.520 --> 54:15.520
Als ich das gesehen hab,

54:15.520 --> 54:17.520
hab ich mir ganz absoluter Schwachsinn erzählt.

54:17.520 --> 54:19.520
Das kann nicht sein.

54:19.520 --> 54:21.520
Dann hab ich mal nachgeguckt.

54:21.520 --> 54:24.520
Es gibt, das ist ja glücklicherweise schön,

54:24.520 --> 54:26.520
an.NET ist alles Open Source.

54:26.520 --> 54:30.520
Microsoft hat getrickst wie Sau.

54:30.520 --> 54:34.520
Wir gucken uns mal kurz diesen Benchmark an.

54:34.520 --> 54:36.520
Moment hier.

54:36.520 --> 54:38.520
Tech Empower.

54:38.520 --> 54:44.520
Und dann zeige ich euch, was Microsoft da treibt.

54:44.520 --> 54:46.520
Ja.

54:46.520 --> 54:49.520
Data Section 21.

54:49.520 --> 54:51.520
So.

54:51.520 --> 54:53.520
ASP.

54:53.520 --> 54:57.520
Also man sieht, das ist relativ oben.

54:57.520 --> 54:59.520
ASP.net.

54:59.520 --> 55:01.520
Node.js ist relativ weit unten.

55:01.520 --> 55:04.520
Aber was euch jetzt wahrscheinlich schon auffällt ist,

55:04.520 --> 55:06.520
wobei die haben ja noch was anderes.

55:06.520 --> 55:08.520
Plain Text haben die ja hier.

55:08.520 --> 55:10.520
Plain Text.

55:10.520 --> 55:13.520
Ihr seht hier, ASP ist ziemlich weit oben.

55:13.520 --> 55:15.520
Aber guckt mal.

55:15.520 --> 55:17.520
Es gibt ASP.

55:17.520 --> 55:19.520
Es gibt ASP Core of Mono.

55:19.520 --> 55:21.520
Es gibt ASP MW.

55:21.520 --> 55:23.520
ASP.NET Core.

55:23.520 --> 55:25.520
Es gibt ganz viel unterschiedliches Zeug.

55:25.520 --> 55:27.520
MVC.

55:27.520 --> 55:29.520
Das ist auch schon gar nicht mehr so gut.

55:29.520 --> 55:31.520
So.

55:31.520 --> 55:35.520
Microsoft hat das folgendermaßen gemacht.

55:35.520 --> 55:37.520
Die bescheißen.

55:37.520 --> 55:39.520
Ja, genau.

55:39.520 --> 55:41.520
Die bescheißen ja nicht wirklich.

55:41.520 --> 55:43.520
Die machen den Benchmark schon.

55:43.520 --> 55:45.520
Allerdings, die Sache ist halt die,

55:45.520 --> 55:47.520
die verwenden ASP.NET Core nicht,

55:47.520 --> 55:49.520
wie man normalerweise eine ASP.NET Core Web-Anwendung

55:49.520 --> 55:51.520
programmieren würde.

55:51.520 --> 55:53.520
Nee, nee.

55:53.520 --> 55:55.520
Die haben quasi explizit eine,

55:55.520 --> 55:59.520
für diesen Benchmark optimierte Web-Anwendung entwickelt,

55:59.520 --> 56:03.520
die so gut wie nichts aus ASP.NET Core verwendet.

56:03.520 --> 56:05.520
Die verwenden keine Controller.

56:05.520 --> 56:09.520
Die verwenden nicht die normale Request-Pipeline.

56:09.520 --> 56:11.520
Ich glaube, RawSocket benutzen sie nicht.

56:11.520 --> 56:16.520
Aber die machen wirklich super krass optimiertes Zeug

56:16.520 --> 56:18.520
nur für diesen Benchmark,

56:18.520 --> 56:21.520
so wie niemand eine ASP.NET Core Web-Anwendung schreiben würde,

56:21.520 --> 56:25.520
mit handoptimierten Klassen für die Responses.

56:25.520 --> 56:28.520
Also, das ist einzig und allein dafür da,

56:28.520 --> 56:31.520
dass die und ihr wisst, ich bin.NET-Fan

56:31.520 --> 56:33.520
und auch das Framework mag ich.

56:33.520 --> 56:35.520
Aber das ist kompletter Bullshit, was sie uns hier erzählen.

56:35.520 --> 56:37.520
Das ist Blödsinn.

56:37.520 --> 56:39.520
Das Gute ist, das ist Open Source.

56:39.520 --> 56:41.520
Man kann sich das alles angucken auf GitHub,

56:41.520 --> 56:43.520
wenn man es dann findet.

56:47.520 --> 56:49.520
Also hier, im Beispiel, wer jetzt hier denkt,

56:49.520 --> 56:51.520
jeder dahinter würde eine Art

56:51.520 --> 56:54.520
eine normale ASP.NET Core Web-Anwendung stecken, nicht.

56:54.520 --> 56:56.520
Das ist auch nicht mal Minimal-API.

56:56.520 --> 56:59.520
Das ist wirklich handoptimiertes Zeug

56:59.520 --> 57:08.520
mit statisch zur Kompilzeit erzeugten Strings

57:08.520 --> 57:10.520
für die Responses.

57:10.520 --> 57:13.520
Also, das ist wirklich nicht mit der Realität zu vergleichen.

57:16.520 --> 57:19.520
Man müsste mal kurz gucken, ob man diese Benchmarks

57:21.520 --> 57:23.520
irgendwie findet.

57:23.520 --> 57:29.520
ASP.NET Benchmarks, Szenarios, Source.

57:32.520 --> 57:34.520
Ich weiß nicht, wo die...

57:36.520 --> 57:38.520
Ach gut, das ist ja so unübersichtlich.

57:38.520 --> 57:40.520
Da kann es ja nicht hier...

57:42.520 --> 57:44.520
Ah, das ist noch der normale.

57:44.520 --> 57:46.520
Ich weiß gar nicht, ob das das Richtige ist, doch.

57:48.520 --> 57:50.520
Wenn man hier durch...

57:50.520 --> 57:53.520
Hier durch...

57:59.520 --> 58:01.520
Habe ich denn das gesehen?

58:06.520 --> 58:08.520
Die verwenden, by the way, noch nicht mal, glaube ich,

58:08.520 --> 58:11.520
den eingebauten Web-Server von.NET.

58:11.520 --> 58:28.520
Oder nicht eigentlich die normale Request-Pipeline.

58:28.520 --> 58:31.520
Nee, das ist nicht das, was ich meine.

58:33.520 --> 58:36.520
Benchmarks, ja, hier kommen wir der Sache näher.

58:36.520 --> 58:38.520
Guck mal, die haben...

58:38.520 --> 58:41.520
Irgendwelche...

58:41.520 --> 58:44.520
Buffer-Klassen dafür erstellt und sowas.

58:44.520 --> 58:46.520
Hier sieht man es.

58:46.520 --> 58:48.520
Guck, das hier. Das ist der Benchmark.

58:48.520 --> 58:50.520
Das hat nichts mit einer normalen

58:50.520 --> 58:53.520
ASP.NET Web-Anwendung zu tun.

59:00.520 --> 59:04.520
Use Benchmarks, Configuration, Create IP, Endpoint.

59:04.520 --> 59:05.520
Das hat nichts...

59:05.520 --> 59:08.520
Allein schon hier durchzublicken ist nicht so ohne.

59:08.520 --> 59:10.520
Guck, im Startup steht beispielsweise auch gar nichts drin.

59:10.520 --> 59:12.520
String-Builder, Cache, es wird...

59:12.520 --> 59:14.520
Also es ist wirklich... Guck mal.

59:14.520 --> 59:16.520
Eine normale.NET Web-Anwendung

59:16.520 --> 59:18.520
hätte beispielsweise

59:18.520 --> 59:21.520
ein paar Minimal-API-Endpunkte

59:21.520 --> 59:22.520
hier in Program.cs.

59:22.520 --> 59:25.520
Die brauchen das alles,

59:25.520 --> 59:28.520
damit das funktioniert.

59:28.520 --> 59:30.520
Guck mal hier.

59:30.520 --> 59:34.520
Die encoden, irgendwelche Sachen machen.

59:34.520 --> 59:37.520
Buffer werden von Hand gelesen, von Hand befüllt.

59:37.520 --> 59:40.520
Keine normale Handle-Requests

59:40.520 --> 59:42.520
mit irgendwelchen komischen

59:42.520 --> 59:44.520
Writer-Readern von Hand.

59:44.520 --> 59:48.520
So sieht keine normale ASP.NET-Anwendung aus.

59:50.520 --> 59:51.520
Guck mal.

59:51.520 --> 59:53.520
Das sieht...

59:53.520 --> 59:56.520
Das ist ja fast schon socket-

59:56.520 --> 59:58.520
von Hand programmiert, wenn du es so willst.

59:58.520 --> 01:00:00.520
Ist es nicht wirklich, aber

01:00:00.520 --> 01:00:02.520
geht in die Richtung.

01:00:02.520 --> 01:00:05.520
So sieht keine normale ASP.NET-Anwendung aus.

01:00:05.520 --> 01:00:06.520
Deswegen muss man ganz ehrlich sagen,

01:00:06.520 --> 01:00:07.520
das ist ziemlicher Blödsinn,

01:00:07.520 --> 01:00:09.520
was wir uns hier verkaufen wollen bei Microsoft.

01:00:09.520 --> 01:00:10.520
Nichtsdestotrotz,

01:00:10.520 --> 01:00:12.520
um mal auf die eigentliche Frage zurückzukommen,

01:00:12.520 --> 01:00:15.520
von der ich drauf gekommen bin,

01:00:15.520 --> 01:00:17.520
ich mag ASP.NET Core trotzdem.

01:00:17.520 --> 01:00:19.520
Es ist immer noch mein Lieblingsweb-Framework.

01:00:19.520 --> 01:00:22.520
Und ich persönlich mag ja die Kombination aus

01:00:22.520 --> 01:00:26.520
API-Endpunkte in.NET Core

01:00:26.520 --> 01:00:29.520
und irgendeine Single-Page-Swelt-Application

01:00:29.520 --> 01:00:31.520
fürs Frontend.

01:00:31.520 --> 01:00:32.520
Wobei man halt sagen muss,

01:00:32.520 --> 01:00:35.520
Single-Page-Application will ja auch nicht jeder haben.

01:00:39.520 --> 01:00:41.520
Und, gut,

01:00:41.520 --> 01:00:44.520
du bist bei jeder Programmiersprache von irgendwas abhängig.

01:00:44.520 --> 01:00:47.520
Benutzt du Go, bist du quasi von Google abhängig.

01:00:47.520 --> 01:00:50.520
Benutzt du Swift, bist du quasi von Apple abhängig.

01:00:50.520 --> 01:00:51.520
Gut, bei PAP weiß ich nicht.

01:00:51.520 --> 01:00:53.520
Aber ganz ehrlich,

01:00:53.520 --> 01:00:55.520
.NET ist nicht morgen weg.

01:00:55.520 --> 01:01:01.520
Das ist mit eines der größten Projekte auf GitHub.

01:01:01.520 --> 01:01:03.520
Und das verschwindet nicht einfach.

01:01:03.520 --> 01:01:04.520
Also du hast jetzt da keine...

01:01:04.520 --> 01:01:06.520
Also da würde ich mir echt keine Gedanken machen,

01:01:06.520 --> 01:01:14.520
dass.NET morgen weg ist oder Microsoft da irgendwas wildes damit macht.

01:01:14.520 --> 01:01:17.520
Mal C++ machst du dich abhängig von den komischen Entscheidungen,

01:01:17.520 --> 01:01:19.520
die das C++-Gremium trifft.

01:01:19.520 --> 01:01:22.520
Chain-Lore, da bist du ja.

01:01:22.520 --> 01:01:25.520
Guckst du Privat 7 vs. Wild? Nee.

01:01:29.520 --> 01:01:32.520
Das Lachen alle über PAP gibt eigentlich gar keinen Grund mehr.

01:01:32.520 --> 01:01:35.520
Modernes PAP ist schon in Ordnung.

01:01:35.520 --> 01:01:37.520
Über PAP hat man halt früher gelacht,

01:01:37.520 --> 01:01:39.520
gerade weil die Leute, die das programmiert haben,

01:01:39.520 --> 01:01:42.520
dann irgendwelches Cookie- und Header-Handling von Hand gemacht haben

01:01:42.520 --> 01:01:44.520
und rein weiß Sicherheitslücken eingebaut haben.

01:01:44.520 --> 01:01:47.520
Mittlerweile ist PAP schon in Ordnung.

01:01:47.520 --> 01:01:49.520
Wie hängt C-Sharp mit ASP.NET?

01:01:49.520 --> 01:01:51.520
Gar nicht.

01:01:51.520 --> 01:01:53.520
Das sind zwei unterschiedliche Paar Schuhe.

01:01:53.520 --> 01:01:56.520
Also C-Sharp ist die Programmiersprache.

01:01:56.520 --> 01:02:04.520
Die einzig nennenswerte Implementierung basiert halt auf.NET Core

01:02:04.520 --> 01:02:09.520
beziehungsweise.NET 7 ist es jetzt ja mittlerweile von Microsoft.

01:02:09.520 --> 01:02:13.520
Es gibt zwar andere Implementierungen von ASP.NET,

01:02:13.520 --> 01:02:17.520
es gibt zwar andere Implementierungen von einem C-Sharp

01:02:17.520 --> 01:02:21.520
beziehungsweise.NET Compiler,

01:02:21.520 --> 01:02:24.520
aber es ist nicht relevant.

01:02:24.520 --> 01:02:26.520
Also insofern hängen die zusammen.

01:02:26.520 --> 01:02:30.520
Beides ist von Microsoft und C-Sharp ist quasi die Microsoft Sprache schlechthin

01:02:30.520 --> 01:02:32.520
für das.NET Framework.

01:02:32.520 --> 01:02:33.520
Hat nicht direkt was miteinander zu tun.

01:02:33.520 --> 01:02:37.520
C-Sharp ist die Sprache,.NET ist die Runtime

01:02:37.520 --> 01:02:42.520
und die Standard Library und halt das, was halt standardmäßig mit dabei ist.

01:02:42.520 --> 01:02:47.520
Und ASP.NET Core ist ein Web Framework auf.NET Basis.

01:02:47.520 --> 01:02:50.520
Der Zusammenhang ist, es kommt alles von Microsoft

01:02:50.520 --> 01:02:54.520
und es wird sicherlich auch Überschneidungen bei den Entwicklern geben.

01:02:54.520 --> 01:02:56.520
Aber im Prinzip hat es erstmal wenig miteinander zu tun.

01:02:56.520 --> 01:03:00.520
Du kannst ASP.NET Core auch in anderen Sprachen programmieren als in C-Sharp.

01:03:00.520 --> 01:03:04.520
Man könnte wahrscheinlich auch in F-Sharp oder sowas machen

01:03:04.520 --> 01:03:10.520
oder in irgendeiner beliebigen VB.NET zum Beispiel.

01:03:10.520 --> 01:03:16.520
Man könnte es in einer beliebigen.NET-Programmiersprache machen.

01:03:16.520 --> 01:03:21.520
Aber meistens ist es halt C-Sharp.

01:03:21.520 --> 01:03:26.520
Und das Prinzip jetzt, du abhängig immer von irgendwen bist, ist klar.

01:03:26.520 --> 01:03:28.520
Guckt euch die Sicherheitslücken an, die wir da in letzter Zeit haben.

01:03:28.520 --> 01:03:30.520
Ich sag nur Log4.

01:03:30.520 --> 01:03:31.520
Was war das?

01:03:31.520 --> 01:03:40.520
Log4Shell war das, wo irgendwo ein paar Maintainer am Start waren

01:03:40.520 --> 01:03:43.520
und was nicht gesehen haben.

01:03:43.520 --> 01:03:45.520
Das kann allen passieren.

01:03:45.520 --> 01:03:47.520
Also da ist die Chance wahrscheinlich sogar noch höher,

01:03:47.520 --> 01:03:49.520
dass dir jetzt mit sowas Kleines passiert,

01:03:49.520 --> 01:03:53.520
wo ein paar Leute hobbymäßig dran sitzen.

01:03:53.520 --> 01:04:18.520
Aber so hängt das Ganze zusammen.

01:04:18.520 --> 01:04:19.520
Kennst du ein gutes Online-Menu?

01:04:19.520 --> 01:04:21.520
WPF.

01:04:21.520 --> 01:04:23.520
Ich hab ein WPF-Buch hier.

01:04:23.520 --> 01:04:25.520
Das hat 1200 Seiten oder so.

01:04:25.520 --> 01:04:27.520
Ein richtig fettes Ding.

01:04:27.520 --> 01:04:29.520
Hab ich nie richtig gelesen.

01:04:29.520 --> 01:04:33.520
Ich wollte vor Jahren mal WPF mich ein bisschen mehr mit beschäftigen,

01:04:33.520 --> 01:04:34.520
aber hab aber keinen Bock drauf.

01:04:34.520 --> 01:04:37.520
Ich muss sagen, also kenn ich nicht.

01:04:37.520 --> 01:04:40.520
Und ich weiß auch nicht, ob man wirklich neue Anwendungen

01:04:40.520 --> 01:04:43.520
ernsthaft mit WPF noch machen will.

01:04:43.520 --> 01:04:46.520
Das ist ja tatsächlich Windows-only.

01:04:46.520 --> 01:04:49.520
Und ja, wenn man es in.NET machen will

01:04:49.520 --> 01:04:51.520
und es soll Windows-only sein,

01:04:51.520 --> 01:04:57.520
dann ist WPF eventuell tatsächlich immer noch das Beste.

01:04:57.520 --> 01:04:59.520
Wobei ich es auch nicht so sagen würde.

01:04:59.520 --> 01:05:01.520
Also Windows Forms ist halt hoffnungslos veraltet.

01:05:01.520 --> 01:05:02.520
WPF aber auch.

01:05:02.520 --> 01:05:04.520
WPF ist zwar ein bisschen neuer,

01:05:04.520 --> 01:05:06.520
aber WPF ist auch hoffnungslos veraltet.

01:05:06.520 --> 01:05:08.520
Windows Forms hat noch mal eine ganze Ecke älter.

01:05:08.520 --> 01:05:10.520
WPF hat halt viele neue Sachen eingeführt,

01:05:10.520 --> 01:05:12.520
die sich im Nachhinein dann auch etabliert haben,

01:05:12.520 --> 01:05:17.520
gerade dass du beispielsweise dein UI in extra Sprache designs,

01:05:17.520 --> 01:05:19.520
Two-Way-Data-Binding hast und sowas.

01:05:19.520 --> 01:05:22.520
Das war im WPF relativ früh mit dabei,

01:05:22.520 --> 01:05:23.520
dass die sowas hatten.

01:05:23.520 --> 01:05:25.520
Deswegen fühlt sich WPF nicht so alt an.

01:05:25.520 --> 01:05:27.520
Aber WPF ist im Kern auch alt.

01:05:27.520 --> 01:05:31.520
Und es ist halt rein Windows-only.

01:05:31.520 --> 01:05:33.520
Neuer wäre WinUI,

01:05:33.520 --> 01:05:35.520
was du auch mit XAML programmieren kannst.

01:05:35.520 --> 01:05:39.520
Da ist halt die Frage, muss auch nicht UWP sein.

01:05:39.520 --> 01:05:41.520
Ist halt die Frage, wie weit die da mittlerweile sind.

01:05:41.520 --> 01:05:43.520
Was anderes wäre Avalonia.

01:05:43.520 --> 01:05:48.520
Avalonia ist quasi ein Cross-Plattform-WPF-Nachbau,

01:05:48.520 --> 01:05:50.520
den ich persönlich deutlich sympathischer finde,

01:05:50.520 --> 01:05:53.520
als jetzt noch was mit WPF anzufangen.

01:05:53.520 --> 01:05:55.520
Ansonsten, ja, eines der großen Probleme,

01:05:55.520 --> 01:05:56.520
die dort net hat, ist,

01:05:56.520 --> 01:05:58.520
dass es kein gescheites UI-Framework gibt.

01:05:58.520 --> 01:05:59.520
Ich weiß jetzt, wenn die Leute sagen,

01:05:59.520 --> 01:06:00.520
ja, aber es gibt Maui.

01:06:00.520 --> 01:06:05.520
Aber Maui ist meiner Ansicht nach auch nicht so das wahre.

01:06:05.520 --> 01:06:07.520
Auf der einen Seite ist es eine Weiterentwicklung von Xamarin.

01:06:07.520 --> 01:06:10.520
Das hatte schon so die ein oder anderen Problemchen.

01:06:10.520 --> 01:06:14.520
Und es ist meiner Meinung nach

01:06:14.520 --> 01:06:20.520
der falsche Ansatz, ein UI-Framework zu bauen.

01:06:20.520 --> 01:06:23.520
War Xamarin auch schon.

01:06:23.520 --> 01:06:26.520
Und Maui ist es auch.

01:06:26.520 --> 01:06:30.520
Weil, ich sage das jetzt, ich versuche es mal zu begründen.

01:06:30.520 --> 01:06:34.520
Weil, also erstens unterstützen sie schon mal gar nicht alle Plattformen.

01:06:34.520 --> 01:06:35.520
Linux wird schon mal außen vor gelassen.

01:06:35.520 --> 01:06:37.520
Kann ich irgendwie noch verstehen.

01:06:37.520 --> 01:06:41.520
Linux Desktop-Unterstützung tut sich keiner freiwillig an.

01:06:41.520 --> 01:06:43.520
Ist natürlich blöd, ja.

01:06:43.520 --> 01:06:46.520
Weil elektronbasierte Sachen oder Qt-basierte Sachen,

01:06:46.520 --> 01:06:48.520
die können halt auch ohne Probleme auf Linux laufen.

01:06:48.520 --> 01:06:52.520
Wir schauen das C-Sharp-Video gleich, ja, gucken wir gleich an.

01:06:52.520 --> 01:06:56.520
Aber eine Sache, die ich in Xamarin schon nicht gut fand

01:06:56.520 --> 01:06:59.520
und in Maui auch nicht gut fand, ist,

01:06:59.520 --> 01:07:05.520
dass sie ihre Controls nicht selber malen.

01:07:05.520 --> 01:07:07.520
Die benutzen Native Controls.

01:07:07.520 --> 01:07:10.520
Das ist so ein bisschen Philosophiefrage, was man besser findet.

01:07:10.520 --> 01:07:12.520
Ja, ich finde es selbst...

01:07:12.520 --> 01:07:14.520
Nee, WPF ist nicht Avalonia.

01:07:14.520 --> 01:07:16.520
Avalonia ist... Moment.

01:07:16.520 --> 01:07:20.520
Avalon oder Avalonia war mal der Codename für WPF.

01:07:20.520 --> 01:07:22.520
Jetzt ist WPF WPF.

01:07:22.520 --> 01:07:29.520
Und das Projekt, was du auf GitHub hast, Avalonia UI,

01:07:29.520 --> 01:07:32.520
das ist quasi ein Open Source...

01:07:32.520 --> 01:07:35.520
Es tut ihnen fast schon unrecht, wenn ich das so sage.

01:07:35.520 --> 01:07:39.520
Das ist quasi ein Open Source Cross-Plattform-WPF-Nachbau.

01:07:39.520 --> 01:07:43.520
Es ist kein WPF-Nachbau, weil es viele Bereiche deutlich besser macht

01:07:43.520 --> 01:07:45.520
und viel moderner ist als WPF.

01:07:45.520 --> 01:07:50.520
Es ist eigentlich das bessere WPF mittlerweile.

01:07:50.520 --> 01:07:52.520
So, aber ich bin der Meinung,

01:07:52.520 --> 01:07:55.520
UI-Frameworks, die ihre Controls nicht selber malen, sind blöd,

01:07:55.520 --> 01:07:58.520
weil du kannst dir einfach nicht sicher sein,

01:07:58.520 --> 01:08:02.520
dass der Krempel ordentlich aussieht auf allen Plattformen.

01:08:02.520 --> 01:08:06.520
Zur anderen Seite hast du dann halt immer wirklich Native UI,

01:08:06.520 --> 01:08:09.520
was auch native aussieht, bis ins Kleinste,

01:08:09.520 --> 01:08:13.520
weil es ja eben die Elemente von der jeweiligen Plattform nimmt.

01:08:13.520 --> 01:08:18.520
Aber du hast ja dann im Prinzip immer nur so den kleinsten gemeinsamen Nenner.

01:08:18.520 --> 01:08:22.520
Jetzt stellt euch mal vor, ihr habt irgendein UI-Element, irgendein Button zum Beispiel.

01:08:22.520 --> 01:08:25.520
Der Button ist auf der einen Plattform standardmäßig rund,

01:08:25.520 --> 01:08:27.520
auf der einen standardmäßig eckig,

01:08:27.520 --> 01:08:31.520
auf der einen hat er Rechtsklick-Fähigkeiten, auf der anderen nicht.

01:08:31.520 --> 01:08:36.520
Auf der einen Plattform kannst du beispielsweise die Menüpunkte standardmäßig sortieren

01:08:36.520 --> 01:08:38.520
und bei der anderen nicht.

01:08:38.520 --> 01:08:42.520
So, und wie machst du das jetzt gescheit?

01:08:42.520 --> 01:08:46.520
Entweder baust du tatsächliche Native UI für jede Plattform.

01:08:46.520 --> 01:08:49.520
Dann ist die Frage, warum du so ein Metaframework überhaupt brauchst,

01:08:49.520 --> 01:08:52.520
was dir das Leben eigentlich einfacher machen sollte.

01:08:52.520 --> 01:08:56.520
Oder du musst den kleinsten gemeinsamen Nenner benutzen.

01:08:56.520 --> 01:09:00.520
Also sprich, du benutzt halt einen Button, auf den man klicken kann.

01:09:00.520 --> 01:09:05.520
Die jeweiligen plattformspezifischen Sachen unterstützt du dann halt einfach nicht in deiner Anwendung,

01:09:05.520 --> 01:09:08.520
weil dann hast du ja Probleme, ein Framework für alles zu verwenden,

01:09:08.520 --> 01:09:12.520
weil dann müsstest du ja wieder für die jeweilige Plattform was programmieren.

01:09:12.520 --> 01:09:16.520
Deswegen ist der Vorteil von UI-Frameworks, die ihre Elemente selbst zeichnen,

01:09:16.520 --> 01:09:18.520
dass du dieses Problem nicht hast.

01:09:18.520 --> 01:09:22.520
Es sieht überall gleich aus, es sieht vielleicht nicht native für diese Plattform aus,

01:09:22.520 --> 01:09:27.520
aber es sieht überall gleich aus, es ist überall auch gleich angehaut, anderenfalls gleich gerendert wird.

01:09:27.520 --> 01:09:31.520
Und du kannst halt das einbauen an Funktionen, was du haben willst, was du unterstützen willst,

01:09:31.520 --> 01:09:33.520
und geht das auch überall.

01:09:33.520 --> 01:09:38.520
Also ich bin da meine UI-Frameworks, die ihre Elemente selbst malen, ist so wie man sagen soll,

01:09:38.520 --> 01:09:39.520
the way to go.

01:09:39.520 --> 01:09:45.520
Ich weiß, dass du mit Maui da verschiedene Extensions machen kannst pro Plattform,

01:09:45.520 --> 01:09:47.520
dass du es dann doch irgendwie unterstützen kannst.

01:09:47.520 --> 01:09:50.520
Ich mag Maui nicht, ich mochte Xamarin schon nicht,

01:09:50.520 --> 01:09:52.520
ich finde es doof, dass sie keine Leerungsunterstützung haben,

01:09:52.520 --> 01:09:54.520
und ich finde den Ansatz nicht gut.

01:09:54.520 --> 01:09:57.520
So, deswegen ist Maui nicht meins.

01:09:57.520 --> 01:09:59.520
Dann lieber Avalonia.

01:10:07.520 --> 01:10:10.520
Ne, wie gesagt, das ist das, wie ich es machen würde.

01:10:10.520 --> 01:10:16.520
Also das klassische MVC, dass du quasi einen Controller hast,

01:10:16.520 --> 01:10:21.520
also einen Model hast du ja nach wie vor, ein Model ist ja im Prinzip die Datenbank-Abstraktion,

01:10:21.520 --> 01:10:25.520
nennen wir es mal so, das was quasi aus der,

01:10:25.520 --> 01:10:30.520
die ganze SQL-Sache ein bisschen besser verpackt.

01:10:30.520 --> 01:10:35.520
Du hast da eine Tabelle in der Datenbank, aber bei dir ist es dann halt ein Model für das,

01:10:35.520 --> 01:10:37.520
was in der Datenbank drinne steht, zum Beispiel ein User.

01:10:37.520 --> 01:10:42.520
In der Datenbank sind es dann unter der Haube halt irgendwelche Felder mit Index und sonst was,

01:10:42.520 --> 01:10:48.520
du hast da ein Model mit User, Vorname, Nachname, und Datenbankgeschichte ist das Model.

01:10:48.520 --> 01:10:51.520
Controller ist das quasi dein AP-Endpunkt.

01:10:51.520 --> 01:10:54.520
Der View ist halt das, was im Browser angezeigt wird,

01:10:54.520 --> 01:11:00.520
und das ist der View in MVC ist halt normalerweise klassisches Server-Site,

01:11:00.520 --> 01:11:03.520
also relativ statisches Server-Site-Rendering.

01:11:03.520 --> 01:11:08.520
Du hast dann irgendeine Templatesprache, bei.NET ist es Razor,

01:11:08.520 --> 01:11:14.520
bei Ruby, bei Ruby on Rails ist es ERB,

01:11:14.520 --> 01:11:17.520
und dann rendert das Server halt diese Seite einmalig,

01:11:17.520 --> 01:11:19.520
mit dem Content, der rein soll, schickt es an Client.

01:11:19.520 --> 01:11:25.520
Du kannst selbstverständlich da drinne dann im Browser auf dem Client JavaScript Zeug machen,

01:11:25.520 --> 01:11:30.520
das ist kein Ding, aber der modernere Ansatz ist eigentlich,

01:11:30.520 --> 01:11:33.520
dass du ein AP, weil man das nicht sagen kann,

01:11:33.520 --> 01:11:35.520
der Trend geht ja gerade ein bisschen wieder hin,

01:11:35.520 --> 01:11:37.520
dass man mehr Server-Site-Rendering macht,

01:11:37.520 --> 01:11:40.520
einfach weil du es besser durchsuchen kannst in Suchmaschinen,

01:11:40.520 --> 01:11:44.520
und weil die Page-Ladezeiten schneller sind,

01:11:44.520 --> 01:11:47.520
aber das ist so ein Hybrid, wie man das aktuell macht,

01:11:47.520 --> 01:11:55.520
so ganz klassisches statisches Server-Site-Rendering ist jetzt eigentlich relativ out.

01:11:55.520 --> 01:11:58.520
Entweder machst du es halt sehr JavaScript-heavy,

01:11:58.520 --> 01:12:03.520
dass du nur AP-Endpunkte baust, dass du quasi nur Model und Controller benutzt,

01:12:03.520 --> 01:12:08.520
du baust halt AP-Endpunkte, und Frontend lieferst du halt aus,

01:12:08.520 --> 01:12:14.520
mit quasi dem JavaScript-Package,

01:12:14.520 --> 01:12:17.520
was sich dann erstmal beim ersten Seitenaufrufen von deiner AP

01:12:17.520 --> 01:12:19.520
die Daten lädt und die Seite aufbaut,

01:12:19.520 --> 01:12:23.520
oder du nimmst halt sowas wie SvelteKit,

01:12:23.520 --> 01:12:27.520
oder andere Dinge in dieser Richtung,

01:12:27.520 --> 01:12:30.520
die so das Hybrid-mäßig machen,

01:12:30.520 --> 01:12:33.520
also die rendern schon die Seite mal vor,

01:12:33.520 --> 01:12:34.520
auf dem Server schicken sie dir rüber,

01:12:34.520 --> 01:12:38.520
aber dann übernimmt dein Client wieder.

01:12:38.520 --> 01:12:42.520
Aber wenn du rein Daten-heavy-Anwendungen hast,

01:12:42.520 --> 01:12:44.520
zu irgendwas einfach mit elendlangen Tabellen,

01:12:44.520 --> 01:12:46.520
Inventarslisten oder sowas,

01:12:46.520 --> 01:12:50.520
dann kannst du natürlich auch dein HTML auf dem Server rendern lassen

01:12:50.520 --> 01:12:53.520
und deinen Client rausschicken.

01:12:53.520 --> 01:13:01.520
Aber es ist jetzt vielleicht nicht mal so das Angesagteste,

01:13:01.520 --> 01:13:03.520
das so zu machen.

01:13:14.520 --> 01:13:16.520
Ist Qt heutzutage noch relevant?

01:13:16.520 --> 01:13:18.520
Ja, ist es.

01:13:18.520 --> 01:13:20.520
Es ist erstaunlich viel in Qt,

01:13:20.520 --> 01:13:22.520
nicht nur an cross-Plattform.

01:13:22.520 --> 01:13:26.520
Origin, das Origin ist ganz zum Beispiel

01:13:26.520 --> 01:13:30.520
zum größten Teil in Qt.

01:13:30.520 --> 01:13:32.520
Ist das EA-Ding, was sie jetzt abgeschafft haben.

01:13:32.520 --> 01:13:35.520
Wahrscheinlich das neue auch.

01:13:35.520 --> 01:13:38.520
Ich mein, Origin ist zum größten Teil ein Browser,

01:13:38.520 --> 01:13:42.520
aber der Rest ist Qt und der Browser-Wrapper auch.

01:13:42.520 --> 01:13:45.520
Ja, es ist relativ viel Qt.

01:13:45.520 --> 01:13:53.520
Darum ist halt C++.

01:13:53.520 --> 01:13:57.520
OBS, ja genau, OBS auch, habe ich ganz vergessen, richtig.

01:13:57.520 --> 01:13:59.520
So, nee, habe ich nicht.

01:13:59.520 --> 01:14:05.520
So, und zwar, jetzt wo Preserif auch da ist,

01:14:05.520 --> 01:14:08.520
wir wollten doch noch dieses.net-Video gucken,

01:14:08.520 --> 01:14:13.520
acht Gründe, warum es die Sharp doof ist oder sowas.

01:14:13.520 --> 01:14:16.520
Ne, fünf Gründe, okay, oder 30 Minuten.

01:14:16.520 --> 01:14:19.520
Da schwätze ich ja wieder ewig zu.

01:14:19.520 --> 01:14:22.520
Fünf Gründe, warum es die Sharp mooks ist

01:14:22.520 --> 01:14:24.520
und nicht mehr so ganz zeitgemäß.

01:14:24.520 --> 01:14:27.520
Also ich gucke seine Videos gerne.

01:14:27.520 --> 01:14:29.520
Ich weiß, dass er früher,

01:14:29.520 --> 01:14:31.520
ich weiß nicht, ob er mal Beispiele zeigt.

01:14:31.520 --> 01:14:33.520
Erzähl da wirklich, 30 Minuten durchgehen.

01:14:33.520 --> 01:14:35.520
Okay, das wird was.

01:14:35.520 --> 01:14:39.520
Ich weiß, dass er früher.net,

01:14:39.520 --> 01:14:42.520
wie nennt sich das bei Microsoft?

01:14:42.520 --> 01:14:45.520
So.net Experte oder irgendwie sowas.

01:14:45.520 --> 01:14:49.520
Ne, wie heißt das?

01:14:49.520 --> 01:14:52.520
Microsoft, wie heißt denn dieses Programm?

01:14:52.520 --> 01:14:54.520
MVP, MVP.

01:14:54.520 --> 01:14:59.520
Er war früher Microsoft MVP für.net oder für C-Sharp.

01:14:59.520 --> 01:15:03.520
Hat sich dann irgendwie mit Microsoft in den Haaren gehabt,

01:15:03.520 --> 01:15:07.520
weil er sich wohl öffentlich kritisch über.net geäußert hat.

01:15:07.520 --> 01:15:09.520
Und dann hat Microsoft zu ihm gesagt,

01:15:09.520 --> 01:15:12.520
du bist jetzt kein.net Experte mehr.

01:15:12.520 --> 01:15:13.520
Und dann hat er gesagt,

01:15:13.520 --> 01:15:14.520
gut, dann mache ich mit Microsoft nichts mehr

01:15:14.520 --> 01:15:15.520
und jetzt was anderes.

01:15:15.520 --> 01:15:17.520
Also er hat so ein bisschen in der Vergangenheit

01:15:17.520 --> 01:15:19.520
Probleme mit Microsoft gehabt.

01:15:19.520 --> 01:15:21.520
Mal gucken, ob das da jetzt mit was zu tun hat.

01:15:21.520 --> 01:15:22.520
Mal schauen.

01:15:22.520 --> 01:15:24.520
Ansonsten gucke ich seine Videos wirklich gerne,

01:15:24.520 --> 01:15:25.520
weil die sind in der Regel,

01:15:25.520 --> 01:15:27.520
hat das Hand und Fuß, was er sagt.

01:15:27.520 --> 01:15:29.520
Aber gucken wir mal,

01:15:29.520 --> 01:15:33.520
was er uns denn zu.net erzählt.

01:15:33.520 --> 01:15:35.520
Vergangene Woche ging es in unserem Video darum,

01:15:35.520 --> 01:15:37.520
dass ich nach vielen, vielen Jahren

01:15:37.520 --> 01:15:39.520
wieder mit C-Sharp und.net in Berührung gekommen bin

01:15:39.520 --> 01:15:41.520
und aktuell mit dieser Sprache

01:15:41.520 --> 01:15:42.520
Plattform entwickle.

01:15:42.520 --> 01:15:43.520
Ich habe erzählt,

01:15:43.520 --> 01:15:45.520
wie sich das nach all den Jahren für mich anfühlt,

01:15:45.520 --> 01:15:47.520
was mir auffällt und was man da...

01:15:47.520 --> 01:15:49.520
Was er hat auch auf Twitter Mastodon

01:15:49.520 --> 01:15:52.520
für ihre Ruby on Rails Basis kritisiert.

01:15:52.520 --> 01:15:55.520
Kann man ja auch im Jahr 2023 machen.

01:15:55.520 --> 01:15:58.520
...als Entwicklerin oder als Entwickler lernen kann.

01:15:58.520 --> 01:15:59.520
Ich habe auch erzählt...

01:15:59.520 --> 01:16:00.520
Bisschen leise.

01:16:00.520 --> 01:16:02.520
... ohne mich jetzt auf den Podest stellen zu wollen,

01:16:02.520 --> 01:16:05.520
doch in einem gewissen Sinne von mir selbst überrascht war,

01:16:05.520 --> 01:16:08.520
wieviel ich von C-Sharp und.net nach all der Zeit noch wusste...

01:16:08.520 --> 01:16:10.520
Okay, wo gehen die Gründe los?

01:16:10.520 --> 01:16:12.520
... dass es schön wäre,

01:16:12.520 --> 01:16:14.520
dass ich endlich wieder eine vernünftige Sprache nutzen würde,

01:16:14.520 --> 01:16:16.520
aber dass es doch schade sei,

01:16:16.520 --> 01:16:17.520
dass ich nicht sehen würde...

01:16:17.520 --> 01:16:19.520
Naja...

01:16:19.520 --> 01:16:21.520
Go ist auch cringe.

01:16:21.520 --> 01:16:25.520
... was im Jahr 2022 mit C-Sharp und.net alles möglich sei,

01:16:25.520 --> 01:16:27.520
und ich müsste mich nur mal vernünftig

01:16:27.520 --> 01:16:29.520
und ausgiebig damit befassen,

01:16:29.520 --> 01:16:31.520
und ich solle C-Sharp doch einfach

01:16:31.520 --> 01:16:32.520
mal eine Chance geben.

01:16:32.520 --> 01:16:34.520
Dann würde sich auch meine Kritik

01:16:34.520 --> 01:16:36.520
ganz sicher ganz schnell erübrigen.

01:16:36.520 --> 01:16:39.520
Und weil ich außerdem von vielen anderen Entwicklerinnen und Entwicklern

01:16:39.520 --> 01:16:40.520
gefragt worden bin,

01:16:40.520 --> 01:16:43.520
was mich denn konkret an C-Sharp und.net stört...

01:16:43.520 --> 01:16:45.520
Dann erzähl mal.

01:16:45.520 --> 01:16:46.520
Also...

01:16:46.520 --> 01:16:47.520
Ich muss dazu sagen,

01:16:47.520 --> 01:16:48.520
ich finde auch nicht alles toll, ja.

01:16:48.520 --> 01:16:50.520
Gerade auch was die letzten Jahre

01:16:50.520 --> 01:16:52.520
alles in.net bzw. C-Sharp eingebaut wurde,

01:16:52.520 --> 01:16:53.520
kann man sich drüber streiten,

01:16:53.520 --> 01:16:56.520
ob das so überlegt ist an vielen Stellen.

01:16:56.520 --> 01:16:58.520
Ich habe ja mittlerweile 50 neue Features eingebaut,

01:16:58.520 --> 01:17:00.520
wo die meisten davon gar nicht...

01:17:00.520 --> 01:17:02.520
Ja, ich finde auch nicht alles gut.

01:17:02.520 --> 01:17:04.520
Warum ich es nicht mehr so ganz zeitgemäß fände,

01:17:04.520 --> 01:17:07.520
deshalb besprechen wir das heute mal ausführlich im Detail.

01:17:07.520 --> 01:17:08.520
Jawoll.

01:17:08.520 --> 01:17:10.520
Ganz wichtig ist mir dabei noch vorneweg darauf hinzuweisen,

01:17:10.520 --> 01:17:13.520
dass mir an C-Sharp nicht alles missfällt.

01:17:13.520 --> 01:17:15.520
Es gibt auch durchaus einige...

01:17:15.520 --> 01:17:17.520
Alter, schon mal sehr persönlich gesagt.

01:17:17.520 --> 01:17:19.520
Konzepte und Features, die ich mag

01:17:19.520 --> 01:17:21.520
und die ich als gelungen bezeichnen würde.

01:17:21.520 --> 01:17:23.520
Nur um die geht es eben heute nicht,

01:17:23.520 --> 01:17:24.520
weil ja gezielt die Frage war...

01:17:24.520 --> 01:17:26.520
Heute wird geflamed, so muss das sein.

01:17:26.520 --> 01:17:27.520
Also insofern,

01:17:27.520 --> 01:17:29.520
take it with a grain of salt,

01:17:29.520 --> 01:17:30.520
wie man im Englischen so schön sagt,

01:17:30.520 --> 01:17:33.520
und damit können wir dann nun auch endlich loslegen.

01:17:33.520 --> 01:17:34.520
In diesem Sinne,

01:17:34.520 --> 01:17:36.520
hallo und herzlich willkommen

01:17:36.520 --> 01:17:38.520
zu unserem neuen Developers Diction.

01:17:38.520 --> 01:17:40.520
Hallo und herzlich willkommen.

01:17:40.520 --> 01:17:41.520
Wer war das?

01:17:41.520 --> 01:17:43.520
War das der Krieger früher?

01:17:43.520 --> 01:17:44.520
Ja, ich glaube schon.

01:17:44.520 --> 01:17:47.520
Weil das Thema ein bisschen umfangreicher ist,

01:17:47.520 --> 01:17:49.520
wird das Video heute ein bisschen länger.

01:17:49.520 --> 01:17:51.520
Und deshalb möchte ich dir vor...

01:17:51.520 --> 01:17:55.520
Nee, Semper Video ist anders.

01:17:55.520 --> 01:17:59.520
Semper Video ist in diesem Video nur ganz kurz.

01:17:59.520 --> 01:18:01.520
...ab kurz einen Überblick geben,

01:18:01.520 --> 01:18:03.520
was dich im Detail so ungefähr erwartet.

01:18:03.520 --> 01:18:05.520
Erzähl, bin ich gespannt.

01:18:05.520 --> 01:18:07.520
Wir schauen uns C-Sharp aus insgesamt 5 verschiedenen...

01:18:07.520 --> 01:18:09.520
Oh, hat nicht so gute Bewertungen.

01:18:09.520 --> 01:18:11.520
Normalerweise haben die wie so eine Top-Bewertung.

01:18:11.520 --> 01:18:13.520
Aber gut, das sind die getriggerten C-Sharp-Fanboys.

01:18:13.520 --> 01:18:14.520
...Perspektiven an.

01:18:14.520 --> 01:18:15.520
Wir beginnen damit,

01:18:15.520 --> 01:18:18.520
wie sich C-Sharp im Lauf der Jahre weiterentwickelt hat

01:18:18.520 --> 01:18:20.520
und welche Inkonsistenzen dabei entstanden sind.

01:18:20.520 --> 01:18:21.520
Oh, da gibt es ein paar, ja.

01:18:21.520 --> 01:18:23.520
Danach gucken wir uns ein paar Features an,

01:18:23.520 --> 01:18:25.520
die zwar ursprünglich mal gut gemeint waren,

01:18:25.520 --> 01:18:28.520
die aber unterm Strich mehr Schaden als Nutzen anrichten.

01:18:28.520 --> 01:18:30.520
Als drittes geht es dann um Dinge,

01:18:30.520 --> 01:18:31.520
die einfach nicht funktionieren,

01:18:31.520 --> 01:18:32.520
wo man sich fragt,

01:18:32.520 --> 01:18:34.520
wieso kann C-Sharp das nicht?

01:18:34.520 --> 01:18:37.520
Danach geht es als viertes noch um ein paar Altlasten.

01:18:37.520 --> 01:18:38.520
Und zum Abschluss, als fünftes,

01:18:38.520 --> 01:18:39.520
erzähle ich dir dann noch,

01:18:39.520 --> 01:18:41.520
was mein ganz persönliches Highlight

01:18:41.520 --> 01:18:43.520
oder vielleicht sollte ich eher sagen,

01:18:43.520 --> 01:18:44.520
Downlight ist.

01:18:44.520 --> 01:18:45.520
Also, was für mich die größte Niveau...

01:18:45.520 --> 01:18:46.520
Gibt es das Wort überhaupt?

01:18:46.520 --> 01:18:48.520
...über was schon mit C-Sharp war.

01:18:48.520 --> 01:18:49.520
Und bevor wir jetzt mit dem ersten Punkt...

01:18:49.520 --> 01:18:50.520
Ich hätte gesagt,

01:18:50.520 --> 01:18:52.520
mein persönlicher Abfuck oder sowas,

01:18:52.520 --> 01:18:54.520
aber er drückt das natürlich deutlich gewählter aus.

01:18:54.520 --> 01:18:55.520
Und falls du dich fragst,

01:18:55.520 --> 01:18:57.520
wie ich überhaupt dazu gekommen bin,

01:18:57.520 --> 01:19:00.520
dass ich mich wieder mit C-Sharp und.NET beschäftige,

01:19:00.520 --> 01:19:01.520
dann möchte ich an der Stelle

01:19:01.520 --> 01:19:04.520
noch einmal auf das Video von voriger Woche verweisen,

01:19:04.520 --> 01:19:06.520
wo ich das ausführlich erklärt habe.

01:19:06.520 --> 01:19:07.520
Und falls du das verpasst hast,

01:19:07.520 --> 01:19:09.520
oder falls du es dir einfach noch mal...

01:19:11.520 --> 01:19:12.520
...Inkonsistenzen in der Sprache.

01:19:12.520 --> 01:19:14.520
C-Sharp wurde ja ursprünglich...

01:19:14.520 --> 01:19:16.520
Oh, ich habe schon das Intro vergessen.

01:19:16.520 --> 01:19:17.520
Ich hätte doch nicht skippen sollen.

01:19:17.520 --> 01:19:19.520
Kommen wir zur ersten Kategorie.

01:19:19.520 --> 01:19:20.520
Okay.

01:19:20.520 --> 01:19:23.520
Kommen wir zu den Inkonsistenzen in der Sprache.

01:19:23.520 --> 01:19:24.520
Da gibt es ein paar, ja.

01:19:24.520 --> 01:19:27.520
...ursprünglich auf der Basis der Erfahrungen mit Java geplant.

01:19:27.520 --> 01:19:28.520
Und man merkt,

01:19:28.520 --> 01:19:31.520
dass C-Sharp viele der Konzepte aus Java übernommen,

01:19:31.520 --> 01:19:34.520
diese aber vor allem weiterentwickelt und weitergedacht hat.

01:19:34.520 --> 01:19:38.520
Und C-Sharp wirkte, als es 2002 auf den Markt kam,

01:19:38.520 --> 01:19:41.520
in sich deutlich schlüssiger und konsistenter als Java,

01:19:41.520 --> 01:19:43.520
weil Microsoft sich damals...

01:19:43.520 --> 01:19:45.520
Ja, weil Anders Heilsberg high IQ ist.

01:19:45.520 --> 01:19:47.520
...in Ruhe hat anschauen können,

01:19:47.520 --> 01:19:50.520
welche Konzepte und Sprachmerkmale von Java gut funktioniert haben

01:19:50.520 --> 01:19:52.520
und welche eher weniger.

01:19:52.520 --> 01:19:53.520
Und darauf dann eben aufbauen konnte.

01:19:53.520 --> 01:19:55.520
Und das ist auch tatsächlich einer der Punkte,

01:19:55.520 --> 01:19:58.520
die mich vor vielen, vielen Jahren an C-Sharp sehr fasziniert haben.

01:19:58.520 --> 01:20:01.520
Die Sprache wirkte damals sehr aus einem Guss.

01:20:01.520 --> 01:20:02.520
Das stimmt.

01:20:02.520 --> 01:20:05.520
Heute sieht das an vielen Stellen leider anders aus.

01:20:05.520 --> 01:20:07.520
Da gebe ich ihm recht.

01:20:07.520 --> 01:20:09.520
Wie gesagt, es sind über die letzten Jahre

01:20:09.520 --> 01:20:11.520
durchaus ein paar Sachen reingekommen,

01:20:11.520 --> 01:20:14.520
wo ich mich auch frage, so, muss das sein?

01:20:14.520 --> 01:20:16.520
Von Default...

01:20:16.520 --> 01:20:18.520
Ich muss mir mal die Liste angucken.

01:20:18.520 --> 01:20:21.520
Ja, von Default Interfaces,

01:20:21.520 --> 01:20:23.520
die ich bis heute nicht verwende.

01:20:23.520 --> 01:20:25.520
Ich verstehe, warum es diese gibt.

01:20:25.520 --> 01:20:27.520
Aber ja, es sind schon ein paar Dinge drin,

01:20:27.520 --> 01:20:29.520
wo ich mir denke, so, hm,

01:20:29.520 --> 01:20:31.520
scheint mir nicht alles so wirklich überlegt zu sein.

01:20:31.520 --> 01:20:34.520
Einfach typisches Beispiel ist der Umgang mit leeren Zeichenketten.

01:20:34.520 --> 01:20:37.520
Da gibt es nämlich inzwischen drei Möglichkeiten,

01:20:37.520 --> 01:20:39.520
wie man das Ganze schreiben kann.

01:20:39.520 --> 01:20:40.520
Nämlich...

01:20:40.520 --> 01:20:42.520
Umgang mit leeren Zeichenketten.

01:20:44.520 --> 01:20:46.520
Was meint er denn?

01:20:46.520 --> 01:20:48.520
Meint er...

01:20:48.520 --> 01:20:50.520
Ah, ich glaube, ich weiß, was er meint.

01:20:50.520 --> 01:20:52.520
String ist...

01:20:52.520 --> 01:20:56.520
String ist white space empty

01:20:56.520 --> 01:21:01.520
und String ist empty und String ist white space or null

01:21:01.520 --> 01:21:03.520
und solche Dinger.

01:21:03.520 --> 01:21:05.520
Wahrscheinlich das.

01:21:05.520 --> 01:21:08.520
Einmal klassisch mit zwei doppelten Anführungszeichen,

01:21:08.520 --> 01:21:10.520
dann String.empty

01:21:10.520 --> 01:21:12.520
und dann String.empty.

01:21:12.520 --> 01:21:14.520
Ja, das ist bescheuert.

01:21:14.520 --> 01:21:16.520
Ich glaube, es gibt keinen.

01:21:16.520 --> 01:21:18.520
Du kannst sowohl groß als auch klein schreiben.

01:21:18.520 --> 01:21:20.520
Ach so, ja.

01:21:20.520 --> 01:21:22.520
Es gibt nämlich String klein geschrieben als Typ in C-Sharp.

01:21:22.520 --> 01:21:24.520
Ich glaube, das ist gar kein Unterschied.

01:21:24.520 --> 01:21:26.520
Groß geschrieben als Typ in.NET.

01:21:26.520 --> 01:21:28.520
Und das ist am Ende derselbe Typ.

01:21:28.520 --> 01:21:30.520
Ich glaube String.empty ist quasi so eine Konstante

01:21:30.520 --> 01:21:32.520
für Lehrer String.

01:21:32.520 --> 01:21:35.520
Also eigentlich quasi so eine Art globale Variable

01:21:35.520 --> 01:21:37.520
für Lehrer String.

01:21:37.520 --> 01:21:40.520
Ja, ich glaube, es macht überhaupt keinen Unterschied.

01:21:40.520 --> 01:21:42.520
Weil String mit kleinem S einfach nur ein Alias

01:21:42.520 --> 01:21:44.520
auf String mit großem S ist.

01:21:44.520 --> 01:21:46.520
Trotzdem gibt es aber halt zwei Schreibweisen.

01:21:46.520 --> 01:21:48.520
Ja, bestimmt.

01:21:48.520 --> 01:21:50.520
Und wenn man nun eine leere Zeichenfolge angeben möchte,

01:21:50.520 --> 01:21:52.520
dann stellt sich die Frage, was man denn dann nimmt.

01:21:52.520 --> 01:21:54.520
Eigentlich lägen die beiden doppelten Anführungszeichen

01:21:54.520 --> 01:21:56.520
ja sehr nahe.

01:21:56.520 --> 01:21:58.520
Also es geht ihm jetzt, wenn ich das richtig verstanden habe,

01:21:58.520 --> 01:22:00.520
es geht ihm jetzt darum, quasi,

01:22:00.520 --> 01:22:02.520
hier, war, blub,

01:22:02.520 --> 01:22:04.520
so

01:22:04.520 --> 01:22:06.520
und jetzt quasi,

01:22:06.520 --> 01:22:08.520
if, blub,

01:22:08.520 --> 01:22:10.520
gleich, gleich, so

01:22:10.520 --> 01:22:12.520
oder

01:22:12.520 --> 01:22:14.520
ja, ich machs, ich machs hier.

01:22:14.520 --> 01:22:16.520
Ist gut, Leute, ist ja.

01:22:16.520 --> 01:22:18.520
Ich, ich, ich, ich

01:22:18.520 --> 01:22:20.520
mach was anderes auf.

01:22:20.520 --> 01:22:22.520
Keine Flashbang, ist okay, ist gut.

01:22:24.520 --> 01:22:26.520
So, hier.

01:22:26.520 --> 01:22:28.520
Also eben gehts glaub ich um so was hier.

01:22:28.520 --> 01:22:30.520
Ist gleich, gleich, oder ist

01:22:30.520 --> 01:22:32.520
String.empty?

01:22:34.520 --> 01:22:36.520
Ich vermute mal, dass es eben darum geht.

01:22:36.520 --> 01:22:38.520
Das oder das. Find ich persönlich

01:22:38.520 --> 01:22:40.520
jetzt nicht so schlimm.

01:22:40.520 --> 01:22:42.520
Mach eigentlich immer das, aber

01:22:42.520 --> 01:22:44.520
ja, warum es noch drin ist,

01:22:44.520 --> 01:22:46.520
keine Ahnung.

01:22:46.520 --> 01:22:48.520
Das ist wohl so der gängige Standard in praktisch

01:22:48.520 --> 01:22:50.520
jeder Programmiersprache, aber es

01:22:50.520 --> 01:22:52.520
gibt tatsächlich einen historischen Grund für die

01:22:52.520 --> 01:22:54.520
anderen beiden Schreibweisen.

01:22:54.520 --> 01:22:56.520
In.NET 1.0 und 1.1

01:22:56.520 --> 01:22:58.520
wurde durch zwei doppelte Anführungszeichen

01:22:58.520 --> 01:23:00.520
nämlich jeweils ein neues Stringobjekt

01:23:00.520 --> 01:23:02.520
im Speicher erzeugt. Ach, das wusste ich nicht.

01:23:02.520 --> 01:23:04.520
Das ist mir neu.

01:23:04.520 --> 01:23:06.520
Und deshalb

01:23:06.520 --> 01:23:08.520
wurde als Ausweg dann String.empty

01:23:08.520 --> 01:23:10.520
eingeführt, was ein statisches

01:23:10.520 --> 01:23:12.520
Read-Only-Feld der String-Klasse ist.

01:23:12.520 --> 01:23:14.520
Das dadurch immer

01:23:14.520 --> 01:23:16.520
denselben, also den identischen Wert repräsentiert.

01:23:16.520 --> 01:23:18.520
Ok, das wusste ich nicht.

01:23:18.520 --> 01:23:20.520
Anfangs war es also tatsächlich empfehlenswert String.empty zu verwenden.

01:23:20.520 --> 01:23:22.520
Das ist schon ein bisschen her.

01:23:22.520 --> 01:23:24.520
Das ganze gilt aber bereits seit.NET 2.0 nicht mehr,

01:23:24.520 --> 01:23:26.520
denn ab dieser Version greift das sogenannte

01:23:26.520 --> 01:23:28.520
In-Turning und gleiche Strings werden

01:23:28.520 --> 01:23:30.520
im Speicher einfach dedupliziert.

01:23:30.520 --> 01:23:32.520
Nun könnte man meinen, dass String.empty

01:23:32.520 --> 01:23:34.520
in den 16 Jahren seit der Veröffentlichung

01:23:34.520 --> 01:23:36.520
von.NET 2 irgendwann

01:23:36.520 --> 01:23:38.520
mal als veraltet deklariert wurde.

01:23:38.520 --> 01:23:40.520
Ok, nochmal was zu der Benamung.

01:23:40.520 --> 01:23:42.520
16 Jahre.NET 2

01:23:42.520 --> 01:23:44.520
er meint.NET Framework 2

01:23:44.520 --> 01:23:46.520
nicht zu verwechseln

01:23:46.520 --> 01:23:48.520
also.NET Framework

01:23:48.520 --> 01:23:50.520
gibt es bis.NET Framework

01:23:50.520 --> 01:23:52.520
4.8

01:23:52.520 --> 01:23:54.520
nicht zu verwechseln mit.NET 5

01:23:54.520 --> 01:23:56.520
oder.NET 6 oder.NET 7.

01:23:56.520 --> 01:23:58.520
Weil.NET

01:23:58.520 --> 01:24:00.520
5 ist quasi ein unbenanntes

01:24:00.520 --> 01:24:02.520
.NET Core

01:24:02.520 --> 01:24:04.520
3.1

01:24:04.520 --> 01:24:06.520
Also sprich.NET Core

01:24:06.520 --> 01:24:08.520
also.NET Core

01:24:08.520 --> 01:24:10.520
ist quasi die Neuentwicklung

01:24:10.520 --> 01:24:12.520
die nichts mehr mit dem.NET Framework

01:24:12.520 --> 01:24:14.520
zu tun hat. Allerdings hat sich Microsoft

01:24:14.520 --> 01:24:16.520
gedacht nach.NET

01:24:16.520 --> 01:24:18.520
Core 1,.NET Core 2

01:24:18.520 --> 01:24:20.520
.NET Core 2.1

01:24:20.520 --> 01:24:22.520
und so weiter und so fort

01:24:22.520 --> 01:24:24.520
dass sie zu

01:24:24.520 --> 01:24:26.520
.NET 3.1

01:24:26.520 --> 01:24:28.520
dann quasi zu.NET

01:24:28.520 --> 01:24:30.520
Core 4 quasi das ganze

01:24:30.520 --> 01:24:32.520
unbenannt in.NET 5

01:24:32.520 --> 01:24:34.520
und warum haben sie das

01:24:34.520 --> 01:24:36.520
gemacht? Weil es sonst Probleme

01:24:36.520 --> 01:24:38.520
gegeben hätte mit.NET Framework

01:24:38.520 --> 01:24:40.520
4.8

01:24:40.520 --> 01:24:42.520
weil die logische neue Benamung

01:24:42.520 --> 01:24:44.520
wäre gewesen.NET Core

01:24:44.520 --> 01:24:46.520
4. Microsoft hat sich

01:24:46.520 --> 01:24:48.520
aber gedacht 4 ist ganz schön doof

01:24:48.520 --> 01:24:50.520
wir benennen das ganze

01:24:50.520 --> 01:24:52.520
jetzt.NET 5

01:24:52.520 --> 01:24:54.520
und daraus resultiert jetzt das nächste

01:24:54.520 --> 01:24:56.520
Problem. Jeder der keine Ahnung

01:24:56.520 --> 01:24:58.520
von der Versionshistorie von.NET hat

01:24:58.520 --> 01:25:00.520
wird sich denken.NET 5

01:25:00.520 --> 01:25:02.520
ist der Nachfolger

01:25:02.520 --> 01:25:04.520
von.NET 4.8

01:25:04.520 --> 01:25:06.520
von.NET Framework 4.8

01:25:06.520 --> 01:25:08.520
das stimmt aber überhaupt

01:25:08.520 --> 01:25:10.520
nicht..NET Framework 4.8

01:25:10.520 --> 01:25:12.520
ist das ganz alte

01:25:12.520 --> 01:25:14.520
und.NET 5 beziehungsweise

01:25:14.520 --> 01:25:16.520
mittlerweile.NET 7 ist die

01:25:16.520 --> 01:25:18.520
Weiterentwicklung von.NET Core und das

01:25:18.520 --> 01:25:20.520
neue

01:25:20.520 --> 01:25:22.520
nur mal so angemerkt ja

01:25:22.520 --> 01:25:24.520
ich hoffe man hat alles verstanden

01:25:24.520 --> 01:25:26.520
jetzt

01:25:26.520 --> 01:25:28.520
Wechselt zu.NET Core und dann wieder

01:25:28.520 --> 01:25:30.520
zurück ohne Hinbrüche in der Codebase

01:25:30.520 --> 01:25:32.520
gab aber dem ist nicht so

01:25:32.520 --> 01:25:34.520
und deshalb streiten Entwicklerinnen und

01:25:34.520 --> 01:25:36.520
Entwickler auch im Jahr 2022

01:25:36.520 --> 01:25:38.520
immer noch darüber was denn nun

01:25:38.520 --> 01:25:40.520
besser lesbar sei und das Schlimme ist nun

01:25:40.520 --> 01:25:42.520
dass es eine nicht zu vernachlässigen

01:25:42.520 --> 01:25:44.520
Anzahl streiten sich die Leute wirklich da

01:25:44.520 --> 01:25:46.520
immer noch drüber die Stringpunkt Empty

01:25:46.520 --> 01:25:48.520
den Vorzug geben. Echt?

01:25:48.520 --> 01:25:50.520
Wer macht denn sowas? Seriously

01:25:50.520 --> 01:25:52.520
wer schreibt Stringpunkt Empty?

01:25:52.520 --> 01:25:54.520
Warum ist das schlimm?

01:25:54.520 --> 01:25:56.520
Ich weiß jetzt sagt die Hälfte vom Chat ich

01:25:56.520 --> 01:25:58.520
funktioniert weil es erst zur Laufzeit

01:25:58.520 --> 01:26:00.520
ausgewertet wird und überall dort

01:26:00.520 --> 01:26:02.520
wo eine Compile Zeit Konstante benötigt

01:26:02.520 --> 01:26:04.520
wird muss man dann halt doch wieder auf die

01:26:04.520 --> 01:26:06.520
Doppelten Anführungszeichen ausweichen

01:26:06.520 --> 01:26:08.520
was zum Beispiel bei Standardwerten für

01:26:08.520 --> 01:26:10.520
optionale Parameter der Fall ist. Was aber

01:26:10.520 --> 01:26:12.520
auch innerhalb von der Switch Anweisung

01:26:12.520 --> 01:26:14.520
der Fall ist oder bei Parametern

01:26:14.520 --> 01:26:16.520
für Attribute. Aber selbst wenn man nun

01:26:16.520 --> 01:26:18.520
sagt ist mir egal ich verwende generell

01:26:18.520 --> 01:26:20.520
ausschließlich die Doppelten Anführungszeichen

01:26:20.520 --> 01:26:22.520
damit es einheitlich ist dann funktioniert

01:26:22.520 --> 01:26:24.520
das wieder nicht. Denn für den Test

01:26:24.520 --> 01:26:26.520
ob eine String Variable leer ist

01:26:26.520 --> 01:26:28.520
soll man in C-Sharp nicht deren

01:26:28.520 --> 01:26:30.520
Inhalt mit dem Leerstring vergleichen

01:26:30.520 --> 01:26:32.520
sondern ihre Länge auf Null prüfen

01:26:32.520 --> 01:26:34.520
weil und da wird... What?

01:26:36.520 --> 01:26:38.520
Wer macht denn sowas?

01:26:38.520 --> 01:26:40.520
...absurd das Performanter ist

01:26:40.520 --> 01:26:42.520
Ok also was er meint ist

01:26:42.520 --> 01:26:44.520
nur mal so für alle die der Sache nicht folgen

01:26:44.520 --> 01:26:46.520
konnte ich glaube er meint man sollte hier folgen

01:26:46.520 --> 01:26:48.520
das nicht machen also man sollte also

01:26:48.520 --> 01:26:50.520
man sollte das hier nicht machen sondern

01:26:50.520 --> 01:26:52.520
man sollte

01:26:52.520 --> 01:26:54.520
so machen

01:26:58.520 --> 01:27:00.520
What?

01:27:00.520 --> 01:27:02.520
But why?

01:27:04.520 --> 01:27:06.520
Das finde ich

01:27:06.520 --> 01:27:08.520
Ok Microsoft sagt

01:27:08.520 --> 01:27:10.520
viel wenn der Tag lang ist man muss es ja nicht machen

01:27:14.520 --> 01:27:16.520
Ich fällt das ganz klar

01:27:16.520 --> 01:27:18.520
unter Microoptimierung aber ich finde es

01:27:18.520 --> 01:27:20.520
erschreckend dass solche Themen tatsächlich im Jahr

01:27:20.520 --> 01:27:22.520
2022... Das ist bestimmt

01:27:22.520 --> 01:27:24.520
Das ist bestimmt auch nicht

01:27:24.520 --> 01:27:26.520
Performanter unter der Haube kommt da bestimmt

01:27:26.520 --> 01:27:28.520
das gleiche raus und wenn nicht dann ist es

01:27:28.520 --> 01:27:30.520
echt ein Fail von Microsoft

01:27:30.520 --> 01:27:58.520
Ja würde ich eigentlich erwarten dass er das macht

01:27:58.520 --> 01:28:00.520
Aber dieses Beispiel steht stellvertretend

01:28:00.520 --> 01:28:02.520
für das was in C-Sharp seit etlichen Jahren

01:28:02.520 --> 01:28:04.520
Aber ich würde es echt wundern wenn das immer noch

01:28:04.520 --> 01:28:06.520
so ist also

01:28:06.520 --> 01:28:08.520
keine Ahnung ich weiß es nicht

01:28:08.520 --> 01:28:10.520
Müssen wir jetzt mal irgendwie in Sharp Lab oder so gucken

01:28:10.520 --> 01:28:12.520
was da rauskommt

01:28:12.520 --> 01:28:14.520
Wollen wir mal gucken?

01:28:16.520 --> 01:28:18.520
Wollen wir mal gucken was da

01:28:18.520 --> 01:28:20.520
rauskommt?

01:28:20.520 --> 01:28:24.520
So das da

01:28:28.520 --> 01:28:30.520
Das da

01:28:30.520 --> 01:28:32.520
Versus

01:28:34.520 --> 01:28:36.520
Das da versus

01:28:36.520 --> 01:28:44.520
Versus

01:28:44.520 --> 01:28:46.520
Das da

01:28:52.520 --> 01:28:54.520
Was?

01:28:54.520 --> 01:28:56.520
Aber nicht das gleiche

01:28:56.520 --> 01:29:02.520
Und

01:29:06.520 --> 01:29:08.520
Alter das kenne ich mir jetzt nicht

01:29:10.520 --> 01:29:12.520
Keine Ahnung was da

01:29:12.520 --> 01:29:14.520
Auf IL habe ich jetzt wirklich keinen

01:29:16.520 --> 01:29:18.520
Keine Ahnung ob da wirklich ein Unterschied ist

01:29:22.520 --> 01:29:24.520
Ich hätte jetzt eigentlich gedacht es kommt

01:29:24.520 --> 01:29:26.520
beim beiden mehr oder weniger unter der Haube

01:29:28.520 --> 01:29:30.520
Das gleiche raus aber vielleicht doch nicht

01:29:30.520 --> 01:29:32.520
Das wäre auf jeden Fall Fail

01:29:32.520 --> 01:29:34.520
wenn das Unterschiede macht

01:29:34.520 --> 01:29:36.520
Zweites Beispiel

01:29:36.520 --> 01:29:38.520
immer noch Thema Inkonsistenz

01:29:38.520 --> 01:29:40.520
dieses mal in Bezug auf die Klassenbibliothek

01:29:40.520 --> 01:29:42.520
denn die gehört zwar nicht direkt zur Sprache

01:29:42.520 --> 01:29:44.520
aber das Ökosystem kann man natürlich nicht einfach

01:29:44.520 --> 01:29:46.520
ignorieren es gibt in.NET sage

01:29:46.520 --> 01:29:48.520
und schreibe 5 Klassen

01:29:48.520 --> 01:29:50.520
um Timer zu implementieren

01:29:50.520 --> 01:29:52.520
Ne es gibt mehr

01:29:52.520 --> 01:29:54.520
Leute ich wette mit euch es gibt mehr

01:29:54.520 --> 01:29:56.520
Threading Timer

01:29:56.520 --> 01:29:58.520
System Windows Forms Timer

01:29:58.520 --> 01:30:00.520
System Web UI Timer

01:30:00.520 --> 01:30:02.520
und mein Liebling

01:30:02.520 --> 01:30:04.520
System Windows Threading Dispatcher Timer

01:30:04.520 --> 01:30:06.520
und die machen im Prinzip

01:30:06.520 --> 01:30:08.520
alles gleiche

01:30:08.520 --> 01:30:10.520
verhalten sich aber natürlich in den Details ganz geringfügig anders

01:30:10.520 --> 01:30:12.520
By the way

01:30:12.520 --> 01:30:14.520
er ist nicht auf dem aktuellen Stand Leute

01:30:14.520 --> 01:30:16.520
es gibt mindestens noch einen sechsten Timer

01:30:16.520 --> 01:30:18.520
nämlich

01:30:18.520 --> 01:30:20.520
C Sharp Periodic Timer

01:30:20.520 --> 01:30:22.520
der ist jetzt neu

01:30:22.520 --> 01:30:24.520
seit.NET 6

01:30:24.520 --> 01:30:26.520
oder.NET 5

01:30:28.520 --> 01:30:30.520
der ist jetzt neu die haben noch nicht genug

01:30:30.520 --> 01:30:32.520
Timer gehabt guck seit.NET 6

01:30:32.520 --> 01:30:34.520
ist der neu

01:30:34.520 --> 01:30:36.520
das ist das erste mal das man den wirklich

01:30:36.520 --> 01:30:38.520
Async verwenden kann ordentlich

01:30:38.520 --> 01:30:40.520
ja die Microsoft Hilfe

01:30:40.520 --> 01:30:42.520
ist auch so ein Ding die ist auch kacke

01:30:44.520 --> 01:30:46.520
der eine verwendet Events

01:30:46.520 --> 01:30:48.520
der andere Core wächst den einen kann man

01:30:48.520 --> 01:30:50.520
Multithreaded nutzen den anderen nicht

01:30:50.520 --> 01:30:52.520
und so weiter

01:30:52.520 --> 01:30:54.520
ja das ist schon das ist schon das hat er schon recht

01:30:54.520 --> 01:30:56.520
das ist Fail

01:30:56.520 --> 01:30:58.520
Schlimm genug wäre kommt dann in Form der MSDN auch noch

01:30:58.520 --> 01:31:00.520
naja

01:31:00.520 --> 01:31:02.520
eher nicht so gelungen

01:31:02.520 --> 01:31:04.520
hier haben wir ja gerade gesehen die Hilfe

01:31:04.520 --> 01:31:06.520
ist oftmals ziemlicher Shit

01:31:06.520 --> 01:31:08.520
da steht einfach gar

01:31:08.520 --> 01:31:10.520
nichts dazu da

01:31:14.520 --> 01:31:16.520
ups what was hat das mit Battlefield zu tun

01:31:16.520 --> 01:31:18.520
Moment

01:31:18.520 --> 01:31:20.520
ah

01:31:20.520 --> 01:31:22.520
ja

01:31:22.520 --> 01:31:24.520
Kommentation hinzu

01:31:24.520 --> 01:31:26.520
um es mal so zu sagen

01:31:26.520 --> 01:31:28.520
wenn ich nämlich zum Beispiel dort nachschlagen

01:31:28.520 --> 01:31:30.520
möchte was genau denn der

01:31:30.520 --> 01:31:32.520
System Windows Threading Dispatcher Timer

01:31:32.520 --> 01:31:34.520
ist dann steht da als Erklärung

01:31:34.520 --> 01:31:36.520
ernsthaft ein Zeitgeber der in die

01:31:36.520 --> 01:31:38.520
Dispatcher Warteschlange integriert ist

01:31:38.520 --> 01:31:40.520
ja obviously ist doch klar

01:31:40.520 --> 01:31:42.520
das hilft mir ehrlich gesagt nicht

01:31:42.520 --> 01:31:44.520
weiter wenn ich nicht weiß was die Dispatcher Warteschlange

01:31:44.520 --> 01:31:46.520
ist und wenn ich das weiß dann brauche ich die Erklärung nicht

01:31:46.520 --> 01:31:48.520
und eigentlich wollte ich ja nur

01:31:48.520 --> 01:31:50.520
dass irgendwas mal periodisch

01:31:50.520 --> 01:31:52.520
alle x Millisekunden ausgeführt wird

01:31:52.520 --> 01:31:54.520
aber das scheint in.NET tatsächlich ein

01:31:54.520 --> 01:31:56.520
größeres Problem zu sein wenn es dafür 5

01:31:56.520 --> 01:31:58.520
Varianten von Timern braucht

01:31:58.520 --> 01:32:00.520
Periodik Timer nicht vergessen

01:32:00.520 --> 01:32:02.520
in TypeScript ruft man da halt einfach Set Intervall auf

01:32:02.520 --> 01:32:04.520
gibt den Callback mit, gibt die Millisekunden

01:32:04.520 --> 01:32:06.520
an und ist fertig. In Go ruft man

01:32:06.520 --> 01:32:08.520
time.tick auf, gibt die Millisekunden

01:32:08.520 --> 01:32:10.520
an und ist fertig. Also wo liegt

01:32:10.520 --> 01:32:12.520
das Problem? So schwer kann das

01:32:12.520 --> 01:32:14.520
doch eigentlich nicht sein einen Timer

01:32:14.520 --> 01:32:16.520
bereitzustellen. Ach ja und der Ausgangspunkt des

01:32:16.520 --> 01:32:18.520
ganzen war übrigens dass wir einen Timer

01:32:18.520 --> 01:32:20.520
gesucht haben den man zurücksetzen kann also

01:32:20.520 --> 01:32:22.520
so was wie die Reset Funktion die

01:32:22.520 --> 01:32:24.520
man in Go zum Beispiel auf dem Timer aufrufen

01:32:24.520 --> 01:32:26.520
kann in.NET

01:32:26.520 --> 01:32:28.520
scheint aber niemanden Timer zurücksetzen

01:32:28.520 --> 01:32:30.520
zu wollen dort gibt es nämlich keine Reset Funktion

01:32:30.520 --> 01:32:32.520
wenn man danach sucht dann

01:32:32.520 --> 01:32:34.520
findet man genau gar

01:32:34.520 --> 01:32:36.520
valide Kritikpunkte ja

01:32:36.520 --> 01:32:38.520
außer jede Menge Stack Overflow Artikel die

01:32:38.520 --> 01:32:40.520
sich damit beschäftigen wie man eine Reset Funktion

01:32:40.520 --> 01:32:42.520
am besten von Hand schreibt

01:32:42.520 --> 01:32:44.520
wurde gemerkt von verschiedenen Varianten

01:32:44.520 --> 01:32:46.520
und auch

01:32:46.520 --> 01:32:48.520
da fragt man sich ist das wirklich

01:32:48.520 --> 01:32:50.520
das Abstraktionsniveau mit dem ich

01:32:50.520 --> 01:32:52.520
mich als Anwendungsentwicklerin oder als

01:32:52.520 --> 01:32:54.520
Anwendungsentwickler heutzutage

01:32:54.520 --> 01:32:56.520
auseinandersetzen sollen müsste

01:32:56.520 --> 01:32:58.520
wenn ich einfach nur eine Anwendung entwickeln

01:32:58.520 --> 01:33:00.520
will oder ist das nicht ein bisschen zu technisch

01:33:00.520 --> 01:33:02.520
und vielleicht ein bisschen zu viele

01:33:02.520 --> 01:33:04.520
unter der Haube Details die irgendwie

01:33:04.520 --> 01:33:06.520
falsch abstrahiert wurden

01:33:06.520 --> 01:33:08.520
und solche Beispiele. Ja da tut sich

01:33:08.520 --> 01:33:10.520
das stimmt schon da tut sich Microsoft ein bisschen

01:33:10.520 --> 01:33:12.520
schwer manchmal verstehe ich auch nicht so genau

01:33:12.520 --> 01:33:14.520
es ist wie Sand am

01:33:14.520 --> 01:33:16.520
Meer

01:33:16.520 --> 01:33:18.520
da will ich jetzt nicht auf alle näher eingehen

01:33:18.520 --> 01:33:20.520
aber um einfach noch ein paar Stichpunkte zu nennen

01:33:20.520 --> 01:33:22.520
warum gibt es isnull und

01:33:22.520 --> 01:33:24.520
gleichgleichnull wenn ich auf null testen will

01:33:24.520 --> 01:33:26.520
weil Pattern

01:33:26.520 --> 01:33:28.520
Matching. Using als Statement

01:33:28.520 --> 01:33:30.520
und Using als Blog und so weiter

01:33:30.520 --> 01:33:32.520
weil

01:33:32.520 --> 01:33:34.520
Using im Blog

01:33:34.520 --> 01:33:36.520
uu alt ist und

01:33:36.520 --> 01:33:38.520
Using quasi im Statement

01:33:38.520 --> 01:33:40.520
die

01:33:40.520 --> 01:33:42.520
neuere Variante die das für dich rappt

01:33:42.520 --> 01:33:44.520
die ich persönlich deutlich schöner finde

01:33:44.520 --> 01:33:46.520
wie Using als Blog

01:33:46.520 --> 01:33:48.520
und du

01:33:48.520 --> 01:33:50.520
konntest das alte halt nicht rausschmeißen weil Rückwärts

01:33:50.520 --> 01:33:52.520
Kompatibilität. Das ist auch ein Punkt

01:33:52.520 --> 01:33:54.520
finde ich da übertreibt es Microsoft

01:33:54.520 --> 01:33:56.520
tatsächlich ein bisschen

01:33:56.520 --> 01:33:58.520
ich finde man könnte durchaus mal

01:33:58.520 --> 01:34:00.520
alle 5 Jahre

01:34:00.520 --> 01:34:02.520
oder so hergehen

01:34:02.520 --> 01:34:04.520
und ein paar so gut wie nicht verwendete Legacy Sachen

01:34:04.520 --> 01:34:06.520
wieder rausschmeißen

01:34:06.520 --> 01:34:08.520
Konsistenzen bzw.

01:34:08.520 --> 01:34:10.520
unterschiedliche Wege die historisch bedingt sind

01:34:10.520 --> 01:34:12.520
die alle jeweils mehr oder weniger

01:34:12.520 --> 01:34:14.520
zum gleichen Ziel führen

01:34:14.520 --> 01:34:16.520
oder zumindest die vollmäßig

01:34:16.520 --> 01:34:18.520
deaktivieren

01:34:18.520 --> 01:34:20.520
ihre Syntax unterscheiden aber letztlich das

01:34:20.520 --> 01:34:22.520
gleiche bewirken die sich in der Regel aber dann

01:34:22.520 --> 01:34:24.520
doch durch feine Kleinigkeiten unterscheiden

01:34:24.520 --> 01:34:26.520
und das ist fehleranfällig

01:34:26.520 --> 01:34:28.520
und das führt wenn man diese Feinheiten ernst nehmen

01:34:28.520 --> 01:34:30.520
möchte zu vielen technischen Diskussionen

01:34:30.520 --> 01:34:32.520
die einen beim lösen des eigentlichen

01:34:32.520 --> 01:34:34.520
fachlichen Problems nicht weiter

01:34:34.520 --> 01:34:36.520
helfen. Ich finde man sieht an diesem

01:34:36.520 --> 01:34:38.520
Beispiel eigentlich schon ganz schön dass man

01:34:38.520 --> 01:34:40.520
eben sieht das C-Sharp historisch gewachsen ist

01:34:40.520 --> 01:34:42.520
dass es sich weiterentwickelt hat

01:34:42.520 --> 01:34:44.520
und dass es über den Initial am Reißbrett mal

01:34:44.520 --> 01:34:46.520
geplante Sprache inzwischen längst hinaus

01:34:46.520 --> 01:34:48.520
gewachsen ist. Und das ist einerseits

01:34:48.520 --> 01:34:50.520
gut aber es sind halt viele Punkte wo ich mich

01:34:50.520 --> 01:34:52.520
frage. Man muss aber auch sagen Microsoft

01:34:52.520 --> 01:34:54.520
legt da wirklich ein ordentliches Tempo vor

01:34:54.520 --> 01:34:56.520
also ich meine die haben

01:34:56.520 --> 01:34:58.520
jedes Jahr eine neue.NET Version die haben

01:34:58.520 --> 01:35:00.520
quasi jedes Jahr eine neue C-Sharp Version die legen

01:35:00.520 --> 01:35:02.520
schon ordentliches Tempo vor. Ich finde auch

01:35:02.520 --> 01:35:04.520
manche Sachen müssten echt nicht sein

01:35:04.520 --> 01:35:06.520
es sind die letzten Jahre einige Sachen in die

01:35:06.520 --> 01:35:08.520
Sprachen gekommen

01:35:08.520 --> 01:35:10.520
mir fehlen jetzt so aus dem Kopf raus

01:35:10.520 --> 01:35:12.520
leider wie gesagt mir fallen bloß jetzt gerade die

01:35:12.520 --> 01:35:14.520
Default Interfaces ein und sowas

01:35:14.520 --> 01:35:16.520
wo man sich so fragt wa gut

01:35:16.520 --> 01:35:18.520
hätt's das jetzt wirklich

01:35:18.520 --> 01:35:20.520
sein müssen

01:35:22.520 --> 01:35:24.520
ja also

01:35:24.520 --> 01:35:26.520
da kann man sich über viele Sachen sicherlich

01:35:26.520 --> 01:35:28.520
streiten

01:35:28.520 --> 01:35:30.520
wie stellt man denn im Laufe der Jahre

01:35:30.520 --> 01:35:32.520
fünf Timer Klassen zur Verfügung

01:35:32.520 --> 01:35:34.520
statt die erste davon zu verbessern

01:35:34.520 --> 01:35:36.520
und weiterzuentwickeln? Ich vermute

01:35:36.520 --> 01:35:38.520
mal das liegt daran weil die erste

01:35:38.520 --> 01:35:40.520
irgendein Rapper um Windows Timer war

01:35:40.520 --> 01:35:42.520
für Windows Forms. Das nächste als

01:35:42.520 --> 01:35:44.520
andere Ding ist für WPF

01:35:44.520 --> 01:35:46.520
und dann gab es irgendwie noch

01:35:46.520 --> 01:35:48.520
mal einen Threading Timer als Unabhängigen

01:35:48.520 --> 01:35:50.520
und der war halt kacke

01:35:50.520 --> 01:35:52.520
und irgendwann hat man gesagt mir

01:35:52.520 --> 01:35:54.520
macht es jetzt richtig und hat diese Periodic

01:35:54.520 --> 01:35:56.520
Timer Klasse eingeführt

01:35:56.520 --> 01:35:58.520
wobei ich die auch nicht gut finde

01:36:00.520 --> 01:36:02.520
das ist irgendwo nicht

01:36:02.520 --> 01:36:04.520
zielführend und das ist ganz sicher

01:36:04.520 --> 01:36:06.520
alles aber nicht keep it simple

01:36:06.520 --> 01:36:08.520
wobei ich persönlich

01:36:08.520 --> 01:36:10.520
diese Sachen gar nicht verwende

01:36:10.520 --> 01:36:12.520
wenn es nicht sein muss

01:36:12.520 --> 01:36:14.520
ich benutze die Reactive

01:36:14.520 --> 01:36:16.520
Extensions für solche Sachen

01:36:16.520 --> 01:36:18.520
und die finde ich ziemlich nice

01:36:18.520 --> 01:36:20.520
Kategorie den wie ich sie vorhin glaube ich

01:36:20.520 --> 01:36:22.520
genannt habe den Verschlimmbesserungen

01:36:22.520 --> 01:36:24.520
C Sharp liegt aktuell in Version 10

01:36:24.520 --> 01:36:26.520
vor. Im November erscheint Version 11

01:36:26.520 --> 01:36:28.520
und wenn wir uns die Versionsgeschichte anschauen

01:36:28.520 --> 01:36:30.520
dann war die bis zur Version 5

01:36:30.520 --> 01:36:32.520
relativ klar strukturiert. Version 1

01:36:32.520 --> 01:36:34.520
war halt die erste Version

01:36:34.520 --> 01:36:36.520
Version 2 hat generische Datentypen

01:36:36.520 --> 01:36:38.520
eingeführt. Version 3 war dann

01:36:38.520 --> 01:36:40.520
Link also die language integrated

01:36:40.520 --> 01:36:42.520
Das stimmt schon. Da hatten wir es ja gerade die Sprache

01:36:42.520 --> 01:36:44.520
und Framework sind zwar unterschiedlich paar Schuhe

01:36:44.520 --> 01:36:46.520
aber wie soll er den Titel denn sonst

01:36:46.520 --> 01:36:48.520
anders schreiben? Zumal das bei Microsoft auch

01:36:48.520 --> 01:36:50.520
alles relativ eng miteinander

01:36:50.520 --> 01:36:52.520
verheiratet ist. Neues

01:36:52.520 --> 01:36:54.520
Release ist auch das Release

01:36:54.520 --> 01:36:56.520
wo dann eine neue C Sharp Version kommt

01:36:56.520 --> 01:36:58.520
sind zwar unterschiedlich paar Schuhe

01:36:58.520 --> 01:37:00.520
aber Microsoft ist alles so ein Sack

01:37:00.520 --> 01:37:02.520
und die damit verbundenen

01:37:02.520 --> 01:37:04.520
Sprachmerkmale Version 4 war

01:37:04.520 --> 01:37:06.520
im wesentlichen die Erweiterung mit Dynamic

01:37:06.520 --> 01:37:08.520
und Version 5

01:37:08.520 --> 01:37:10.520
3 war Link oder?

01:37:10.520 --> 01:37:12.520
hat er glaube ich gesagt

01:37:12.520 --> 01:37:14.520
Version 2 hat generische Datentypen

01:37:14.520 --> 01:37:16.520
eingeführt. Version 3 war dann Link

01:37:16.520 --> 01:37:18.520
also die language integrated Query Syntax

01:37:18.520 --> 01:37:20.520
und die damit verbundenen Sprachmerkmale

01:37:20.520 --> 01:37:22.520
Version 4 war im wesentlichen die Erweiterung

01:37:22.520 --> 01:37:24.520
Link vermisse ich ja in Go ein bisschen

01:37:24.520 --> 01:37:26.520
muss ich sagen

01:37:26.520 --> 01:37:28.520
es gibt jetzt ja Generics in Go und es gibt

01:37:28.520 --> 01:37:30.520
jetzt ein paar Sachen quasi mit den Go Generics

01:37:30.520 --> 01:37:32.520
Link ein bisschen nachzubauen. Link finde ich das eine coole

01:37:32.520 --> 01:37:34.520
Sache. Hätte ich gerne in mehr Sprachen

01:37:34.520 --> 01:37:36.520
mit Dynamic und in Version 5

01:37:36.520 --> 01:37:38.520
kamen Async und Await

01:37:38.520 --> 01:37:40.520
hinzu. Danach also ab C Sharp 6

01:37:40.520 --> 01:37:42.520
haben die Version jeweils

01:37:42.520 --> 01:37:44.520
nicht mehr so einen klaren Schwerpunkt. Es war dann

01:37:44.520 --> 01:37:46.520
eher so ein bisschen was mal hier

01:37:46.520 --> 01:37:48.520
ein bisschen was da. Das war auch das wo sich anders

01:37:48.520 --> 01:37:50.520
wie spricht man den Kerl eigentlich

01:37:50.520 --> 01:37:52.520
korrekt aus. Man spricht ihn ja

01:37:52.520 --> 01:37:54.520
gar nicht anders an das Halsberg

01:37:54.520 --> 01:37:56.520
aus. Wahrscheinlich irgendwie norwegisch

01:37:56.520 --> 01:37:58.520
spricht man ihn aus.

01:37:58.520 --> 01:38:00.520
Der ist ja dann weg. Der hat

01:38:00.520 --> 01:38:02.520
später dann Typescript erfunden

01:38:02.520 --> 01:38:04.520
der ist weg und ich glaube

01:38:04.520 --> 01:38:06.520
das war halt auch die Zeit wo dann

01:38:06.520 --> 01:38:08.520
bisschen so die Feature Rittes angefangen

01:38:08.520 --> 01:38:10.520
hat für C Sharp und

01:38:10.520 --> 01:38:12.520
nicht alles mal bis zu Ende gedacht war.

01:38:12.520 --> 01:38:14.520
ein bisschen

01:38:14.520 --> 01:38:16.520
funktionale Konzepte, ein bisschen was aus der

01:38:16.520 --> 01:38:18.520
Community vielleicht noch

01:38:18.520 --> 01:38:20.520
den ein oder anderen neuen Operator

01:38:20.520 --> 01:38:22.520
was halt gerade irgendwie so

01:38:22.520 --> 01:38:24.520
halbwegs gepasst hat. Und auf der einen

01:38:24.520 --> 01:38:26.520
Seite ist das natürlich auch schön

01:38:26.520 --> 01:38:28.520
weil auf die Art ja auch interessante Features

01:38:28.520 --> 01:38:30.520
ihren Weg in C Sharp hineingefunden waren. Und Timer

01:38:30.520 --> 01:38:32.520
neue Timer. Zum Beispiel das Pattern Matching

01:38:32.520 --> 01:38:34.520
was ich persönlich sehr gelungen finde. Pattern Matching

01:38:34.520 --> 01:38:36.520
gerade, gerade

01:38:36.520 --> 01:38:38.520
seit der letzten Version Pattern Matching ist wirklich

01:38:38.520 --> 01:38:40.520
nice mittlerweile. Doch auch sehr deutlich

01:38:40.520 --> 01:38:42.520
es ist leider nicht so richtig intuitiv

01:38:42.520 --> 01:38:44.520
für

01:38:44.520 --> 01:38:46.520
mich oftmals benutzbar. Also

01:38:46.520 --> 01:38:48.520
ich tue mir da teilweise noch schwer

01:38:48.520 --> 01:38:50.520
weil ich jetzt and oder or oder und und

01:38:50.520 --> 01:38:52.520
und so verwenden muss.

01:38:52.520 --> 01:38:54.520
Es ist aber Gewöhnungssache. Pattern Matching

01:38:54.520 --> 01:38:56.520
ist wirklich eine äußerst nice Sache.

01:38:56.520 --> 01:38:58.520
Version 6 irgendwo der rote Faden fehlt

01:38:58.520 --> 01:39:00.520
und es zeigt sich auch, dass nicht jede

01:39:00.520 --> 01:39:02.520
wenn auch vielleicht gut gemeinte

01:39:02.520 --> 01:39:04.520
Veränderung auch tatsächlich eine

01:39:04.520 --> 01:39:06.520
gelungene Verbesserung in der Praxis

01:39:06.520 --> 01:39:08.520
darstellt. Inzwischen gibt es in C Sharp

01:39:08.520 --> 01:39:10.520
nämlich eine ganze Reihe an Sprachkonstrukten

01:39:10.520 --> 01:39:12.520
die zwar dazu führen, dass man weniger Code

01:39:12.520 --> 01:39:14.520
machen muss, aber halt das Ganze geht

01:39:14.520 --> 01:39:16.520
halt in der Regel leider zulasten der Lesbarkeit.

01:39:16.520 --> 01:39:18.520
Prominentes Beispiel dafür in C

01:39:18.520 --> 01:39:20.520
Sharp sind die Global Usings.

01:39:20.520 --> 01:39:22.520
Die Idee ist... Ja das ist unsinnig.

01:39:22.520 --> 01:39:24.520
Das verstehe ich auch nicht warum

01:39:24.520 --> 01:39:26.520
es das gibt.

01:39:26.520 --> 01:39:28.520
Verwende ich auch nicht.

01:39:28.520 --> 01:39:30.520
Also ja macht es theoretisch ein bisschen übersichtlicher.

01:39:30.520 --> 01:39:32.520
Ganz ehrlich könnte mir nicht

01:39:32.520 --> 01:39:34.520
egaler sein das Feature.

01:39:34.520 --> 01:39:36.520
Wo man halt sagen muss Go ist

01:39:36.520 --> 01:39:38.520
da auch so. Go

01:39:38.520 --> 01:39:40.520
ist das andere Extrem.

01:39:40.520 --> 01:39:42.520
In Go machst du dann

01:39:42.520 --> 01:39:44.520
kein Array

01:39:44.520 --> 01:39:46.520
Filter, sondern machst zwei

01:39:46.520 --> 01:39:48.520
Nested Schleifen und sowas.

01:39:48.520 --> 01:39:50.520
Das ist dann schon wieder zu viel das Guten.

01:39:50.520 --> 01:39:52.520
In diesem Namespace enthaltenen

01:39:52.520 --> 01:39:54.520
Typen automatisch projektweit

01:39:54.520 --> 01:39:56.520
zur Verfügung stehen. Das

01:39:56.520 --> 01:39:58.520
reduziert wie gesagt den Schreibaufwand

01:39:58.520 --> 01:40:00.520
verschleiert aber völlig was eigentlich

01:40:00.520 --> 01:40:02.520
alles importiert wird, was woher

01:40:02.520 --> 01:40:04.520
kommt, was wo zur Verfügung steht. Ja das stimmt.

01:40:04.520 --> 01:40:06.520
Global Usings ist auch so ein Ding was ich

01:40:06.520 --> 01:40:08.520
verstehe warum man das braucht.

01:40:08.520 --> 01:40:10.520
Das bedeutet man das nun vor dem Hintergrund

01:40:10.520 --> 01:40:12.520
dass praktisch jeder Editor und jede IDI

01:40:12.520 --> 01:40:14.520
ja ohnehin Unterstützung für das Verwalten

01:40:14.520 --> 01:40:16.520
der Usings enthält, sodass man sich da

01:40:16.520 --> 01:40:18.520
Alt Enter Import fertig.

01:40:18.520 --> 01:40:20.520
Dann ergibt das Feature irgendwie nicht so unglaublich

01:40:20.520 --> 01:40:22.520
viel Sinn.

01:40:22.520 --> 01:40:24.520
Ein zweites Beispiel dafür ist

01:40:24.520 --> 01:40:26.520
Using Static. Das ist quasi das gleiche in grün.

01:40:26.520 --> 01:40:28.520
Importiere ich eine Klasse auf dem Weg

01:40:28.520 --> 01:40:30.520
führt das dazu, dass ich die in ihr

01:40:30.520 --> 01:40:32.520
enthaltenen statischen Methoden direkt

01:40:32.520 --> 01:40:34.520
aufrufen kann, ohne sie mit dem Namen

01:40:34.520 --> 01:40:38.520
der Klasse prefixen zu müssen.

01:40:38.520 --> 01:40:40.520
Habe ich glaube ich legit

01:40:40.520 --> 01:40:42.520
noch nie verwendet. Kann man zum Beispiel

01:40:42.520 --> 01:40:44.520
einfach WriteLine anstatt

01:40:44.520 --> 01:40:46.520
Konsolerein schreiben.

01:40:46.520 --> 01:40:48.520
Auch da gilt wieder. Keine Ahnung, verwende ich nicht.

01:40:48.520 --> 01:40:50.520
Aber ganz ehrlich wozu?

01:40:50.520 --> 01:40:52.520
Wo liegt denn da der große Ding? Das ist was das

01:40:52.520 --> 01:40:54.520
Microsoft in den Demos zeigen kann.

01:40:54.520 --> 01:40:56.520
Wie cool sie sind. Auf mich persönlich

01:40:56.520 --> 01:40:58.520
wirkt das ein bisschen wie der schlechte Workaround

01:40:58.520 --> 01:41:00.520
dafür, dass man Funktionen in C

01:41:00.520 --> 01:41:02.520
Sharp nach wie vor nicht einfach auf

01:41:02.520 --> 01:41:04.520
der grünen Wiese, also ohne umgebende

01:41:04.520 --> 01:41:06.520
Klasse definieren kann, sondern dass

01:41:06.520 --> 01:41:08.520
man sie halt immer in eine zweifelsfall

01:41:08.520 --> 01:41:10.520
statische Klasse stecken muss und

01:41:10.520 --> 01:41:12.520
das wird jetzt dadurch halt irgendwie so ein bisschen

01:41:12.520 --> 01:41:14.520
verschleiert. Und das ergibt sogar irgendwo

01:41:14.520 --> 01:41:16.520
Sinn vor dem Hintergrund, dass

01:41:16.520 --> 01:41:18.520
Microsoft ja versucht mehr funktionale

01:41:18.520 --> 01:41:20.520
Elemente in C Sharp hineinzubringen.

01:41:20.520 --> 01:41:22.520
Das stimmt, aber das finde ich nicht schlimm.

01:41:22.520 --> 01:41:24.520
Ich meine, wenn du wirklich einfach

01:41:24.520 --> 01:41:26.520
nur so eine Funktionssammlung

01:41:26.520 --> 01:41:28.520
haben willst, die du untereinander schreiben würdest,

01:41:28.520 --> 01:41:30.520
dann machst du genau, machst du halt eine

01:41:30.520 --> 01:41:32.520
statische Klasse, nennst die

01:41:32.520 --> 01:41:34.520
im Zweifelsfall Functions, wenn dir nichts

01:41:34.520 --> 01:41:36.520
besseres einfällt,

01:41:36.520 --> 01:41:38.520
und schreibst

01:41:38.520 --> 01:41:40.520
den Kram da untereinander rein.

01:41:42.520 --> 01:41:44.520
Also,

01:41:44.520 --> 01:41:46.520
da kannst du die statische Klasse ein bisschen wie den

01:41:46.520 --> 01:41:48.520
Namespace drum herum sehen. Das finde ich jetzt nicht so wild.

01:41:48.520 --> 01:41:50.520
Funktionalen

01:41:50.520 --> 01:41:52.520
Sprache kann man natürlich Funktionen

01:41:52.520 --> 01:41:54.520
einfach so ohne Klassen definieren,

01:41:54.520 --> 01:41:56.520
deswegen heißt es ja auch Funktionale

01:41:56.520 --> 01:41:58.520
Programmierung, aber irgendwie fühlt sich das halt

01:41:58.520 --> 01:42:00.520
eher so an, als wenn man das Pferd von hinten aufzog.

01:42:00.520 --> 01:42:02.520
Gut, man kann Local Functions mittlerweile machen.

01:42:02.520 --> 01:42:04.520
Es ist ein merkwürdiger Workaround für ein eigentlich tiefer liegendes

01:42:04.520 --> 01:42:06.520
und konzeptionelles Problem der Sprache,

01:42:06.520 --> 01:42:08.520
und dieses Problem wird halt nicht gelöst,

01:42:08.520 --> 01:42:10.520
es wird einfach nur verschleiert. Und ganz

01:42:10.520 --> 01:42:12.520
schlimm wird es meiner Meinung nach, wenn man dann Global

01:42:12.520 --> 01:42:14.520
Using und Using Static auch noch zu

01:42:14.520 --> 01:42:16.520
Global Using Static kombiniert,

01:42:16.520 --> 01:42:18.520
was auch noch möglich ist. Ah gut, ganz ehrlich,

01:42:18.520 --> 01:42:20.520
ich habe beides glaube ich noch nie

01:42:20.520 --> 01:42:22.520
verwendet und hab's auch nicht vor. Ob das nicht genügen

01:42:22.520 --> 01:42:24.520
würde, das Ganze muss dann noch nicht mal

01:42:24.520 --> 01:42:26.520
mehr im Code stehen, man kann es auch

01:42:26.520 --> 01:42:28.520
mit Projektdatei als XML

01:42:28.520 --> 01:42:30.520
eintragen, und das ist so der Punkt, wo ich mich

01:42:30.520 --> 01:42:32.520
halt unwillkündig... Also,

01:42:32.520 --> 01:42:34.520
das ist dann schon

01:42:34.520 --> 01:42:36.520
obfoscated C-Sharp

01:42:36.520 --> 01:42:38.520
Contest, den du damit

01:42:38.520 --> 01:42:40.520
gewinnen kannst, mit

01:42:40.520 --> 01:42:42.520
Imports in

01:42:42.520 --> 01:42:44.520
diesem Project

01:42:44.520 --> 01:42:46.520
XML-Ding.

01:42:46.520 --> 01:42:48.520
Also wer das macht, weiß ich, hab ich noch nicht

01:42:48.520 --> 01:42:50.520
gesehen. Wenn ich tatsächlich

01:42:50.520 --> 01:42:52.520
frage, wer um alles in der Welt

01:42:52.520 --> 01:42:54.520
hat denn bei Microsoft gedacht, dass das

01:42:54.520 --> 01:42:56.520
eine gute Idee wäre. Ja, das stimmt schon.

01:42:56.520 --> 01:42:58.520
Das ist unsinnig. Das dritte und letzte

01:42:58.520 --> 01:43:00.520
Beispiel für die Verschlimmbesserungen,

01:43:00.520 --> 01:43:02.520
für ihre Demos vielleicht.

01:43:02.520 --> 01:43:04.520
Diese ermöglichen, dass man keine Main-Funktion mehr

01:43:04.520 --> 01:43:06.520
schreiben muss, sondern den eigentlich darin

01:43:06.520 --> 01:43:08.520
enthaltenen Code nun einfach so

01:43:08.520 --> 01:43:10.520
in der C-Sharp-Datei schreiben kann. Das Ganze

01:43:10.520 --> 01:43:12.520
soll den Einstieg erleichtern, denn

01:43:12.520 --> 01:43:14.520
auf dem Weg fühlt sich C-Sharp ein bisschen mehr

01:43:14.520 --> 01:43:16.520
wie eine Skriptsprache an, auch wenn

01:43:16.520 --> 01:43:18.520
es das im Hintergrund natürlich eigentlich

01:43:18.520 --> 01:43:20.520
nicht ist. Und das Problem dabei ist...

01:43:20.520 --> 01:43:22.520
Ich mag Top-Level-Statements auf der einen Seite und

01:43:22.520 --> 01:43:24.520
auf der anderen Seite nicht.

01:43:24.520 --> 01:43:26.520
Also Top-Level-Statements ist zum Beispiel,

01:43:26.520 --> 01:43:28.520
dass wenn ich

01:43:28.520 --> 01:43:30.520
Konsolenanwendungen

01:43:30.520 --> 01:43:32.520
anlege,

01:43:32.520 --> 01:43:34.520
ich direkt quasi

01:43:34.520 --> 01:43:36.520
Console-Write-Line-Hello-World schreiben kann,

01:43:36.520 --> 01:43:38.520
anstatt

01:43:38.520 --> 01:43:40.520
dass

01:43:40.520 --> 01:43:42.520
ich

01:43:42.520 --> 01:43:44.520
Program, Main und was auch immer

01:43:44.520 --> 01:43:46.520
machen muss. Ist auf der einen Seite

01:43:46.520 --> 01:43:48.520
ganz gut, weil für kurze Sachen

01:43:48.520 --> 01:43:50.520
übersichtlicher.

01:43:50.520 --> 01:43:52.520
Auf der anderen Seite ist es relativ viel

01:43:52.520 --> 01:43:54.520
Magic.

01:43:54.520 --> 01:43:56.520
Was ist denn jetzt schon wieder?

01:43:56.520 --> 01:43:58.520
Toss. Leute, was habe ich

01:43:58.520 --> 01:44:00.520
vergessen? Was ist Toss?

01:44:02.520 --> 01:44:04.520
Auf der anderen Seite ist es ein bisschen Magic, weil es gibt

01:44:04.520 --> 01:44:06.520
diese Datei nur einmalig.

01:44:08.520 --> 01:44:10.520
Und du kannst sie auch nicht doppelt anlegen,

01:44:10.520 --> 01:44:12.520
da gibt es einen Fehler.

01:44:14.520 --> 01:44:16.520
Letztendlich finde ich es auch nicht so wild,

01:44:16.520 --> 01:44:18.520
wenn man

01:44:18.520 --> 01:44:20.520
Static-Main

01:44:20.520 --> 01:44:22.520
hinschreibt.

01:44:22.520 --> 01:44:24.520
Also, ja, weiß nicht.

01:44:26.520 --> 01:44:28.520
Damit das funktioniert,

01:44:28.520 --> 01:44:30.520
im Hintergrund ganz viel böse

01:44:30.520 --> 01:44:32.520
Compiler-Magie laufen muss,

01:44:32.520 --> 01:44:34.520
dass der Compiler erkennt, was von dem Code

01:44:34.520 --> 01:44:36.520
in der Datei gehört denn nun in die Main-Funktion,

01:44:36.520 --> 01:44:38.520
was nicht. Und dann separiert

01:44:38.520 --> 01:44:40.520
er das Ganze mehr oder weniger intelligent

01:44:40.520 --> 01:44:42.520
und natürlich, wie sollte es auch

01:44:42.520 --> 01:44:44.520
anders sein, stößt man dabei über kurz

01:44:44.520 --> 01:44:46.520
oder lang an gewisse Grenzen.

01:44:46.520 --> 01:44:48.520
Als Einsteigerin oder als Einsteiger

01:44:48.520 --> 01:44:50.520
verwirrt das Ganze dann viel eher, als dass es

01:44:50.520 --> 01:44:52.520
nützt. Und für jemanden mit fortgeschrittenen

01:44:52.520 --> 01:44:54.520
Kenntnissen und Fähigkeiten ist das Ganze

01:44:54.520 --> 01:44:56.520
eher lästig, weil man dann unter Umständen

01:44:56.520 --> 01:44:58.520
umständlich erstmal all das umbauen

01:44:58.520 --> 01:45:00.520
muss, was man sich vorher vermeintlich

01:45:00.520 --> 01:45:02.520
gespart hat. Ich glaube,

01:45:02.520 --> 01:45:04.520
der Grund ist, warum es das gibt,

01:45:04.520 --> 01:45:06.520
weil Microsoft quasi so

01:45:06.520 --> 01:45:08.520
cool wie Python sein will und das

01:45:08.520 --> 01:45:10.520
aktuell eine der Hype-Sprachen ist.

01:45:10.520 --> 01:45:12.520
Und die wollten einfach in Demos zeigen,

01:45:12.520 --> 01:45:14.520
guckt mal, wir können das jetzt auch in einer

01:45:14.520 --> 01:45:16.520
Zeile. Gebraucht

01:45:16.520 --> 01:45:18.520
hätte es echt keiner.

01:45:18.520 --> 01:45:20.520
Es ist auf der einen Seite nice, aber auf der

01:45:20.520 --> 01:45:22.520
anderen Seite auch irgendwie

01:45:22.520 --> 01:45:24.520
nicht. Also

01:45:24.520 --> 01:45:26.520
ich benutze es, weil es defaultmäßig

01:45:26.520 --> 01:45:28.520
so eingerichtet ist. Gebraucht

01:45:28.520 --> 01:45:30.520
hätte ich es ehrlich gesagt auch nicht.

01:45:30.520 --> 01:45:32.520
... dass man eigentlich gar nichts spart,

01:45:32.520 --> 01:45:34.520
sondern das Feature, wenn man nicht gerade nur

01:45:34.520 --> 01:45:36.520
ein Hallo-Welt-Programm schreibt, eher

01:45:36.520 --> 01:45:38.520
lästig ist. Und das Schlimme ist auch

01:45:38.520 --> 01:45:40.520
hier wieder, das Feature verschleiert

01:45:40.520 --> 01:45:42.520
das eigentliche Problem, denn

01:45:42.520 --> 01:45:44.520
es ist nicht schwierig, wenn man

01:45:44.520 --> 01:45:46.520
anfängt zu programmieren, eine Main-

01:45:46.520 --> 01:45:48.520
Funktion zu definieren. Was schwierig

01:45:48.520 --> 01:45:50.520
ist, das sind die ganzen Konstrukte, die man

01:45:50.520 --> 01:45:52.520
in C-Sharp zusätzlich noch benötigt.

01:45:52.520 --> 01:45:54.520
Eine Klasse, eine Namespace,

01:45:54.520 --> 01:45:56.520
das Static-Keyword, weil die

01:45:56.520 --> 01:45:58.520
Main-Funktion Static sein muss und so weiter.

01:45:58.520 --> 01:46:00.520
Trotzdem, ich muss sagen, für mich

01:46:00.520 --> 01:46:02.520
ist C-Sharp immer noch die angenehmste

01:46:02.520 --> 01:46:04.520
Sprache überhaupt. Also ohne Klassen

01:46:04.520 --> 01:46:06.520
definieren, dann wäre das sehr viel einfacher.

01:46:06.520 --> 01:46:08.520
Auch für mich angenehmer als Go. Dann bräuchten wir auch keine Top-Level-Statements,

01:46:08.520 --> 01:46:10.520
weniger Compiler-Magie und

01:46:10.520 --> 01:46:12.520
es würde zugleich auch solche Konstrukte

01:46:12.520 --> 01:46:14.520
wie Using Static überflüssig machen.

01:46:14.520 --> 01:46:16.520
In Go funktioniert das ja schließlich auch.

01:46:16.520 --> 01:46:18.520
Oder in JavaScript.

01:46:18.520 --> 01:46:20.520
Oder in TypeScript. Oder in C.

01:46:20.520 --> 01:46:22.520
Oder in Python. Oder in so ziemlich

01:46:22.520 --> 01:46:24.520
jeder anderen Sprache. Warum

01:46:24.520 --> 01:46:26.520
Microsoft da so hartnäckig dran festhält,

01:46:26.520 --> 01:46:28.520
dass in C-Sharp jede Funktion

01:46:28.520 --> 01:46:30.520
immer zwingend innerhalb

01:46:30.520 --> 01:46:32.520
einer Klasse definiert werden muss, auch wenn das

01:46:32.520 --> 01:46:34.520
überhaupt keinen Sinn macht, das erschließt

01:46:34.520 --> 01:46:36.520
sich mir persönlich einfach nicht.

01:46:36.520 --> 01:46:38.520
Apropos, erschließt sich mir nicht,

01:46:38.520 --> 01:46:40.520
das ist die perfekte Überleitung zur Kategorie

01:46:40.520 --> 01:46:42.520
3, nämlich warum

01:46:42.520 --> 01:46:44.520
zum Kuckuck funktionieren

01:46:44.520 --> 01:46:46.520
gewisse Dinge in C-Sharp eigentlich nicht.

01:46:46.520 --> 01:46:48.520
Und da ist das erste Beispiel relativ einfach.

01:46:48.520 --> 01:46:50.520
Warum kann ich in C-Sharp keinen

01:46:50.520 --> 01:46:52.520
Yield-Return innerhalb eines

01:46:52.520 --> 01:46:54.520
Try-Catch-Blocks ausführen? Wieso geht das nicht?

01:46:54.520 --> 01:46:56.520
In anderen Sprachen ist das problemlos

01:46:56.520 --> 01:46:58.520
möglich. Gute Frage.

01:46:58.520 --> 01:47:00.520
Zum Beispiel in JavaScript und in TypeScript.

01:47:00.520 --> 01:47:02.520
Es kann also kein grundsätzlich konzeptionelles

01:47:02.520 --> 01:47:04.520
Problem sein. Und natürlich gibt es auch

01:47:04.520 --> 01:47:06.520
Workarounds. Man merkt sich... Also der

01:47:06.520 --> 01:47:08.520
meint im Prinzip sowas hier.

01:47:08.520 --> 01:47:10.520
Also wenn ich irgendeine Funktion habe,

01:47:10.520 --> 01:47:12.520
da drin habe ich irgendwie eine Schleife

01:47:12.520 --> 01:47:14.520
for each, keine Ahnung,

01:47:14.520 --> 01:47:16.520
var, blub in

01:47:16.520 --> 01:47:18.520
blubs.

01:47:18.520 --> 01:47:20.520
Oder machen wir anders,

01:47:20.520 --> 01:47:22.520
wir machen eine Vorschleife.

01:47:22.520 --> 01:47:24.520
Alter,

01:47:24.520 --> 01:47:26.520
ich habe keine...

01:47:26.520 --> 01:47:28.520
Was ist das? Keine

01:47:28.520 --> 01:47:30.520
Snippets oder was? Jetzt muss ich das vorne

01:47:30.520 --> 01:47:32.520
von Hand machen. Ich habe glaube ich seit 5 Jahren

01:47:32.520 --> 01:47:34.520
keine Vorschleife mehr von Hand. Wie sieht das

01:47:34.520 --> 01:47:36.520
jetzt aus? I, kleiner, 10,

01:47:36.520 --> 01:47:38.520
I++, irgendwie so, gell?

01:47:38.520 --> 01:47:40.520
So,

01:47:40.520 --> 01:47:42.520
Ehm,

01:47:42.520 --> 01:47:44.520
Eield-Return, I, so,

01:47:44.520 --> 01:47:46.520
sowas in der Richtung weiter. So, und wenn jetzt dieses

01:47:46.520 --> 01:47:48.520
I, sagen wir vielleicht nicht aus der

01:47:48.520 --> 01:47:50.520
Schleife kommt,

01:47:50.520 --> 01:47:52.520
sondern von irgendeinem

01:47:52.520 --> 01:47:54.520
HTTP-Request.

01:47:54.520 --> 01:47:56.520
Also sagen wir mal

01:47:56.520 --> 01:47:58.520
Try-Catch.

01:47:58.520 --> 01:48:00.520
Wie sieht denn das

01:48:00.520 --> 01:48:02.520
aus? Exceptions.

01:48:02.520 --> 01:48:04.520
Alter, ich muss jetzt ohne Sünder, ohne Completion

01:48:04.520 --> 01:48:06.520
und alles, gar nicht mehr gewohnt.

01:48:06.520 --> 01:48:08.520
So, also man kann jetzt beispielsweise

01:48:08.520 --> 01:48:10.520
nicht sowas hier machen anscheinend.

01:48:10.520 --> 01:48:12.520
Ist mir bis jetzt noch nicht

01:48:12.520 --> 01:48:14.520
aufgefallen, aber ist eine gute

01:48:14.520 --> 01:48:16.520
Frage, warum das nicht geht.

01:48:28.520 --> 01:48:30.520
Also, wahrscheinlich möchtest du dann

01:48:30.520 --> 01:48:32.520
was anderes machen. Wahrscheinlich möchtest du hier

01:48:32.520 --> 01:48:34.520
keine Ahnung, Get-Request

01:48:34.520 --> 01:48:36.520
gleich

01:48:36.520 --> 01:48:38.520
irgendwie was, ja, und dann willst du hier

01:48:38.520 --> 01:48:40.520
quasi den Get-Request machen.

01:48:40.520 --> 01:48:42.520
Am besten noch Async oder so, das

01:48:42.520 --> 01:48:44.520
Ganze. Und

01:48:44.520 --> 01:48:46.520
dann willst du hier Return und hier willst du wahrscheinlich

01:48:46.520 --> 01:48:48.520
mal angenommen, man will irgendwie sowas machen.

01:48:48.520 --> 01:48:50.520
Da wusste ich nicht, dass das nicht geht.

01:48:50.520 --> 01:48:52.520
Ich war doch nicht in der

01:48:52.520 --> 01:48:54.520
Situation jetzt, dass ich

01:48:54.520 --> 01:48:56.520
gebraucht habe, aber kann ich verstehen.

01:48:56.520 --> 01:49:00.520
Also ich erkenne den Anwendungszweck, ja.

01:49:00.520 --> 01:49:02.520
Einfach innerhalb des Try Blocks den gewünschten

01:49:02.520 --> 01:49:04.520
Wert und fühlt das Yield-Return dann

01:49:04.520 --> 01:49:06.520
danach aus. Aber das ist halt so

01:49:06.520 --> 01:49:08.520
unnötig umständlich. Und ich habe eine ganze Weile

01:49:08.520 --> 01:49:10.520
gesucht, ob ich Gründe finde, warum

01:49:10.520 --> 01:49:12.520
das in C Sharp konzeptionell nicht funktionieren

01:49:12.520 --> 01:49:14.520
sollte. Ich habe aber nichts

01:49:14.520 --> 01:49:16.520
gefunden. Und auf mich wirkt das Ganze

01:49:16.520 --> 01:49:18.520
ehrlich gesagt eher so, als ob das nicht

01:49:18.520 --> 01:49:20.520
gewünscht wäre und weniger

01:49:20.520 --> 01:49:22.520
als dass es dafür einen triftigen, technischen

01:49:22.520 --> 01:49:24.520
Grund gäbe. Wie gesagt, das würde

01:49:24.520 --> 01:49:26.520
mich in Anbetracht der Tatsache, dass es in anderen

01:49:26.520 --> 01:49:28.520
Sprachen ja anstandslos funktioniert, auch sehr wundern,

01:49:28.520 --> 01:49:30.520
wenn es dafür technische Gründe gäbe.

01:49:30.520 --> 01:49:32.520
Aber das macht es im Grunde genommen nur umso

01:49:32.520 --> 01:49:34.520
ärgerlicher. Und es mag sein,

01:49:34.520 --> 01:49:36.520
dass das viele Entwicklerinnen und Entwickler,

01:49:36.520 --> 01:49:38.520
die mit C Sharp arbeiten, überhaupt

01:49:38.520 --> 01:49:40.520
nicht stört. Muss ich sagen, ja.

01:49:40.520 --> 01:49:42.520
Weil sie einfach nicht mehr mit Yield arbeiten.

01:49:42.520 --> 01:49:44.520
Aber bei uns war bzw.

01:49:44.520 --> 01:49:46.520
bei uns ist das der Fall.

01:49:46.520 --> 01:49:48.520
Und dann ist so eine künstliche und im Prinzip

01:49:48.520 --> 01:49:50.520
völlig unnötige Einschränkung halt

01:49:50.520 --> 01:49:52.520
doch sehr lästig und führt

01:49:52.520 --> 01:49:54.520
zu länglichem und schlecht lesbarem Code.

01:49:54.520 --> 01:49:56.520
Das zweite Beispiel

01:49:56.520 --> 01:49:58.520
für wieso zum Coco geht das nicht,

01:49:58.520 --> 01:50:00.520
ist das komplette Fehlen von algebraischen

01:50:00.520 --> 01:50:02.520
Datentypen in C Sharp. Man kann

01:50:02.520 --> 01:50:04.520
nicht ausdrücken, dass eine Variable vom Typ

01:50:04.520 --> 01:50:06.520
X oder Y ist. Zum Beispiel um eine

01:50:06.520 --> 01:50:08.520
Liste zu definieren, die Werte vom Typ

01:50:08.520 --> 01:50:10.520
String oder Int enthält.

01:50:10.520 --> 01:50:12.520
Wofür braucht man das?

01:50:12.520 --> 01:50:14.520
Ich glaube, genau

01:50:14.520 --> 01:50:16.520
das, was er

01:50:16.520 --> 01:50:18.520
jetzt sagt, geht nicht.

01:50:18.520 --> 01:50:20.520
Aber

01:50:20.520 --> 01:50:22.520
seit.NET 7

01:50:22.520 --> 01:50:24.520
gibt es jetzt ja diese

01:50:24.520 --> 01:50:26.520
neue Interface-Geschichte,

01:50:26.520 --> 01:50:28.520
dass du zumindest mal

01:50:28.520 --> 01:50:30.520
Listen und Typen definieren

01:50:30.520 --> 01:50:32.520
kannst, die Zahlen enthalten.

01:50:32.520 --> 01:50:34.520
Und dann ist es egal,

01:50:34.520 --> 01:50:36.520
ob das ein Int ist oder ein Float

01:50:36.520 --> 01:50:38.520
ist oder sowas. Das ist jetzt neu

01:50:38.520 --> 01:50:40.520
seit.NET 7..NET 7

01:50:40.520 --> 01:50:42.520
iNumeric

01:50:42.520 --> 01:50:44.520
oder irgendwie sowas. Ich weiß gar nicht, wie das heißt.

01:50:44.520 --> 01:50:46.520
iNumber oder sowas?

01:50:46.520 --> 01:50:48.520
Ja, List Object, klar.

01:50:48.520 --> 01:50:50.520
Das kannst du natürlich machen.

01:50:56.520 --> 01:50:58.520
Das ist jetzt

01:50:58.520 --> 01:51:00.520
übelst umständliches Beispiel,

01:51:00.520 --> 01:51:02.520
aber okay.

01:51:02.520 --> 01:51:04.520
Also du kannst jetzt,

01:51:04.520 --> 01:51:06.520
die haben jetzt eine Reihe neue Interfaces,

01:51:06.520 --> 01:51:08.520
sieht ja fast schon ein bisschen wie C++ aus,

01:51:08.520 --> 01:51:10.520
die haben eine Reihe neue Interfaces,

01:51:12.520 --> 01:51:14.520
wo du dann zum Beispiel so Sachen machen kannst,

01:51:14.520 --> 01:51:16.520
wie eine Funktion, die sowohl

01:51:16.520 --> 01:51:18.520
für Ints als auch

01:51:18.520 --> 01:51:20.520
für Floats funktioniert

01:51:20.520 --> 01:51:22.520
und solche Geschichten.

01:51:22.520 --> 01:51:24.520
Da muss man sich mal gucken,

01:51:24.520 --> 01:51:26.520
was es da alles gibt. Hab ich mir im Detail noch nicht angeguckt,

01:51:26.520 --> 01:51:28.520
aber die sind da, die sind da

01:51:28.520 --> 01:51:30.520
auf dem Weg,

01:51:30.520 --> 01:51:32.520
dass sowas in der Richtung geht.

01:51:38.520 --> 01:51:40.520
Wofür braucht man das denn?

01:51:42.520 --> 01:51:44.520
Naja, überall da,

01:51:44.520 --> 01:51:46.520
wo was dynamisch ist,

01:51:46.520 --> 01:51:48.520
würde ich sagen.

01:51:52.520 --> 01:51:54.520
Also, ich, wenn du...

01:51:56.520 --> 01:51:58.520
Lass mal überlegen, was es gibt.

01:51:58.520 --> 01:52:00.520
Irgendwo, wo du halt nicht weißt,

01:52:00.520 --> 01:52:02.520
genau was der Input ist,

01:52:02.520 --> 01:52:04.520
oder der Inhalt.

01:52:06.520 --> 01:52:08.520
Zum Beispiel,

01:52:08.520 --> 01:52:10.520
zum Beispiel Webrequest.

01:52:10.520 --> 01:52:12.520
Du machst ein Webrequest, so.

01:52:12.520 --> 01:52:14.520
Du möchtest jetzt 1000 Webrequests machen.

01:52:14.520 --> 01:52:16.520
Es ist jetzt ein bisschen konstruiert das Beispiel,

01:52:16.520 --> 01:52:18.520
mir fällt gerade nichts besseres ein.

01:52:18.520 --> 01:52:20.520
Wahrgenommen, du willst 1000 Webrequests

01:52:20.520 --> 01:52:22.520
machen

01:52:22.520 --> 01:52:24.520
und willst die Antwort in der Liste

01:52:24.520 --> 01:52:26.520
speichern.

01:52:26.520 --> 01:52:28.520
So, jetzt kann es ja sein,

01:52:30.520 --> 01:52:32.520
dass es mal

01:52:32.520 --> 01:52:34.520
nicht geht.

01:52:34.520 --> 01:52:36.520
Sag mal, 90% der Fälle

01:52:36.520 --> 01:52:38.520
geht der Request durch und du kriegst

01:52:38.520 --> 01:52:40.520
eine Antwort und dann speicherst du dir

01:52:40.520 --> 01:52:42.520
den String vom Response

01:52:42.520 --> 01:52:44.520
und gut ist. Aber es kann ja auch mal

01:52:44.520 --> 01:52:46.520
sein, dass es nicht geht.

01:52:46.520 --> 01:52:48.520
Vielleicht möchtest du einfach in der Liste

01:52:50.520 --> 01:52:52.520
auch irgendwie

01:52:52.520 --> 01:52:54.520
die String-Response

01:52:54.520 --> 01:52:56.520
oder eben die Fehlermeldung

01:52:56.520 --> 01:52:58.520
als Exception speichern.

01:52:58.520 --> 01:53:00.520
Was auch immer. Dann bräuchts eine Liste, die Strings

01:53:00.520 --> 01:53:02.520
und Exceptions nimmt oder sowas in der Richtung.

01:53:04.520 --> 01:53:06.520
Oder mal angenommen, du bekommst

01:53:06.520 --> 01:53:08.520
eine Antwort

01:53:08.520 --> 01:53:10.520
von einer Api

01:53:10.520 --> 01:53:12.520
und je nachdem

01:53:14.520 --> 01:53:16.520
was für

01:53:16.520 --> 01:53:18.520
ja, keine Ahnung

01:53:20.520 --> 01:53:22.520
was du für ein Auto hast,

01:53:22.520 --> 01:53:24.520
ist die Response unterschiedlich.

01:53:26.520 --> 01:53:28.520
Also mal angenommen, du hast

01:53:28.520 --> 01:53:30.520
eine Api, Get, Vehicle,

01:53:30.520 --> 01:53:32.520
Status und du hast

01:53:32.520 --> 01:53:34.520
ein Motorrad und dann sieht die Antwort

01:53:34.520 --> 01:53:36.520
anders aus als die Antwort

01:53:36.520 --> 01:53:38.520
bei einem Auto

01:53:38.520 --> 01:53:40.520
und

01:53:40.520 --> 01:53:42.520
da musst du das

01:53:42.520 --> 01:53:44.520
irgendwie

01:53:46.520 --> 01:53:48.520
dann JSON deserialisen

01:53:48.520 --> 01:53:50.520
in eine Klasse und du hast da

01:53:50.520 --> 01:53:52.520
eine Klasse für Auto und du hast eine Klasse für Motorrad

01:53:52.520 --> 01:53:54.520
aber der Request ist der

01:53:54.520 --> 01:53:56.520
gleiche.

01:53:56.520 --> 01:53:58.520
Da kannst du jetzt nicht einfach sagen, hier

01:53:58.520 --> 01:54:00.520
wir machen da eine

01:54:00.520 --> 01:54:02.520
Liste mit Autos, weil

01:54:02.520 --> 01:54:06.520
das können ja auch Motorräder sein.

01:54:10.520 --> 01:54:12.520
So wirklich, so ein 100%

01:54:12.520 --> 01:54:14.520
gutes Beispiel fällt mir, mal gucken, vielleicht

01:54:14.520 --> 01:54:16.520
fällt mir eins ein.

01:54:16.520 --> 01:54:18.520
Doch, doch, das könntest du machen.

01:54:18.520 --> 01:54:20.520
Das könntest du machen.

01:54:20.520 --> 01:54:22.520
Das könntest du machen.

01:54:24.520 --> 01:54:26.520
Wobei es dann halt auch wieder,

01:54:26.520 --> 01:54:28.520
dann hast du irgendwann mal so dieses Problem

01:54:28.520 --> 01:54:30.520
mit

01:54:30.520 --> 01:54:32.520
ist eine Ellipse ein Kreis

01:54:32.520 --> 01:54:34.520
oder ist ein Kreis eine Ellipse und solche Geschichten?

01:54:36.520 --> 01:54:38.520
Das ist wieder so ein typischer Fall von

01:54:38.520 --> 01:54:40.520
ich kann mir durchaus vorstellen,

01:54:40.520 --> 01:54:42.520
dass jemand ein Problem hat,

01:54:42.520 --> 01:54:44.520
wozu er das braucht, mir fällt jetzt aber

01:54:44.520 --> 01:54:46.520
aus dem Bauchhaus kein

01:54:46.520 --> 01:54:48.520
richtig gutes Beispiel ein, mal gucken, was er dazu sagt.

01:54:48.520 --> 01:54:50.520
Also wie gesagt,

01:54:50.520 --> 01:54:52.520
dynamische Inhalte ist so eins, wo ich mir denke

01:54:52.520 --> 01:54:54.520
ja, da kannst du das Problem haben.

01:54:56.520 --> 01:54:58.520
Okay, er erklärt es jetzt

01:54:58.520 --> 01:55:00.520
ja auch, was er für ein Problem hat.

01:55:02.520 --> 01:55:04.520
...definieren die Werte vom Typ String

01:55:04.520 --> 01:55:06.520
oder Int enthält. Wofür braucht man

01:55:06.520 --> 01:55:08.520
das? Naja, wenn man zum Beispiel eine Liste

01:55:08.520 --> 01:55:10.520
von Objekten über eine Http

01:55:10.520 --> 01:55:12.520
API geschickt bekommt und diese

01:55:12.520 --> 01:55:14.520
Objekte können von unterschiedlichen Typen sein.

01:55:16.520 --> 01:55:18.520
Ist ja ein ähnliches Beispiel zu dem, was ich mir gerade

01:55:18.520 --> 01:55:20.520
aus den Fingern gesaugt habe.

01:55:20.520 --> 01:55:22.520
Die haben aber keine gemeinsame Basis-Klasse,

01:55:22.520 --> 01:55:24.520
dann wäre es halt schon schön, wenn das ginge,

01:55:24.520 --> 01:55:26.520
um nicht auf sowas wie Object

01:55:26.520 --> 01:55:28.520
zurückgreifen zu müssen. In TypeScript

01:55:28.520 --> 01:55:30.520
ist das zum Beispiel überhaupt kein Problem, dort gibt es

01:55:30.520 --> 01:55:32.520
Union Types, mit denen man genau das

01:55:32.520 --> 01:55:34.520
ausdrücken kann. In C Sharp hingegen

01:55:34.520 --> 01:55:36.520
hat man da schlichtweg Pech gehabt.

01:55:36.520 --> 01:55:38.520
Also ich muss euch ehrlich sagen, ich war jetzt

01:55:38.520 --> 01:55:40.520
nicht

01:55:40.520 --> 01:55:42.520
wissentlich in einer Situation bisher, wo ich

01:55:42.520 --> 01:55:44.520
es gebraucht hätte, ich habe aber bestimmt

01:55:44.520 --> 01:55:46.520
schon die ein oder anderen Male List

01:55:46.520 --> 01:55:48.520
Object gemacht, weil ich vielleicht so ein

01:55:48.520 --> 01:55:50.520
Problem hatte, es aber nicht realisiert habe.

01:55:50.520 --> 01:55:56.520
Also ich kann die Kritik schon nachvollziehen.

01:55:56.520 --> 01:55:58.520
Den Objekten zugrunde liegende gemeinsame

01:55:58.520 --> 01:56:00.520
Basis-Klasse oder ein gemeinsames Interface

01:56:00.520 --> 01:56:02.520
zur Not kann man sich da natürlich auch

01:56:02.520 --> 01:56:04.520
mit einem Marker-Interface behelfen,

01:56:04.520 --> 01:56:06.520
was dann allerdings ironischerweise

01:56:06.520 --> 01:56:08.520
von der Code-Analyse angemarkert

01:56:08.520 --> 01:56:10.520
wird.

01:56:10.520 --> 01:56:12.520
Dass man doch bitte keine leeren

01:56:12.520 --> 01:56:14.520
Interfaces definieren sollte.

01:56:14.520 --> 01:56:16.520
Und wenn man das ganze Problem mit eingebauten

01:56:16.520 --> 01:56:18.520
Datentypen wie String und Int angehen möchte,

01:56:18.520 --> 01:56:20.520
dann gibt es überhaupt keine Lösung, weil die

01:56:20.520 --> 01:56:22.520
schlichtweg keine gemeinsame Basis besitzen.

01:56:22.520 --> 01:56:24.520
Aber Microsoft macht das schon.

01:56:24.520 --> 01:56:26.520
Microsoft ist da schon

01:56:26.520 --> 01:56:28.520
auf dem richtigen Weg. Wie gesagt,

01:56:28.520 --> 01:56:30.520
mit.NET 7 gibt es jetzt diese Geschichte mit

01:56:30.520 --> 01:56:32.520
iNumber und so was und noch ganz viel

01:56:32.520 --> 01:56:34.520
mehr, was man sich auch mal im Detail angucken

01:56:34.520 --> 01:56:36.520
muss.

01:56:36.520 --> 01:56:38.520
Da tut sich was.

01:56:38.520 --> 01:56:40.520
Ja, aber so richtige Union-Types

01:56:40.520 --> 01:56:42.520
gibt es noch nicht. Sogar in C++

01:56:42.520 --> 01:56:44.520
gibt es sowas. Das heißt schon was.

01:56:44.520 --> 01:56:46.520
Gut, in C++ gibt es vieles.

01:56:46.520 --> 01:56:48.520
Es gibt so vieles, dass keiner mehr versteht.

01:56:52.520 --> 01:56:54.520
Was gibt's, Chet?

01:56:54.520 --> 01:56:56.520
Eine Frage habe ich noch..NET nutzt ja

01:56:56.520 --> 01:56:58.520
HTML-Attribute. Das ist Razor-Templates.

01:56:58.520 --> 01:57:00.520
Benutzen das?

01:57:00.520 --> 01:57:02.520
Verwende ich nicht. Keine Ahnung.

01:57:02.520 --> 01:57:04.520
Razor-Templates...

01:57:06.520 --> 01:57:08.520
Ich guck grad, wo ich das Emote

01:57:08.520 --> 01:57:10.520
hab. Ich wollte so

01:57:10.520 --> 01:57:12.520
ein Emote, wo es was auf die Tür zeigt.

01:57:12.520 --> 01:57:14.520
Razor-Templates out.

01:57:14.520 --> 01:57:16.520
Benutz ich nicht.

01:57:18.520 --> 01:57:20.520
Ich habe keine Ahnung, wie

01:57:20.520 --> 01:57:22.520
Razor-Templates funktionieren.

01:57:26.520 --> 01:57:28.520
Wenn du mich fragst, gar nicht.

01:57:28.520 --> 01:57:30.520
Ich würde was anderes benutzen.

01:57:30.520 --> 01:57:32.520
Und das ist dann

01:57:32.520 --> 01:57:34.520
aus naheliegenden Gründen doch eher

01:57:34.520 --> 01:57:36.520
suboptimal, um es mal vorsichtig

01:57:36.520 --> 01:57:38.520
auszudrücken.

01:57:38.520 --> 01:57:40.520
Das dritte Beispiel für warum geht das

01:57:40.520 --> 01:57:42.520
nicht? Und das hat mich wirklich schockiert,

01:57:42.520 --> 01:57:44.520
denn das Problem besteht bereits

01:57:44.520 --> 01:57:46.520
seit C-Sharp 2.0.

01:57:46.520 --> 01:57:48.520
Das ist, dass man bei generischen Datentypen

01:57:48.520 --> 01:57:50.520
tatsächlich immer noch mit Co- und

01:57:50.520 --> 01:57:52.520
Contra-Variants zu kämpfen hat.

01:57:52.520 --> 01:57:54.520
Und das generische Typen

01:57:54.520 --> 01:57:56.520
oftmals immer noch einen Haufen

01:57:56.520 --> 01:57:58.520
Probleme mit sich zieht.

01:57:58.520 --> 01:58:00.520
Wir hatten ein ganz einfaches Szenario.

01:58:00.520 --> 01:58:02.520
Eine generische Klasse namens

01:58:02.520 --> 01:58:04.520
Event von T. Und T sind

01:58:04.520 --> 01:58:06.520
irgendwelche Nutzdaten. Und was wir

01:58:06.520 --> 01:58:08.520
haben wollten, war einfach nur eine Liste

01:58:08.520 --> 01:58:10.520
von Events, die jeweils ein anderes

01:58:10.520 --> 01:58:12.520
T haben können. Also quasi

01:58:12.520 --> 01:58:14.520
eine Liste von Events von

01:58:14.520 --> 01:58:16.520
Any. Und Überraschung, das geht nicht,

01:58:16.520 --> 01:58:18.520
weil C-Sharp keinen Any-Typ oder so was

01:58:18.520 --> 01:58:20.520
in der Richtung hat. Jetzt könnte man ja

01:58:20.520 --> 01:58:22.520
meinen, man nimmt einfach List von Event von Object,

01:58:22.520 --> 01:58:24.520
aber das klappt auch nicht. Da beschwert sich der

01:58:24.520 --> 01:58:26.520
Compiler bei Konvertierungen. Und am Ende läuft

01:58:26.520 --> 01:58:28.520
es dann tatsächlich auf List von Object hinaus.

01:58:28.520 --> 01:58:30.520
Das heißt, die Information, dass es sich bei den

01:58:30.520 --> 01:58:32.520
Listenelementen eigentlich um Events handelt,

01:58:32.520 --> 01:58:34.520
die ist halt einfach weg. Und das war

01:58:34.520 --> 01:58:36.520
wie gesagt in C-Sharp 2.0 schon ein Problem.

01:58:36.520 --> 01:58:38.520
Und dass das heute, 16 Jahre später

01:58:38.520 --> 01:58:40.520
in C-Sharp 10 immer noch haargenau dasselbe

01:58:40.520 --> 01:58:42.520
Problem ist, das ist schon ziemlich traurig.

01:58:44.520 --> 01:58:46.520
Bevor wir zum Abschluss zu meinem

01:58:46.520 --> 01:58:48.520
persönlichen, wie gesagt, Highlight

01:58:48.520 --> 01:58:50.520
oder Downlight kommen, kommen wir erst noch

01:58:50.520 --> 01:58:52.520
zur vierten Kategorie, nämlich den

01:58:52.520 --> 01:58:54.520
Alplasten. Es gibt so ein paar Dinge in C-Sharp,

01:58:54.520 --> 01:58:56.520
die haben sich tatsächlich kein bisschen verändert,

01:58:56.520 --> 01:58:58.520
die waren... Ja, wie gesagt,

01:58:58.520 --> 01:59:00.520
da bin ich auch der Meinung, paar richtig, richtig

01:59:00.520 --> 01:59:02.520
altes Zeug, oder auch so

01:59:02.520 --> 01:59:04.520
im 5-Jahres-Rhythmus oder so, man könnte

01:59:04.520 --> 01:59:06.520
durchaus mal was deprecateen und rausschmeißen.

01:59:06.520 --> 01:59:08.520
Oder zumindest es standardmäßig

01:59:08.520 --> 01:59:10.520
eben deaktivieren.

01:59:10.520 --> 01:59:12.520
Dass die Leute halten

01:59:12.520 --> 01:59:14.520
besseren Anhaltspunkt damit, okay,

01:59:14.520 --> 01:59:16.520
was ist denn jetzt der Weg, wie man es machen sollte?

01:59:16.520 --> 01:59:18.520
In C-Sharp 1 schon nicht besonders gelungen

01:59:18.520 --> 01:59:20.520
und heute

01:59:20.520 --> 01:59:22.520
wirken sie eigentlich umso mehr

01:59:22.520 --> 01:59:24.520
aus der Zeit gefallen. Und das

01:59:24.520 --> 01:59:26.520
erste, was mir in der Hinsicht aufgefallen ist,

01:59:26.520 --> 01:59:28.520
ist iDisposable.

01:59:28.520 --> 01:59:30.520
Da habe ich mich ernsthaft gefragt, wie es sein kann,

01:59:30.520 --> 01:59:32.520
dass Microsoft innerhalb von 20

01:59:32.520 --> 01:59:34.520
Jahren, die es C-Sharp nun gibt, das ist fast

01:59:34.520 --> 01:59:36.520
ein Vierteljahrhundert, wie sie

01:59:36.520 --> 01:59:38.520
nicht geschafft haben, zumindest

01:59:38.520 --> 01:59:40.520
mal eine Alternative zu schaffen, die nicht ganz

01:59:40.520 --> 01:59:42.520
so umständlich ist und die sich nicht ganz

01:59:42.520 --> 01:59:44.520
so gruselig anfühlt. Das Gute

01:59:44.520 --> 01:59:46.520
war, dass ich das, was ich vor 20 Jahren mal

01:59:46.520 --> 01:59:48.520
gelernt habe, über Finalizer,

01:59:48.520 --> 01:59:50.520
die Dispose-Funktion in ihren verschiedenen

01:59:50.520 --> 01:59:52.520
Überladungen, die Garbage Collection

01:59:52.520 --> 01:59:54.520
Klasse, Suppress Finalize und so weiter,

01:59:54.520 --> 01:59:56.520
dass ich den ganzen Quatsch immer noch anwenden

01:59:56.520 --> 01:59:58.520
konnte, aber das kann doch nicht

01:59:58.520 --> 02:00:00.520
State of the Art im Jahr 2022 sein,

02:00:00.520 --> 02:00:02.520
wenn ich in der Klasse Aufräumcode unterbringen will,

02:00:02.520 --> 02:00:04.520
dass ich nach wie vor ausgerechnet

02:00:04.520 --> 02:00:06.520
dieses Konstrukt umsetzen muss, was

02:00:06.520 --> 02:00:08.520
kaum jemand und schon gar nicht aus dem Kopf

02:00:08.520 --> 02:00:10.520
richtig umsetzt.

02:00:10.520 --> 02:00:12.520
Gut, bei Rider ist das einfach, da sagst du

02:00:12.520 --> 02:00:14.520
Implement iDisposable und er macht das für dich.

02:00:14.520 --> 02:00:16.520
So wild,

02:00:16.520 --> 02:00:18.520
muss ich ehrlich sagen,

02:00:18.520 --> 02:00:20.520
sehe ich das nicht.

02:00:20.520 --> 02:00:22.520
Ich finde das eigentlich

02:00:22.520 --> 02:00:24.520
gar nicht so übel, wie das gemacht ist.

02:00:24.520 --> 02:00:26.520
Du kannst iDisposable

02:00:26.520 --> 02:00:28.520
implementieren, wenn du entweder

02:00:28.520 --> 02:00:30.520
manuell aufräumen willst, zu

02:00:30.520 --> 02:00:32.520
Haltpunkt x,

02:00:32.520 --> 02:00:34.520
oder du setzt das in den Using,

02:00:34.520 --> 02:00:36.520
dann weißt du am Ende des Blocks, wenn das

02:00:36.520 --> 02:00:38.520
out of scope geht, wird es automatisch

02:00:38.520 --> 02:00:40.520
aufgeräumt.

02:00:40.520 --> 02:00:42.520
Das ist doch eigentlich

02:00:42.520 --> 02:00:44.520
nicht schlecht.

02:00:44.520 --> 02:00:46.520
Und wenn du willst, dass der Garbage Collector

02:00:46.520 --> 02:00:48.520
das macht, dann musst du

02:00:48.520 --> 02:00:50.520
ein Finalizer einbauen.

02:00:50.520 --> 02:00:52.520
So schlimm finde

02:00:52.520 --> 02:00:54.520
ich das eigentlich gar nicht, finde ich das eigentlich ganz gut.

02:00:56.520 --> 02:00:58.520
Immer noch der gleiche Mist ist wie in C Sharp 1,

02:00:58.520 --> 02:01:00.520
da fällt mir nicht mehr viel zu ein.

02:01:00.520 --> 02:01:02.520
Und das tatsächlich Einzige,

02:01:02.520 --> 02:01:04.520
was sich daran überhaupt geändert hat, ist,

02:01:04.520 --> 02:01:06.520
dass man Using nun als Statement

02:01:06.520 --> 02:01:08.520
statt als Blog schreiben kann.

02:01:08.520 --> 02:01:10.520
Das ist das Einzige, was daran nicht schwierig

02:01:10.520 --> 02:01:12.520
und kompliziert ist.

02:01:14.520 --> 02:01:16.520
Aber toll, dass sich ausgerechnet da

02:01:16.520 --> 02:01:18.520
etwas getan hat.

02:01:18.520 --> 02:01:20.520
Das ist aber nicht das Einzige. Was ebenfalls

02:01:20.520 --> 02:01:22.520
sehr stark von Altlasten geprägt ist, ist die Code-Analyse.

02:01:22.520 --> 02:01:24.520
C Sharp gibt es nämlich anders, als

02:01:24.520 --> 02:01:26.520
in so ziemlich jeder anderen modernen Sprache,

02:01:26.520 --> 02:01:28.520
nicht einfach einen Linter, den man

02:01:28.520 --> 02:01:30.520
über eine bestimmte Datei konfigurieren kann,

02:01:30.520 --> 02:01:32.520
sondern es gibt eine ganze Reihe

02:01:32.520 --> 02:01:34.520
von Regeln, die über die Editor-

02:01:34.520 --> 02:01:36.520
Konfig-Datei konfiguriert werden.

02:01:36.520 --> 02:01:38.520
Eigentlich sollte diese Datei ja

02:01:38.520 --> 02:01:40.520
lediglich Editor-spezifische Einstellungen

02:01:40.520 --> 02:01:42.520
enthalten und keine Regeln für

02:01:42.520 --> 02:01:44.520
Code-Analyse, die projektweit gelten.

02:01:44.520 --> 02:01:46.520
Ihr wisst, Chat, wir machen hier keine Tests

02:01:46.520 --> 02:01:48.520
und keine Kommentare, weil wir machen

02:01:48.520 --> 02:01:50.520
keine Fehler und deswegen braucht man natürlich

02:01:50.520 --> 02:01:52.520
auch keine Analyse. So logisch.

02:01:52.520 --> 02:01:54.520
Macht man das halt so, dann ist diese Datei

02:01:54.520 --> 02:01:56.520
nicht wie sonst zehn Zeilen lang, sondern

02:01:56.520 --> 02:01:58.520
500. Wenn das wenigstens die einzige Datei

02:01:58.520 --> 02:02:00.520
wäre, die man anfassen müsste, dann wäre

02:02:00.520 --> 02:02:02.520
das ja vielleicht noch zu verschmerzen,

02:02:02.520 --> 02:02:04.520
aber zusätzlich muss man auch noch die Projekt-

02:02:04.520 --> 02:02:06.520
Datei editieren, dort werden nämlich die Roslin

02:02:06.520 --> 02:02:08.520
Analyzer konfiguriert. Das heißt, man

02:02:08.520 --> 02:02:10.520
editiert von Hand... Ich mach das gar nicht,

02:02:10.520 --> 02:02:12.520
wenn überhaupt, mach ich das,

02:02:12.520 --> 02:02:14.520
wenn das

02:02:14.520 --> 02:02:16.520
in Rider

02:02:16.520 --> 02:02:18.520
gelbe,

02:02:18.520 --> 02:02:20.520
ja,

02:02:20.520 --> 02:02:22.520
gelb unterkringelt ist, dann mach ich

02:02:22.520 --> 02:02:24.520
die Hilfe-Funktion auf und sag,

02:02:24.520 --> 02:02:26.520
ah ja, ok, bitte hier hinzufügen.

02:02:26.520 --> 02:02:28.520
... und eine XML-Datei

02:02:28.520 --> 02:02:30.520
und spätestens

02:02:30.520 --> 02:02:32.520
sehr nach Mitte der 90er Jahre

02:02:32.520 --> 02:02:34.520
an. Allerdings ist das auch nicht

02:02:34.520 --> 02:02:36.520
die einzige XML-Datei, die man bearbeiten

02:02:36.520 --> 02:02:38.520
darf, wenn man nämlich möchte... Oder Rider

02:02:38.520 --> 02:02:40.520
sagt mir, aha, ich sehe, sie verwenden

02:02:40.520 --> 02:02:42.520
irgendwelche Logging-Frameworks, sollen wir jetzt

02:02:42.520 --> 02:02:44.520
die Analyzer für Logging hinzufügen? Da sag ich, ja,

02:02:44.520 --> 02:02:46.520
mach.

02:02:46.520 --> 02:02:48.520
... Einstellungen für mehrere Projekte

02:02:48.520 --> 02:02:50.520
innerhalb einer Solution gelten,

02:02:50.520 --> 02:02:52.520
dann muss man zusätzlich noch eine Datei mit dem

02:02:52.520 --> 02:02:54.520
tollen Namen directory-build-

02:02:54.520 --> 02:02:56.520
props anlegen.

02:02:56.520 --> 02:02:58.520
Microsoft und Benamung, das kannst du eh schon immer

02:02:58.520 --> 02:03:00.520
vergessen. Und vergleicht man das alles

02:03:00.520 --> 02:03:02.520
mal mit dem, zum Beispiel

02:03:02.520 --> 02:03:04.520
mit es-lint für JavaScript oder TypeScript,

02:03:04.520 --> 02:03:06.520
dann liegen halt zwischen diesen beiden ansetzten Welten

02:03:06.520 --> 02:03:08.520
und das leider nicht zu Gunsten

02:03:08.520 --> 02:03:10.520
von C-Sharp. Und damit

02:03:10.520 --> 02:03:12.520
kommen wir zur Fün... Dafür braucht's

02:03:12.520 --> 02:03:14.520
den Java-Script ist odd und ist even

02:03:14.520 --> 02:03:16.520
und musst einen NPM für installieren.

02:03:16.520 --> 02:03:18.520
Das waren alles meine

02:03:18.520 --> 02:03:20.520
Vor-Nachteile. Oder du musst

02:03:20.520 --> 02:03:22.520
sowas ekliges wie Webpack verwenden.

02:03:36.520 --> 02:03:38.520
Ich hätte wetten können,

02:03:38.520 --> 02:03:40.520
dass das kommt.

02:03:40.520 --> 02:03:42.520
Ja.

02:03:42.520 --> 02:03:44.520
Die

02:03:44.520 --> 02:03:46.520
JSON-Unterstützung ist mittlerweile

02:03:46.520 --> 02:03:48.520
besser, aber die haben

02:03:48.520 --> 02:03:50.520
halt lange Zeit, lange Jahre nichts gemacht.

02:03:50.520 --> 02:03:52.520
Es gab jason.net

02:03:52.520 --> 02:03:54.520
und

02:03:54.520 --> 02:03:56.520
das

02:03:56.520 --> 02:03:58.520
konnte einfach alles,

02:03:58.520 --> 02:04:00.520
was man so gebraucht hat. Und

02:04:00.520 --> 02:04:02.520
Microsoft hat es selbst verwendet.

02:04:02.520 --> 02:04:04.520
Irgendwann haben sie dann den Creator

02:04:04.520 --> 02:04:06.520
von jason.net eingestellt

02:04:06.520 --> 02:04:08.520
und

02:04:08.520 --> 02:04:10.520
jetzt haben sie einen eigenen JSON-Serializer

02:04:10.520 --> 02:04:12.520
und die Serializer im

02:04:12.520 --> 02:04:14.520
Framework. Der ist mittlerweile

02:04:14.520 --> 02:04:16.520
system.txt.json

02:04:16.520 --> 02:04:18.520
ist das jetzt?

02:04:18.520 --> 02:04:20.520
Der ist ganz

02:04:20.520 --> 02:04:22.520
okay mittlerweile.

02:04:22.520 --> 02:04:24.520
Aber ich muss ehrlich sagen, ich verwende

02:04:24.520 --> 02:04:26.520
am liebsten immer noch jason.net.

02:04:26.520 --> 02:04:28.520
Ja, das da hat er recht.

02:04:28.520 --> 02:04:30.520
Das haben die

02:04:30.520 --> 02:04:48.520
lange stiefmütterlich behandelt.

02:04:48.520 --> 02:04:50.520
Und eigentlich fängt das Ganze zunächst

02:04:50.520 --> 02:04:52.520
auch ganz vielversprechend an.

02:04:52.520 --> 02:04:54.520
Wenn man sich zum Beispiel den ASP.NET Core mal anschaut,

02:04:54.520 --> 02:04:56.520
wie die Minimal API das Thema umsetzt,

02:04:56.520 --> 02:04:58.520
dann geht da schon einiges. Aber das Ganze

02:04:58.520 --> 02:05:00.520
funktioniert halt nur so lange gut,

02:05:00.520 --> 02:05:02.520
wie man es lediglich mit 0.8.15 Datenstrukturen

02:05:02.520 --> 02:05:04.520
zu tun hat. Sobald es nämlich

02:05:04.520 --> 02:05:06.520
Variants in der JSON-Struktur geben

02:05:06.520 --> 02:05:08.520
kann, fangen die Probleme an.

02:05:08.520 --> 02:05:10.520
Und da sprechen wir noch nicht über besonders ausgefallene

02:05:10.520 --> 02:05:12.520
Situationen, sondern über

02:05:12.520 --> 02:05:14.520
eigentlich sehr einfache und vor allem auch

02:05:14.520 --> 02:05:16.520
durchaus gängige Patterns, die sich

02:05:16.520 --> 02:05:18.520
aber in C Sharp als riesen Problem erweisen.

02:05:18.520 --> 02:05:20.520
Zum Beispiel, ich möchte als

02:05:20.520 --> 02:05:22.520
Payload ein Objekt schicken, aber je nach

02:05:22.520 --> 02:05:24.520
Kontext hat das Objekt die eine

02:05:24.520 --> 02:05:26.520
oder die andere Struktur. Ganz

02:05:26.520 --> 02:05:28.520
einfach. Ganz einfach.

02:05:28.520 --> 02:05:30.520
Gar nicht parsen. Einfach

02:05:30.520 --> 02:05:32.520
Dynamic benutzen.

02:05:32.520 --> 02:05:34.520
Und das sich rausholen,

02:05:34.520 --> 02:05:36.520
was man braucht.

02:05:42.520 --> 02:05:44.520
Okay, ich gebe zu, die schönste

02:05:44.520 --> 02:05:46.520
Lösung ist das nicht.

02:05:46.520 --> 02:05:48.520
Das ganze Typ sicher und mit IDE-Support

02:05:48.520 --> 02:05:50.520
wäre natürlich besser. Aber wenn gar nichts hilft,

02:05:50.520 --> 02:05:52.520
das einfach Dynamic machen und

02:05:52.520 --> 02:05:54.520
das rausziehen, was man

02:05:54.520 --> 02:05:56.520
braucht und dann in eine Klasse

02:05:56.520 --> 02:05:58.520
schreiben, die die ganzen Daten

02:05:58.520 --> 02:06:00.520
beinhaltet.

02:06:00.520 --> 02:06:02.520
Ein Feature namens polymorphische

02:06:02.520 --> 02:06:04.520
Deserialisierung. Und das

02:06:04.520 --> 02:06:06.520
kann doch nicht einfach nicht. Wow, high IQ.

02:06:06.520 --> 02:06:08.520
Und der Grund dafür ist relativ einfach.

02:06:08.520 --> 02:06:10.520
Man müsste dafür nämlich in der Lage sein,

02:06:10.520 --> 02:06:12.520
einen Typen zu definieren, der wahlweise

02:06:12.520 --> 02:06:14.520
einer von zwei Strukturen entspricht.

02:06:14.520 --> 02:06:16.520
Das geht ja nicht, haben wir ja gerade gelernt.

02:06:16.520 --> 02:06:18.520
Das ist gar nicht so abwegig, wie das zunächst vielleicht mal klingt.

02:06:18.520 --> 02:06:20.520
Das ist in der funktionalen Programmierung

02:06:20.520 --> 02:06:22.520
durchaus gängig und das Konzept dahinter,

02:06:22.520 --> 02:06:24.520
das habe ich vorhin schon mal erwähnt, nennt sich

02:06:24.520 --> 02:06:26.520
algebraischer Datentyp.

02:06:26.520 --> 02:06:28.520
Da war doch aber vorhin auch schon genau,

02:06:28.520 --> 02:06:30.520
was das C-Sharp halt das

02:06:30.520 --> 02:06:32.520
einfach nicht kann, dass das das nicht unterstützt.

02:06:32.520 --> 02:06:34.520
Und da kommt dann ganz schnell der Hinweis,

02:06:34.520 --> 02:06:36.520
dass man für JSON-Parsing doch lieber

02:06:36.520 --> 02:06:38.520
JSON.NET von Newtonsoft als

02:06:38.520 --> 02:06:40.520
externe Bibliothek. Ja, benutze ich auch am liebsten.

02:06:40.520 --> 02:06:42.520
Klar, das kann man auch machen, aber mal

02:06:42.520 --> 02:06:44.520
im Ernst. Was ist das denn für eine Plattform,

02:06:44.520 --> 02:06:46.520
wo ich im Jahr 2022 eine externe

02:06:46.520 --> 02:06:48.520
Abhängigkeit benötige, um

02:06:48.520 --> 02:06:50.520
JSON vernünftig parsen zu können?

02:06:50.520 --> 02:06:52.520
Da findest du in Go aber auch

02:06:52.520 --> 02:06:54.520
ja, er hat Recht, das macht

02:06:54.520 --> 02:06:56.520
C-Sharp nicht besser.

02:06:56.520 --> 02:06:58.520
Da hat Go allerdings auch so seine Dinge.

02:06:58.520 --> 02:07:00.520
Wie gesagt, warum muss ich in Go zwei

02:07:00.520 --> 02:07:02.520
Nested Schleifen machen, um irgendwie den Array ordentlich zu

02:07:02.520 --> 02:07:04.520
filtern und sowas. Gibt alles

02:07:04.520 --> 02:07:06.520
mögliche. Kannst dich bei allem irgendwie

02:07:06.520 --> 02:07:08.520
in mehrere Richtungen beschweren.

02:07:08.520 --> 02:07:10.520
Ich persönlich mag JSON.NET,

02:07:10.520 --> 02:07:12.520
einfach weil ich es Jahre schon verwende

02:07:12.520 --> 02:07:14.520
und länger als die Default Implementierung.

02:07:16.520 --> 02:07:18.520
Dass es nicht in der Standard Library

02:07:18.520 --> 02:07:20.520
ist, sagen wir, dass

02:07:20.520 --> 02:07:22.520
ein nicht so umfangreicher

02:07:22.520 --> 02:07:24.520
JSON Serializer in der

02:07:24.520 --> 02:07:26.520
Standard Library ist. Ja, gut,

02:07:26.520 --> 02:07:28.520
ich kann die Kritik verstehen. Es wird besser.

02:07:30.520 --> 02:07:32.520
Es wird besser.

02:07:32.520 --> 02:07:34.520
Du hast Recht, man braucht gar nicht zwei

02:07:34.520 --> 02:07:36.520
Nested. Brauchst nur eine normale Schleife,

02:07:36.520 --> 02:07:38.520
nicht zwei Nested Schleifen.

02:07:42.520 --> 02:07:44.520
Brauchst du nicht.

02:07:44.520 --> 02:07:46.520
Wieso kann.NET das nicht von Haus aus

02:07:46.520 --> 02:07:48.520
auf eine vernünftige Art?

02:07:48.520 --> 02:07:50.520
Das ist aus meiner Sicht ein völliges

02:07:50.520 --> 02:07:52.520
... Ja, das mag ich mich bei JavaScript und Go auch bei

02:07:52.520 --> 02:07:54.520
vielen Sachen, aber das kannst du nicht

02:07:54.520 --> 02:07:56.520
in alle Richtungen kannst du das

02:07:56.520 --> 02:07:58.520
drehen und wenden. Ja, da hat schon Recht.

02:07:58.520 --> 02:08:00.520
Warum ist das in C-Sharp so?

02:08:00.520 --> 02:08:02.520
Könnte sicherlich besser sein.

02:08:02.520 --> 02:08:04.520
Könnte aber auch deutlich schlechter sein, wenn man mal

02:08:04.520 --> 02:08:06.520
zu C++ guckt, die ja bis heute nicht mal

02:08:06.520 --> 02:08:08.520
Webrequest in der Standard Library machen können.

02:08:10.520 --> 02:08:12.520
Hat alles seine Vor- und Nachteile.

02:08:12.520 --> 02:08:14.520
Das zeigt einfach, dass.NET an manchen

02:08:14.520 --> 02:08:16.520
Stellen nicht auf der Höhe der Zeit ist.

02:08:16.520 --> 02:08:18.520
Ja, ist so.

02:08:18.520 --> 02:08:20.520
Ja, natürlich. Wie gesagt,

02:08:20.520 --> 02:08:22.520
kannst du dir irgendwie so

02:08:22.520 --> 02:08:24.520
in jeder Sprache Dinge raussuchen.

02:08:24.520 --> 02:08:26.520
Ist in dem Fall schon so.

02:08:26.520 --> 02:08:28.520
Hat er ja schon Recht, so ist das net.

02:08:30.520 --> 02:08:32.520
Das Standard Jason

02:08:32.520 --> 02:08:34.520
Handling im Framework

02:08:34.520 --> 02:08:36.520
konnte durchaus besser sein.

02:08:36.520 --> 02:08:38.520
Gab es ja bis zu.NET 6, glaube ich,

02:08:38.520 --> 02:08:40.520
gar nicht richtig. Ich weiß nicht,

02:08:40.520 --> 02:08:42.520
wann die System-

02:08:42.520 --> 02:08:44.520
Texts Jason eingeführt haben, ob es.NET

02:08:44.520 --> 02:08:46.520
5 oder.NET 6 war. Ist auf jeden Fall

02:08:46.520 --> 02:08:48.520
noch nicht so lange her. Ich glaube,.NET 5 war es

02:08:48.520 --> 02:08:50.520
quasi unbenutzbar.

02:08:50.520 --> 02:08:52.520
In.NET 6 wurde es besser und in.NET 7

02:08:52.520 --> 02:08:54.520
haben sie es ja noch ein bisschen besser gemacht.

02:08:56.520 --> 02:08:58.520
Ich verwende jason.net ganz gern.

02:08:58.520 --> 02:09:00.520
Das gibt es auch schon länger.

02:09:02.520 --> 02:09:04.520
Kommt damit eigentlich gut klar, aber

02:09:04.520 --> 02:09:06.520
könnte durchaus

02:09:06.520 --> 02:09:08.520
in der Standard Library was besseres sein.

02:09:08.520 --> 02:09:10.520
Das ist kein Spezialfall, der nur einmal

02:09:10.520 --> 02:09:12.520
in fünf Jahren vorkommt, sondern über die

02:09:12.520 --> 02:09:14.520
Basis dessen, wie HTTP-APIs

02:09:14.520 --> 02:09:16.520
heutzutage funktionieren.

02:09:16.520 --> 02:09:18.520
Das Allerschlimmste an der ganzen Sache

02:09:18.520 --> 02:09:20.520
kommt aber erst noch. In der MSDN steht

02:09:20.520 --> 02:09:22.520
nämlich wortwörtlich, dass das

02:09:22.520 --> 02:09:24.520
polymorphische Deserialisieren mit

02:09:24.520 --> 02:09:26.520
Wortmitteln von.NET nicht möglich sei.

02:09:26.520 --> 02:09:28.520
Und das Traurige ist, das ist falsch.

02:09:28.520 --> 02:09:30.520
Es geht nämlich sehr wohl,

02:09:30.520 --> 02:09:32.520
wenn man die Klasse System-Text-

02:09:32.520 --> 02:09:34.520
Jason-Nodes-Jason-Node verwendet.

02:09:34.520 --> 02:09:36.520
Obviously. Und sich mit der GetValue

02:09:36.520 --> 02:09:38.520
die Parse-Methode von Hand

02:09:38.520 --> 02:09:40.520
von Property zu Property durchhangelt.

02:09:40.520 --> 02:09:42.520
Denn man kennt die Struktur ja.

02:09:42.520 --> 02:09:44.520
Man weiß ja, was man erwartet.

02:09:44.520 --> 02:09:46.520
Das ist ja nicht irgendwas. Ja gut.

02:09:46.520 --> 02:09:48.520
Da kann man aber auch einfach Dynamic verwenden, oder?

02:09:48.520 --> 02:09:50.520
Liebig ist, es gibt einfach nur

02:09:50.520 --> 02:09:52.520
verschiedene Möglichkeiten, was da kommen kann.

02:09:52.520 --> 02:09:54.520
Wenn man es so halbwegs

02:09:54.520 --> 02:09:56.520
typ-sicher haben will, kann man es auch

02:09:56.520 --> 02:09:58.520
deserialisieren

02:09:58.520 --> 02:10:00.520
in ein Objekt,

02:10:00.520 --> 02:10:02.520
soweit man es weiß.

02:10:02.520 --> 02:10:04.520
Und ab dort, wo man es nicht mehr weiß,

02:10:04.520 --> 02:10:06.520
kann man es eben dann als J-Object

02:10:06.520 --> 02:10:08.520
oder ab dann Dynamic weiter.

02:10:08.520 --> 02:10:10.520
Das geht ja auch.

02:10:10.520 --> 02:10:12.520
Ob man dann direkt Dynamic da drin dann wiederum machen kann,

02:10:12.520 --> 02:10:14.520
weiß ich nicht. Aber du kannst auf jeden Fall

02:10:14.520 --> 02:10:16.520
ein J-Object nehmen,

02:10:16.520 --> 02:10:18.520
wo du dann mit Array-Syntax auf die

02:10:18.520 --> 02:10:20.520
unterelemente zugreifen kannst.

02:10:20.520 --> 02:10:22.520
Oder halt direkt Dynamic nehmen.

02:10:24.520 --> 02:10:26.520
Aber gut, man könnte es schöner machen.

02:10:26.520 --> 02:10:28.520
Für Stück parsen.

02:10:28.520 --> 02:10:30.520
JavaScript und TypeScript überhaupt kein Problem,

02:10:30.520 --> 02:10:32.520
ist das klar. An der Stelle allerdings

02:10:32.520 --> 02:10:34.520
meiner Meinung nach ein sehr schwaches Argument.

02:10:34.520 --> 02:10:36.520
Denn dort kann man ja auf ein dynamisches

02:10:36.520 --> 02:10:38.520
Typ-System zurückgreifen, was C-Sharp nicht kennt.

02:10:38.520 --> 02:10:40.520
Insofern lässt sich das dort naturgemäß

02:10:40.520 --> 02:10:42.520
weitaus einfacher umsetzen. Aber,

02:10:42.520 --> 02:10:44.520
und das ist dann der Punkt, wo ich bei.NET aussteige,

02:10:44.520 --> 02:10:46.520
warum das in Go,

02:10:46.520 --> 02:10:48.520
was ja wie C-Sharp ebenfalls ausschließlich

02:10:48.520 --> 02:10:50.520
ein statisches Typ-System kennt,

02:10:50.520 --> 02:10:52.520
mit zwei Zeilen Code erledigt ist,

02:10:52.520 --> 02:10:54.520
und in.NET ein riesiges Problem

02:10:54.520 --> 02:10:56.520
darstellt, was zu hunderten

02:10:56.520 --> 02:10:58.520
Zeilen Code führt, das erschließt sich mir nicht.

02:10:58.520 --> 02:11:00.520
In Go ist das einfach derart gelöst,

02:11:00.520 --> 02:11:02.520
dass man beim Parsen von Jason festlegen kann.

02:11:02.520 --> 02:11:04.520
Na, Go hat auch schon so ein bisschen

02:11:04.520 --> 02:11:06.520
Magic-Sachen.

02:11:06.520 --> 02:11:08.520
Also gerade diese Sache,

02:11:08.520 --> 02:11:10.520
wenn du Structs in Go definierst

02:11:10.520 --> 02:11:12.520
und dann kannst du ja dahinter schreiben

02:11:12.520 --> 02:11:14.520
als String,

02:11:14.520 --> 02:11:16.520
in so komischen Backticks

02:11:16.520 --> 02:11:18.520
irgendwie,

02:11:18.520 --> 02:11:20.520
was es da wie wo genau machen soll,

02:11:22.520 --> 02:11:24.520
ist auch schon ein bisschen Magic dabei.

02:11:24.520 --> 02:11:26.520
Dass nur bis zu einer gewissen

02:11:26.520 --> 02:11:28.520
Ebene geparsst wird und der Rest einfach

02:11:28.520 --> 02:11:30.520
als Raw Jason zurückgegeben wird.

02:11:30.520 --> 02:11:32.520
Und dann kann man zum Beispiel abhängig von dem

02:11:32.520 --> 02:11:34.520
bereits gepaarsten Teil entscheiden,

02:11:34.520 --> 02:11:36.520
wie und was das ist.

02:11:36.520 --> 02:11:38.520
Also das funktioniert. Du kannst

02:11:38.520 --> 02:11:40.520
eine Klasse machen in

02:11:40.520 --> 02:11:42.520
C-Sharp. Ja, keine Ahnung.

02:11:42.520 --> 02:11:44.520
Was war ich hier? Public Class

02:11:44.520 --> 02:11:46.520
Response

02:11:46.520 --> 02:11:48.520
oder so.

02:11:48.520 --> 02:11:50.520
Gehen wir mal davon auf, wir verwenden

02:11:50.520 --> 02:11:52.520
jason.net. Und da drin

02:11:52.520 --> 02:11:54.520
gibt es jetzt, boah, ich will das nicht

02:11:54.520 --> 02:11:56.520
alles von Hand schreiben. Wir machen das einfach so.

02:11:56.520 --> 02:11:58.520
So, da drin gibt es jetzt StringName

02:11:58.520 --> 02:12:00.520
und String,

02:12:00.520 --> 02:12:02.520
keine Ahnung, Age

02:12:02.520 --> 02:12:04.520
oder sowas.

02:12:04.520 --> 02:12:06.520
Und da drunter gibt es dann irgendwie noch

02:12:06.520 --> 02:12:08.520
ein j

02:12:08.520 --> 02:12:10.520
Object

02:12:12.520 --> 02:12:14.520
Details

02:12:14.520 --> 02:12:16.520
oder sowas. Das geht.

02:12:16.520 --> 02:12:18.520
Du kannst das, du kannst das

02:12:18.520 --> 02:12:20.520
das hier parsen lassen, deserialisieren

02:12:20.520 --> 02:12:22.520
lassen.

02:12:22.520 --> 02:12:24.520
Dann füllt er das mit allem,

02:12:24.520 --> 02:12:26.520
was du haben willst, an der Stelle.

02:12:28.520 --> 02:12:30.520
Und den anderen Kram macht er

02:12:30.520 --> 02:12:32.520
halt als jObject, wo du dich

02:12:32.520 --> 02:12:34.520
dann quasi lang hangeln musst.

02:12:34.520 --> 02:12:36.520
Ich mach nix in Visual Studio Code, das ist ja bloß

02:12:36.520 --> 02:12:38.520
Beispiel. Ich hätte auch Notepad

02:12:38.520 --> 02:12:40.520
verwenden können.

02:12:40.520 --> 02:12:42.520
Normalerweise würde ich dann quasi sagen Response

02:12:42.520 --> 02:12:44.520
Punkt Name, wäre alles okay.

02:12:44.520 --> 02:12:46.520
Und hier müsste ich dann sagen Detail

02:12:46.520 --> 02:12:48.520
und dann, je nachdem, was es ist,

02:12:48.520 --> 02:12:50.520
was dann

02:12:50.520 --> 02:12:52.520
dann auch immer drunter kommt.

02:12:52.520 --> 02:12:54.520
Also ich root

02:12:54.520 --> 02:12:56.520
keine Ahnung.

02:12:58.520 --> 02:13:00.520
Socken.

02:13:04.520 --> 02:13:06.520
Also das, das, das, das geht

02:13:06.520 --> 02:13:08.520
schon. War nicht so schön wie in Go,

02:13:08.520 --> 02:13:10.520
daher gebe ich ihm ja recht.

02:13:10.520 --> 02:13:12.520
Warum es dafür in.NET

02:13:12.520 --> 02:13:14.520
nicht von Haus aus eine vernünftige

02:13:14.520 --> 02:13:16.520
Abstraktion gibt, sondern warum ich das alles

02:13:16.520 --> 02:13:18.520
von Hand machen muss, wie gesagt,

02:13:18.520 --> 02:13:20.520
das erschließt sich mir überhaupt nicht. Und das ist so

02:13:20.520 --> 02:13:22.520
ein Punkt, wo ich mir denke, das

02:13:22.520 --> 02:13:24.520
kann es irgendwie nicht sein. Das ist tatsächlich

02:13:24.520 --> 02:13:26.520
schlecht umgesetzt.

02:13:26.520 --> 02:13:28.520
Ja, wenn man das

02:13:28.520 --> 02:13:30.520
alles jetzt mal zusammennimmt, dann wird vielleicht

02:13:30.520 --> 02:13:32.520
klarer, warum ich gesagt habe, dass ich auch nach

02:13:32.520 --> 02:13:34.520
zehn Jahren, in denen ich mich nicht mit C-Sharp

02:13:34.520 --> 02:13:36.520
und.NET beschäftigt habe, relativ schnell

02:13:36.520 --> 02:13:38.520
wieder mit der Sprache und der Plattform

02:13:38.520 --> 02:13:40.520
zurechtgekommen bin. Aber warum ich

02:13:40.520 --> 02:13:42.520
auch sage, vieles fühlt sich einfach nicht

02:13:42.520 --> 02:13:44.520
mehr gut an. Beziehungsweise vieles

02:13:44.520 --> 02:13:46.520
fühlt sich einfach nicht mehr zeitgemäß an.

02:13:46.520 --> 02:13:48.520
Und da ist, wie gesagt, gerade das Jason

02:13:48.520 --> 02:13:50.520
Parsing ein unglaublich gutes Beispiel.

02:13:50.520 --> 02:13:52.520
Und da schneiden C-Sharp und.NET

02:13:52.520 --> 02:13:54.520
im Vergleich zu anderen Sprachen und Plattformen

02:13:54.520 --> 02:13:56.520
extrem schlecht ab.

02:13:56.520 --> 02:13:58.520
Aber das ist eben nur ein Beispiel. Das ist sozusagen

02:13:58.520 --> 02:14:00.520
nur die Spitze des Eisbergs. Als wir im Frühjahr

02:14:00.520 --> 02:14:02.520
angekündigt haben, zukünftig

02:14:02.520 --> 02:14:04.520
auch Go zu nutzen, kam ebenfalls

02:14:04.520 --> 02:14:06.520
relativ häufig die Frage auf,

02:14:06.520 --> 02:14:08.520
warum wir uns denn nicht für.NET entschieden hätten.

02:14:08.520 --> 02:14:10.520
Und ich glaube, diese Frage habe ich jetzt

02:14:10.520 --> 02:14:12.520
heute ausreichend beantwortet. Und natürlich,

02:14:12.520 --> 02:14:14.520
das muss man der Fairness halber noch

02:14:14.520 --> 02:14:16.520
dazu sagen, ist auch in Go

02:14:16.520 --> 02:14:18.520
oder auch in JavaScript oder...

02:14:18.520 --> 02:14:20.520
Ich denke immer auch, weil er wahrscheinlich noch ein bisschen angepisst

02:14:20.520 --> 02:14:22.520
von Microsoft ist.

02:14:22.520 --> 02:14:24.520
Auch dort gibt es Stolperfallen und Dinge,

02:14:24.520 --> 02:14:26.520
die unlogisch oder inkonsistent sind.

02:14:26.520 --> 02:14:28.520
Aber insgesamt finde ich, dass man

02:14:28.520 --> 02:14:30.520
C-Sharp sein Alter halt leider doch sehr

02:14:30.520 --> 02:14:32.520
anmerkt, weil es die vor 20

02:14:32.520 --> 02:14:34.520
Jahren eingeschlagenen und inzwischen

02:14:34.520 --> 02:14:36.520
vorgetrampelten Pfade nicht verlässt,

02:14:36.520 --> 02:14:38.520
sondern an zu vielen Stellen im Gestern verharrt

02:14:38.520 --> 02:14:40.520
und zwar irgendwie versucht neue Dinge

02:14:40.520 --> 02:14:42.520
aufzugreifen. Finde ich gar nicht mal so

02:14:42.520 --> 02:14:44.520
extrem. Also die legen

02:14:44.520 --> 02:14:46.520
in der Entwicklung, wie gesagt,

02:14:46.520 --> 02:14:48.520
ist ja schon richtig, was er sagt.

02:14:48.520 --> 02:14:50.520
Das ist alt. Und für das, dass die Sprache

02:14:50.520 --> 02:14:52.520
so viele Jahre auf den Buckel hat,

02:14:52.520 --> 02:14:54.520
legen die echt ein beachtliches

02:14:54.520 --> 02:14:56.520
Tempo vor mit ein

02:14:56.520 --> 02:14:58.520
Jahr pro Release.

02:15:00.520 --> 02:15:02.520
Ich fände es auch besser, wenn man manche Sachen

02:15:02.520 --> 02:15:04.520
fertiger machen

02:15:04.520 --> 02:15:06.520
würde, wenn sie reinkommen.

02:15:06.520 --> 02:15:08.520
Auch wenn es zwei, drei Jahre länger dauert.

02:15:10.520 --> 02:15:12.520
Dabei aber halt auf den roten Faden verzichtet.

02:15:12.520 --> 02:15:14.520
Insgesamt immer mehr zu einem

02:15:14.520 --> 02:15:16.520
zusammengewürfelten Stückwerk wird,

02:15:16.520 --> 02:15:18.520
wo von Version zu Version einfach nur

02:15:18.520 --> 02:15:20.520
noch mehr neue Schlüsselwörter hinzukommen

02:15:20.520 --> 02:15:22.520
für Spezialfälle. Und das ist eigentlich

02:15:22.520 --> 02:15:24.520
sehr schade, denn ich bin ja wie gesagt mit C-Sharp groß

02:15:24.520 --> 02:15:26.520
geworden. Und gerade die Konsistenz,

02:15:26.520 --> 02:15:28.520
die innere Schlüssigkeit, das war

02:15:28.520 --> 02:15:30.520
mal die große Stärke von C-Sharp.

02:15:30.520 --> 02:15:32.520
Und davon ist irgendwie nicht allzu viel

02:15:32.520 --> 02:15:34.520
geblieben. Und um es nochmal zu sagen,

02:15:34.520 --> 02:15:36.520
ich habe es am Anfang schon gesagt, aber es geht

02:15:36.520 --> 02:15:38.520
mir nicht darum, C-Sharp niederzumachen.

02:15:38.520 --> 02:15:40.520
Dieses Video ist einfach nur die Sammlung von

02:15:40.520 --> 02:15:42.520
den Punkten, die mir in den vergangenen Monaten

02:15:42.520 --> 02:15:44.520
an C-Sharp immer wieder negativ

02:15:44.520 --> 02:15:46.520
aufgefallen sind und die man vielleicht auch nur

02:15:46.520 --> 02:15:48.520
dann als so störend empfindet, wenn man weiß,

02:15:48.520 --> 02:15:50.520
wie es in anderen Sprachen aussieht,

02:15:50.520 --> 02:15:52.520
wie die Welt sein könnte. Und da das

02:15:52.520 --> 02:15:54.520
immer wieder gefragt wurde, haben wir

02:15:54.520 --> 02:15:56.520
das eben in diesem Video zusammengefasst.

02:15:56.520 --> 02:15:58.520
Er hat ja

02:15:58.520 --> 02:16:00.520
viel erzählt, das kann ich...

02:16:00.520 --> 02:16:02.520
Das meiste ist valid, würde ich sagen, das kann ich schon

02:16:02.520 --> 02:16:04.520
nachvollziehen.

02:16:04.520 --> 02:16:06.520
Vielleicht stört mich auch vieles nicht,

02:16:06.520 --> 02:16:10.520
weil ich es halt eben öfters verwende.

02:16:10.520 --> 02:16:12.520
Ich denke unterm Strich kann man sagen, das hat alles so

02:16:12.520 --> 02:16:14.520
seine Vor- und Nachteile. Es gibt auch genug, was mir

02:16:14.520 --> 02:16:16.520
ein Go auf den Keks geht.

02:16:16.520 --> 02:16:18.520
Es gibt genug Sachen auch, die mich an C-Sharp

02:16:18.520 --> 02:16:20.520
nerven.

02:16:20.520 --> 02:16:22.520
Insgesamt, und wir haben

02:16:22.520 --> 02:16:24.520
im Stream schon alles Mögliche gemacht, ja,

02:16:24.520 --> 02:16:26.520
von

02:16:26.520 --> 02:16:28.520
WebAssembly, C++,

02:16:28.520 --> 02:16:30.520
.NET, teilweise sogar ein bisschen

02:16:30.520 --> 02:16:32.520
Rust, alle möglichen Sachen. Wir haben uns wirklich schon

02:16:32.520 --> 02:16:34.520
viel angeguckt, also ich denke, man kann sagen,

02:16:34.520 --> 02:16:36.520
wir haben da hier einen breiten Einblick

02:16:36.520 --> 02:16:38.520
in vielen Sprachen gehabt.

02:16:38.520 --> 02:16:40.520
Für mich persönlich

02:16:40.520 --> 02:16:42.520
ist C-Sharp

02:16:42.520 --> 02:16:44.520
immer noch die Sprache, wo ich

02:16:44.520 --> 02:16:46.520
am besten mit zurecht komme und am liebsten Sachen

02:16:46.520 --> 02:16:48.520
drinne mache. Neben Ruby

02:16:48.520 --> 02:16:50.520
vielleicht, was ja

02:16:50.520 --> 02:16:52.520
nicht mehr so richtig angesagt ist.

02:16:52.520 --> 02:16:54.520
Leider, nachdem Rails so

02:16:54.520 --> 02:17:10.520
abgekackt ist.

02:17:10.520 --> 02:17:18.520
Boah, Alter, Wall of Text, Mann.

02:17:18.520 --> 02:17:20.520
Aber ich kann es nachvollziehen.

02:17:20.520 --> 02:17:22.520
Man muss ja auch nicht bei der

02:17:22.520 --> 02:17:24.520
gleiche Ansicht sein.

02:17:24.520 --> 02:17:26.520
Jeder hat so seine Vorzüge

02:17:26.520 --> 02:17:36.520
vor vorzugten Sachen.

02:17:36.520 --> 02:17:46.520
Was ist das Memereview?

02:17:46.520 --> 02:17:48.520
Jetzt nicht.

02:17:48.520 --> 02:17:50.520
Java Script for the Haters.

02:17:50.520 --> 02:17:52.520
Ja, das können wir uns tatsächlich angucken.

02:17:52.520 --> 02:17:54.520
Wir gucken jetzt in der Runde Fireship an.

02:17:54.520 --> 02:17:58.520
Geht schon wieder hier los.

02:17:58.520 --> 02:18:00.520
Rust ist doch ein Game, auch.

02:18:00.520 --> 02:18:02.520
Aber Rust ist auch eine Programmiersprache.

02:18:02.520 --> 02:18:04.520
Es ist denen aber auch aufgefallen,

02:18:04.520 --> 02:18:06.520
dass es keine allzu gute Idee ist,

02:18:06.520 --> 02:18:08.520
dass die Sprache

02:18:08.520 --> 02:18:10.520
nur Rust heißt, deswegen

02:18:10.520 --> 02:18:12.520
macht man da oftmals

02:18:12.520 --> 02:18:14.520
auch Language oder sowas dahinter,

02:18:14.520 --> 02:18:16.520
dass es nicht

02:18:16.520 --> 02:18:18.520
doppel ist. Es war eine Zeit

02:18:18.520 --> 02:18:20.520
lang so, dass, wenn man

02:18:20.520 --> 02:18:22.520
Reddit Rust gesucht hat,

02:18:22.520 --> 02:18:24.520
dass das Game zuerst kam.

02:18:24.520 --> 02:18:26.520
Mittlerweile, wahrscheinlich

02:18:26.520 --> 02:18:28.520
auch, weil Google gelernt hat, was ich mir

02:18:28.520 --> 02:18:30.520
hauptsächlich angucke,

02:18:30.520 --> 02:18:32.520
kommt tatsächlich die Programmiersprache

02:18:32.520 --> 02:18:34.520
zuerst.

02:18:34.520 --> 02:18:36.520
Ja, Go ist komplett lost.

02:18:36.520 --> 02:18:38.520
Nach Go kannst du überhaupt nicht suchen

02:18:38.520 --> 02:18:40.520
mit einfach nur Go.

02:18:40.520 --> 02:18:50.520
Selbstverständlich ist bei Go ähnlich.

02:18:50.520 --> 02:18:52.520
Bei Go stand lange Jahre immer, bei allem

02:18:52.520 --> 02:18:54.520
written in Go, wobei das ein bisschen

02:18:54.520 --> 02:18:56.520
abgenommen hat, aber in Rust ist das ganz

02:18:56.520 --> 02:18:58.520
schlimm. In Rust ist wirklich

02:18:58.520 --> 02:19:00.520
der 500.

02:19:00.520 --> 02:19:02.520
LS-Nachbau.

02:19:02.520 --> 02:19:04.520
Written in Rust.

02:19:04.520 --> 02:19:12.520
Amazingly fast.

02:19:12.520 --> 02:19:20.520
Ok, wir gucken jetzt Javascript vor der Haters an.

02:19:20.520 --> 02:19:36.520
Was macht Himen da?

02:19:36.520 --> 02:19:38.520
Ja gut.

02:19:38.520 --> 02:19:40.520
Wisst ihr, warum das in sieben Tagen entworfen

02:19:40.520 --> 02:19:42.520
wurde Javascript? Das haben wir sogar letztens

02:19:42.520 --> 02:19:44.520
in einem Video gesehen, weil die eben gesagt

02:19:44.520 --> 02:19:46.520
haben, er soll mal eine Programmiersprache,

02:19:46.520 --> 02:19:48.520
also so eine Skriptingsprache in den Browser

02:19:48.520 --> 02:19:50.520
machen, die wird aber später eh nicht

02:19:50.520 --> 02:19:52.520
benutzt.

02:19:52.520 --> 02:19:54.520
Nur zu Demozwecken, bau mal irgendwas ein,

02:19:54.520 --> 02:19:56.520
die wird später eh nicht benutzt.

02:19:56.520 --> 02:19:58.520
Tja.

02:19:58.520 --> 02:20:00.520
Und jetzt haben wir Javascript.

02:20:14.520 --> 02:20:16.520
Ja und jetzt hat er Deno am Start.

02:20:16.520 --> 02:20:42.520
Richtig.

02:20:42.520 --> 02:20:44.520
Das ist wichtig.

02:20:44.520 --> 02:20:46.520
Amazingly fast. Aber

02:20:46.520 --> 02:20:48.520
Amazingly fast können eigentlich nur Rust-Programme

02:20:48.520 --> 02:20:52.520
sein.

02:20:52.520 --> 02:20:54.520
Wie wärs denn was mit

02:20:54.520 --> 02:20:56.520
Insanely fast?

02:20:56.520 --> 02:20:58.520
Hab ich jetzt selten gehört.

02:20:58.520 --> 02:21:00.520
Insanely fast.

02:21:00.520 --> 02:21:02.520
Man gibt doch bestimmt noch irgendwelche Steigerungen

02:21:02.520 --> 02:21:10.520
davon.

02:21:10.520 --> 02:21:12.520
Ohje.

02:21:12.520 --> 02:21:24.520
Twitter ist schon unterwegs.

02:21:24.520 --> 02:21:28.520
Ok, ja es ist Javascript.

02:21:28.520 --> 02:21:30.520
Javascript ist doch die einzige Sprache, wo du so viele Dinge

02:21:30.520 --> 02:21:32.520
machen kannst.

02:21:32.520 --> 02:21:34.520
Wir wissen ja, was

02:21:34.520 --> 02:21:36.520
not a number plus not a number ist in Javascript,

02:21:36.520 --> 02:21:38.520
oder?

02:21:38.520 --> 02:21:40.520
Wer weiß es, was ist not a number plus

02:21:40.520 --> 02:21:42.520
not a number?

02:22:04.520 --> 02:22:06.520
Falsch. Falsch. Falsch. Das ist Falsch.

02:22:06.520 --> 02:22:08.520
Das ist halt

02:22:08.520 --> 02:22:10.520
Javascript.

02:22:10.520 --> 02:22:28.520
Das ist Javascript.

02:22:28.520 --> 02:22:40.520
Das ist Javascript.

02:22:40.520 --> 02:22:42.520
Ja, Javascript passt

02:22:42.520 --> 02:22:44.520
eigentlich gut jetzt

02:22:44.520 --> 02:22:46.520
als Ergänzung zu letztem.

02:22:46.520 --> 02:22:54.520
Es hat alles seine Vor- und Nachteile.

02:22:54.520 --> 02:23:22.520
Pech. Lange ist es.

02:23:22.520 --> 02:23:38.520
Kurz davor.

02:23:38.520 --> 02:23:46.520
Jetzt wissen wir Bescheid.

02:23:46.520 --> 02:23:50.520
Haben wir noch was, was wir uns geben können?

02:23:50.520 --> 02:24:08.520
Ich bin blind.

02:24:08.520 --> 02:24:20.520
Watercooling my house.

02:24:20.520 --> 02:24:22.520
Das ist ein guter Channel,

02:24:22.520 --> 02:24:24.520
wer sich ein bisschen mit

02:24:24.520 --> 02:24:26.520
.net und C-Sharp beschäftigen will.

02:24:26.520 --> 02:24:28.520
Nichts, was wir hier im Stream gucken müssten,

02:24:28.520 --> 02:24:34.520
aber der macht gute Videos.

02:24:34.520 --> 02:24:38.520
Der GameStar Test zu Warzone 2.

02:24:38.520 --> 02:24:40.520
Da bin ich ja tatsächlich mal

02:24:40.520 --> 02:24:42.520
gespannt, was die GameStar dazu sagt.

02:24:42.520 --> 02:24:44.520
Wir hatten das

02:24:44.520 --> 02:24:46.520
Manscaped Bewerbung, alles klar.

02:24:46.520 --> 02:25:00.520
Wir hatten das.

02:25:00.520 --> 02:25:02.520
Ja, der Titel ist nicht schlecht,

02:25:02.520 --> 02:25:04.520
aber ich bin sehr gespannt,

02:25:04.520 --> 02:25:14.520
was in dem Zustand des Games geht.

02:25:14.520 --> 02:25:16.520
Schau dir nochmal sowas Langes an.

02:25:16.520 --> 02:25:18.520
Muss richtig viel repetitive Arbeit machen.

02:25:18.520 --> 02:25:20.520
Grad ist perfekt für den Ball.

02:25:20.520 --> 02:25:26.520
Ich bin nicht mal lange da.

02:25:26.520 --> 02:25:56.500
mal eins an. Wer? Na toll. Bei der Musik, ah ja. Okay, hab ich noch nie gehört. Was

02:25:56.500 --> 02:26:12.320
bei der Musik geht? Pepo Dance geht da gerade ab. Das ist wirklich ein guter Soundtrack von dem

02:26:12.320 --> 02:26:27.240
Game. Crypt of the Necrodancer. Das ist ein uraltes, 2015, das ist ein uraltes Game. Ein

02:26:27.240 --> 02:26:30.320
guter Ding auf No Man's Sky, das haben wir schon geguckt vor drei Jahren oder so,

02:26:30.320 --> 02:26:37.320
als das rausgekommen ist. Okay, komm, wir gucken uns jetzt an, was die GameStar zu Warzone 2 sagt.

02:26:37.320 --> 02:26:47.200
Immer gespannt. Mein Eindruck von Warzone war ja kurz und knackig. Ich hab nicht viel gespielt,

02:26:47.200 --> 02:26:57.520
hab auch überhaupt keinen Bock mehr drauf. Tommy, nur für dich. Du meinst das hier. Das

02:26:57.520 --> 02:27:22.240
hier willst du hören, oder?

02:27:27.520 --> 02:27:50.720
Ein Durchgang, hören wir uns an. Also nicht zehn Stunden, sondern ein Durchgang des Songs.

02:27:57.520 --> 02:28:15.880
Zehn Stunden, hören wir uns nicht an. Okay, einmal durch. Banger, richtiger Banger. Okay,

02:28:15.880 --> 02:28:27.560
also was sagt denn die GameStar zu Warzone? Zeig mal her. Kommen wir uns jetzt mal an. Schauen wir mal.

02:28:27.560 --> 02:28:47.360
Warzone 2 ist im Grunde genauso gestartet. Das Warzone Grill. Wieder Multiplayer von

02:28:47.360 --> 02:28:52.960
Modern Warfare 2 und davor auch die Singleplayer Kampagne vom 2022. Nee,

02:28:52.960 --> 02:28:57.400
das ist Petra Schmitz. Die ist uralt bei der GameStar schon dabei. Ich will nicht sagen,

02:28:57.400 --> 02:29:01.360
nein, sorry, ich will nicht sagen, die ist uralt. Die ist schon sehr lange bei der GameStar dabei.

02:29:01.360 --> 02:29:05.360
Ich glaub, so alt ist die gar nicht. Wahrscheinlich ein bisschen älter als ich oder so. Die ist schon

02:29:05.360 --> 02:29:11.440
ewig bei der GameStar dabei. Als ich die GameStar abonniert hatte, gab's die schon. Die ist uralt,

02:29:11.440 --> 02:29:33.280
also bei der GameStar. Das wollte ich damit sagen. Schon richtig lange dabei. So lang nicht im

02:29:33.280 --> 02:29:50.880
direkten Vergleich mit Battlefield 2042. Der Gulag mit zwei Leuten hat mir überhaupt nicht

02:29:50.880 --> 02:29:56.080
gefallen. Und auch ansonsten technisch wirkt das sehr holprig noch. Übrigens,

02:29:56.080 --> 02:30:01.320
könnt ihr euch dran erinnern, wir haben doch letztens ein Video geguckt. Hier, von ihm. Haben

02:30:01.320 --> 02:30:09.960
wir doch letztens ein Video geschaut. Nicht dice please nerf. Wir haben so letztens ein Video

02:30:09.960 --> 02:30:17.200
von ihm angeschaut zu Warzone, wo er richtig über die Entwickler hergezogen hat. Und guckt mal,

02:30:17.200 --> 02:30:24.560
das Video ist weg. Ich weiß nicht, ob er das Video selbst gelöscht hat oder ob das Leute,

02:30:24.560 --> 02:30:31.840
ob das irgendwelche Warzone-Fanboys gemeldet haben und es wurde gesperrt. Keine Ahnung. Würde

02:30:31.840 --> 02:30:45.320
mich echt mal interessieren. Wir haben Warzone 2 in den letzten Tagen hoch und runter gespielt,

02:30:45.320 --> 02:30:51.320
uns über furchtbare Menüs, Performance-Probleme und Interface-Pucks geärgert und dennoch zahlreiche

02:30:51.320 --> 02:30:56.320
spannende Gefechte erlebt. Neuerungen wie der Proximity-Chat, mit dem wir die Stimmen

02:30:56.320 --> 02:31:01.640
unserer Gegner in der Nähe hören können, sorgen für Überraschung, Panik. Massive Controller Auto

02:31:01.640 --> 02:31:07.200
Aim, nice. Erfolgreichen Kills auch mal für Schadenfreude, sofern man diese Funktion aktiviert

02:31:07.200 --> 02:31:16.880
hat natürlich. Und der neue DMZ-Modus bringt vielleicht Spieler und Spielerinnen zum ersten Mal. Hat mir

02:31:16.880 --> 02:31:24.240
auch nicht, ganz ehrlich, DMZ hat mir überhaupt nicht gefallen. Ich habe Bots gekillt, auf einmal

02:31:24.240 --> 02:31:29.160
sehe ich im Killfeed, das war ein echter Gegner. Also so Modi, wo das gemischt wird, ich weiß nicht,

02:31:29.160 --> 02:31:33.640
ist nicht meins. Vielleicht ist es ja super High-IQ-Spielmodus, ich habe die Generalität noch

02:31:33.640 --> 02:31:40.320
nicht gecheckt, kann sein. Mein Fall war es nicht. Den Kontakt mit dem Extraction-Gameplay von Genre

02:31:40.320 --> 02:31:51.840
Hits wie Hunt Showdown oder natürlich Escape from Tarkov. Leute, Hazard Zone. Wer weiß,

02:31:51.840 --> 02:31:57.080
vielleicht wird DMZ sogar das Sprungbrett, das dieses Genre braucht, um mal so ganz groß durch

02:31:57.080 --> 02:32:01.600
zu starten. Ich weiß das. Wenn die Entwickler herausgefunden haben, wohin die Reise damit gehen

02:32:01.600 --> 02:32:07.680
soll, denn aktuell ist DMZ noch in einer Beta und das zu Recht. Aber fangen wir doch mal mit

02:32:07.680 --> 02:32:14.040
Warzone 2 und seiner gigantischen Karte an. Nach Verdansk und Caldera, die ersten Warzone,

02:32:14.040 --> 02:32:20.320
geht es dank Almazra in Warzone 2 nun in die Wüste und die ist riesig und gar nicht so...

02:32:20.320 --> 02:32:25.880
Endlich! Ich war nehme ich doch nie in einer Wüste. Öde, wie man beim Wörtchen Wüste

02:32:25.880 --> 02:32:32.160
zunächst meinen sollte. Auf der Karte finden wir x kleinere und größere Siedlungen mit Almazra City,

02:32:32.160 --> 02:32:37.560
sogar eine recht moderne Ortschaft inklusive Hochhäusern, wobei weitem nicht so viele Sniper

02:32:37.560 --> 02:32:43.520
rumlungern, wie man das vielleicht vermuten würde. Denn, und das ist in diesem Fall Segen und Fluch

02:32:43.520 --> 02:32:48.600
zugleich, die Häuser sind nicht nur als Häuser getarnte Türme, sie haben auch Stockwerke,

02:32:48.600 --> 02:32:54.520
verschachtelte Gänge, Aufzüge, viele kleine und große Räume. Allein die Fläche, die dadurch in

02:32:54.520 --> 02:32:59.680
dieser City entsteht, ist riesig. Da verlaufen sich die Spieler schon mal und Sniper können

02:32:59.680 --> 02:33:05.960
gefühlte Wochen auf den Dächern rumlungern, ohne auch nur einen Gegner zu sehen. So ist halt Battle

02:33:05.960 --> 02:33:12.320
Royale Gameplay. Da kannst du theoretisch, wenn du Glück hast mit der Zone, auch mal 20 Minuten auf

02:33:12.320 --> 02:33:18.560
einem Flag liegen und dir passiert nichts. Du reißt aber auch nichts. Und diese süde Wahrheit lässt

02:33:18.560 --> 02:33:23.360
sich auf viele andere Abschnitte der Karte übertragen. Was uns nun wieder mal wünschen lässt,

02:33:23.360 --> 02:33:29.880
es würden nicht nur 150, sondern 200 Menschen Platz in einer Partie finden. Insbesondere wenn

02:33:29.880 --> 02:33:34.640
man in einer Partie landet, in der sich nicht nur ein großer Kreis von Beginn anschließt,

02:33:34.640 --> 02:33:39.440
sondern zunächst drei separate, die erst später miteinander verschmelzen. Dann kann es passieren,

02:33:39.440 --> 02:33:45.880
dass man in seinem Kreis nahezu alleine unterwegs ist. Hallo, ist hier jemand? Besser? Hey, Leute,

02:33:45.880 --> 02:33:53.440
ich erinnere nur mal an den Halo Battle Royale Modus, wo der Endkreis noch nicht mal random ist

02:33:53.440 --> 02:34:01.840
und so gelegt ist, dass du teilweise im Aussitzen, also fast im Aussitzen kannst, wo keiner zu dir

02:34:01.840 --> 02:34:07.040
kommen kann und sowas. Also das ist das hier ja mal richtig high IQ dagegen. Mr. Moogame,

02:34:07.040 --> 02:34:23.560
Dankeschön für den Sub. What the fuck? Okay, die schiere Größe der Map und die Zufallskreise

02:34:23.560 --> 02:34:28.240
haben auch Vorteile. Nämlich für alle, die es lieber ruhig angehen, für alle die Gefechte

02:34:28.240 --> 02:34:35.720
lieber vermeiden, als sie zu suchen, um sich erst einmal in Ruhe auszurüsten. Das ist auch

02:34:35.720 --> 02:34:41.640
so ein Ding, wo ich bedenke, und das war teilweise im ersten schon so, dass diese Dinge, aber wer

02:34:41.640 --> 02:34:50.400
hat sich gedacht, das sieht gut aus. Aber irgendwann wird auch diese Spieler und Spielerinnen das

02:34:50.400 --> 02:34:56.040
Schicksal in Form der Gaswolke ereilen, die die Karte schrumpfen und damit Auseinandersetzung

02:34:56.040 --> 02:35:06.480
unausweichlich werden lässt. Was ich meine, naja guck mal, diese weiße Kontur, das sieht einfach

02:35:06.480 --> 02:35:13.280
kacke aus. Das sieht aus wie nicht richtig geladen. Auseinandersetzung unausweichlich werden lässt

02:35:13.280 --> 02:35:20.040
Battle Royale eben. Wer aber nun von Warzone 1 rüber gemacht hat, wird sich nicht nur in Sachen

02:35:20.040 --> 02:35:26.000
Kreismechanik und Webgröße umstellen müssen. Das neue Loadout-System hat nämlich auch so seine

02:35:26.000 --> 02:35:30.920
Tücken. Das stimmt, ich verstehe, dass ganz viele Warzone-Spieler das Loadout-System Scheiße

02:35:30.920 --> 02:35:36.120
finden, weil sie halt sagen, ok, bei Caldera, wie gesagt, ich habe nur Verdant gespielt, ein

02:35:36.120 --> 02:35:41.080
bisschen als es rausgekommen ist, wie es auf Caldera war mit dem Loot, weiß ich ehrlich gesagt nicht,

02:35:41.080 --> 02:35:46.040
ich gehe mal davon aus ähnlich. Dass sie das Scheiße finden, verstehe ich, früher hast du

02:35:46.040 --> 02:35:52.760
dein Loadout gecalled, nach einer Weile, da hat es seine Klasse und alles war gut. Es macht das

02:35:52.760 --> 02:36:00.120
Ganze aber etwas Battle Royaleiger, mit dem mehr Looten und an den Stationen erstmal noch die

02:36:00.120 --> 02:36:11.480
Primary Waffen kaufen können. Dass es jetzt diese Bot-Base-Dinger da gibt, mit Quests quasi für

02:36:11.480 --> 02:36:17.440
das Loadout, ja, durftest du das brauchen? Das macht es zumindest etwas Battle Royaleiger,

02:36:17.440 --> 02:36:22.880
mit dem Looten finde ich. Während man in Warzone 1 nach ein paar Minuten mit einem privaten Loadout

02:36:22.880 --> 02:36:28.320
Drop mit zuvor hochgelevelten, akribisch zusammengestellten und optisch personalisierten

02:36:28.320 --> 02:36:33.760
Waffen sowie Gadgets und Perks rechnen konnte, muss man sich nun anstrengen, um an den Krempel zu

02:36:33.760 --> 02:36:39.440
kommen. Es gibt zwei recht gefährliche Möglichkeiten. Erstens, man wartet, bis die

02:36:39.440 --> 02:36:45.160
Map sogenannte Strongholds ausweist. Diese Festungen sind von zig irrsinnig gut treffenden

02:36:45.160 --> 02:36:50.640
und teilweise ekelhaft gepanzerten KI-Soldaten bewacht. Die Mischung finde ich auch nicht gut.

02:36:50.640 --> 02:37:00.240
Ganz ehrlich, Bots passen da irgendwie nicht rein. Also das, was ich bisher davon gesehen habe,

02:37:00.240 --> 02:37:05.600
hat mich nicht überzeugt. Dass an den Festungen aber nicht nur zig KI-Soldaten und man selbst drum

02:37:05.600 --> 02:37:10.640
hängt, dürfte nachvollziehbar sein. Immerhin ist eine Festung mal offen. Ja und du siehst

02:37:10.640 --> 02:37:15.000
auf den ersten Blick noch nicht mal, wer Gegner ist und wer Bot ist. Klar, am Movement und

02:37:15.000 --> 02:37:20.120
letztendlich wahrscheinlich erkennst du es auch ganz gut, wenn du da einen Blick für hast an der

02:37:20.120 --> 02:37:24.920
Optik. Aber für mich als Noob, der es noch nicht viel gespielt hat, ich habe erst mal gedacht,

02:37:24.920 --> 02:37:28.400
ja wie? Ach, das war jetzt ein echter Gegner. Ist mir erst mal gar nicht aufgefallen. Ist mir erst

02:37:28.400 --> 02:37:33.520
nach dem Kill aufgefallen, dass es ein echter Gegner war. Und sich bedienen, sofern sich der Kreis

02:37:33.520 --> 02:37:38.920
nicht schon zu weit geschlossen hat. Aber die Design-Entscheidung, starke KI in ein Battle Royale

02:37:38.920 --> 02:37:44.320
zu packen und sie obendrein noch ans eigene Loadout zu koppeln, sorgt wesentlich öfter für Frust

02:37:44.320 --> 02:37:50.800
als für Spielspaß. Okay. Zweitens, im letzten Drittel einer Partie fallen dann auch Loadout-Drops,

02:37:50.800 --> 02:37:56.080
die allerdings alle Spieler plündern können. Auch hier nachvollziehbar, dass man nur selten

02:37:56.080 --> 02:38:00.840
die Chance bekommt, sich dort unbehelligt zu bedienen. Alternativ kann man immerhin noch

02:38:00.840 --> 02:38:05.440
seine Primärwaffen aus seinen Custom-Loadouts an den typischen Kaufstationen erstehen,

02:38:05.440 --> 02:38:11.000
sofern man zuvor genug Kohle eingesammelt hat. Aber das wundervolle, wenn auch trügerische

02:38:11.000 --> 02:38:15.680
Gefühl der Sicherheit, das mit dem eigenen Krempel kommt, wird man als normalsterblicher

02:38:15.680 --> 02:38:23.680
trotzdem vergleichsweise selten erleben. Also nur logisch, dass das eigene Loadout auch im

02:38:23.680 --> 02:38:28.080
Pre-Match keine... Mal gucken. Sie haben ja in Warzone 1 auch die ein oder anderen Anpassungen

02:38:28.080 --> 02:38:36.000
gemacht. Vielleicht kommen sie den Warzone-Fans noch ein bisschen entgegen. Und eine Sache,

02:38:36.000 --> 02:38:43.480
die ich auch schon bei Verdansk nicht hübsch fand, ist, die Map ist zwar groß, die Map ist

02:38:43.480 --> 02:38:49.480
spielerisch sicherlich auch für Battle Royale gut gemacht und in gewisser Weise auch ein

02:38:49.480 --> 02:38:54.040
bisschen abwechslungsreich mit den unterschiedlichen Arealen. Aber eins muss man echt sagen, wirklich

02:38:54.040 --> 02:39:00.120
schön fand ich Verdansk nicht, Caldera, keine Ahnung, habe ich nicht gespielt und schön

02:39:00.120 --> 02:39:06.080
finde ich jetzt auch die Map nicht. Da muss ich sagen, da fand ich fast die... Wie hieß

02:39:06.080 --> 02:39:13.480
das Ding? Weiß noch jemand, wie der Kram in Black Ops hieß? Die ja quasi zur Hälfte

02:39:13.480 --> 02:39:18.760
aus alten Black Ops Maps bestanden haben. Also da fand ich tatsächlich die Map in diesem

02:39:18.760 --> 02:39:23.240
Black Ops Battle Royale, ich rede nicht vom Gameplay, rein von der Optik her, sogar noch

02:39:23.240 --> 02:39:35.480
irgendwie schöner. Also vom Hocker reißen die mich nicht. Gut, dass große Maps noch

02:39:35.480 --> 02:39:46.800
liebloser sein können, sieht man bei Battlefield 2042. Blackout, ja. Hier sind ja auch, sieht

02:39:46.800 --> 02:39:51.080
man ja, das ist ja auch eine MW2 Map, wo man da gerade drauf ist. Es sind viele Stellen,

02:39:51.080 --> 02:39:59.160
sind alte Maps, aber so die Verbindungen dazwischen, es sieht irgendwie nicht, weiß nicht, es sieht

02:39:59.160 --> 02:40:03.280
jetzt optisch nicht so ansprechend aus, da ich sage, oh das ist aber eine schicke Map.

02:40:03.280 --> 02:40:08.080
Über Abschüsse im Pre-Match, wer aber hofft hier seine Lieblingswaffe gezielt hochspielen

02:40:08.080 --> 02:40:13.520
zu können, schaut in die Röhre. Das ist insbesondere für Free-to-Play-Spieler doof, die nicht schon

02:40:13.520 --> 02:40:19.920
im Multiplayer von Modern Warfare 2 ihre bevorzugten Waffen hochleveln konnten. In diesem Kontext

02:40:19.920 --> 02:40:25.800
die Frage, ist das für ein Free-to-Play-Spiel der richtige Ansatz? Warum sollte ich Kohle

02:40:25.800 --> 02:40:31.440
in Fancy-Waffen-Blueprints und Co. investieren, wenn ich den Kram ohnehin nur alle 3-4 Matches

02:40:31.440 --> 02:40:35.640
zu Gesicht bekomme? Gute Frage. Ihr mutmaßen, dass Activision hier über kurz oder lang

02:40:35.640 --> 02:40:41.560
noch einmal anpassen wird, sowohl in Sachen Pre-Match als auch beim Loadout-System. Nun

02:40:41.560 --> 02:40:46.080
ja, wer seinen Kram gar nicht oder erst sehr spät im Spiel bekommt, der muss wirklich

02:40:46.080 --> 02:40:57.280
noch Money optimiert werden. Wie gesagt, das macht es insgesamt etwas Battle-Royaliger,

02:40:57.280 --> 02:41:01.800
dass man nicht so direkt nach dem ersten Drittel auf jeden Fall seinen Loadout am Start hat.

02:41:01.800 --> 02:41:10.080
Ja, kann man jetzt gut finden oder nicht? Ich verstehe, dass es viele alte Warzone-Spieler,

02:41:10.080 --> 02:41:14.640
also die letzten Teil lange gespielt haben, nicht gut finden. Ich könnte mir aber wiederum

02:41:14.640 --> 02:41:20.080
vorstellen, dass viele Battle-Royal-Liebhaber an sich das mögen werden.

02:41:20.080 --> 02:41:26.000
Nicht mehr nur in den typischen Kisten oder einfach auf dem Boden, sondern auch in Regalen

02:41:26.000 --> 02:41:30.320
oder gar Schränken. Das vermittelt einen mild gesteigerten Realismus gegenüber dem

02:41:30.320 --> 02:41:36.040
ersten Warzone. Das Spiel versucht sich auch andernorts an Realismus. So verbrauchen Fahrzeuge

02:41:36.040 --> 02:41:41.240
oder Helikopter oder Boote Benzin und müssen wieder aufgetankt werden, sobald sie leergefahren

02:41:41.240 --> 02:41:46.800
sind. Kommt selten genug vor, ist aber drin. Und auch die Batterie des Herzschlag-Sensors

02:41:46.800 --> 02:41:51.840
leert sich nun nach und nach, was durchaus ärgerlich am Ende einer Partie sein kann.

02:41:51.840 --> 02:41:55.440
Und wie füllt man die wieder auf? Gar nicht neues Attachement einsammeln oder wie?

02:41:55.440 --> 02:42:01.360
Noch einen zweiten Sensor im Gepäck. Warzone 2 arbeitet nun mit zusätzlichen Rucksäcken

02:42:01.360 --> 02:42:04.640
in unterschiedlichen... Ja, macht es auch ein bisschen Battle-Royaliger.

02:42:04.640 --> 02:42:09.720
Wie gesagt, das ist das, was mich hier die Leute nach dem Tag gefragt haben, was ich

02:42:09.720 --> 02:42:13.440
davon halte. Das Erste, was mir eingefallen ist, ist, dass das durch viele Sachen eben

02:42:13.440 --> 02:42:22.000
etwas mehr klassischer Richtung Battle-Royal geht. Auch mit dem Inventory und dem Looten

02:42:22.000 --> 02:42:27.000
und dass du nicht direkt ein Loadout hast. Es ist ein Hauch mehr Battle-Royal als die

02:42:27.000 --> 02:42:31.520
letzten Warzones. Im Grüßen. Als das letzte Warzone, aber es sind ja im Prinzip trotzdem

02:42:31.520 --> 02:42:36.720
mehrere Ausgaben davon gewesen. Darin kann man beispielsweise eben einen zweiten Herzschlag-Sensor

02:42:36.720 --> 02:42:43.440
packen, Munition oder auch aufgesammelte Killstreaks. So toll das ist, so fummelig kann es in der

02:42:43.440 --> 02:42:47.920
Hitze des Grafenflieger werden, sich die Rosinen aus den Hinterlassenschaften anderer zu glauben.

02:42:47.920 --> 02:42:51.280
Ja, das war vorher noch schlimmer. Das war ja vorher noch schlimmer. Da hast du immer

02:42:51.280 --> 02:42:54.400
Sachen aufgehoben, die du nicht haben wolltest. Wenn Waffen nach einer zünftigen Ballerei

02:42:54.400 --> 02:42:59.800
auf dem Boden rumliegen und man etwas aufheben will, passiert es gerne mal, dass insbesondere

02:42:59.800 --> 02:43:05.120
Rucksäcke die darunter liegenden Waffen blockieren. Das muss dringend entschlackt beziehungsweise

02:43:05.120 --> 02:43:11.680
entbackt werden. Null. Damit nix entbackt. Wer in Warzone 2 den Löffel abgibt, wandert

02:43:11.680 --> 02:43:14.840
nach wie vor in dem Spiel. Die Leute haben sich dran gewöhnt, also die Entwickler dort

02:43:14.840 --> 02:43:21.680
haben sich dran gewöhnt, dass sich die Spieler so mit half-assed, halb-fertiges Zeug zufrieden

02:43:21.680 --> 02:43:26.000
geben. Die werden da nichts verbessern, solange es nicht negative Auswirkungen irgendwie auf

02:43:26.000 --> 02:43:30.400
das Spiel und letztendlich auf das Geld hat. Solange die Spieler da spielen, bauen die

02:43:30.400 --> 02:43:36.160
lieber neue Sachen und verschwenden ihre Zeit darauf, als Sachen zu fixen, wenn die Spieler

02:43:36.160 --> 02:43:45.960
doch das akzeptieren, dass es kaputt ist. Ja, das hat mir auch nicht gefallen, 2 versus

02:43:45.960 --> 02:43:51.720
2. Ich nicht. Ja.

02:43:51.720 --> 02:44:19.000
Jetzt haben wir schon eine Menge Dinge beschrieben, die Warzone 2 im Vergleich zum ersten Teil

02:44:19.000 --> 02:44:24.720
in unseren Augen nicht ganz so elegant löst. Aber was macht das mit dem Spielgefühl? Eine

02:44:24.720 --> 02:44:29.960
Menge. Und dann auch wieder in der Hitze des Gefechts vergleichsweise wenig. Denn das

02:44:29.960 --> 02:44:35.240
Schussgefühl ist grandios. Das Movement macht einfach Laune. Die Spannung ist zum Ausflippen

02:44:35.240 --> 02:44:41.360
spannend. Ausflippen. Und durch die Häuserschluchten von Almazra zu laufen, vermittelt tatsächlich

02:44:41.360 --> 02:44:46.320
ein, um es im Marketing Englisch zu sagen, super excited, stellenweise intensiveres

02:44:46.320 --> 02:44:51.280
Gefühl, als über die Weiten von Caldera zu fetzen. Weil ja wirklich überall jemand

02:44:51.280 --> 02:44:57.680
lauern könnte. Das ist eine typische GameStar Formulierung. Da merkste, dass sie das schon

02:44:57.680 --> 02:45:03.760
lange macht. Das ist wie die GameStar bei Hack'n'Slay-Spielen früher geschrieben hat,

02:45:03.760 --> 02:45:09.760
die wilde Monster-Huts geht wieder los oder solches Zeug. Irgendwo hinter einem Fenster.

02:45:09.760 --> 02:45:14.360
Und wenn diese Anspannung dann darin gipfelt, dass man unter den letzten Menschen auf der

02:45:14.360 --> 02:45:20.080
bald winzigen Map ist und man zu guter Letzt auch noch gewinnt, das ist wirklich diese

02:45:20.080 --> 02:45:26.800
einzigartige Stärke eines guten Battle Royale. Ja, das ist auch das, was es im Stream auf

02:45:26.800 --> 02:45:32.120
Twitch so beliebt macht. Und der Weg zu einem ausgezeichneten ist gar nicht so weit, wie

02:45:32.120 --> 02:45:36.660
es vielleicht jetzt noch wirken mag. Das Spiel hat nur das Pech, sich mit seinem Vorgänger

02:45:36.660 --> 02:45:41.920
messen zu müssen. Ach ja und Bugs. Bugs hat es auch.

02:45:41.920 --> 02:45:46.680
Abschließend noch ein paar Gedanken zu DMZ, das wie gesagt aktuell noch in der Beta steckt.

02:45:46.680 --> 02:45:52.640
Darin wird die Map von Al-Masra zu einem Gebiet, in dem sich überall KI-Soldaten aufhalten,

02:45:52.640 --> 02:45:55.880
aber auch Spieler und Spielerinnengruppen. Ja, hat mir nicht wirklich gefallen.

02:45:55.880 --> 02:45:58.920
Die müssen vor festgelegte Aufträge und in der Partie getriggerte Einsätze...

02:45:58.920 --> 02:46:02.160
Alter, was? Was ist das für Pepega-Aim hier? Das ist ja noch schlimmer als meins und ich

02:46:02.160 --> 02:46:06.800
hab's die letzten Tage schon verkackt.... um weitere Aufträge freigeschaltet zu bekommen

02:46:06.800 --> 02:46:09.160
und so weiter und so fort. Das ist auch noch Controller.

02:46:09.160 --> 02:46:14.080
Hier levelt man Waffen und seinen grundsätzlichen Rang. Und wer sich richtig reinkniet, kann

02:46:14.080 --> 02:46:19.400
außerdem Waffen-Blueprints freispielen. Aber das alles nur, wenn man es wie eben in

02:46:19.400 --> 02:46:23.960
Hand Showdown oder Escape from Tarkov schafft, am Ende von der Map zu entkommen.

02:46:23.960 --> 02:46:28.160
Wem das nicht gelingt, der hat nicht einfach nur eine Partie in den Sand gesetzt, sondern

02:46:28.160 --> 02:46:33.160
verliert auch die Waffen. Denn das Spiel weist uns zuvor ein Pool von Knarren zu, aus dem

02:46:33.160 --> 02:46:36.880
wir wählen können. Sterben wir, gehen die gewählten Waffen verloren und am Ende...

02:46:36.880 --> 02:46:40.120
Also, bisschen wie Hazard Zone, nur hoffentlich besser.

02:46:40.120 --> 02:46:44.800
Am Ende können wir nur alle paar Stunden auf unsere Backup-Wumme zugreifen oder müssen

02:46:44.800 --> 02:46:49.560
schlicht und ergreifend zunächst mit langen Fäusten in ein Match. Grundsätzlich sollte

02:46:49.560 --> 02:46:54.200
man sich für die MC eine feste Gruppe suchen, in der alle Teilnehmer die gleichen Aufträge

02:46:54.200 --> 02:46:59.320
erfüllen müssen. Andernfalls haben im schlimmsten Fall drei Leute neun unterschiedliche Ziele

02:46:59.320 --> 02:47:03.300
auf der Karte und das artet schnell... Ja, mit random Leuten kannst du sowas eh

02:47:03.300 --> 02:47:08.200
prinzipiell nicht spielen. Und wo wir gerade bei Zielen sind, wir wissen

02:47:08.200 --> 02:47:13.480
noch nicht, was das große Ziel von DMZ sein soll. Weil die Map so riesig ist und die echten

02:47:13.480 --> 02:47:19.120
Gegenspieler so wenig, es sind nur 66 Menschen in einer Lobby, weil die Aufträge nicht sonderlich

02:47:19.120 --> 02:47:23.760
einfallsreich und die KI-Gegner ab Punkt X nur noch nervig sind, haben wir recht schnell

02:47:23.760 --> 02:47:28.160
die Lust an diesem Spielmodus verloren. Ja, ich hab's einmal gespielt, kein Lob mehr

02:47:28.160 --> 02:47:31.000
gehabt. Eine erfolgreiche Extraktion aus DMZ ist

02:47:31.000 --> 02:47:35.720
nur halb so befriedigend wie eine aus Hunt Showdown. Außer vielleicht man hat die begehrte

02:47:35.720 --> 02:47:40.960
Waffe des Chemikers retten können. Aber wie schon gesagt, DMZ ist offiziell noch

02:47:40.960 --> 02:47:44.560
in einer Beta. Ich hoffe der Chemiker ist auch ein Chineser.

02:47:44.560 --> 02:47:49.600
Genau neben ist das Warzone 2 auch noch. Vieles funktioniert noch nicht einwandfrei, einiges

02:47:49.600 --> 02:47:54.520
ist schlichtweg nicht zu 100% gelungen. Und kleinere Varianten wie zuletzt in Warzone

02:47:54.520 --> 02:48:00.240
1, die fehlen uns übrigens auch. Und trotzdem macht Warzone 2 jetzt schon wahnsinnig viel

02:48:00.240 --> 02:48:05.040
Laune. Wenn die Entwicklungsteams in den kommenden Wochen auf die Kritik der Spielerinnen und

02:48:05.040 --> 02:48:08.560
Spieler hören, werden die Gefechte auf Almasra zu einem Battle Royale.

02:48:08.560 --> 02:48:15.320
Das ist ja nun wirklich nicht ihre Stärke. Auf Kritik bzw. Feedback zu hören.

02:48:15.320 --> 02:48:25.360
Da sind wir uns sicher. Okay. Jetzt wissen wir auch was die GAMES

02:48:25.360 --> 02:48:31.440
auch dazu denkt. Schlauer bin ich jetzt nicht danach. Hat hier mal ein Axis Point & Switches

02:48:31.440 --> 02:48:42.840
von TP-Link im Einsatz? Nope. Hab ich nicht. TP-Link hatte diese Omada-Geschichten, die

02:48:42.840 --> 02:48:50.680
so ein bisschen Unify-Interface-Clones sind. Aber bessere Features zum größten Teil unterstützen

02:48:50.680 --> 02:49:01.880
als Unify. Warum Unify so beliebt ist? Kannste nicht mehr ganz nachvollziehen.

02:49:01.880 --> 02:49:12.800
Gut, Mundpropaganda letztendlich. Viele auf YouTube haben das vorgestellt und es funktioniert

02:49:12.800 --> 02:49:18.360
ja auch ganz brauchbar. Weil ich sagen muss, weder Preis-Leistungstechnisch noch von Features

02:49:18.360 --> 02:49:25.120
her finde ich das so überzeugend. Es sieht halt cool aus. Also Leute die auch Apple-UIs

02:49:25.120 --> 02:49:29.960
mögen oder so, die mögen wahrscheinlich auch das Unify-UI, weil das so clean aussieht.

02:49:29.960 --> 02:49:50.360
Ja, PPSK, genau, das kann ja Unify nicht. Na gut, Cisco ist ja wieder eine ganz andere

02:49:50.360 --> 02:50:10.520
Axis Point nach 1500 Euro. Aber TP-Link ist von Features her tatsächlich besser. Leute,

02:50:10.520 --> 02:50:14.480
bald ist es soweit, bald bestelle ich den neuen Rechner, wenn ich den Lade-Teile bekomme

02:50:14.480 --> 02:50:20.480
und nicht ein Teil davon wahnsinnig überzogen teuer ist. Dezember wird der Rechner gebaut.

02:50:20.480 --> 02:50:33.680
13900k, vielleicht auch in 13700. Mal gucken. Wahrscheinlich zum ersten Mal eine Wasserkühlung,

02:50:33.680 --> 02:50:47.240
also all in one, Wasserkühlung. 4090, 32G RAM, DDR5, das wird teuer. Das wird auf jeden

02:50:47.240 --> 02:50:58.440
Fall nicht billig. Das wird ein teurer Dezember. Ich brauche ein neues Handy, ein neuer Rechner,

02:50:58.440 --> 02:51:05.480
ein Capture-Card, bin wahrscheinlich den Dezember irgendwie 6000, 7000 Euro los für Technikspielerei

02:51:05.480 --> 02:51:18.280
quasi insgesamt. Das wird nicht billig, aber man gönnt sich ja sonst nichts. Warum Wasserkühlung?

02:51:18.280 --> 02:51:30.240
Weil das Ding verdammt viel Abwärme erzeugt. Was für ein Handy, ich kaufe mir wahrscheinlich

02:51:30.240 --> 02:51:43.040
ein iPhone 14 Pro, kein Plus, ist mir zu groß. Ist auch unsinnig teuer. Ja, wird wieder ein

02:51:43.040 --> 02:51:53.920
neuer Rechner. Was ist eigentlich aus dem Bewerbungsgespräch geworden? Ich hatte letzte Woche Montag Vorstellungsgespräch.

02:51:53.920 --> 02:52:02.000
Was diese Woche Montag? Nee, letzte Woche Montag. Lief gut, haben sich auch gleich gemeldet

02:52:02.000 --> 02:52:08.440
bei mir und nächste Woche fahre ich da mal hin und gucke mir das vor Ort an. Leute, kennt

02:52:08.440 --> 02:52:15.600
sich jemand in Würzburg bei euch aus am Bahnhof? Da muss ich demnächst hinfahren. Wo sind denn

02:52:15.600 --> 02:52:20.920
da die Busse? Wie muss man da laufen? Kein Ding, wenn ihr es nicht wisst, ich kann mir

02:52:20.920 --> 02:52:28.320
jetzt einfach Google Maps angucken oder beziehungsweise im Routenplaner. Vielleicht weist aber einer

02:52:28.320 --> 02:52:34.400
aus dem Kopf, wie es da so ausschaut. War schon ein Gespräch mit einem aktuellen Arbeitgeber?

02:52:34.400 --> 02:52:38.640
Sponsor der den Rechner, wenn du bleibst. Nein, machen sie nicht. Aber ein Gespräch mit aktuellem

02:52:38.640 --> 02:52:46.520
Arbeitgeber war schon, ist nichts rausgekommen. Also ich bin wohl Ende des Jahres dort weg.

02:52:46.520 --> 02:52:53.360
Ne, ne, ne. Also eine Wasserkühlung ist auf jeden Fall jedem auch eine teure Noctur oder

02:52:53.360 --> 02:53:00.000
sonst was überlegen. Die können ja auch die Physik nicht überlisten. Die können schon

02:53:00.000 --> 02:53:06.120
mithalten. Aber der 13900K, der verbraucht halt richtig viel Strom, verzeugt richtig

02:53:06.120 --> 02:53:17.320
viel Abwärme. Wenn man okay ist, dass der runter taktet bei ordentlicher Last. Ja. Ich

02:53:17.320 --> 02:53:29.920
hatte noch nie eine Wasserkühlung. Ich bin da echt mal gespannt. Ohne Kündigungsfrist,

02:53:29.920 --> 02:53:35.760
ne. Kündigungsfrist habe ich. Mag es eine Frage mal alle hier? Wie sieht es mit Tattoos

02:53:35.760 --> 02:53:45.640
im IT Bereich aus? Juckt keinen. Je nachdem wo du die hast, wirst du vielleicht schepp

02:53:45.640 --> 02:53:52.200
angeguckt. So wie auf der Straße auch. Wenn es gar so offensichtlich oder zu ausgefallen

02:53:52.200 --> 02:53:57.960
oder zu groß oder an komischen Stellen ist. Aber ansonsten juckt das keinen. Zumindest

02:53:57.960 --> 02:54:07.760
habe ich noch nie mitbekommen, mitgekriegt, dass es irgendjemand jucken würde. Du gehst

02:54:07.760 --> 02:54:11.000
aus dem Hauptbahnhof Main Exit raus, gehst in Richtung der Tram und dort müssen die

02:54:11.000 --> 02:54:24.320
Busse auch sein. Okay. TAX. Oh. FeelsBatman. Ja, werde ich mir da mal angucken. Wenn du

02:54:24.320 --> 02:54:29.680
das hast, dann hast du so viel Geld, da musst du dir keine Gedanken mehr drüber machen,

02:54:29.680 --> 02:54:44.280
ob das in deinem Job gut ankommt oder nicht. Ja. Vier Tage. Vier Tage. Weiß ich wie hoch

02:54:44.280 --> 02:54:48.680
die Chance auf einen Wasserschaden, weil er all in one Wasserkühlung ist. Weil die gehen

02:54:48.680 --> 02:54:55.760
nicht umsonst da fünf Jahre Garantie drauf. Also die haben da schon gewisse. Ja, gewisse

02:54:55.760 --> 02:55:01.240
Zuverlässigkeit muss das ja schon haben. Wissen die, dass die YouTube macht nicht wirklich?

02:55:01.240 --> 02:55:08.200
Also einer weiß es, weil den kannte ich ja vorher schon. Geht ja auch kein was an großartig.

02:55:08.200 --> 02:55:13.120
Oder meinst du dort, wo ich jetzt arbeite? Doch, doch, wo ich jetzt arbeite, die wissen

02:55:13.120 --> 02:55:18.360
das. Meinem Chef wurde witzigerweise vor nicht allzu langer Zeit mein Schnee Video durch

02:55:18.360 --> 02:55:23.680
den Gartenstells Video empfohlen auf YouTube von YouTube, vom YouTube Algorithmus. Da hat

02:55:23.680 --> 02:55:32.320
ihm gesagt, hier guck dir mal vom Max das Gartenstells Video an. Viel Spatmen, weil du

02:55:32.320 --> 02:55:46.120
es nicht gekriegt hast. Ach du wolltest es gar nicht machen oder was? Oder du bist da

02:55:46.120 --> 02:55:49.480
hingegangen und hast dann dort festgestellt, dass es nicht das ist, was du machen willst?

02:55:49.480 --> 02:56:00.640
Ach so. Was sind denn möchte gern Beamte? Muss den gleichen Krempel machen, bist aber

02:56:00.640 --> 02:56:16.840
kein Beamter oder wie? Ist das Video nicht zehn Jahre alt? Doch. Das Video ist fast zehn

02:56:16.840 --> 02:56:42.560
Jahre alt. Nicht ganz. Neun Jahre alt. Nächstes Jahr ist es zehn Jahre alt.

02:56:42.560 --> 02:57:00.960
Das ist gut, das finde ich. Das finde ich nice. Ist geendet. Keck JavaScript beste.

02:57:00.960 --> 02:57:15.720
Zu Top Top E-Mode. Warum bin ich der Einzige, der das geendet hat bisher? Hast du das gerade

02:57:15.720 --> 02:57:22.240
hochgeladen oder wie? Ich muss noch refreshen. Vielleicht geht es dann schon, aber dauert

02:57:22.240 --> 02:57:27.920
immer ein bisschen. Alter Flashback dauert ein bisschen, bis es gesüngt hat. Gehe nicht

02:57:27.920 --> 02:57:35.600
davon aus, dass es probiert mal aus. Keck JavaScript. Nee, geht noch nicht. Geht noch nicht. Gibt

02:57:35.600 --> 02:57:45.800
noch kein Keck JavaScript. Kein Keck JavaScript. Das dauert meistens. Ich habe hier FFZ und

02:57:45.800 --> 02:57:49.680
das ist bei der Twitch TV. Das kann durchaus mal eine Viertelstunde dauern, bis es gesüngt

02:57:49.680 --> 02:57:55.240
ist. Bei dir geht es? Ja, du hast wahrscheinlich bei der Twitch TV nicht FFZ. Oder ist das

02:57:55.240 --> 02:58:08.120
jetzt schon gesüngt? Alter, warum merkt sich das Ding nicht? Nee, noch nicht drin. No-Pass.

02:58:08.120 --> 02:58:15.960
Beides, nee beides. Also, braucht man nicht. Kann schon sein, dass du beides interessiert

02:58:15.960 --> 02:58:34.400
hast. Beides installiert hast, aber eigentlich reicht eins davon. Tja Leute, ihr wisst was

02:58:34.400 --> 02:58:43.600
jetzt ist oder? Boomer müde. Auch wenn es bei der Musik schwierig wäre, müde zu sein.

02:58:43.600 --> 02:59:11.560
Was ist LULW? Bestes Emote. Guck hier, bestes Emote. Eindeutig. Ich glaube, da sind wir

02:59:11.560 --> 02:59:21.400
uns alle einig, dass LULW größer KeckW ist. Und auch größer Keckl. LUL3D auch nicht

02:59:21.400 --> 02:59:32.280
verkehrt. Wir haben zur Not auch Keck4D oder sowas. Haben wir auch noch. In Chatterino

02:59:32.280 --> 02:59:38.960
geht es. Sekunde, ich reloade mal kurz. Nee, bei mir geht es noch nicht. Hat noch nicht

02:59:38.960 --> 02:59:42.920
gesüngt. Alter, der Flashbang ist krass. Warum merkt er sich das jetzt eigentlich nicht?

02:59:42.920 --> 02:59:53.520
Dark Mode Design. Was? Automatisches, dunkles Design deaktivieren? Nee, nee. Irgendwie kaputt.

02:59:53.520 --> 03:00:07.200
Keck4D ist was anderes. Keckium ist das. Keck4D. Ja, guckt. Barry, danke schön für den Sub.

03:00:07.200 --> 03:00:16.160
Sorry an alle, die ich heute übersehen habe im Eifer des Gefechts wieder. Guck mal kurz

03:00:16.160 --> 03:00:43.320
rein, bevor ich off gehe. Kallumina. Danke schön für den Sub. Waterline. Mr. Moogame.

03:00:43.320 --> 03:00:55.800
Temple Ritter. Danke schön Leute für die massive, huge Subscriptions. Wir haben eindeutig

03:00:55.800 --> 03:01:02.080
zu viele Keck Emotes, oder? Was braucht man davon nicht mehr? Ernsthaft? Das benutzt doch

03:01:02.080 --> 03:01:15.520
keiner, oder? Niemand benutzt KeckU. Den Rest, der Rest wird tatsächlich ab und zu mal benutzt.

03:01:15.520 --> 03:01:20.960
Den Rest, den Rest kann ich nicht löschen. Der Chaelor mag KeckBald. Ich glaube wegen

03:01:20.960 --> 03:01:34.560
Ema war es auch der Einzige, weshalb wir das hinzugefügt haben. KeckBald. KeckAlu.

03:01:50.960 --> 03:02:02.880
Gut Leute. Schön, dass ihr da wart. Oh, was? Frage. Wohner Pflegeheim hat eine Prepaid

03:02:02.880 --> 03:02:08.000
Karte und nun ein Samsung S5 Handy, sagt immer Netzwerkbetreiber oder so ähnlich verbinden.

03:02:08.000 --> 03:02:21.960
Das funktioniert aber nicht. Ich habe nicht den plastesten Hauch einer Ahnung. Mit der

03:02:21.960 --> 03:02:30.400
Beschreibung kann man da aber auch nicht viel debacken. Gut, Bettgeteim. Boomer müde.

03:02:30.400 --> 03:02:43.840
Jetzt schlafen. Den Proviner fragen, das dürfte das Beste sein. Machts gut, C.U.

