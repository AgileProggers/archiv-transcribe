So, das war's für heute, bis zum nächsten Mal, bis zum nächsten Mal, bis zum nächsten Mal, bis zum nächsten Mal.
So Leute, das gibt heute einen ultra entspannten Strebensor.
Die Katze hat mich heute Nacht irgendwie wach gehalten.
So, jetzt machen wir erstmal den Text weg. Und der Vogel kommt auch weg.
So, also was wir heute machen, wir erweitern unser Meme-Tool, also das hier, ich zeige es nochmal.
Wo man transparente Bilder overlayen kann und 0,4D durchführen, ganz wichtig.
0,4D ist eigentlich die wichtigste Funktion. So, das Programm hat ein paar Probleme.
Und zwar, ich werde euch das mal zeigen, ich starte jetzt mal ein Game.
Da wird man schon sehen, oder relativ schnell sehen, wo das Problem ist.
Wir spielen jetzt nichts, also wir spielen jetzt kein Battle Royale.
Also ich zeige es euch nur mal anhand von dem Game, was das Programm für ein Problem hat.
So, wir starten das jetzt mal. Ah, blenden das aus. Alles gut.
Mal davon abgesehen, dass das Shortcuts belegt, die das Game braucht.
Ah, aber ich glaube ihr seht nichts, oder?
Nee, ihr seht nichts. Moment, ich muss das mal umstellen.
Ach doch, ihr seht was. Aber ich muss das erstmal umstellen, hier auf Borderless-Window.
So, und jetzt sieht man schon das Problem, sobald ich, guckt, das Game hat keinen Fokus mehr.
Sobald ich das Programm anmache, also sobald ich das Fenster, das ist ja ein unsichtbares Fenster, aufallehe,
hat das Programm dahinter keinen Fokus mehr. Ich muss erst wieder reinklicken.
Das ist natürlich kacke. Weil, wenn ich das verwende, um was einzublenden in einem Spiel,
keine Ahnung, dann bin ich hier gerade am rumlaufen, am spielen, dann blende ich was ein, dann habe ich keinen Fokus mehr.
Ja, und dann gucke ich so. Das ist natürlich nicht Sinn und Zweck der Sache.
Das funktioniert wunderbar bei irgendwelchen statischen Sachen, wie Overlay für Livestreams,
wie wir es bei der E3 gemacht haben zum Beispiel. Der Chat verlangt einen Haftbefehl.
Ja, manchmal ist mir auch egal, was der Chat verlangt. Haftbefehl brauchen wir jetzt nicht.
Wir lassen jetzt die Porno-Musik an.
Klar, Patrick, kann man auch was dagegen machen.
Deswegen werden wir das jetzt so einstellen, dass man einmal komplett durchklicken kann.
Weil, ihr seht, man sieht im Prinzip noch, dass hier ein Fenster drumherum ist.
Hier ist transparent, da wo halt das Bild transparent ist.
Das heißt, ihr seht ja, ich kann hier durchklicken, obwohl hier ein Fullscreen transparentes Fenster im Vordergrund ist.
Aber hier kann ich nicht durchklicken. Erst wieder hier, wo es transparent ist.
Gucken wir jetzt halt so, die Grenze hier geht es nicht.
Deswegen werden wir jetzt das Ding komplett transparent machen.
Nicht komplett transparent, komplett durchgängig, also durchdurchlässig.
Und dann stellen wir ein und das funktioniert natürlich nur, wenn das Game im Fenstermodus ist.
Weil, sobald das Game Fullscreen ist und quasi den Komplett hier, den Fokus quasi hat.
Ne, wie nennt man das? Also wenn du quasi exklusiv, exklusiv irgendwie 3D-Geduld auflässt.
Also wenn du das Bild, wenn man das Spiel im Fullscreen laufen lässt, dann funktioniert eh das ganze Tool nicht.
Weil, das kann nicht funktionieren. Weil, sobald ich irgendwas anderes starte, dass das Fullscreen-Game nicht mal Fullscreen hat.
Dann geht das Game halt raus. Das ist blöd.
Das heißt, es funktioniert eh nur, wenn das Game im Fenstermodus läuft.
Beziehungsweise im Borderless-Window-Modus, was die meisten Games mittlerweile standardmäßig machen.
Also sprich, wenn sich der Windows-Window-Manager um halt das Malen der Fenster kümmert, nicht das Game direkt.
Katze, was ist?
Mao, mao, yo, mao, was ist?
Oh ne, jetzt rennt nicht unam Schreibtisch rumrennen, Katze.
So, und deswegen müssen wir noch einstellen, im Titel soll Agane stehen, das ist schon richtig.
Ich könnte mal auf Twitter posten.
Katze, was machst du an meinem Kabel hier? Was ist da los?
Nein, nein, nein, geh mal fort.
Die Katze ist der Meinung, das Headset-Kabel ist furchtbar interessant.
Katze, nein, nein, das wollen wir nicht. Geh weg.
Ja, da wollen wir auch nicht reinbeißen. Nee, nee.
Lol.
So, wir können das ja mal auf Twitter posten.
So, genau, wo bin ich stehen geblieben?
Ich muss mal kurz dein Auge auf die Katze haben, ich weiß nicht, was die hier genau treibt eben.
Katze, was hast du vor?
Ja, nimm das USB-Kabel.
Ah, genau, wunderschön, jetzt kannst du ein bisschen USB-Kabel fangen, das ist auch sehr spannend.
Das muss ich euch mal zeigen hier.
Wie die immer da liegt mit dem USB-Kabel.
Ja, wartet mal, jetzt hab ich irgendwo auch mal gepostet.
Die kaut auch ganz gerne mal auf USB-Kabel bzw. die werden dann halt erlegt, die USB-Kabel,
dann legt man sich erst mal drauf, dann hat man es halt gefangen.
So, okay, machen wir weiter, also muss ich mal stehen geblieben.
Genau, so, also das ist halt das Problem, dass das Fokus verliert und nachdem die meisten Spiele ja
in Borderless-Window heute zumindest standardmäßig laufen und man jedes Spiel so ziemlich darauf einstellen kann,
müssen wir einmal dafür sorgen, dass man komplett durchklicken kann durch das Overlay,
also sprich, dass das halt wirklich ein Overlay ist und hier merkt man halt noch, dass es ein transparentes Fenster ist,
was quasi Fullscreen ist, weil hier kann man irgendwo durchklicken, erst wieder hier.
So, und dann müssen wir dafür sorgen, dass es in der Reihenfolge von den Fenstern ganz hinten ist,
sprich, ihr seht es ja bei Windows, das oberste Fenster ist Steam, das nächste Fenster ist Vision Studio,
irgendwo dahinter ist OBS und hier ist der Explorer davor, also sprich, Windows Manager hat ja so eine Reihenfolge von Fenstern,
was, wie, also so Z-Index quasi, Tiefe, also sprich, wie weit vorne irgendwas ist und wie weit hinten und da hast du nicht gesehen.
So, ich habe keine Ahnung, wie das geht, wie man das setzt, aber das funktioniert.
Das habe ich schon mal ausprobiert, dass das klappt, also prinzipiell.
Na, dann kann man nämlich durchklicken und das Ding kriegt keinen Fokus mehr.
Das mit keinem Fokus dürfte, glaube ich, am einfachsten sein.
Da weiß ich, dass man das setzen kann direkt hier in WPF, da müssen wir auch nicht viel umbauen,
sondern, manche haben mal ein Chat weggemacht.
IRL, das ist doch IRL. Wo ist das sonst?
Ich stream das immer in IRL. So, das Einfachste dürfte sein.
Das, was wir hier aktuell gerade machen, ist, um dieses Ein- und Ausplenden zu realisieren.
So, das da. Creative, Creative guckt keine Sau. Creative guckt keine Sau.
Die ganzen Musikchannels und sowas, die sind alle mittlerweile auch bei IRL, weil Creative keiner guckt.
Creative ist einfach dead Kategorie.
Na, Programming gibt es ja gar keine Kategorie. Programming ist der Hashtag dafür. Das ist total kaputt.
Ich blende euch jetzt gleich Katzencam ein oder sowas, dann ist das besser IRL.
So, und...
Ja, dann ist das neu, dass es eine Programming-Kategorie gibt.
Bisher ging das immer nur dadurch, dass man den Hashtag in Titel gesetzt hat.
Oh, wartet mal. Nein. Wo ist die Katze? Ich blende euch jetzt den.
So, das ist doch IRL genug. Guckt mal, hier sogar mit IRL-Catcam.
Dein Pull-Request muss ich mal gucken, weil ich bin kein großartiger Fan von XML-Config.
Und das werden wir heute auch noch machen, dass man die Shortcuts automatisch weggeben kann.
Aber jetzt fangen wir erst mal an. Also, das hier funktioniert nicht.
Wir machen das ja aktuell so, wenn das Fenster sichtbar ist.
Oh, ich muss noch die Pornomusik ein bisschen leiser machen.
So. Ah, Lautsteig ist immer noch okay.
Genau, aktuell machen wir es ja so. Wenn das Fenster sichtbar ist, dann minimieren wir es.
Und wenn es nicht sichtbar ist, dann zeigen wir es an.
So, und ich glaube, das Einfachste, was wir machen können, dass das Ganze eben nicht fokussiert, ist es nicht minimisieren und maximisieren, sondern verstecken und wieder anzeigen.
Und beim Wiederanzeigen ihm sagen, dass er das Fenster nicht fokussieren soll.
Was ist, Katze, wo steckste? Habt ihr es gehört? Hört ihr es? Was ist?
Mao, du sitzt auf dem Sofa und guckst mich an. So nach dem Motto, ich soll dir das Streicheln kommen, Katze, das geht jetzt nicht.
Habt ihr es gehört? Ja?
Okay, also wir machen es mal hier. Ist es visible? Machen wir es jetzt mal raus.
Und wenn es visible ist, dann verstecken wir es.
So, und jetzt kommt Trick 17, wo man gleich sieht, dass es doch funktioniert.
Wir sagen hier unten nicht Activate, sondern wir sagen Show, weil man sieht der Unterschied zwischen Activate ist.
Activate, Bring Window to Foreground and Activate, das die meinen, damit es so viel wie Fokus geben.
Und wir machen Show. Show ist standardmäßig zwar auch, dass das Fenster Fokus kriegt,
aber man kann sowas setzen wie, ich hab mich extra vorhin nachgeguckt, sowas wie Show Activated auf False.
Und dann, pass mal auf. Ah, dann gibt es eine Exception, weil ich irgendwas vergessen hab.
Achso, weil ich Window State gesetzt hab, oh mega null.
Alter, war ich denn falsch?
Achso, ach du guck mal da oben steht es ja noch drin.
Ah, guck mal. Und schon behält das hintere Fenster seinen Fokus.
Ach, warum das geht nicht.
Bloß durchklicken geht noch nicht, durchklicken geht noch nicht.
Und wenn ich hier drauf klicke, dann verliert das natürlich Fokus.
Aber einfach nur durch das, man sieht es ja auch hier, dass im Hintergrund das aktiv bleibt,
also einfach nur durch das Ein und Ausblenden passiert nichts.
So muss das sein, weil dann können wir das nämlich auch als Overlay verwenden.
Jetzt stellen wir bloß noch ein, dass das Ganze nicht in der Taskleiste steht.
Boah, dann sieht das nämlich richtig schön aus, hat das schon ein bisschen Steam Overlay mäßig was.
Ok, jetzt bleibt das hier im Hintergrund, egal ob ich das Ein und Ausblende.
Sogar, guckt sogar mein Tracking Drop bleibt aktiv.
Das juckt es überhaupt nicht, ob ich das Ein und Ausblende, was natürlich ziemlich gut ist.
Das heißt, wenn ich am Spielen bin und mache das als Overlay, dann kann ich das Spiel nicht mehr weiter bedienen.
So, das ist das erste, was wir machen müssen.
Das nächste ist, dass es noch ein bisschen angenehmer in-game zu benutzen wird, wir müssen es transparent machen.
Also nicht transparent, sondern wir müssen es komplett durchlässig machen, weil wenn man sich vorstellt,
kann man es nicht mehr durchlässig machen.
Ja, das was UWP nötig kann, kann ich mir vorstellen.
UWP kann ja nichts Patrick, das ist ja fail.
Man sieht ja auch, dass es im Endeffekt ein Fenster ist, weil ich hin und her Tracking Droppen kann.
Warum nicht in Java? Weil es ein Windows-Only-Programm ist und das einfach mit Microsoft Sachen am besten funktioniert.
Und außerdem mag ich kein Java.
Nichts gegen Leute, die Java programmieren.
Aber in Java, dann wäre das hier die Bitmap Manager Factory auf Bitmap Manager Factories Images.
Und ich erkenne kaum keine Java Flames.
Ich bin einfach kein großartiger Java-Fan, ich habe auf der Arbeit jeden Tag mit Java-Anwendungen zu tun.
Und ich habe da auch keinen Bock drauf. Glück muss ich da nichts ändern.
Das Einzige, was ich auf JVM-Basis machen muss, ist ein bisschen was in Groovy, aber das ist ja nicht ganz so schlimm wie in Java selbst.
Ja, und die Java-Standard-Libräen und sowas ist ja nicht übel, da ist ja auch alles dabei, was man braucht.
Bloß Java als Sprache an sich kann ich überhaupt nichts abgewinnen.
So, jetzt haben wir das erste Schöne hingekriegt. Als nächstes, jetzt müssen wir nur noch gucken, wie wir das machen.
Da habe ich keine Ahnung, wie es genau funktioniert.
Da müssen wir jetzt mal Stack-Overflow bemühen.
Wie man komplett durchklicken kann durch das Fenster.
Also quasi hier Click-Through-WPF.
Irgendwas.
Und das ist ein ganz wichtiger Skill, den man heute als Programmierer haben muss.
Nämlich das sogenannte Stack-Overflow-Triven-Programming.
Man sucht was und kopiert sich dann von Stack-Overflow.
Was Hit-Is-Hit-Test-Visible schon nie verwendet.
Mal gucken, ob das was bringt.
So, und dann ein bisschen Try-and-Error. Und dann geht es vielleicht noch weiter.
Nein, das funktioniert nicht. Ok. Ok, das war schon mal nicht das, was wir haben wollen.
Ich will ja komplett durchklicken können. Wahrscheinlich.
So mein Bauchgefühl sagt mir, das geht nicht direkt in WPF.
Da muss man bestimmt irgendwelche Winners API-Geschiss einbinden oder so. 100 Pro. Die kann ich wetten.
Making a WPF-Winner-Click-Through, but not its controls.
Na ja, das ist nicht so wirklich das, was wir haben wollen.
Ne, ne, ne. Das, das.
How to create a semi-transparent-Winner in WPF, that allows mouse-events to pass through.
Ja, das waren wir.
Ja, muss ich dem Patrick recht geben. Das sage ich auch unseren Azubis immer.
Wenn man sowas lernt oder studiert oder was auch immer.
Wichtig ist nicht unbedingt, dass man die ganzen Kram auswendig lernt.
Ich meine, wir lernen ja kein BWL oder irgendwelche Rechtsgeschichten,
sondern das Wichtigste ist eigentlich, dass man weiß, wie man was findet.
Das heißt, man muss sich gut genug auskennen, dass man die passenden Wörter suchen kann,
um das zu finden, was man sucht.
Weil, wenn man sich überlegt, Windows mit C-Sharp ist bei weitem nicht die einzige,
sag mal Windows mit.NET, ist ja bei weitem nicht die einzige Plattform,
mit der man irgendwelche Programme, irgendwelche Projekte umsetzen kann.
Bei weitem nicht. Das sind so irgendwie, wenn man sich die verbreiteten Sachen anguckt,
irgendwie so Kanal an 10%, das ist ja nichts im Endeffekt.
Und selbst da gibt es wahrscheinlich niemand, der das komplette Framework aus dem Kopf kennt.
Das geht gar nicht.
So.
Visual Studio macht es noch ein bisschen einfacher nach Sachen zu tun, aber das geht nicht.
Das heißt, man muss ungefähr wissen, was man machen will.
Und dann kann man danach suchen.
Und man lernt mit der Zeit zu den Sachen, die man öfters braucht in der jeweiligen Sprache,
die man verwendet.
Ah ja, sowas hier. Das sieht doch schon mal nice aus.
Windows API-Hacks, beste.
Das, das geht bestimmt jetzt.
Müssen wir mal gucken, was er da eigentlich genau macht.
Ähm, deswegen, man muss das einfach suchen können.
Das ist echt das Wichtigste.
Und, wenn man da noch dazu rechnet, was es ja eigentlich für viele verschiedene Plattformen mittlerweile gibt,
für viele verschiedene Sprachen.
Ähm, das kannst du gar nicht wissen. Das geht nicht.
Du kannst allerdings was nicht sprachspezifisches lernen, sondern nämlich, wie dieser ganze Scheiß heißt.
Den du brauchst.
Und dann suchst du danach, plus mit irgendwie Java dabei.
Sie schreibt dabei,.NET dabei, Rust, was auch immer.
In der Suchmaschine, da findest du den Kram.
Deswegen das Wichtigste ist, man muss wissen, wie man was findet.
So, was macht denn der Kerl hier eigentlich?
How to create a semi-test. Genau das wollen wir.
Wir wollen durchklicken können.
Focus craps ja schon nicht.
Sieht man ja hier.
Also, Focus craps der Scheiß ja schon gar nicht.
Das ist natürlich, was natürlich praktisch ist.
Aber wenn ich jetzt aus Versehen draufklick, hat es natürlich trotzdem wieder Focus.
Deswegen muss ich das Ding komplett durchklickbar machen.
So, wie machen die das jetzt hier?
Die machen auch irgendwas mit Hit-Test-Visible.
Okay.
Okay, das ist schonmal die als...
Ah ja, und weil es der Patrick gerade schreibt, das ist auch noch wichtig.
Wenn man Probleme hat, und das ein Open Source Projekt ist,
kann ich euch immer empfehlen, geht auf GitHub,
auf die Projekt-Seite, und schreibt,
auf die Projekt-Seite, und sucht nach dem, was nicht funktioniert in den Fehlerreports,
beziehungsweise in den Issues.
Da findest du auch sau viele Sachen, die noch nicht gefixt sind,
wo irgendwelche Leute Workarounds reingeschrieben haben.
So, was macht denn der Kerl hier eigentlich?
Was macht der hier für krasse Windows-Hack-Source?
Publix? Okay, der macht den ja.
Ich mach's mal so fett, dass man das besser sieht.
Kannst du mal erzählen, was du genau beruflich machst?
Ich kümmere mich hauptsächlich um Software-Repos.
Source-Code, Git-Repos.
So, was macht der da eigentlich?
Okay, da sucht sich irgendwelche...
Okay, was verwende ich?
Get-Window-Long?
Okay, das ist irgendwelche Win32-AP-Magic, die man wahrscheinlich nicht verstehen muss.
Ja, Window-Handles stehen hier in der Windows-AP unglaublich drauf.
Das muss ja sein.
Da fällt mir nur das hier zu ein.
Da fällt mir nur das hier zu ein.
Wartet mal.
Windows-AP-Benahmung, ey.
Windows-AP-Benahmung, ey.
Was zum Teufel?
Okay, was macht denn der Krampel überhaupt?
Set-Window-X, also man ersetzt irgendwelche Transparenz-Tinger.
Ja, der Patrick hat's erkannt.
Ungefähr sowas guck ich mir wirklich den ganzen Tag an.
Gibt's zu dieser komischen Funktion auch irgendwann eine Hilfe-Seite von Microsoft oder so?
Gäbt sich dieses Super-Secret, die ist nirgendswo beschrieben.
Ganz toll, Microsoft, super.
Ach nee, Moment.
Das ist ja was von dem.
Naja, stimmt, stimmt.
Nee, nee, vergesst.
Das klingt halt so Microsoft-mäßig, ne?
Okay, also der verwendet Get-Window-Long und Set-Window-Long.
Aha, wunderbar.
Na, wenn er noch was macht.
Was macht der denn da?
Wir probieren einfach mal aus, ob das funktioniert.
Wir machen jetzt klassisches Stack-Overflow-Driven-Programming.
Wir kopieren uns was von Stack-Overflow und gucken, ob's geht.
Und wenn's geht, dann versuchen wir zu verstehen, was er eigentlich macht.
Beste, so funktioniert das.
So, Copy-Paste, Import, zack.
Ey, man, was Schlimmes kannst du ja nicht machen.
So, dann Copy-Paste, wir den Shit hier rein.
Window-Style-Nahten, Topmost, True...
Moment, weiß nicht, ob wir das alles gesetzt haben.
Window-Style-Nahten, Lautsatz.
Topmost können wir noch setzen, Topmost.
Einfach noch mal gucken, ob's geht.
So, und das ist irgendwie ein...
So, guck mal, ich hab keine Ahnung, was es macht.
Wir gucken jetzt einfach mal, ob's funktioniert.
Und wenn's funktioniert, versuchen wir rauszukriegen, was es macht.
Funktioniert.
Porgas.
Ups, ich will nicht printen.
Porgas, es funktioniert.
Okay.
Das ist gut und schlecht zugleich, dass es funktioniert.
Gut ist, wir wissen, was wir machen können.
Zum Fenster durchklicken.
Schlecht ist...
Wir haben keine Ahnung, wie's funktioniert.
Okay, was macht der da eigentlich, genau?
Ich muss das ja erst mal irgendwie checken.
Set Window-Long.
Okay, da gucken wir uns jetzt mal die Dokumentation von Microsoft für an, was das macht.
Ja, ich kann leider in meinem Channel nicht sehen, wie das funktioniert.
Ich kann leider in meinem Channel keine Better Twitch TV Emotes mehr aktivieren, außer die, die ich hab.
Sonst kosten's Geld im Monat.
Was ich wahrscheinlich sogar mache.
Ich hab ja Unity Media gekündigt jetzt.
Das heißt, ab September bezahle ich 45€ weniger im Monat.
Für meinen Internetanschluss.
Als jetzt.
Das heißt, dafür kann ich mir dann auch die 5€ im Monat Better Twitch TV Emotes leisten.
Ist doch Deal, oder?
Das ist Hyper-Poggers schon.
So, was macht das denn?
Was macht das denn?
Was?
Ach, wisst ihr was, eigentlich ist mir wurscht, was das macht, das funktioniert.
Diese Windows-Benahmung immer.
Okay, was setzt der denn hier? GWL, XStyle, Extended, WSX, Transparenz und GWL.
Oh, Windows-Abi, krasse Scheiße.
Gibt's schon mal nicht.
Also, Transparenz, gibt's hier gar nicht.
Fuck man, was macht der?
Okay, der setzt das da schon mal.
Komm mal.
GWL, XStyle.
GWL, XStyle ist...
Setzt den New Windows-Style, okay, wer hat das gedacht?
Das hier ist, das ist wahrscheinlich der aktuelle Windows-Style.
Oh fuck, eine Donation.
Poggers, Koggers, Mega-Pog.
Für Poggers.
Oh nein, Patrik.
Das hätte doch jetzt nicht sein müssen, danke.
50 Euro, Pogchamp.
Ich...
Hyper...
Hyperpog.
Poggerino, gibt's sowas eigentlich?
Das fehlt eigentlich noch, gibt's sowas?
Gibt's das als Emote?
Hätte man gerade so... Nee, gibt's nicht.
Irgendwie wundert mich, dass noch keiner auf die Idee gekommen ist, so ein Emote anzulegen.
Poggerino.
Moment, das gibt's, was ist das?
Wein.
Oder? Wein, Alter.
Poggerino-Wein.
Wahrscheinlich heißt das Poggerino oder irgendwie sowas.
Poggerino.
Okay, was machen denn die anderen Optionen?
In...
Moment, das ist der Index.
Ah nee, passt, okay.
Die Replacement-Value.
Leute, ich hab absolut keine Ahnung, was das hier eigentlich macht, aber es funktioniert.
Deswegen, scheiß drauf, wir verwenden es jetzt einfach.
Gucken, ob wir das hier nicht noch vielleicht ein bisschen umbasteln.
Weil ich mein...
Wir machen da mal eine eigene Klasse draus.
Vielleicht brauchen wir noch mehr Windows-Native-Zeug.
Machen wir mal eine eigene Klasse.
Für Windows-API-Geschiss.
Auch ein Glas.
Ein Glas.
Native.
Oh.
Bisschen schöner, da müssen wir den Kram hier nicht mit verseuchen.
Public.
Oh.
Wrappen wir das einfach mal hier rein.
Okay.
Und den Krabbeln können wir uns sparen.
Ja, das hier brauchen wir auch noch.
Weinpoggerst.
Ja.
Ja, ja, Mr. Milchmann, das seh ich auch.
Aber wo steht denn bitteschön in der Beschreibung, was denn das eigentlich genau macht?
Weil das Wort transparent, finde ich, hier drin hat.
Ah ja, einfach mal da nachsuchen.
Auch gut.
Was macht das?
Okay, also, wenn man diesen Style dazusetzt, zusätzlich setzt.
Also, von der Idee her macht das hier genau das, was der Milchmann macht.
Der holt sich den aktuellen Style.
Hier holt er sich den aktuellen Style vom Window.
Das hier bedeutet, dass er den neuen Style setzen will.
Alter Style plus neuer Style.
In dem Fall ist das hier das und das zusammen.
Also plus ist das hier eigentlich, das oder an der Stelle.
So.
Okay, was macht das denn?
Window should not be painted until the next window is painted.
Should not be painted until the next window.
Wat?
Moment Leute.
Was macht das?
Okay.
Das Fenster soll nicht neu gemalt werden.
Bis alle unter, also ab Sipplings.
Was ist das hier?
Was sind Sipplings?
Nicht nachfahren, sondern...
Was genau heißt das eigentlich?
Geschwister.
Englisch Skills.
Geschwister.
Also quasi bis alle Fenster, die unterhalb von diesem Fenster liegen, die von dem gleichen Thread erzeugt werden, gemalt sind.
Okay und warum genau führt das jetzt dazu, dass man durchklicken kann?
Ja, der Milchmann, das verstehe ich auch nicht.
Scheiß drauf, Windows API, who cares, es funktioniert.
Das ist die Hauptsache, es funktioniert.
Da haben wir wieder gesehen, Dokumentation lesen bringt alles nichts, Stack Overflow größer Selbstdenken.
Beste.
Und wisst ihr was auch schön ist?
Dass mein Programm grad 143 MB braucht, obwohl es versteckt ist und nichts anzeigt.
Das ist auch nicht übel oder?
Aber ich mein 143 MB RAM, was ist das im Jahr 2018 schon?
Okay, ähm...
Halt mal.
Wir können den Cramp wirklich rüber kopieren.
Die, die, die, die, die, die, die, die.
So, aber halt mir das mal so bei.
Naja, Stack Overflow, beste.
So, was, ähm...
Äh gut, das gibt es jetzt natürlich nicht, das heißt jetzt ja Native.
Warte mal, ähm...
This, this ist eine Main Window.
Ja gut, ne, das können wir doch eigentlich, das können wir doch eigentlich hier drinnen machen, ne?
Ah.
Das machen wir, das machen wir besser auch gleich hier mit drinnen.
Window.
Oder?
Ach ne.
Ah, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne, ne.
Oder?
Ach ne, ne, na, so ist schon besser.
Lassen wir das einfach mal so.
Okay.
Ähm...
Ja gut, das scheint zu funktionieren.
Sehr schön.
Muss man nicht verstehen, ne?
Pff, auch gut.
Okay, ähm, dann können wir den ganzen Knempel rausschmeißen.
So, jetzt haben wir eigentlich schon mal zwei ganz wichtige Sachen geschafft.
Es crappt sich kein Fokus mehr.
Und?
Ah.
Moment.
Ah, haha, nice.
Man kann durchklicken.
Aber?
Drag'n'drop?
Ach ne, das ist Drag'n'drop vom Visual Studio.
Okay, alles gut.
Okay, es ist wirklich, richtig, äh, absolut overlay und transparent jetzt.
Es hat überhaupt keine Auswirkung auf andere Fenster.
Sehr schön, so muss es sein.
So.
Jetzt machen wir mal weiter.
Das ist nämlich sehr unordentlich und was mir halt überhaupt nicht gefällt ist,
dass ich hier meine Keybindings hardcoded hab.
Das ist halt doof.
Das war so die quick-and-dirty-Lösung vorm E3-Stream.
Und auch hier, dass das alles von Hand definiert sein muss, das ist ziemlich doof.
Das gefällt mir nicht.
Hi Max, hast du Zelda mit DLC gezockt?
Ne.
DLC hab ich nicht gespielt.
Ich hab auch gelesen, die Zelda, also die Breath of the Wild DLC soll nicht so der Bringer sein.
Okay.
Jetzt räumen wir das Ganze ein bisschen auf, weil das ist echt hässlich.
So, ich hab hier aufgeschrieben, was wir heute alles machen wollen.
Das nicht aktivieren haben wir, das durchklicken haben wir auch.
Ich würd jetzt gerne zwei Sachen in einem noch machen.
Nämlich, dass ich die Shortcuts hier, den Krempel, dass der automatisch definiert wird.
Also, dass man das nicht irgendwie hardcoded jedes Mal quasi neu machen muss.
Das ist nämlich, also für jedes Bild hardcoded im Source Count in Keybindings.
Das ist ja nur wirklich nicht schön.
Und ich hätte gerne, dass es die Bilder automatisch neu lädt, alle 5 Sekunden oder so.
So, und ich hab mir überlegt, ich zeig euch das mal, ich hab das nämlich vorhin schonmal vorbereitet.
So wie in der Kochsendung.
Ich hab mir überlegt, wir machen das nämlich so.
Und zwar, nachdem ich das so möglichst einfach halten will, wie möglich das Programm.
Also, ich hab erstens keinen Bock drauf, einen Konfigdialog zu basteln.
Ich hab auch keinen Bock, wobei das machen wir vielleicht noch ein Tray Icon für das Programm.
Dass man es beenden kann später.
Weil ich mein, man sieht ja nichts mehr, dann kann man es auch nicht beenden.
Das wär vielleicht nicht schlecht.
Dass es einen Tray Icon kriegt, wo man dann sagen kann, hier rechtsklick exit.
Das machen wir vielleicht später noch.
Aber ich will keine Interfaces programmieren.
Ich kann auch WPF nicht, sondern nicht gut.
Deswegen wäre das gut, wenn ich keine Interfaces programmieren muss.
Ja, der Invisible Darkness ist aber eine XML-Konfig.
XML ist das Schlimmste.
XML krieg ich immer Anfälle bei.
Aber das, was du gemacht hast, wir können uns das ja mal angucken, dass das nicht vergebens war.
Sein Pull-Request.
Er hat das schön gemacht.
Ich hab mir das ja angeguckt.
Er hat das schön gemacht.
Er hat quasi hier...
Warte mal, false changed.
Er hat quasi hier eingestellt, dass man so eine...
Er hat meinen Dreck ein bisschen aufgeräumt.
Was sehr schön ist, das machen wir jetzt auch gleich zusammen noch mal.
Wo war denn die Konfig?
Genau.
Wo ist die Konfig?
Oh, sogar eine Notifikation.
Boah, ja, krass.
Nice.
Ich hab mir da wirklich Mühe gegeben.
Was ist das für eine Library, was du nimmst für dieses Notifikation-Icon?
Das kann ja WPF, glaube ich, nicht von Haus aus.
BWTASPA-Icon.
Genau.
Wo ist denn hier ein Beispiel für die Konfig-Datei?
Hab ich übersehen?
Wo ist das Beispiel für die Konfig-Datei?
Hier.
Ja.
Blöd, wo ist es denn?
Hattest du nicht ein Beispiel drin für die Konfig?
Ich sag mal, für die Konfig-Datei.
Is animated.
Ja, zumindest...
Mal gucken, wie weit das dann noch kompatibel ist zu dem, was wir heute basteln.
Ach, stimmt.
Warte mal.
Ich glaub, hier hat das drin stehen gehabt.
Ja, genau.
Hier war ein Beispiel von der Konfig.
Als man spricht, dann könnte man so eine Konfig anlegen.
Name vom Bild, dann welche Taste man binden will und wie das heißt und so.
Ich hab gedacht, wir machen es ein bisschen anders.
Wir machen das so simpel und billig, wie es irgendwie geht.
Und zwar, wie gesagt, ich hab das schon mal vorbereitet.
Wir machen das so.
Wir nehmen das Bild und prefixen das einfach mit dem Key, den wir binden wollen.
Also sprich, zum Beispiel...
Wenn ich jetzt Steuerung F5 drücke, dann blende der das Bild hier ein.
Oder wenn ich hier Steuerung F7 drücke, dann blende der hier Debated ein.
Da brauchen wir keine extra Konfig-Datei oder sowas.
Was man damit nicht machen kann, ist den Shortcut-Key.
In dem Fall nehmen wir hier immer Control.
Aber den lassen wir jetzt erst mal Hardcoded-Control.
Da können wir uns immer noch überlegen, was wir eigentlich genau machen.
Wir müssen das Ganze jetzt mal ein bisschen aufräumen.
Und wir müssen einstellen, dass es automatisch reloadet.
Das erste, was wir dafür machen, ist...
Wir legen erst mal eine neue Klasse an, um das Ganze ein bisschen zu kapseln.
Und schmeißen hier das ganze Meme-Zeug raus.
Wir commiten erst mal neu.
Wie macht man das in Visual Studio überhaupt?
Und dann macht man das als Control.
Machst du doch nach Dateinamen in dem Ordner.
Ja, mache ich doch.
So, guck.
So ist das gedacht.
Das Bild heißt dann beispielsweise hier F-Woodface.
Und F nimmt er dann als Binding.
Beste Comment-Messages.
Könnt ihr euch alle daran orientieren, dass jeder weiß, wie es gedacht war.
Okay, den Kram können wir zumachen.
So, Public Classmeme.
Was braucht man da?
Lass mal kurz in mich gehen.
Den ganzen Mist hier müssen wir dann eh später rausschmeißen.
Es könnte sein, dass wir das Programm erst mal wieder komplett kaputt machen, bis es dann eine halbe Stunde später wieder funktioniert.
Als erstes würde ich sagen, machen wir irgendwie so eine Static-Construct-Methode.
Nachdem ich kein Freund bin von einer Meme-Factory oder sowas wie in der Java-Welt, wie sie das gerne machen würden, machen wir mal sowas hier in der Richtung.
Nämlich eine List of Memes, bzw. eine List of Memes, geben wir da zurück.
Wir nennen es einfach Load und da geben wir dann das Verzeichnis, wo der ganze Schmodder drin liegt.
So, und wenn ich das jetzt noch in die Klasse rein kopiere anstatt den Namespace, dann funktioniert das auch.
So, und da machen wir jetzt, was nehmen wir für einen Ordner hier, den da?
Ich nenne ihn mal anders, ich nenne ihn jetzt einfach hier Memes2.
Mal, dass er keinen Fehler mehr schmeißt, mal eine leere Liste zurück.
Und dann legen wir hier drinnen mal eins an und gucken, ob das funktioniert.
Das müssen wir nicht setzen, das setzt nur im XAML schon.
Und wir machen jetzt die Keybindings mal hier unten weg.
Keybindings unten weg und sagen jetzt mal hier Load und dann den Fahrt.
Und dann gucken wir mal, ob das funktioniert.
Wir müssen uns auf jeden Fall noch eine Debug-Konsole einblenden, weil sonst erkenne ich überhaupt nicht, was das Ding macht.
Aber, bla bla bla, Load.
Und jetzt gucken wir mal, wie man das hier ordentlich gesplitted kriegt.
Also erstmal gucken, ob das aufgerufen wird.
Ja, passt wunderbar.
Also von der Idee her, einfach hier eine Klasse, eine Klasse Memes, da ist dann sowas drinnen wie, was brauchen wir denn für Properties?
Filename brauchen wir. Jetzt brauchen wir ja noch alles. Filename, Binding, Binding.
Oder irgendwie so Binding-Key oder sowas.
Gucken wir mal, wie man das genau nennt.
Und ich lasse mich jetzt noch mal ein bisschen inspirieren von dem Pullrequest von DreckigerDan.
Wir machen noch sowas rein wie Is Animated, falls es ein GIF ist.
Das ist nicht verkehrt.
Kann ich gleich nachgucken, ob das animiert ist, weil wenn das animiert ist, müssen wir das ja komplett anders behandeln.
Wenn das ein normales Bild ist, können wir einfach sagen Bitmap Source und das Bildladen.
Wenn das animiert ist, müssen wir hier dieses Giraffel da machen.
Diese GIF Animation Library da verwenden, dass das funktioniert.
Ich glaube, das war es. Viel mehr werden wir nicht brauchen.
Mal gucken, was uns noch so einfällt.
So, jetzt müssen wir uns erstmal alle Files holen.
Falls ihr in der Schule C-Sharp lernt oder Java, das ist bestimmt relativ ähnlich.
Das ist eine Aufgabe, die kommt garantiert.
Liste alle Dateien in einem Verzeichnis auf oder sowas in der Richtung. Das kommt immer.
Heute noch Realm Royale Stellings, ja heute Abend im E-Ax wahrscheinlich.
Gestern, ne Leute, gestern habe ich Stream Rage gewettet, habe ich ein paar Stunden Pause gemacht
und danach habe ich irgendwie drei Runden fast am Stück gewonnen.
So ist das, Streamer Fluch.
Dotnet-mäßig ist es super einfach, sich die Dateien ausgeben zu lassen.
Das kommt immer, egal wo man das lernt.
Das ist eine der ersten Aufgaben, die man kriegt, gib mal alle Dateien aus.
Die klassische Variante, das zu machen, wäre quasi sowas hier in der Richtung.
For each, File, in, Directory, List, ne, List Files, Files, wie ist das?
Get Files.
Das wäre das Simpelste.
Und da können wir jetzt sagen, Ausgaben hier, File.
So, dann Bam, seht ihr?
Das sind die, geh weg, achso ich habe kein Binding mehr, das sind die Bilder hier in dem Verzeichnis.
Das war die klassische Variante.
Nachdem wir aber halt, ich zeige euch jetzt mal so wie man das früher prozedural nacheinander
und wie man das eigentlich in jeder Programmiersprache machen kann.
Danach zeige ich euch, wie man das in die Schraube schöner machen kann.
So, das heißt, ich laufe jetzt hier einmal durch alle Dateien durch in diesem Verzeichnis.
Und im Prinzip will ich ja hier mir eine Liste zusammenstellen aus allen Dateinamen.
Plus noch ein bisschen Magic mitmachen.
Also zum Beispiel hier diese Sachen hier setzen und sowas.
So ganz grob die klassische Variante wäre, dass ich hier sowas sage wie, keine Ahnung, List.
Also wie gesagt, so würde ich es in die Schraube nicht machen.
List und dann sage ich hier, List Add.
Vorher sage ich hier.
So, wir machen es jetzt ganz hässlich, absichtlich.
Jetzt muss jetzt keiner ankommen, irgendwie so macht man das nicht.
So, und dann denke ich mir irgendwie aus, wie ich das hier rauskriege aus den Dateinamen.
Dann überlege ich mir, wie ich irgendwie, na gut, die Filename setzen ist relativ simpel.
Und dann gucke ich noch ob Animated, bla bla bla, gleich GIF, dann True.
Und das würde ich dann nehmen und sagen, List Add.
Und am Ende sage ich dann, Return List.
Das geht, kein Ding, wird wunderbar funktionieren, aber schön ist es nicht.
Und in die Schraube kann man das viel, viel einfacher und simpler machen.
Man kann dieses Geschubel hier quasi in eine, finde ich, ziemlich gut lesbare Zeile verwandeln.
Tasten wir uns da mal ran.
Also das erste, was man machen kann, das schlägt zwischen Studio auch schon vor.
Man kann das erst mal so initialisieren, das ist dann schon mal ein bisschen lesbarer das Ganze.
Warte mal kurz.
Also wie gesagt, so wie hier macht man das.
Warum diskutiert der Chat eigentlich gerade über mein Klo?
Was habe ich denn hier wieder verpasst?
Was habe ich denn hier verpasst, muss ich gerade mal gucken.
Was?
Mache das Elgato Stream Deck in den Stream rein oder sehe ich das Ganze auch?
Weil der Sinn und Zweck dieser Sache ist ja hier, dass ich selbst sehe.
Das ist ja gerade, also ich will es ja selbst sehen.
Dass ich das einfach hier direkt in OBS mit einem Tastenkürzel overlayen kann, ist mir klar.
Die Sache ist bloß, dann sehe ich es nicht, dass es an ist.
Und ich will es ja gerade als overlay haben, dass ich selbst sehe.
Ich will es ja selbst sehen.
Ich will es nicht nur in den Stream rendern oder so.
Ich will es selbst sehen.
Und dazu kommt, dass ich hier selbst Funktionen einbauen kann, wie ich will.
Also zum Beispiel hier diese Geschichte.
Wenn ich will, dass ich irgendwie das Bild sich rotieren kann oder so, was irgendwie gerade nicht funktioniert,
was auch klar ist, weil ich jetzt komplett durchklicke, dann kann ich das machen.
Das kann ich ja bei Stream Deck nicht.
Außerdem lernt man was bei.
Was soll das Programm machen, wenn es fertig ist?
Das haben wir ja in den E3 Livestreams schon verwendet.
Das kann dir Bilder overlayen.
So was hier zum Beispiel.
Ich habe jetzt leider keine Tastenkürzel, weil ich die gerade gelöscht habe.
Kann ich ein- und ausblenden transparente Bilder.
Ja, wie ist es denn jetzt bei Stream Deck?
Sehe ich da die Bilder auch oder sehe ich die nicht?
Der Witz hier dran ist ja gerade, dass ich die Bilder selbst sehe.
Ich finde die beste Kombination wäre eigentlich sowas wie,
wenn ich das dann hier noch irgendwie mit Stream Deck verbinde,
dass ich dann auch noch sehe, warum ich die Bilder sehen will,
dass ich zum Beispiel nicht vergesse auszumachen.
Ja, das ist als Reaction Tool.
Du kannst mal, wenn es dich genau interessiert, wie man es verwendet und zu was,
kannst du dir irgendwie mal einen der letzten E3 Streams aufmachen als Watt.
Da habe ich das Laufen verwendet, um blödes Zeug einzublenden.
Deswegen haben wir ja auch so viele Bildchen hier drin.
Wie Musik, ey.
So, jetzt zeige ich euch mal, wie man das in C Sharp schön macht.
Also so funktioniert das ja hier prinzipiell in jeder Programmiersprache,
dass dynamische Arrays hat.
Also du legst eine Liste an, läufst alle Dateien durch,
addest sie dann und dann gibst du es zurück.
Das ist aber, das ist der C Sharp Loop Style.
So macht man das nicht.
Jemand, der das in C Sharp macht, oder eine der Varianten,
das ist ja nicht irgendwie die ultimative Wahrheit,
die ich jetzt irgendwie erzählen will,
kann das auf verschiedene Varianten machen.
Also wie ich das machen würde, ist natürlich,
ich brauche alle Files aus diesem Verzeichnis.
Logisch, ne.
Dann sagen wir, okay, wir nehmen alles aus diesem Verzeichnis,
File, also im Prinzip eine Schleife,
bloß dass man die Schleife nicht selbst basteln muss,
File und aus diesem erzeugen wir jetzt einfach ein neues Meme.
Jetzt ist natürlich immer noch das Problem,
erstens, wie kriegen wir denn die Dinger hier gefüllt?
Das können wir hier entweder inline machen,
das wird dann aber ein bisschen eklig.
Und die nächste Sache ist,
wie kriegen wir daraus jetzt eine Liste?
Wie man Liste kriegen ist einfach,
To List, fertig.
Wow.
Da kann man noch Return davor schreiben und gut ist.
Das ist die schöne Variante,
da müssen wir zugeben, die sieht auch ein bisschen besser aus.
So, jetzt ist natürlich hier noch nichts drinne,
das heißt, das Ding braucht noch einen ordentlichen
Constructor, wo ich das Zeug übergebe.
String, File Name,
und dann machst du mal irgendwie keine Ahnung mehr.
Pass, File, wie auch immer, das ist eigentlich vollkommen wurscht.
So, und da übergebe ich den Krempel jetzt.
Und hier kann ich die Anleitung jetzt auch noch
inline machen.
Und hier kann ich die eigentliche Logik machen
und im Constructor ist die Logik auch richtig,
wie ich den Krempel hier befülle.
Da kann ich inline reinschreiben.
Ja, ich mach das das nächste Mal.
Ich mach das das nächste Mal in Programming.
Das letzte Mal, wo ich den Stream in Programming hatte,
da war Programming noch irgendeine Unterkategorie
von Creative oder sowas,
was dazu geführt hat,
dass das wirklich keine Sau gesehen hat.
Ich kann mal kurz gucken.
Gucken, ob das jetzt funktioniert.
Tatsächlich, es gibt jetzt eine eigene...
Hat er das jetzt geändert?
Gucken wir mal, das sollte die Kategorie jetzt eigentlich gleich ändern.
Aber ich finde es schon mal gut,
dass Programming jetzt eine eigene Kategorie ist.
Hat er bei euch die Kategorie geändert?
Ich habe umgestellt jetzt.
Aber vielleicht braucht er es einfach nur ein bisschen.
Den hat nicht wirklich umgestellt, oder?
Hat er? Hat er echt?
Nice.
The fog sets in.
Ja, hat's.
Guck mal, Programming ist so eine stiefmütterlich behandelnde
Kategorie auf Twitch,
dass das Ding noch nicht mal ein Vorschau-Thumbnail hat.
Das ist ja der Witz.
Fail.
Ich würde auch gar nicht sagen,
dass das um die IRL falsch ist.
Du hast auch so viele Leute, die Musik machen und sowas,
die das hier drin streben sollen.
Das Problem ist einfach,
dass in diese anderen Sachen wirklich absolut kein Mensch reinguckt.
So.
Weiter geht's.
Okay.
Habe ich jetzt auf einmal so viele Views,
denn die Leute hat aufgewacht, oder was?
Okay.
Was macht dieser File Operator?
Das ist hier,
also die richtige Sonntagswähre eigentlich so.
In einem Argument darf man die Klammer allerdings weglassen.
Das ist einfach,
für jedes Element in diesem Array wird diese Funktion hier aufgerufen.
Das ist quasi der Lambda-File ist das hier.
Und wenn man an der Stelle mehr machen will als nur eine Sache,
dann kann man hier auch ganz normal Block-Klammern drum herum machen
und mehr schreiben.
Sogar über mehrere Zeilen und so.
Aber so ist einfacher.
Also was diese Zeile hier macht, ist eigentlich relativ simpel.
Das nimmt jedes Element aus diesem Get-Files-Array,
legt halt hier eine neue Meme-Instanz von dieser Klasse an
und da wiederum, was da alles rauskommt,
konvertieren sie zu einer Liste.
So, fertig.
Also im Prinzip das, was wir vorhin in 10 Zeilen gemacht haben,
kann man jetzt in einer machen.
Oh, das Charakter, der hat das, das, das, das hat er schön erklärt.
Diese Musik ist extrem nervig, ich mag die Musik.
Das ist so, weiß nicht, so Pornomusik irgendwie.
Ich finde das super entspannt.
Das ist ja auch immerhin hier Relaxing Jazz.
Rainy Jazz ist das immerhin.
So, haben wir weiter.
Jetzt müssen wir den ganzen Kram hier noch befüllen.
Gucken wir mal, ob das prinzipiell immer noch funktioniert.
Auch übrigens so Dinger macht man im Constructor normalerweise nicht.
Hast du noch mal auch das Problem, was hast du manchmal auch das Problem,
dass Visual Studio nicht den Code ausführt, den du geschrieben hast?
Nö.
Das Problem habe ich in Visual Studio nicht.
Ich muss eh sagen, von allen Ideas gefällt mir Visual Studio am besten.
Ich bin ja für tägliche Arbeit eher so der Commando Zeile plus Vim Benutzer.
Aber wenn man mal ein bisschen was längeres machen will als 20 Zeilen oder so,
Visual Studio, vor allem für Windows ist das beste.
Okay, also wir müssen jetzt irgendwie aus dem, aus dem File,
müssen wir rauskriegen, welchen Key wir beiden wollen und ob das ein GIF ist.
Dann setzen wir das und den Filename setzen wir das.
Also was wir schon mal machen können, ist das Filename,
können wir schon mal auf File setzen, das ist okay.
Wir sparen uns hier mal den Check, ob es dieses File wirklich gibt.
Natürlich könnte das hier irgendwie einer mit Schwachsinn drin anlegen,
aber nachdem das außer uns eh keiner anlegt.
Das Einzige, also die Chatplains Dinger sind nicht schlecht,
trotzdem ist Visual Studio immer noch für mich die beste Idee.
Aber du kannst ja auch ReSharper reinhauen.
Da hast du quasi noch ein bisschen Chatplains.
Jetzt müssen wir nochmal, jetzt müssen wir hier Binding Key uns irgendwie rausbasteln.
Und wir müssen gucken, ob das animatet ist.
Also ich würde sagen, das Einfachste das rauszukriegen.
Wir machen das mal anders.
Wir legen mal ein FileInfo an, weil da sind schon ganz viele praktische,
da sind ja NC Sharp, da macht man das glaube ich so.
Ja schön, da steht Microsoft drauf, wie CamelCase schreibt.
FileInfo, da haben wir nämlich gleich solche Dinger drin, wie Extension und sowas.
Das heißt wir müssen da eigentlich gar nicht mehr selbst großartig Stringmanipulation mit der Dateiname machen.
Das heißt wir können FileName schon mal setzen.
Übrigens dieses Dis und so, das brauchen wir nicht.
Das ist ein Tick von mir.
Die meisten Leute stehen drauf, das so zu machen.
Das ist für interne, für private Sachen, private, wenn ich noch richtig schreiben könnte.
Ja private, plupp, da machen die meisten Leute gerne dann so Dinger hier drauf, so plupp mit Unterstrich.
Aber, und die lassen dann halt das Dis weg, sondern schreiben hier bloß so plupp.
Kann man auch machen.
Mir gefällt es so besser.
Das ist aber Geschmacksfrage.
Ich schreibe irgendwie gerne Dis davor.
Ja stimmt, aber ich schreibe immer davor ob public oder private.
Immer.
Ich finde das macht es irgendwie lesbarer.
FileName ist für sich FileName.
Ich weiß gar nicht ob das, das ist ganz praktisch sogar.
Das kommt wahrscheinlich auch sogar, ob es das gibt und gibt eine ordentliche Fehlermeldung wenn es das nicht gibt.
Das ist auch schon mal praktisch.
So und es ist nicht FileName sondern es ist hier.
Ja so Path ist besser.
Rename.
Path.
Ups.
So jetzt müssen wir uns den ganzen anderen Krempel hier irgendwie noch ein bisschen noch raussuchen.
Das heißt, ob das Ding animated ist, setzen wir einfach auf true wenn es ein GIF ist.
Das ist relativ simpel.
Ja.
Wir unterstützen eh nur GIFs zum animieren.
Falls es noch andere Formate gibt, also jetzt mal von Videoformaten abgesehen, die das unterstützen, wir unterstützen animated nur GIFs.
Weil unsere Dings Library hier zum animieren, kann nur GIFs.
Wir können da gar nichts anderes einplanten.
Vielleicht können wir in Zukunft noch irgendwie Video-Dings-Dings-Support einbauen, aber nee.
So das heißt wir gucken jetzt, ist animated, dürfte relativ simpel sein.
Wir können einfach gucken ob die Extension GIF ist würde ich sagen.
Das ist eigentlich sehr simpel.
Ich weiß nicht was passiert wenn GIF groß geschrieben ist.
Da wird es nicht funktionieren falls es das hier nicht abfängt.
Aber lassen wir erstmal so, gucken wir mal ob das funktioniert.
So und jetzt wird es spannend, jetzt müssen wir gucken wie wir irgendwie das Binding da raus kriegen.
Wie gesagt wir sagen hier Binding ist prefix bla bla unter Strich und dann kommt das eigentlich in Bild.
Das heißt das müssen wir uns da irgendwie raus basteln.
Binding-Key ist FileInfo.
Wir brauchen jetzt eigentlich nur den Dateiname.
Name ist nur der hintere Teil.
Also quasi Fullname ist quasi C++ User Max Desktop Plub.png und Name ist nur Plub.png.
Soweit die Idee.
Ja das können wir wirklich machen.
Dann hast du das Problem nicht.
So FileInfo Name.
Mal gucken, ich bin mir nicht ganz sicher ob Fehler Tolerant das Spaß ist.
Wenn wir das jetzt Splitten.
Funktioniert das so?
Wir Splitten das und nehmen dann das erste.
Das müsste eigentlich gehen.
Gucken wir mal Binding-Key.
Bam!
Ja das funktioniert.
Gut sehr schön.
Mal Gedanken darüber machen wie Fehler Tolerant das Ganze ist.
Was passiert wenn einer zwei Unterstriche rein macht?
Nix, alles immer noch das gleiche.
Was passiert wenn da kein Unterstrich drin ist?
Dann steht da der komplette Dateiname drin und es kackt ab.
Ja aber das ist auch nicht schlimm.
Ist der Typ selbst dran Schuld wenn er sein Zeug falsch benennt.
Rekt.
Achja Leute, GIF oder JIF?
Ihr habt gerade auch schon die Diskussion im Chat.
Also ich bin ja für GIF.
Habt ihr die Devolver Conference gesehen bei der E3?
Da hatten sie genau das Thema ob GIF oder JIF.
So.
Ok fordert ihr wie das Ganze funktioniert?
Gut.
Wir brauchen einen Einschnitt.
Kann man noch zusammenschreiben?
Jo.
Ok.
Das funktioniert.
Jetzt müssen wir das hier einbauen.
Dieser ganze Hardcoded Mist muss hier weg.
Hier haben wir schon rausgeschmissen.
Das heißt wir ersetzen mal unser...
Ach wir haben ja gar nichts.
Machen wir hier mal die Liste draus.
So und die laden wir jetzt.
Ok.
Da können wir nämlich die ganzen anderen Krämpel raus machen.
Gucken wir mal wie wir das am besten jetzt hinkriegen.
Das ganze Hardcoded Mist den wir hier das letzte Mal drin haben.
So diese Memes Collection brauchen wir dann auch nicht mehr.
Weil es können beliebig viele sein.
Den Scheiß kopieren, den kommentiere ich mal aus.
Weil man weiß, da brauchen wir garantiert noch was davon.
Memen.
Das funktioniert aber nicht.
Ich muss das jetzt mal umbauen was wir das letzte Mal hatten.
Dass es wieder lauffähig wird.
Genau.
Jetzt muss ich mal kurz überlegen, wie machen wir das jetzt am besten.
Jetzt erst mal den ganzen alten Schmodder raus.
Und wir müssen jetzt ja die Keybindings noch anlegen.
Das machen wir hier.
Das heißt hier brauchen wir eine Schleife.
Es kann sein, dass ich mich jetzt auch ein bisschen verzettel.
Ich muss erst mal überlegen, wie wir das am besten machen.
Also im Prinzip brauchen wir eigentlich eine Schleife über alle zusammen.
Schreibt man das übrigens klein oder groß?
Wie macht man das?
Ich glaube Microsoft will, dass man das an der Stelle klein schreibt.
Kann ich auch mitleben.
Ich kann mir immer nicht merken, wann Microsoft empfiehlt was klein und groß zu schreiben.
Ich glaube, wenn das ein Property ist, dann möchten die, dass man das groß schreibt.
Irgendwie so.
So.
Und dann müssen wir jetzt das Keybinding setzen.
Das heißt wir machen eine Schleife hier und haben dann hier das Keybinding drin als String.
Und davon müssen wir jetzt einen Funktionsaufruf erzeugen, der uns das...
Okay.
Wie machen wir das jetzt am besten?
Wir machen uns da eine eigene Funktion für.
Wir machen so was hier.
Meine neue Tastatur, ich habe jetzt eine Corsair K95 Platinum irgendwas mit Cherry MX Speed Switchen mit 1,4 Millimeter...
Wie nennt man das?
Wo man drücken muss, bis es reagiert.
Und man kann darauf so krass schnell tippen, dass ich die Knöpfe immer nicht treffe.
Also wenn ich Private schreiben will, kann es sein, dass ich irgendwie so was mache hier.
So.
So haben wir den anderen überhaupt kein Problem.
Machen wir eben so was wie Z-Keybindings.
Was mache ich denn da?
Da habe ich außerdem den Caps Lock gedrückt, wenn ich zu schnell schreibe.
Z-Keybindings.
Alter.
Sag mal.
Z-Keybindings.
Ja.
So.
Und da machen wir jetzt den ganzen Krempel drin.
Ja.
Und da drin müssen wir jetzt diesen komischen String, den wir hier haben, diesen Prefix, also B, C und 0, 8 und sowas.
Und dann müssen wir jetzt irgendwie parsen in einen Key-Enum.
Weil die Funktionen, die wir aufrufen, um wirklich die Keybindings einzurichten, die braucht halt so einen Key-Enum.
Und ja.
Chat gucken, ob ich was überlesen habe.
Nur Parameter, Kleinschreiben, keine Ahnung.
Normalerweise meckert Rüssel Studio ja, wenn man gegen diese Standardschreibweise irgendwie verstößt.
Aber in dem Fall scheint es okay zu sein.
Aber ist es nicht?
Was soll das Meme-Tool am Ende alles machen?
Das ist Open-End.
Also das Einfaste und das, was ja auch schon funktioniert, ist auf Tastendruck auf Meme-Bildchen-Overlays einplanten hier.
Das funktioniert ja auch.
Bloß ein bisschen animieren, ein bisschen Blödsinn, ja.
Das nächste, das machen wir heute aber wahrscheinlich nicht mehr.
Das nächste ist, das habe ich schon mal in Quick and Dirty Lösungen für die E3 Streams gebastelt,
ist, dass das Ding eine Netzwerk-Funktion kriegt, dass man von einem zweiten PC aus das Fernsteuern kann.
Also sprich, dass wenn man mit einem zweiten PC, mit einem zweiten Streaming-PC, mit einem zweiten Monitor,
dass man dann dort einen Dashboard kriegt mit den Bildern, die man anklicken kann und der zeigt die dort an.
Also quasi ein bisschen wie Elgato Stream Deck, bloß auf dem zweiten Monitor.
Netzwerk-Funktion machen wir aber, glaube ich, das nächste Mal.
So, jetzt müssen wir irgendwie den Krempel hier, also hier B, C, D, D7 und so,
müssen wir umwahlen in KeyEnum.
Das ist glücklicherweise, das ist relativ einfach.
Dann kann ich einfach sagen, Enum, glaube ich, Enum Try Pass, dann sagt man in was man passen möchte, nämlich in Key
und dann kann man sagen, was.
Jetzt können wir übrigens ein schönes neues C-Sharp-7-Feature verwenden.
Früher musste man sowas machen.
Hier Key Result und dann musste man schreiben Out, wenn man richtig schreiben kann.
Oder nicht, mache ich jetzt Mist.
Out Result.
So musste man das früher machen.
Ja, guck, der macht es jetzt schon für einen.
So musste man das früher machen.
Mittlerweile kann man das viel schöner machen.
Man kann einfach sagen, ok, war und dann halt, wie es heißen soll.
Dann hat man jetzt das Ding.
Das ist zwar nicht sonderlich fehlerlich, aber es ist einfach so.
Dann hat man jetzt das Ding. Das ist zwar nicht sonderlich fehler tolerant, wenn da irgendwie Mist drinne steht.
Warum man sowas braucht?
Ja, wenn man Overlays einblenden will.
Weil wir nennen das nicht Result. Result ist doof, weil das hier eigentlich das Result aufs geklappt hat.
Mal gucken.
Gucken wir mal.
Wir machen erstmal die fehleranfällige Variante.
Gucken wir mal, ob das Prinzipiel jetzt funktioniert.
Result.
Ja.
Scheint zu funktionieren.
Und jetzt sagen wir New, Hotkey.
Übrigens kann man das auch anbinden irgendwie.
Wie anbindet man mit dieser komischen Library eigentlich?
Keys.
Gucken.
New, Hotkey.
Modifier.
Machen wir mal Control.
Nehmen wir mal HardcodedControl als Modifier.
Also was man zusammendrücken muss.
Result. Den Key, den wir binden wollen.
Für dieses Fenster.
Und Action.
Ja genau, was passieren soll, wenn man diesen Shortcut drückt.
Und da wollen wir eigentlich unsere ChangeMeme-Funktion aufrufen.
Kann ich das jetzt so direkt schreiben an der Stelle?
Nee.
Warum nicht?
Ah.
Aha.
Okay. Ich brauche den Parameter nicht wirklich.
Okay, nice.
So.
Von der Logik her müsste das funktionieren jetzt.
Jetzt bindet er den Kram.
Jetzt muss ich noch gucken, wie ich den Kram wieder anzeige.
Klingt jetzt eigentlich logisch.
Und ich muss mal kurz aufs Klo, kurz auf.
Okay.
Okay.
So.
So. Wieder am Start.
Okay.
Also, von der Idee her müssen wir jetzt genau das gleiche machen.
Wie vorher auch.
Plus, dass wir jetzt hier was dynamisch festgelegt haben.
Okay.
Stopp.
Hm.
Okay.
Also, von der Idee her können wir eigentlich...
Ja, jetzt ist gut, dass wir hier sowas wie isAnimated drin haben.
Weil jetzt können wir gucken...
Das Ding ist isAnimated.
Ja, das ist schön, das gefällt mir.
IstAnimated.
Dann machen wir nämlich dieses Geschwubbel hier.
Ah ja, das ist viel einfacher als vorher.
Dann machen wir dieses Geschwubbel hier.
Allerdings natürlich nicht hardcoded.
Das wäre ein bisschen doof.
Path.
So, und wenn es nicht animated ist,
dann setzen wir einfach this image source new.
Bei Edge können wir uns das...
Ach komm, ich schreib's jetzt.
Bitmap.
Image.
Ich weiß nicht, ob man das irgendwie schöner machen kann.
Auf Filename.
Nee, auf Path heißt es.
So.
Das müsste funktionieren.
Mal gucken, ob's funktioniert.
Bam.
Nice.
Guck mal.
Von hardcoded dynamisch zu...
Je nachdem, wie der Teilnahme heißt.
Ja, das ist doch schön.
Das ist doch sehr nice.
So, jetzt müssen wir noch gucken, dass das Auto...
So, okay.
Also angeblich ist jetzt Strg1...
Oh, ah, Moment.
Das Switchen funktioniert noch nicht.
Wartet mal.
Äh.
Moment.
Ich hab vergessen, nach der Animation zu resetten.
Äh.
Ähm, Moment.
Ich muss die Animation resetten.
Ähm.
Ja, nee.
Nee, einfach nullen musste man das.
Genau.
Das war ganz, äh, ganz wirr.
Set Animated Source.
Äh.
Null.
Dann funktioniert's jetzt auch.
Das ist jetzt jetzt auch.
So.
Ja, nice.
So, also von der Idee her müsste jetzt
StrgB müsste Prane sein.
StrgC müsste Command-Bra.
Null ist Money.
Hot Pocket eins.
Zwei, drei, vier.
Nice.
Okay, das funktioniert.
Das ist doch schon mal 3 Milliarden mal besser als
hardcoded Scheiße am Anfang.
Moin, TommyK.
Das ist doch schon viel besser.
Dann kommen wir jetzt den ganzen Schmodder weg.
Guck mal, wie viel übersichtlicher
das jetzt ist, ne?
Wie viel übersichtlicher das jetzt ist, ohne diesen hardcoded Schmodder,
den wir am Anfang drin hatten.
Ähm.
Serious Max, das geht gerade nicht.
Du kannst auch aktuell, das machen wir jetzt gleich.
Ähm, du kannst doch aktuell noch nicht
on the fly neue
neue Bilder laden.
Das funktioniert noch nicht.
Ähm, übrigens, das Ding wird wahrscheinlich abkacken,
wenn ein Bild die gleichen Keybindings hat.
Also ich fang ja aktuell null Fehler ab.
Also probieren wir, probieren wir das einfach mal.
Machen wir mal hier, ähm,
was weiß ich.
Oh, doch es heißt C.
Das crasht jetzt wahrscheinlich.
Bam, ja, immerhin ist klar.
Dann versuch ich jetzt zweimal das gleiche.
Aber das können wir noch machen dann.
Ist ja, Fehlerbehandlung
immer erst am Schluss und dann die Hälfte vergessen.
Ist, war Special Studio? Ist 660 Euro?
Nein. Du nimmst einfach hier
Community,
Community, bam,
Download.
Ist einfach hin.
Und laden sie das for free runter.
Den Rest brauchst du nicht.
Ähm,
früher war es so, dass nur die
Pay-Version von Visual Studio, also als das
noch Express hieß und sowas,
früher war es so, dass die Pay-Version von Visual Studio
nur Extensions und Zeugs gekriegt hat,
aber das ist mittlerweile
auch nicht mehr so.
Ich weiß gar nicht genau, ehrlich gesagt,
wo der Unterschied ist
zwischen der Community und der
Nicht-Community-Version. Wahrscheinlich hast du
noch irgendwie dieses Microsoft Visual, wie heißt das,
Source, Source Safe,
oder, ne, wie heißt das,
Visual Teams Studio, ne, ja, keine Ahnung.
Ich weiß gar nicht, was der Unterschied ist.
Aber die
Community Edition für 0 Euro reicht voll und ganz aus.
Okay.
Aber das ist schon mal schön. Das ist viel, viel, viel
schöner.
So, und jetzt müssen wir mal in uns gehen.
Ich muss mal meine Liste abhaken.
Also, was wir jetzt geschafft haben,
ist, ähm, Bindings
automatisch
haben wir geschafft.
So,
ähm,
jetzt, jetzt schauen wir mal,
dass wir das automatisch, dynamisch
reloaded kriegen. Da bin ich mir noch
ziemlich unschlüssig, wie wir das Ganze machen.
Also, das müssten wir in irgendeinem
Flat machen, auf jeden Fall.
Oder mit irgendeinem Timer machen wir das wahrscheinlich am besten.
Hast du eigentlich mal was
mit 900 Networks gemacht? Nein, habe ich nicht.
Das heißt, wir müssen uns irgendwo
wir probieren das einfach mal
mit einem Timer hier im Hintergrund.
Error 403,
ne, ne, Fehlerbehandlung ist es.
Was für Weicheier.
Das machen wir nicht.
Also, Features
sind wichtiger als Bugs zu fixen.
Wir machen das EA-Style.
So macht man das heute.
Und Activation und EA machen Millionen damit.
Ich muss mal was essen.
Bitte.
Ich will als erstes nochmal einmal, dass das Ding im Hintergrund
nachlädt.
Klar macht man das so.
Guck dir das bei EA an.
Oder bei Ubisoft.
Guck dir das mal bei Ubisoft mit
welches Assassin's Creed
war das? Unity.
Assassin's Creed Unity.
Die haben das zwei Jahre nach
Release noch nicht geschafft, die Bugs zu fixen.
Also warum sollten wir das machen?
Na klar bauen wir das ein.
WTF.
Das war das Debate des Jahres.
Das Memetool, das gibt es dann demnächst,
gibt es das Memetool as a Service.
Filesystem Watcher.
Ach sowas gibt es.
Das ist sehr nice.
Das gefällt mir.
Das finde ich cool.
Gibt es das wirklich eingebaut?
Echt krass.
Sehr schön.
Das ist sehr schön.
Also ich hatte jetzt eigentlich so
mein naiver Ansatz wäre jetzt gewesen,
dass wir einen Timer machen.
Da haben wir einen Timer
mit alle 10 Sekunden.
Und dann das Ganze neu einlesen.
Aber mit Filesystem Watcher ist das Ganze
natürlich noch viel schöner.
Wie verwendet man das?
Das habe ich glaube ich noch nie verwendet.
Was soll das Programm genau machen?
Das kann ich dir zeigen.
Du kannst transparent Overlay Bilder einblenden.
Du legst den Ordner rein.
Mit definiertem Keybindings kannst du
die Bilder als Overlay einblenden.
Das Beste ist, du kannst durchklicken.
Also es ist wirklich ein richtiges,
echtes Overlay mittlerweile.
Du kannst durchklicken.
Und es nimmt auch nicht den Fokus
vom Programm weg.
Also das heißt es ist wunderbar
für Stremsor die blöde Billchen
einblenden wollen, transparente.
Das ist ein großes Gehirn.
Moment, das sollte ich vielleicht
mal überm Return machen.
Ich muss mal gucken,
wie verwendet man das jetzt eigentlich?
Habe ich noch nie verwendet.
Das eins muss man,
man kann viel auf Microsoft flamen,
die Dokumentation für das.NET Framework
und auch die Beispiele.
Das ist wirklich das beste was es gibt.
Mir fällt kein Projekt ein ohne Scheiß.
Durch die Bank weg. Nichts.
Egal ob das 100.000 kostet,
egal ob es kostenlos ist,
egal ob für Windows, für Linux oder sonst was.
Mir fällt nichts ein,
was eine so gute Dokumentation hat
wie das.NET Framework.
Die ganzen Büsse des Dingers sind in der Regel
noch viel schlimmer.
Die schreiben einfach gar nichts.
Unity habe ich noch nicht verwendet.
Kann sein.
Aber Unity kann es ja auch an sich scharf basteln.
Unity habe ich noch nicht verwendet.
Aber könnte ich mir vorstellen,
dass Unity,
wenn Unity
eine ähnlich gute Dokumentation hat,
könnte ich mir vorstellen, dass das eines der Gründe ist,
warum sich Unity durchgesetzt hat.
Was ich gehört habe,
ist, dass die CryEngine
krottenschlecht dokumentiert ist.
Habe ich keine eigenen Erfahrungen mit,
womit habe ich gehört.
Ich kenne einen, der einen kennt,
so nach dem Motto.
Ich komme ja auch aus Frankfurt.
Das muss ganz grausam sein.
Unity weiß ich nicht.
Ja, es gibt ein paar Projekte.
Manche Sachen...
Cute Dogs sind auch nicht schlecht.
Die sind auch nicht übel.
Aber ich finde,
die Geschichte für.NET
ist wirklich super.
Kann man echt nicht beschweren.
Okay.
Changed, created, deleted, renamed.
Okay, nennen wir mal einfach nur created.
Ja, das ist ja easy mode.
Das ist ja easy mode.
Das probieren wir jetzt mal aus.
Das ist nicht die richtige Stelle, das hier zu machen.
Wenn man das mehrfach aufruft,
hätte man mehrere Filesystem-Watcher und so.
Ich bin jetzt einfach mal ausprobieren,
ob ich etwas falsch habe.
Created.
Ach so.
Hey.
Created.
Warum macht das eigentlich kein Auto
für Vollständigung?
Normalerweise macht das doch immer Auto
für Vollständigung in der Stelle.
Ach, jetzt.
Tab.
Blöd.
Brauchen wir nicht.
Wir machen das mal inline.
Mal gucken, ob das funktioniert.
Ich habe das wie gesagt nie verwendet.
Das funktioniert echt.
Krass.
Okay.
Okay, gucken wir mal,
ob der Filesystem-Watcher funktioniert.
Copy.
Paste.
Geht nicht.
Warum geht der nicht?
Der geht nicht.
Was war jetzt daran falsch?
Filesystem-Watcher bastet.
Geht nicht.
Warum geht der nicht?
Ah, Notify-Filters.
Ah.
Das ist gut.
Da wird man auch nicht vollgespammt,
wenn man in einem Ordner ist,
wo sich viel ändert.
Das ist nicht übel.
Das hat was.
Wo? Falscher Knopf.
Das ist jetzt schöner,
aber ich weiß ja nicht.
Okay.
Was kann man da eigentlich alles filtern?
Ach, das sind die Attribute von einem File,
was sich ändert oder wie?
Probieren wir mal, ob das jetzt funktioniert.
Copy.
Paste.
Nee, geht immer noch nicht.
Wahrscheinlich habe ich noch
Created nicht gefiltert oder so.
Was muss ich noch als Filter,
dass er das mitkriegt?
Was muss ich da noch eintragen?
Das Ding hat sich schon nie verändert.
Wie geht denn das?
Kein Schimmer.
Tja.
Du musst das aktivieren.
Echt?
Ah.
Poggerino.
Nee.
Nicht Begin.
Enable.
Start geht auch?
Nee.
Das ist aber bisschen umständlich.
Okay, gucken wir mal.
Hab ich das jetzt auch in der richtigen Reihenfolge gemacht?
Ja.
Okay.
Wisst ihr was?
Wir probieren jetzt erst mal, ob das ohne...
Wir probieren es jetzt mit Filter,
aber auch dann ohne Filter.
Ich habe doch einen Eventhändler für Created drin.
Da, hier.
Da, guck.
Geht.
Bam.
Nice.
Sehr schön.
Das hat was.
Das ist echt nice gemacht.
Gucken wir mal, ob das ohne diese komischen Filter funktioniert.
Ja, geht auch.
Dann, nice.
Das ist schön gemacht.
Das gefällt mir.
Das finde ich hübsch.
Nee, Steuerung C und Steuerung V geht nicht,
weil Steuerung C ist hier dran gebunden gerade.
Ich glaube, Steuerung V wird funktionieren.
Das weiß ich, warum ich so umständlich kopiere.
Das sind vielleicht nicht die glücklichsten Bindings,
Steuerung C.
Was man auch noch bräuchte ist,
wenn man dann irgendwann mal Netzwerkfunktionen für einbauen,
dass man quasi auf so einem Dashboard noch hat,
wo man die Bilder anklicken kann,
dass man auch Bilder einfügen kann,
die eben keine Bindings haben.
Das könnte man relativ einfach machen,
indem wir einfach gucken,
ob das startet mit Unterstrich zum Beispiel,
dann macht er dafür kein Binding.
Irgendwie sowas.
Könnte man auch machen.
Weil es könnte ja sein,
ich will ja gar nicht unbedingt alles binden.
Spätestens, wenn ich dann noch mal auf dem anderen Monitor
eine Übersicht habe,
dann beinde ich mir halt die häufigsten 5,
die ich brauche auf irgendwelche Knöpfe,
die ich sonst nicht brauche.
Den Rest kann ich dann über das Dashboard bedienen.
Das kann man auch noch machen.
Wo bauen wir jetzt diesen Watcher am besten ein?
Bei den Load-Memes ist er auf jeden Fall verkehrt.
Hauen wir das überhaupt in der Meme-Klasse ein?
Eher nicht.
Weil es da eigentlich gar nicht so schlecht ist.
Machen wir was Eigenes?
Ja, im Konfig machen wir vielleicht doch
irgendeinen Mini-Jasten-Konfig.
Aber aktuell finde ich es ganz gut,
dass ich keinen Konfig brauche.
Machen wir irgendeine eigene Klasse draus.
Irgendwie so eine Background-Watch oder irgendwas sowas.
Weil das hat auch im Main-Window
überhaupt nichts zu suchen.
Das hat im Main-Window nichts zu suchen,
wobei er hier thematisch eigentlich ganz gut wäre.
Aber nein, eine Klasse draus.
In der Uni hatten wir eine Aufgabe
über drei Wochen eine Mini-Programmiersparre zu schreiben,
die man einfach in einer TXT-Dateikode
in einer Sündag schreibt
und der Java-Compiler per Strings überprüft und übersetzt.
Strings passiert das aber, in Java ist es so langsam.
Kommt drauf an, wie man es macht, denke ich.
Also in C-Sharp ist es auch übelst langsam,
wenn man irgendwie zu oft sowas hier macht.
Wenn man jetzt eine Schleife machen würde,
irgendwie so, also eine große lange Schleife
und du machst dann quasi in der Schleife
irgendwie 30 Milliarden Mal hier Blablabla da dran.
Das ist mega langsam.
Also sowas ist übertrieben langsam.
Was besser ist, ist wenn du einen String-Builder verwendest.
Dafür und dann musst du nicht so viel
neues String-Objekte erzeugen.
Beziehungsweise nicht so viel Speicher.
Das ist einfach viel schneller.
Wie nennt man das Ding?
Wie nennt man die Klasse?
Ich brauche einen guten Namen
für irgendwie dieses Background-Filesystem-Word.
Oder komm, wisst ihr was?
Scheiß drauf.
Wir hauen diesen Filesystem-Word
jetzt einfach mal in unser Main-Window rein und gut ist.
Können wir immer noch machen.
Also hört er zwar nicht wirklich hin,
aber dann funzt es erst mal.
Wobei, wie gefällt mir das nicht.
Das machen wir nicht.
Das machen wir nicht.
Meme-Watcher, das finde ich schick.
Das machen wir.
Das hat was.
Meme-Watcher.
Wobei, wie machen wir das jetzt?
Da bin ich bei uns schlussig.
Was ist denn das?
Ich habe Hunger.
Wie machen wir das jetzt am besten?
Hm.
Also von der Idee her soll er ja sowas hier machen.
Was, nimm sowas wie isActive
mit Synchronize-Funktion?
Was meinst du?
Ach du meinst, ob der gerade läuft?
Dass das nicht mehrere gleichzeitig oder was?
Also ich werde es jetzt zum Ausprobieren mal.
Ich werde es jetzt zum Ausprobieren doch mal
in mein Main-Window hauen.
Und das hier funktioniert übrigens nicht.
Das gibt auf jeden Fall irgendeine Threat-
Da haste nicht gesehen.
Das muss ich invoke-en.
Und das ist auf jeden Fall meine
Ich würde jetzt einfach mal ausprobieren, ob das prinzipiell funktioniert, was, was ich hier vor habe.
Äh, wie geht denn das, wie geht denn das in WPF?
Invoke?
Wie, wie invo, wie invoked man dann, wie macht man das?
Ach, Dispatcher war das, genau. Dispatcher.
Invoke.
Weil sonst, nur mal so von der Idee her, das ist ein schönes Beispiel, wo man sieht, dass Multiswitching immer komplizierter ist, als man auf den ersten Blick denkt.
Also was hier passiert, von der Idee her ist, ähm, es wird ein Hintergrundstrett gestartet, verbute ich mal, ich weiß nicht, wie es intern implementiert ist, ja.
Es wird ein, es wird ein Hintergrundstrett, es wird ein weiterer Strett gestartet, der dann quasi überwacht, ob in diesem Ordner hier neue Dateien erstellt werden.
Wenn neue Dateien erstellt werden, dann führt er das hier aus.
So, wenn ich jetzt allerdings von diesem zweiten Strett Sachen ändere, in meinem UI-Strett, dann knallt's in der Regel.
Wir können das ja mal ausprobieren, ob das funktioniert.
Wir können einfach mal gucken, was passiert. Oh, noch funktioniert's?
Also das muss, das Schöne ist ja auch bei Multithreading Probleme.
Okay, das funktioniert anscheinend, aber das muss nicht immer funktionieren.
Also das ist auf jeden Fall so ein Ding, wo ich aufpassen würde.
Irgendwelche Sachen hier zu setzen, vor einem anderen Strett, das ist so...
Nee.
Alles besser, wir machen das über Invoke.
Dann wird das hier im UI-Strett ausgeführt und gut ist.
Aber wenn das, ja gut, das liefert wahrscheinlich Fehler, wenn ich im gleichen Moment versuchen würde,
dass ich Fehler, wenn ich im gleichen Moment versucht drauf zu... Irgendwie sowas.
Es ist auf jeden Fall nicht sehr safe, auf gar keinen Fall, was hier bastelt.
Also müssen wir das irgendwie so machen. So, von der Idee her irgendwie sowas.
Agane ist XQC Englisch.
Willst du das Programm jetzt fertig zum Download anbieten? Ja, klar.
Kannste dann über das GitHub runterladen.
So, wir gucken jetzt mal, ob das überhaupt funktioniert.
Wir lassen uns hier nochmal was ausgeben, so, keine Ahnung, neues File oder so.
Ja, es ist bei GitHub. Font-Size.
Font-Size. Font ist Default, Konsolas.
So, und das müssen wir auch nochmal machen, dann da drinnen.
Keybinding neu laden. Das ist alles noch nicht so der Weisheitsletzter Schluss.
Da muss ich mir noch ein bisschen Gedanken drüber machen, weil aktuell machen wir das ja nur einmal
und hier laden wir es mehrfach. Und sobald man irgendwelchen Code Copy Paste muss,
ist in der Regel was nicht richtig.
So, mal gucken, ob das jetzt funktioniert. Also von der Idee her sollte es ja so sein.
Wenn ich jetzt, das probieren wir mal aus.
Keine Ahnung, legen wir uns mal das hier hin und nennen es jetzt irgendwie F8 oder so.
Mal gucken, was, ich glaube F8 habe ich noch nichts gebindet.
F1, 2, 3, 4, 5, 6, 7, oh fuck. Fuck, ich habe schon alle F-Dinger durch.
Okay, F11 ist noch frei. F11, okay. F11. Okay, und dann sollte das funktionieren.
Und dann bin ich jetzt mal gespannt, ob das klappt. Ich glaube nicht.
Das klappt, ich habe es kaputt gemacht. Ich habe es kaputt gemacht.
Ich habe es kaputt gemacht. Es ist keine gute Idee gewesen, das hier hinzuschreiben.
Was? Ah, logisch, dass es nicht funktioniert.
Okay, das klappt. Jetzt bin ich echt gespannt, ob das klappt.
Wenn wir jetzt hier etwas Neues reintrecken, ob es dann neu lädt.
Okay, probieren wir mal aus.
Nein. Ah, already in use. Warum? Ah, weil er das neu, jetzt muss, okay, wie unset.
Ich muss das einmal unsetten, alles. Wie macht man das?
Wie geht denn das mit dieser komischen Library des unsetten?
Aber das ist auch doof, da muss ich alles unsetten und danach neu setzen.
Damn, das ist irgendwie nicht schön.
Da muss ich mir in Ruhe noch mal Gedanken tun, aber fällt mir gerade keine schicke Lösung zu ein.
Also eigentlich müssten wir rauskriegen, was neu ist.
Eigentlich müsste man gucken, quasi einen Diff irgendwie machen.
Quasi irgendwie das da, das da. Nee, warte mal.
Was für eine Menge will ich haben, wenn ich zwei Listen habe und ich will wissen, was nur was nicht in beiden drin ist.
Das da, oder?
Oh, das wird ganz schön das Gefrickel hier, was ich da gerade bastel.
Keine doppelten, genau.
Beste Variablename, Temp natürlich, was sonst?
Was ist jetzt da dran verkehrt?
Okay, wie verwendet man den Knäppel?
Wie ging das?
Ah, man macht das auf einmal, man macht nicht beide zusammen.
Wie geht das jetzt gescheit?
Das ist jetzt komplizierter, als ich mir das so vorgestellt habe.
Im Prinzip brauche ich die Elemente von dem Alten und dem Neuen und dann will ich wissen, was neu ist.
Schauen wir mal kurz nebenbei, kurz was vorder.
Wie heißt das? Das ist nicht Teilmenge, das ist, wie nennt sich das denn?
Teilmenge ist, was beide haben.
Ich will die Elemente haben, die quasi nicht doppelt sind.
Schnittmenge, wie heißt Schnittmenge auf Englisch?
Was heißt Schnittmenge auf Englisch?
Ich will keine Schnittmenge, ich will das Gegenteil von Schnittmenge, Differenz will ich haben.
Ja, das will ich, das will ich.
Genau das und jetzt die andere, ja genau so.
Sowas will ich haben.
Das ist zwar nicht schön, aber das müsste jetzt funktionieren, weil jetzt setzen wir nur das Neue.
Genau, ja jetzt setzen wir nämlich nur das Neue.
Soweit von der Idee her, gucken ob das funktioniert.
Ne, das Alte lösche ich nicht. Hier ist alles drin und ich setze nur für das neue Keybindings.
Das Alte bleibt da, ich meine damit funktioniert nur hinzufügen, ich muss mir da eh noch mal Gedanken drüber machen, wie ich das ordentlich mache, weil hier drinnen das einzubauen ist eh total abartig.
Jetzt aber nur prinzipiell mal gucken ob das funktioniert, weil ich mir das so überlegt habe.
So F11, geh weg.
Was? Warum? Aber warum? Warum? F11 ist nicht doppelt.
Warum ist das doppelt?
Das ist das beste immer noch dran.
Ich muss Steuerung C unbedingt entbinden.
Ist F11 schon doppelt?
Das check ich nicht.
Okay nochmal, nochmal. Warum? Was? Die Buggy mit Weitland.
Das check ich nicht. Das wäre jetzt zu hoch.
Da kommt nicht das raus, was ich erwartet habe. Was? Mach ich das falsch rum? Kann das sein?
Ohne Difference ist bestimmt nicht das Prain Bild.
Warte mal. Das macht nicht das, was ich denke, dass es macht.
Das macht es doch, was ich will. Muss ich das vielleicht so machen?
Ist das einfach mal geraten?
Jetzt muss ich erstmal löschen. Das check ich nicht.
Okay, von der Idee her ist es... Alter, piss dich.
Ich will eigentlich das. Da müsste eigentlich eine Sache rauskommen.
Oder wenn ich das falsche...
Von der Idee her ist es doch eigentlich die Dateienung von dem Prain Bild.
Ich hätte das gleich ordentlich machen sollen. Nicht so eklig rein. Jetzt blicke ich durch, was an welcher Stelle passiert.
Okay, das ist auf jeden Fall verkehrt. Wir testen das jetzt mal. Wir nehmen jetzt den ganz langen Weg.
Wir machen jetzt mal eine neue Konsolenanwendung und dann mache ich das mit zwei Arrays und probiere was aus.
Was ist denn los? Warum geht das nicht? Probieren wir jetzt aus. List 1 von int.
Gucken wir mal. 1, 2, 3. Gucken, was da jetzt passiert. Ich habe da garantiert irgendeinen Denkfehler drin.
So, und jetzt sagen wir mal einfach, List 1. List 2. Wenn es das machen würde, was ich denke...
Also was ich haben will, dann sollte jetzt da 4 rauskommen. Kommt wahrscheinlich aber nicht. Ach nee.
Hä? Moment. Warum kommt denn da jetzt gar nichts raus?
Ich glaube, das ist nicht das, was ich haben will. So finde ich schon mal sicher.
Ach so, das ergibt jetzt Sinn. Aber dann war das doch richtig bei dem anderen, was ich gemacht habe.
Dann ist das bei dem anderen doch richtig. Das macht doch genau das, was ich haben will.
Ha. Verstehe ich nicht.
Oder? Nee, das war doch richtig, was ich gemacht habe.
Okay, dann liegt das daran, dass er das nicht richtig kompären kann.
Er kann das nicht richtig kompären, weil das Klassen sind und er einfach guckt, ob die Instanz gleich ist.
Ja, das wird es wahrscheinlich sein. Das wird auch Sinn ergeben.
Da muss, guck mal eben, Custom-Compare-Funktion oder sowas, ob man da sowas angeben kann.
Wie geht das? Wie gibt man, wie gibt man eine Custom-Compare-Funktion an?
Wie geht das? Ja, das wird daran liegen, relativ sicher.
Der erkennt einfach nicht, der kann das nicht durchführen, weil für die Dinge alles anders aussieht.
Ich meine, man könnte, man könnte irgendwie Equals oder so überschreiben in der Klasse.
Nee, wie kann man da nicht einfach eine Funktion hinten angeben, die dann kompärt für einen? Muss man, muss man das wirklich so machen?
Kann man da nicht irgendwie kompärtet, das ist doch, das ist doch doof.
Boah, das ist Big Brain der Typ, ey.
Das ist Big Brain.
Das ist übelst clever. Der nimmt die Elemente aus List 2, die nicht in List 1 drin sind.
Das ist Big Brain.
Das finde ich gut, das ist sehr nice.
Aber was ich ein bisschen, was ich, was ich wirklich doof finde ist, warum kann man dann hier nicht hinten einfach eine, eine, eine Compare-Funktion oder sowas angeben?
Das ist blöd.
Kann man, kann man das nicht? Das kann man fast so ziemlich, das kannst du in Hubi, kannst du das auch, das kannst du fast überall.
Muss man da wirklich so ein kack, so ein ewig langes, ja das können wir machen, wir können Equals überschreiben, aber das ist nicht unbedingt das, was wir wollen.
Was, klar kannst du ja widern.
Ja widern, da muss ich, da muss ich irgendwie, irgendwas basteln, was irgendwie iEquality, iEquality-Dings-Comparer kann.
Geht doch auch mit Lambda, echt?
Okay, wie ist da die richtige Sonntagsführer, da stehe ich jetzt gerade auf dem Schlauch.
Also ich, am liebsten würde ich hier sowas machen, so bam, irgendwie keine Ahnung, aber das geht ja nicht, weil eigentlich bräuchte ich sowas hier.
Compare A, Compare B und dann A ist sonst was, aber das geht nicht.
Wie mache ich das richtig?
Profis im Chat, PlattChat, wie funs da, das kann es doch nicht sein, dass man da immer so ein eigenes Comparer-Ding basteln muss, das gefällt mir nicht, das gefällt mir nicht.
Da finde ich das viel schöner, was der Typ hier gebaut hat.
Ja so, sowas will ich im Prinzip machen, einfach nur mit, mit einer, das finde ich nicht schick.
Ja, was will ich machen?
Guck, die basteln nicht sogar eigene Link-Extensions dafür, das kann das standardmäßig nicht.
Ich muss da wirklich, entweder muss ich Equals überschreiben oder so einen komischen eigenen Comparer basteln, das ist mir zu doof.
Dann mache ich lieber, dann mache ich lieber das hier, ne, das hier, das finde ich sehr clever von dem Typ.
Aber das kann es doch nicht sein, dass das so kompliziert ist.
Und vor allem kann ich mir nicht vorstellen, dass das sonst keiner braucht.
Das ist doch voll, so eigentlich fast alltäglich, dass du so eine Custom-Comparer-Funktion hinten dran hauen willst.
Aber gut, anscheinend, ähm, kannst das bei Accept nicht.
Das riecht ja Patrick, richtig schlau ist das.
Ah gut.
Dann Stack-Overflow-Driven-Programmigen wir mal.
Boah, kopierst du mir doch aus dem Kram.
Boah, das sollte wegkommen.
Gucken wir mal, ob das jetzt funktioniert.
BigBrain Stack-Overflow kopieren.
Ach ne, erst mal wieder löschen.
Funktioniert.
Funktioniert.
Das ist Massive-BigBrainer-Typ.
Okay, das automatisch wiederholt funktioniert.
Allerdings nur bei neu hinzugefügten Sachen, das müssen wir eh anders machen.
Was, wie löscht du ohne bestätigen zu müssen?
Ich lösche ohne bestätigen zu müssen, keine Ahnung, ist das nicht immer so?
Also ich bin mir nicht darüber im Klaren, dass ich da was geändert habe.
Ich will nur auf Logik.
Bestätigen müssen beim löschen in 2K18.
Stack-Overflow-GGWP.
Okay, die richtig gute Lösung wäre ja, dass man, und da muss ich wirklich noch mal in mich gehen, wie wir das jetzt ordentlich machen.
Also wir sehen, dass das prinzipiell mit File-System-Watcher und so funktioniert, das wunderbar.
Erstens, also kommt, muss man gleich dabei schreiben, kommt dazu, dass das in meinem Main-Window überhaupt nichts zu suchen hat.
Plus, dass das jetzt nur beim hinzufügen von neuen Sachen funktioniert.
Das heißt, die schönere Variante wäre, wenn wir das wirklich hier, machen wir das in eine eigene Klasse rein.
Und dann müssen wir irgendwie gucken, wie wir das alles so zusammenkleben.
Vor allem auch, dass löschen funktioniert.
So, und das löschen funktioniert müssen wir erstmal schon.
Wie anbindet man dann überhaupt was?
Wie anbindet man dann Hotkeys?
Gucken wir mal, ob der ein Beispiel für hat. Das ist ja die Library, die wir verwenden. Hat er ein Beispiel für, wie man anbindet?
Wie anbeindet man? Hat er natürlich nicht. Ich hoffe nicht, dass man das wieder nullen muss oder sowas. Das wäre nicht sonderlich die Sharp-Typisch. Wie anbeindet man denn?
Hat er Beispiele?
Wie anbeindet man denn den ganzen Mist wieder? Mein Gehen muss es ja.
Wie ist der Kram?
Wie anbeindet man denn?
Nullsetz, oh ne bitte nicht. Wie gesagt, ich hoffe nicht, dass man das nullen muss.
Ah, oh ne das ist die Low-Level-Geschichte.
Es leben Open Source-Projekte, wo man einfach nachgucken kann.
Unregister
Ah, Moment, man muss das Dispose, das ist aber...
Okay
Heißt das, ich muss das Disposen, dass das...
Ja gut, warum nicht? Doch, das ist gar nicht so schlecht. Der hängt ja Native-Zeugs dran, also muss ich mir das speichern irgendwie so.
So, und dann sind die Bindings weg.
Und dann machen wir es wahrscheinlich einfach, und die billigste Variante ist, ich merke mir einfach alle Bindings, ich lösche alle Bindings und mache einfach alle Bindings neu.
Das geht so schnell, das merkt keiner, und da gehe ich jeglichen Problemen aus dem Weg, dass ich irgendwas diffen muss, bzw. dass ich irgendwas in die Quere kommen kann.
Gucken wir mal, ob das funktioniert, also von der Idee her wäre es jetzt ja so, ich schmeiß übrigens den ganzen Mist hier mal wieder raus, von der Idee her wäre es jetzt ja so, dass wenn ich das so mache, keine Hotkeys funktionieren dürfen.
Ja, passt.
Okay, funktioniert. Man muss den Campbell Disposen, dann ist das Binding weg.
Okay, ja, warum nicht?
Ehe nicht.
Diffen, mit diff meinte ich einfach den Unterschied zwischen zwei Listen in dem Fall.
Wenn du Liste A hast, Liste B, und du willst einfach gucken, was ist quasi nicht in beiden.
Ja, das ist das Einfachste.
Ich anbinde einfach alles.
Easy, so war das.
Es geht auch schnell, ich glaube, da müsstest du halt, also du müsstest schon im ganz falschen Moment klicken.
Nee, noch nicht mal, noch nicht mal, nee das passt, das ist vollkommen in Ordnung.
Das Schlimmste, was dir passieren könnte, ist, dass das GUI kurz hängt, während er die Hotkeys neu setzt.
Weil wir haben es ja so gemacht hier oben, wir sagen ja, dass er das im UI-Thread ausführt, muss er ja,
weil das sind ja hier, die liegen ja hier im Speicher, ja, das geht.
Und wenn es einfach zu lange dauert, weil wir das im UI-Thread ausfinden,
das Schlimmste, was passieren kann, ist beim Reload, dass es kurz hängt.
Aber ich kann mir nicht vorstellen, dass das groß hängt, beim Registrieren von 15 Hotkeys oder von 20 Hotkeys.
Okay, das heißt, wir müssen uns die Keys merken, die wir hier gesetzt haben.
Also müssen wir hier irgendwie sowas machen.
Hotkey, Nee, Hotkey, Hot, Hotkey.
So, jetzt haben wir eine Liste mit allen Keys und hier kann ich dann einfach alle löschen.
So, dann müssen wir so noch gucken, wie das funktioniert, sich das zu registrieren.
Ich benutze keinen wie Sharper, nee.
So, das heißt, wir wollen jetzt alles registrieren, wir wollen.
Aber das ist noch mal kurz rückgängig, weil das kommt man, kann ich jetzt hier nicht mehr zurück,
kann ich jetzt hier nicht mehr zurück, ah, weil ich geschlossen habe, sehr clever, Max.
Sehr, sehr clever.
Also von der Idee her, wir wollen jetzt, was wollen wir uns abonnieren?
Wir wollen Created, Deleted, was gab es denn da noch alles?
Changed, wollen wir Changed?
Im Prinzip können wir das machen, wir können Renamed, Deleted, Changed, Created,
wir subscriben einfach alles und löschen jedes Mal die Keybindings und fügen sie wieder hinzu.
Das ist zwar nicht wirklich schön, aber es macht bestimmt die wenigsten Probleme.
Ok, den Kram braucht man.
Kann man bei dem Ding nicht einfach ein Event registrieren für alles?
Ok, wir probieren das jetzt einfach mal.
Ja, äh, nein, Buschel Studio.
So, wir wollen nicht Watcher Created, wie gesagt, das ist in dieser Klasse vollkommen falsch.
Äh, aber ich.
Changed, wurscht, wie das heißt.
Changed.
Renamed, Deleted und was haben wir da als letztes noch?
Created, Renamed, Deleted, was war das andere noch?
Changed.
Ja, Changed brauchen wir nicht.
Changed, Changed wird ja bedeuten, der, Changed ist uns egal.
Hauptsache die Funktion heißt Changed.
Ok.
Ja, das passt.
Oh Leute, ich hab übel gezogen, ich muss erstmal was futtern.
Wenn alle Lines immer gleich lang sind, Crackers.
Es gibt ja die Hardcore, 80 Zeichen Limit Fanatiker, kennt ihr die?
Die sagen, dass eine Zeile, darf nicht länger als 85 Zeichen sein.
Wir brauchen kein Changed, weil der Inhalt ist mir egal, das geht mir nur um die Dateinahme.
Also wenn jetzt einer den Inhalt ändert, dann ist das Binding gleich und der Dateinahme gleich.
Ich muss mir nachher mal in Ruhe aufstehen, überlegen, wie ich das am besten dann wieder zusammenklebe alles.
Weil das hat in der Meme Klasse nichts zu suchen.
Dieser Fall System Watcher.
Und der hat hier drinnen auch nichts zu suchen.
Allerdings haben wir nur hier drinnen die Collections, die wir eigentlich brauchen.
Also wahrscheinlich, wahrscheinlich müssen wir eine Klasse bauen, die dann selbst wiederum irgendwelche Events wirft, die wir dann hier drin handhaben.
Irgendwie sowas.
Aber ich bin schon mal froh, dass wir sowas hier gefunden haben.
Wusste ich nicht, dass es das gibt.
Gut, dann schalten wir das mal wieder aus.
Bis ich mir da Gedanken drüber gemacht habe.
Aber zumindest haben wir was ordentliches schon mal geschafft heute.
Die ganzen Dynamik gebunden.
Es gibt keinen Fokus mehr drauf.
Man kann nicht mehr drauf rumklicken.
Und es nimmt anderen Anwendungen keinen Fokus weg.
Also ist doch schon mal was.
Debug Version.
Was jetzt natürlich nicht mal geht.
Eine Sache, die wir kaputt gemacht haben, fällt mir gerade auf.
Wir haben ja gesagt, wenn man rechts klickt.
Wo ist das denn?
Wenn man rechts klickt, dann rotiert das Ganze.
Nachdem wir jetzt eingestellt haben, dass das durchsichtig ist, das reagiert nicht mehr.
Wenn ich hier reinklick, das heißt, die Klicks gehen durch.
Dementsprechend kriege ich auch keinen Rechtsklick mehr hier abgefangen.
Das heißt, da müsste man jetzt vielleicht noch Bindings machen.
Irgendwie, weiß nicht, Steuerung Pfeil links, Steuerung Pfeil rechts oder sowas.
Für Rotation, für drehen oder so.
Müssen wir mal gucken.
So, aber...
Ich würde sagen, wir laden das jetzt erstmal wieder auf GitHub hoch.
So den Zwischenstand.
Ich meine...
Hauptsache, wir laden am Ende des Streams eine funktionsfähige Version hoch.
Die muss ja nicht alles haben.
Also, ich finde, die...
Die Git-Implementierung hat, glaube ich, auch vorhin alle im Chat geschrieben.
In Visual Studio ist irgendwie sehr gewöhnungsbedürftig.
Was, rollen?
Die Taste, die Taste rollen, die Rollentaste, ja.
Die Wetterfüße, die Wetterfüße war wahrscheinlich wirklich gut.
Aber die macht andere Sachen kaputt, wenn sie an ist.
So, ich wollte jetzt was fordern.
Ja, kommenden wir den Krempel und pushen das mal.
Epos, Memboard, Copy, ist das richtige.
Okay.
Wir brauchen eine Aussage, kräftige.
Bild hoch und Bild runter.
Au, Bild hoch und Bild runter, das ist das, das gefällt mir.
Was ist das?
Bild hoch und Bild runter?
Das ist das, das gefällt mir.
Das ist das, das gefällt mir.
Das ist das, das gefällt mir.
Oh, das ist das, das ist das, das gefällt mir.
Bild hoch und bild runter auch bild hoch und bild runter das ist das das gefällt mir das mag ich
Das schreibe ich immer hier rein
Wir machen ja das ist das ist eine super idee tommy dass das hier big brain ist es wieder
Big big biggest brain das war ein sprain wir nehmen einfach steuerung bild hoch bild runter
Für bild links rum rotieren bild rechts rum rotieren
Aussage kommet message was haben wir heute gemacht
Changed to be a real overlay fällt jetzt nichts anderes ein so bamm
Sehr schön, pushen wir den krempel noch mal
Hit push warum ist das nicht mehr in der historie
Boah was habe ich denn für ein password da fuck wartet mal
Github password save
Passwort selbst das problem war das letzte mal schon mal ich vergesse immer mein github password
Und keys haben immer noch nicht hinzugefügt
Wart mal moment leute ich habe es hier irgendwo gespeichert vom letzten mal noch
Da ist es chops
Passwort
Leaked
Da ist es neueste version am start
Wenn sie interessiert kann ich sie angucken wir basteln dann das nächste mal weiter und
Bauen diesen diesen automatischen reload ein
Ich habe pass also ich verwende auch pass da war es aber nicht drinnen mein github password
Das nächste mal bauen wir dann die rotation hier ein mit mit shortcuts bauen ein
Dass das automatische reload funktioniert bei bildchen
Und wenn wir das fertig haben dann bauen wir noch ein dass man das ding übers netzwerk fernsteuern
Kann wie gesagt ich habe hier schon mein meine version die das kann
Aber die ist wirklich nicht schön deswegen machen wir das noch mal zusammen hier
Ich komme jetzt mal rein wie viel follows heute gegeben hat
Finde immer noch interessant dass das dass es so vielen leuten gefällt
Aber ich meine für mich ich finde das super
On stream programmieren macht fast noch mehr spaß als im off stream auch wenn alles im
Schneckentempo vorangeht
Ok ich sehe leider nur die letzten paar follower
Herzlich willkommen im stream kdc 49 66 the crane xx isa 97 xx
The fun maker i bims reichert
Und die kartoffel und eben gerade noch ganz neu der clocks hd
Ich hoffe euch hat es gefallen
Heut Abend gibt es wahrscheinlich noch ein bisschen streben realmoral mit dem ehex zusammen
Wir haben gestern so krass geowned
Wir haben es so krass geowned drei runden instant win
Irgendwie der Rest irgendwie zweiter
Ich liebe es programmier streams zu sehen vor allem deutsch und c-sharp ist nice wenn
euch das gefällt
Aber wie im spiel tja ach ist das heut abend
Heute abend deutschland dings
Also mich mein leute schon ein bisschen länger dabei sie wissen das wahrscheinlich
Aber ist ja ich bin nicht so der fußball fan
Was du hast eine realmoral random drop app programmiert
Seit gestern im playstore
Zeig mal wie heißt die denn die gucken wir uns jetzt mal an
Wenn du willst können wir uns mal den playstore link an
17 Uhr
Schweiz Brasilien danach
Können die schweizer mal die brasilianer recken
Gucken wir uns mal die die app an von tats cut
Da ist das ding realmoral drop picker
Mal davon abgesehen ich mein eigentlich braucht man sowas nicht
Aber da geht es ja nicht drum
Die meisten die besten sachen wohl programieren
Was sie nicht braucht
Aha
Das heißt die app die sagt dir dann wo du jetzt trocken sollst
Wenn du wenn du selbst nicht in der lage bist dass du entscheidende oder was
Ja warum nicht
Sowas ist auch immer eine schöne übung so klein ist es halt immer schön übersichtlich
Und man weiß an jeder stelle wo was passiert
Was ich allerdings ein bisschen bedenklich finde ist
Und das geht nicht gegen deine app
Sondern was ich ein bisschen bedenklich finde ist
Die dass die qualitätskontrolle von google halt die ist das gibt es halt nicht
Du kannst halt mittlerweile alles
Du kannst alles in den play store pushen
Das juckt dir überhaupt nicht mehr
Also das ist jetzt ja offensichtlich eine übungsapp quasi um ein bisschen rein zu kommen
Für android programmieren denke ich mal
Und instant akzeptiert easy
Also die qualität im google store ist wirklich unterirdisch
Und wie gesagt ist das online app schlecht
Schlecht will ich will ich nicht schlecht machen
Aber du hast ja selbst gesagt das ist eine übungsapp
Und da fragt man sich so warum muss google die unbedingt ins store packen
Weißt du das ist wie wenn ich jetzt jemand komisches unfertiges meme tool
Committen würde für den microsoft store
Was nicht geht weil das ja keine keine uwp app ist
Ja wie das seriousmax schreibt ich hoffe du hast wenigstens dein bitcoin miner
Dein monero miner dein ethereal miner und dein was es da noch so alles gibt miner eingebaut
Und es hat eigentlich schon mal jemand versucht das müsste man jetzt mal machen
Man könnte man könnte doch einfach mal die android heizungsapp programmieren
Man sagt quasi die app macht dein android telefon so warm dass du keine heizung mehr
brauchst
Und dann brauchst du halt irgendwas was das warm macht und lässt du halt coins mine
Hand warmer free das gibt es ernsthaft allen ernst das
Nicht jetzt nicht der ernst oder
all
Weil es eine dumme idee gehabt und war klar dass das gibt
So gucken wir uns mal die absolut programmieren pro programmiertechnische meisterleistung
an hier
Heating may take a few minutes ja kommt auch an wie gut
Okay mal gucken wie sie das anpreisen
Okay der macht wenigstens kein geheimnis drum dass er einfach eine endlosschleife laufen
lässt oder so was
Was kein hoff schütz
Das phone von ihm ist kaputtgegangen
Okay es ist wenigstens kostenlos wie es aussieht kostet anscheinend nichts
Aber eigentlich wäre das doch eine super idee oder
Was sagt ihr dazu wir machen eine android app die halt die brauchen wir halt in super
text
Und dann bringen wir eine android app raus die für uns coins mine und die leute freuen
sich noch drüber dass sie für uns coins mine dürfen weil sie sich die hände an ihrem
handy wärmen können
Das machen wir
Ich hab noch bettel royal im namen vergessen ja das können wir auch noch nicht
Die app die ist ja die besteht ja im endeffekt wahrscheinlich dann bloß aus fünf zeilen
oder so
Die können wir dann auch noch in verschiedenen versionen rausbringen auch die bettel royal
edition
Die yoga edition
Was auch immer noch
Ach ja bei der gelegenheit
Ja so war das
Das ist das nächste projekt wenn wir hier fertig sind
Android app
Guck mal wie das program 360mb ran braucht
Für ein paar bilder
Lull
Spielst du noch bdo ich logge ich logge ein und hole daily rewards
Immersive heating experience
Oh das finde ich gut felix
Das ist der naja
Most immersive heating simulator ist das dann
Unsere android app
Aber es war klar das schlimme ist ja leute
Das war eine
Bescheuerte so bescheuerte gehirn furz den ich gerade hatte
Und das schlimme ist
Wir haben nachgeguckt und es gibt es wirklich
Und mich würde nicht wundern wenn diese ganzen heating apps tatsächlich um coins mine
oder sowas machen
Weil ich meine die leute schreien doch gerade danach so nach dem motto bitte überhitzt
mein mein android phone
Warum soll ich dann anstatt einfach eine endlosschleife laufen zu lassen nicht wenigstens
mal was ordentliches machen
Was mir was bringt
Und ich kann mich sogar noch mit rausreden
Ich kann mich sogar noch mit rausreden und sagen ja die die app war ja ich meine ich
hab die entwicklung quasi komplett komplett alleine getragen und die app ist ja auch kostenlos
Und dann ist es ja denke ich nur fair wenn ich dann auch ein bisschen ein bisschen was
abgekommen von den gemeinten coins
Kannst du dich noch mit rausreden
Ja genau mit achievements erreiche 120 grad
Okay leute machen wir Schluss
Also ich weiß nicht ich wusste nicht dass heute abend fußball ist
Dann streben wir wahrscheinlich nicht
Oder doch mal gucken ich weiß es nicht
Muss man schauen man fragt ob der fußball gucken will
Ich bin nicht so scharf drauf
Wir machen Schluss
Ich hoffe euch hat es gefallen
Machts gut bis zum nächsten mal
Tschüss
See you
Ja stimmt wir streamen einfach danach
Jo komm auch mal
Bis dann
