WEBVTT

00:00.000 --> 00:06.000
Siddi dit, dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit

00:06.000 --> 00:20.600
auoo åu

00:20.600 --> 00:49.600
Wir haben ja auch Quality Options, falls schon irgendjemand da ist, dann schreibt mal bitte was in den Chat, weil ich seh grad nichts.

00:49.600 --> 01:03.600
Und ich muss ja erstmal checken, dass alles funktioniert, bevor ich hier loslege und bis ich durchdrehen werde, weil wir irgendwie, warte mal sich, wie viele Zeilen in Assembler basteln müssen heute.

01:03.600 --> 01:10.600
Da hab ich ja schon Bock drauf, ey. Das wird grausam, Leute, ich sag's euch, das wird ganz schlimm.

01:10.600 --> 01:20.600
Vor allem, diese Art von Assembler, das ist ja nicht zu vergleichen, du kannst auf dieser Mini-CPU fast nichts machen.

01:20.600 --> 01:29.600
Also wenn das Stream dann mal richtig live ist, also nicht nur faked live zu sein, dann kann ich auch erzählen, was wir heute machen.

01:29.600 --> 01:42.600
Oh, tatsächlich, jetzt, jetzt, ja, ja, hallo Leute, also jetzt hat anscheinend Twitch es geschafft, die Benachrichtigung rauszuschicken, das ist doch schon mal toll.

01:42.600 --> 01:51.600
Ich warte noch mal, ich warte noch mal kurz, paar Minuten, weil, also irgendwie ist Twitch jedes Mal, jedes Mal wenn ich drauf komm anders kaputt.

01:51.600 --> 02:00.600
Wisst ihr übrigens, was mich an Twitch übelst, übelst nervt? Ich mein, es ist jetzt vielleicht ein bisschen so, beeist sich das, wenn ich quasi auf Twitch streame

02:00.600 --> 02:11.600
und jetzt als erstes mal erzähle im Stream, was mich auf Twitch nervt, aber rein aus, aus Viewersicht nervt mich eine Sache auf Twitch, Kirby halt mal kurz die Klappe.

02:11.600 --> 02:26.600
Aus Viewers und hier der Vogel muss auch mal weg, der Vogel muss weg, wo ist der Vogel? Easy. Also was mich als Viewer übelst nervt in der Zeit, auf Twitch ist

02:26.600 --> 02:32.600
und auf YouTube übrigens auch, es war nicht mal auf Twitch exklusiv, dass es so viel Werbung gibt.

02:32.600 --> 02:38.600
Habt ihr nicht auch das Gefühl, dass Twitch mittlerweile viel mehr Werbung hat als noch vor einem Jahr?

02:38.600 --> 02:47.600
Also mir kommt das so vor und YouTube auch, YouTube hat neuerdings doppelt, doppelt Werbung.

02:47.600 --> 02:55.600
Also vor YouTube Videos kriegst du doppelt Werbung. Habt ihr das auch? Das machst du ein YouTube Video auf und du kriegst nicht nur einmal Werbung,

02:55.600 --> 03:00.600
sondern du kriegst gleich zweimal Werbung hintereinander. Ganz, ganz merkwürdiges Zeug.

03:00.600 --> 03:10.600
Ja und es geht mir auf Twitch ehrlich gesagt ein bisschen auf den Keks, dass es so viel Werbung gibt und vor allem kriegst du auf Twitch mittlerweile wirklich bei, bei jedem Mist Werbung.

03:10.600 --> 03:20.600
Ich rede jetzt nicht auf dem Desktop, wenn man genau, genauso wie das der Online-Ritter gerade schreibt, ich rede jetzt nicht irgendwie auf dem Desktop,

03:20.600 --> 03:30.600
wo man einen Ad-Blocker hier installiert hat oder so, sondern ich rede auf dem iPhone zum Beispiel. Auf dem iPhone.

03:30.600 --> 03:37.600
Und auf dem iPhone musst du ja quasi mehr oder weniger die offizielle App verwenden, weil es gibt ja keine anderen Twitch Apps.

03:37.600 --> 03:47.600
Im Safari ist Twitch räudig. P-Haul regelt auf dem Handy. Ne, das funktioniert mit Twitch nicht. Oder funktioniert das bei dir?

03:47.600 --> 03:57.600
Interro. Also meines Wissens nach, und deswegen habe ich es auch mittlerweile nicht mehr, funktioniert P-Haul, das hört sich irgendwie schon, hört sich so ein bisschen verkehrt an,

03:57.600 --> 04:07.600
aber deswegen funktioniert hier P-Haul nicht auf Twitch, weil, also wie das Ganze funktioniert, ich meine vielleicht kennt das die eine oder andere,

04:07.600 --> 04:17.600
aber wer es nicht kennt, ich erzähle es mal kurz, das ist ein DNS-Server, der einfach alle möglichen Domains, die bekannt sind dafür Werbung zu verteilen, nicht auflöst.

04:17.600 --> 04:25.600
Von der Idee her ist das natürlich nicht schlecht. Twitch macht es allerdings mittlerweile relativ clever und verteilt die Werbung von Twitch.

04:25.600 --> 04:31.600
Und nicht von der extra Domain. Das heißt du kannst es nicht mehr blocken. YouTube macht es wahrscheinlich mittlerweile ähnlich.

04:31.600 --> 04:42.600
Zumindest du kannst auf dem iPhone oder auf dem iPad kannst du nur die offizielle App verwenden, was halt ein bisschen doof ist, weil da kannst du die Werbung nicht ausschalten.

04:42.600 --> 04:48.600
Und ich habe ja gar nichts dagegen, wenn manche Leute im Stream ein bisschen Werbung laufen lassen, oder wenn ab und zu mal ein bisschen Werbung kommt,

04:48.600 --> 04:55.600
wo es mich halt nervt, ist einmal wenn man pennt dabei, ich mache öfters mal einen Stream an, und dann penne ich ein und dann geht auf einmal die Werbung los.

04:55.600 --> 05:05.600
Ich meine die Lautstärke ist natürlich auch schon viel lauter wieder bei der Werbung App als bei dem, wenn du dir irgendwie einen Streamer anguckst,

05:05.600 --> 05:10.600
der entspannt sitzt und irgendwas spielt. Ich gucke mir meistens gerne so ein bisschen ältere Games an, so irgendwelche.

05:10.600 --> 05:17.600
Zum Beispiel was ich mir ganz gerne angucke sind so Link to the Past, Randomizer Turniere oder sowas. Das ist eigentlich super entspannt.

05:17.600 --> 05:25.600
Ja da sitzt einer oder labern dazu, das ist relativ ruhig und dann geht auf einmal, schaltet Twitch auf einmal auf die Werbung um,

05:25.600 --> 05:33.600
und da musst du dir dann irgendwie das neue Clean Shave sonst was in übelster Lautstärke anhören. Das ist doof, wirklich doof.

05:33.600 --> 05:43.600
Und du kannst das nicht überspringen. Pyhall hilft dir nix, weil es DNS, weil DNS-Blocken nix mehr bringt auf Twitch und Ad-Blocker für die mobile Twitch App gibt es nix.

05:43.600 --> 05:54.600
Ist nervig. Genauso wisst ihr was mich auch übelst, übelst aufregt ist YouTube App Pop-Up. Das hier. Weiß ich ob es da ein Bild zu gibt.

05:54.600 --> 06:14.600
Trial Pop-Up? Ey Leute, wie mir dieses Pop-Up auf den Sack geht. Ey das geht mir mega auf den Keks. Ja genau, Akenas.

06:14.600 --> 06:27.600
Immer wenn man sich guckt, der Akenas will sich jetzt Bob Ross angucken, liegt dann, was weiß ich, abends im Bett, will mal pennen, denkt, achja gut, jetzt noch mal eine Runde Happy Little Trees und hier den, wie macht der immer?

06:27.600 --> 06:38.600
Moment, ich krieg das mit dem Finger nicht hin. So, der Devil. War doch ziemlich original, oder? Leute, so gehört sich das ja immer an.

06:38.600 --> 06:51.600
Und da kommt auf einmal irgendwie eine kack Werbung. Und ich hab nix dagegen, dass ab und zu Werbung läuft, allerdings manchmal ist es wirklich sehr nervig.

06:51.600 --> 06:57.600
Und vor allem auf dem iPhone, wo du nix machen kannst. So und dieses Pop-Up geht mir auch richtig auf den Keks auf YouTube.

06:57.600 --> 07:10.600
Und es ist nicht so, dass es reichen würde, dass du das mal wegklickst. Das kommt gefühlt quasi jedesmal, wenn du die App aufmachst und jedesmal, wenn du das Video switchst.

07:10.600 --> 07:19.600
Deswegen, was du in Assembler programmierst, ja ich warte jetzt bis der Stream richtig live ist. Das ist ja, ist ja gerade erst angegangen, dann erzähl ich gleich, was wir machen.

07:19.600 --> 07:28.600
Ich weiß nicht, ob ich das überhaupt im Kopf aushalte, heute so viel Assembler-Gramm. Also ich vergesse, was ich sagen wollte.

07:28.600 --> 07:34.600
Ja genau, wie gesagt, ich hab nix dagegen, aber man kann ja im Prinzip nix dagegen machen, vor allem auf dem iPhone.

07:34.600 --> 07:39.600
Und deswegen hab ich mir überlegt, und da hab ich gestern mal geguckt, ob es nicht irgendwelche Proxy-Lösungen gibt.

07:39.600 --> 07:51.600
Also sprich, wo man sein ganzes HTTP-Zeug dann drüberleitet und das für einen die Werbung rausfiltert. Hab ich ein paar Sachen gefunden, wo ich mal auspumpt, ob das Ganze funktioniert.

07:51.600 --> 07:54.600
Wird schwierig, ich meine letztendlich geht es über HTTPS.

07:58.600 --> 08:02.600
Ich weiß nicht, was ich hier für ein Textdokument auf hab. Weiß nicht, ob ich euch das zeigen kann. Oh, reveal.

08:05.600 --> 08:06.600
Boah, das war schlecht, oder?

08:06.600 --> 08:07.600
Ja.

08:09.600 --> 08:14.600
Mittlerweile subscriben? Nein, und ich kann mich als auch nicht mehr bewerben, weil ich jetzt irgendwie drei Monate oder so nicht mehr gestrebt hab.

08:14.600 --> 08:17.600
Und deswegen jetzt mein Partnerbewerbungsstell nicht mehr funktioniert.

08:18.600 --> 08:27.600
So, also, ich guck mal kurz, ob ich irgendwas im Chat überlesen hab. Und falls nicht, dann fangen wir jetzt gleich an.

08:27.600 --> 08:48.600
Ne, ich hab nichts übersehen. Also, was wir heute machen. Lautstärke passt, denke ich, ganz gut von Geschwätze und von Musik.

08:48.600 --> 09:17.600
Also, was wir heute machen. Ihr wisst ja, dass ich, ich mach doch irgendwann mal ein Stream oder ein Video zu, dass ich bei mir ziemlich viel in Richtung Heimautomatisierung und Sachen, die drum herum dazugehören.

09:17.600 --> 09:25.600
Bei mir daheim aber aufrüsten bin. Und ich hab ja schon ein paar Raspberries rum, es steht auch ein paar Raspberry Zeros.

09:25.600 --> 09:40.600
Ich hab auch schon die ein oder anderen Microcontrollers rumhängen, die beispielsweise den Wasserstand von den Blumen auf dem Balkon und auf dem Beet im Hof messen.

09:40.600 --> 09:51.600
Und das ist so ein billig China-Bodenfeuchtigkeits-Bluetooth-Messer ist das und da hängt an der Tür so ein Ding, was das ganze Bluthoos abfragt. Und so und so Dinge.

09:51.600 --> 10:06.600
So, und zumindest, ja, SilentPain, du hast recht, wenn ich auf Android wäre, also ich hab ja im Prinzip nur Android-Tablets, allerdings, Smartphone ist halt ein iPhone, dann würd ich auch ne andere YouTube-App nehmen.

10:06.600 --> 10:22.600
So, und aktuell versuch ich noch zwei Sachen. Ich versuch nen Schalter zu basteln, den ich ans Hoftor machen kann, wo mir das dann beim Öffnen Bescheid sagt.

10:22.600 --> 10:34.600
Das ist, aber das machen wir heute nicht. Was wir heute machen ist, und da muss ich jetzt ein bisschen weiter ausholen, wozu das ganze da sein soll, weil ich muss mal kurz in mich gehen.

10:34.600 --> 10:45.600
Ich weiß gar nicht, ob ich das überhaupt erklären muss, ob man das versteht, ne, das erzähl ich, wenn wir dann dabei sind, das ist sonst zu viel Geschwätze davor.

10:45.600 --> 11:04.600
Zumindest, ich hab hier ne ganze Reihe ESP32 und ESP, ach lass mir das nicht, 2866, kann man immer nicht die Reihenfolge merken, wie der Krempel heißt. Genau, rumliegen. Und aktuell hab ich hier so einen.

11:04.600 --> 11:21.600
Zum Testen hier gerade hier nebendran liegen. Aber ich hab mir ne ganze Reihe in China gekauft. Und, ähm, mal zur Erklärung für jemand, der sowas noch nicht in der Hand hatte, weil bei mir ist es auch noch nicht so lange her, dass ich mit dem ganzen Krams angefangen hab.

11:21.600 --> 11:36.600
Ähm, das sieht zwar auf den ersten Blick aus wie ne, wie ne Raspberry Pi. Zero ist es allerdings nicht. Es ist ungefähr so groß wie ne Pi Zero. Allerdings läuft da drauf kein Linux.

11:36.600 --> 11:51.600
Da drauf läuft im Prinzip, also bis auf ein paar ganz kleine Ausnahmen läuft da nichts drauf, außer was man draufflasht. Das heißt, man muss das wirklich so ganz roh programmieren, draufflaschen und dann macht er was man will.

11:51.600 --> 12:07.600
Ähm, die Dinger haben jede Menge IOs, also ich glaub sogar mehr als so ein Raspberry IOs hat. Und ich hab mir einen Bodenfeuchtigkeitssensor gekauft. Und den versuchen wir heute mal auszulesen.

12:07.600 --> 12:21.600
Allerdings nicht so einfach. Wo ist es im Moment? Den da hab ich mir gekauft, genau. Das ist so ein Ding, da musst du hier oben, musst du was drüber pappen und das hier unten stöpselst du dann in den Boden.

12:21.600 --> 12:35.600
Und dann kannst du messen quasi wie die Bodenfeuchtigkeit ist. Eher wie ein Arduino, genau. Klapperrottel. Das ist auch Arduino kompatibel das Ding. Also wir werden auch Arduino als Framework nehmen.

12:35.600 --> 12:42.600
Allerdings, und jetzt kommen wir zum eigentlichen Punkt, warum Assembler im Titel drinne steht. Ich will das Ganze natürlich nicht so Noobstyle machen, ja.

12:42.600 --> 13:05.600
Sondern ich will das ordentlich machen. Also sprich, das Ding soll, wenn es nichts tut, schlafen, dass es nicht so viel Strom verbraucht. Ich hab so, ich plan das auch an eine Batterie zu machen. So eine ganz normale 1200 oder 2000 mAh LiPo Batterie, so eine kleine.

13:05.600 --> 13:15.600
Und das heißt, das Ding muss wirklich wenig, wenig Strom verbrauchen. So, und das geht nur, wenn man das Ding in, den hab ich hier am Start, genau. Wenn man das Ding ins Leap schickt.

13:15.600 --> 13:32.600
Ich hab, für den niedrigen Energieverbrauch hab ich noch ein anderes Board. Das ist jetzt nur mal zum Ausprobieren. Und was halt Strom braucht, ist das Übertragen von, also erstmal überhaupt an sein verbraucht viel Strom.

13:32.600 --> 13:41.600
Und was richtig viel Strom verbraucht, also viel, in Form von Batteriebetrieb viel. Also sprich, wenn das Ding ein Jahr laufen soll, kannst du es halt nicht ein Jahr durchgängig laufen lassen.

13:41.600 --> 13:48.600
Und dann musst du schlafen legen und kannst es einmal die Stunde aufwecken. So, und jetzt kommt der Witz. Und das ist das, warum Assembler im Titel steht.

13:48.600 --> 14:04.600
Ähm, richtig pro wärs natürlich, wenn das Ding den Wasserstand messen könnte, also den Boden, die Bodenfeuchtigkeit messen könnte, ohne, dass die Haupt-CPU aktiv sein muss.

14:04.600 --> 14:11.600
Sondern quasi aus dem Deep Sleep raus. Ich hoffe, das hat man jetzt verstanden. Und das Tolle ist hier an diesem, an diesem Microcontroller.

14:11.600 --> 14:23.600
Das hat viel mehr als so ein, als auch vor ein paar Jahren eigentlich auf so einem Board drauf war. Ähm, das Ding hat verschiedene, verschiedene Kerne.

14:23.600 --> 14:36.600
Das Ding hat, also hier der da, genau. Also das Ding hat verschiedene Kerne. Das hat zwei 32-Bit-CPUs, Kerne.

14:36.600 --> 14:49.600
Ähm, ich glaub mit 240 Mhz, so irgendwie in dem Dreh. Und dazu kommt, es hat hier unten einen Ultra Low Power Co-Prozessor.

14:49.600 --> 14:59.600
So, und dieses Ding kann man nicht irgendwie etwa mit dem Standard Arduino Framework oder hier irgendwie in C programmieren.

14:59.600 --> 15:08.600
Diesen Scheiß muss man in Assembler programmieren, dass er das macht, was man will. Und, das wird, das wird was ey.

15:08.600 --> 15:15.600
Ich hab mir schon was rausgesucht. Ich bin nicht, ich bin nicht ganz planlos. Ich hab schon im Vorfeld ein bisschen nachgeguckt, wie das, wie das so funktioniert.

15:15.600 --> 15:23.600
Man muss auch nicht wirklich alles von Hand machen. Man kann ein paar C-Macros verwenden dafür.

15:23.600 --> 15:35.600
Aber im Prinzip ist es, im Prinzip sind es Assembler Befehle. Und jetzt passen wir auf, ähm, Instructions Set.

15:35.600 --> 15:48.600
Das Ding hat, ähm, acht Befehle. Acht, acht, ähm, wie nennt man das? Acht Instructions, verschiedene.

15:48.600 --> 15:58.600
Das Ding, also dieser, das ist alles. Das ist alles. Das ist alle, alle, alle, quasi eingebauten Microcode,

15:58.600 --> 16:05.600
sonst was Befehle, die, die diese Ultra Low Power CPU kann. Das ist, das ist quasi nix im Endeffekt.

16:05.600 --> 16:12.600
Ich hab keine Ahnung, wie viel, wie viel Befehle so ein aktueller X86, 64 Dings an CPU hat.

16:12.600 --> 16:20.600
Wahrscheinlich 50.000 oder so. Ich hab gar nicht gesagt, keine Ahnung. Ähm, zumindest acht ist wenig.

16:20.600 --> 16:26.600
Und das ist auch sehr, sehr unadvanced, was das Ding kann, ja.

16:26.600 --> 16:31.600
Machst du es mit Inline Assembler in C. Also es gibt zwei, zwei Varianten, wie man das Ganze machen kann.

16:31.600 --> 16:42.600
Ähm, man macht es entweder in einem eigenen Assembler File und lässt es dann in, in, quasi beim Kompilieren,

16:42.600 --> 16:47.600
so mit rein linken, irgendwie. Oder man macht das quasi mit C-Macros.

16:47.600 --> 16:51.600
So, so richtig Inline Assembler unterstützt der ganze Kram, nicht?

16:51.600 --> 16:56.600
Frag mich nicht warum, aber wir, wir versuchen mal die Variante mit C-Macros.

16:56.600 --> 17:03.600
Weil das Schöne ist, die Variante mit C-Macros geht hier ganz gut aus der Entwicklungsumgebung raus.

17:03.600 --> 17:10.600
Die Variante mit, mit, äh, mit Assembler Files braucht ein bisschen gefuddelt drum herum.

17:10.600 --> 17:16.600
So, ähm, genau, jetzt noch ein bisschen, bisschen mehr dazu, weil ich seh schon die ersten Fragen im Chat.

17:16.600 --> 17:21.600
Also, so einfach ist es natürlich nicht. Also, nochmal, nochmal was anderes.

17:21.600 --> 17:27.600
Das Schöne hieran ist, an diesem Ultra Low Power Core Prozessor, der ist aktiv.

17:27.600 --> 17:34.600
Alle, kann man einstellen, ich sag mal alle, keine Ahnung, alle 30 Minuten, sagen wir jetzt mal, wacht er auf.

17:34.600 --> 17:43.600
Ohne dass halt die Hauptkerne aufwachen müssen. Das bedeutet, ähm, also wir reden hier von Stromverbrauch ungefähr.

17:43.600 --> 17:57.600
Das Ding, so ein ESP32, braucht ungefähr, ähm, wenn er über WLAN was überträgt, so ungefähr 150mA.

17:57.600 --> 18:07.600
Und, wenn er einfach nur an ist, so um die 50mA, und wenn er im Deep Sleep ist und man das passende Board hat,

18:07.600 --> 18:17.600
ungefähr 10mA. Also, das ist wirklich verdammt wenig. Das heißt, man tut guter dran, möglichst lange die Hauptkerne im Sleep zu lassen.

18:17.600 --> 18:24.600
Ja, und dieser Ultra Low Power Prozessor braucht glaube ich irgendwie 2 oder 3mA für die ganz kurze Zeit, wo er aktiv ist.

18:24.600 --> 18:33.600
Der schläft dann auch immer 30 Minuten. So, ähm, deswegen ist das Ziel, den Sensor abzufragen,

18:33.600 --> 18:39.600
mit dem Ultra Low Power Prozessor dann zu vergleichen. Das ist ja noch nicht so einfach, ja.

18:39.600 --> 18:42.600
Ich glaube nicht, dass wir das heute gebacken kriegen, alles komplett.

18:42.600 --> 18:49.600
Ähm, dann muss der den letzten Wert, den er gemessen hat, mit dem aktuellen Wert vergleichen.

18:49.600 --> 18:52.600
Also, ich erzähle mal so, was ich mir so gedacht habe, wie man das machen könnte.

18:52.600 --> 18:57.600
Und nur, wenn der Wert über einen gewissen, gewissen Schwellwert abweicht.

18:57.600 --> 19:06.600
Also, sag mal mal so, wenn der aktuelle gelesene Wert, sag mal mal, 100, 100 größer ist als der zuletzt gelesene Wert,

19:06.600 --> 19:11.600
nur dann weckt er die Hauptkerne auf und nur dann wird das Ganze per WLAN übertragen.

19:11.600 --> 19:16.600
Weil viel Strom verbraucht einmal, wenn eben die Haupt-CPU läuft.

19:16.600 --> 19:20.600
Und was richtig viel Strom verbraucht, ist, wenn das Ding per WLAN Daten schicken muss.

19:20.600 --> 19:25.600
Also, da reden wir von, keine Ahnung, 15.000x mehr Stromverbrauch.

19:25.600 --> 19:27.600
Und das ist an sich nicht viel.

19:27.600 --> 19:31.600
Das ist immer noch insgesamt, selbst wenn der einfach nur läuft und nichts macht,

19:31.600 --> 19:35.600
ist es immer noch viel, viel, viel, viel, viel sparsamer als beispielsweise den Raspberry Pi Zero.

19:35.600 --> 19:40.600
Allerdings, an der Batterie kann man nicht sparsam genug sein.

19:40.600 --> 19:42.600
Hat man das jetzt verstanden?

19:47.600 --> 19:52.600
Äh, Kappa-Rottel, das bin ich noch am überlegen.

19:52.600 --> 19:57.600
Aktuell will ich jetzt erst mal gucken, wie man diesen Low-Power-Prozessor programmieren kann.

19:59.600 --> 20:03.600
So, und als erstes, was wir als erstes machen, wir legen hier mal ein neues Projekt an.

20:03.600 --> 20:07.600
Und ich habe leider mein einziges Wasserglas hier jetzt stehen,

20:07.600 --> 20:12.600
mit Wasser drin, wo der Bodenfeuchtigkeitssensor drin hängt.

20:12.600 --> 20:15.600
Das heißt, es kann sein, dass ich gleich mal runtergehen muss, was zu trinken holen.

20:15.600 --> 20:18.600
Ich habe jetzt bloß noch hier halbe Tasse Tee.

20:18.600 --> 20:23.600
So, wir legen jetzt mal ein neues Projekt an.

20:23.600 --> 20:28.600
Und was wir als erstes machen, ist, wir lesen auf ganz traditionelle Art und Weise,

20:28.600 --> 20:30.600
also ohne Ultra-Low-Power, sonst was.

20:30.600 --> 20:36.600
Einfach auf dem Main-Core lesen wir einfach mal den Bodenfeuchtigkeitssensor aus

20:36.600 --> 20:38.600
und gucken, was da für Werte rauskommen.

20:38.600 --> 20:40.600
Also, ein neues Projekt.

20:40.600 --> 20:49.600
Dann werden wir mal irgendwie streamtest. Dort habe ich eine NodeMCU32S.

20:49.600 --> 20:55.600
Wir nehmen als Framework das ganz normale Arduino-Framework, da ist alles schön dabei, was man so braucht.

20:55.600 --> 21:00.600
Das ESP-IDF ist das offizielle Framework vom Hersteller, das sind irgendwelche Chinesen.

21:00.600 --> 21:04.600
Max baut sich einen automatisierten Hanfgarten.

21:04.600 --> 21:09.600
Die Möglichkeiten sind theoretisch ziemlich unbegrenzt.

21:09.600 --> 21:13.600
Ich erzähle euch gleich noch, wofür ich es eigentlich verwenden will.

21:13.600 --> 21:17.600
Das hat nichts mit einem automatisierten Hanfgarten zu tun.

21:17.600 --> 21:20.600
Das hat, finde ich, einen recht praktischen Sinn.

21:20.600 --> 21:24.600
Kann ich das jetzt mal anlegen hier?

21:24.600 --> 21:26.600
Aktuell mache ich es nämlich so.

21:26.600 --> 21:31.600
Da habe ich bei mir im Hof und auf der Terrasse die Dinger stehen.

21:31.600 --> 21:37.600
Das sind China Bodenfeuchtigkeits-Messensoren.

21:37.600 --> 21:45.600
Die können Nährstoffe im Boden messen, Leitfähigkeit, also sprich, wie viel Wasser im Boden ist, Licht und Temperatur.

21:45.600 --> 21:49.600
Allerdings, ich bin nur interessiert an der Bodenfeuchtigkeit.

21:49.600 --> 21:56.600
Und für so einen habe ich schon so einen ESP32, unten neben der Tür hängen, der per Bluetooth die Dinger abfragt.

21:56.600 --> 21:59.600
Allerdings, ich erzähle euch gleich, was ich genau machen will.

21:59.600 --> 22:11.600
Open.

22:11.600 --> 22:14.600
Ach da, da ist es schon.

22:14.600 --> 22:18.600
Also, wir lesen jetzt diesen Sensor mal aus.

22:18.600 --> 22:21.600
Ohne irgendwelche Sperenzen, einfach nur auslesen.

22:21.600 --> 22:28.600
Das erste, was man immer machen muss, ist erst mal, das ist ziemlich raw heute, das ist ziemlich low-level shit.

22:28.600 --> 22:30.600
Ich erzähle euch gleich schon.

22:30.600 --> 22:34.600
Da ist nichts mit Konsole, Printline oder, nein, das ist jetzt ein doofes Beispiel.

22:34.600 --> 22:37.600
Konsole, Printline gibt es da auch.

22:37.600 --> 22:43.600
Aber da ist nichts mit irgendwelchen dynamischen Listen oder sonst was.

22:43.600 --> 22:45.600
Das ist ziemlich, ziemlich raw.

22:45.600 --> 22:51.600
Und deswegen nehmen wir auch hier das Standard Arduino-Framework, weil da schon viele Sachen dabei sind, die wirklich sehr angenehm sind.

22:51.600 --> 22:54.600
So, als erstes müssen wir mal unsere serielle Schnittstelle.

22:54.600 --> 22:58.600
Ja, und das habt ihr richtig gehört, unsere serielle Schnittstelle initialisieren.

22:58.600 --> 23:05.600
Standardmäßig waren wir mit 9600, was ist das, Weiß pro Sekunde, Kilobits pro Sekunde.

23:05.600 --> 23:11.600
Ich habe ehrlich gesagt keine Ahnung.

23:11.600 --> 23:14.600
Ist auch egal, es ist langsam auf jeden Fall.

23:14.600 --> 23:18.600
Also, wir müssen erst mal unsere serielle Schnittstelle initialisieren.

23:18.600 --> 23:27.600
Und dann können wir hier in der Main Loop, oder wie auch immer man das nennt, geben wir einfach mal was aus.

23:27.600 --> 23:36.600
Also hier, serielle, Printline, hallo, Tremsor.

23:36.600 --> 23:40.600
Und jetzt, nachdem das Ding, das muss ich jetzt vielleicht auch nochmal erklären.

23:40.600 --> 23:43.600
Das Ding ist halt, da ist kein Betriebssystem drunter oder sowas.

23:43.600 --> 23:50.600
Das, was wir hier programmieren, wird kompiliert und dort als Firmware auf den internen Flash-Speicher geflasht.

23:50.600 --> 23:54.600
Von diesem Teil.

23:54.600 --> 23:57.600
Das hier, ich glaube, hier vorne wird der Flash sein, keine Ahnung.

23:57.600 --> 24:07.600
Und das hat, glaube ich, auch nur 8 Kilobyte Flash für persistente Geschichten.

24:07.600 --> 24:12.600
Also, das ist nicht so groß.

24:12.600 --> 24:18.600
Dementsprechend, da läuft kein Betriebssystem oder sonst was in der Richtung drunter.

24:18.600 --> 24:27.600
Das heißt, alles, was ich hier reinschreibe, wird direkt und genauso, wie ich es reinschreibe, ausgeführt.

24:27.600 --> 24:36.600
Das heißt, ich muss hier auch selbst irgendwie dafür sorgen, dass die Dinger im richtigen Intervall laufen, im richtigen Timing laufen und sonstige Dinge.

24:36.600 --> 24:38.600
Das ist jetzt auch noch relativ einfach.

24:38.600 --> 24:46.600
Wenn ich das jetzt mal ausführe und uploade, also sprich, der kompiliert das jetzt und flasht das jetzt hier über USB, über die serielle Schnittstelle.

24:46.600 --> 24:48.600
Das emuliert halt serielle Schnittstelle über USB.

24:48.600 --> 24:54.600
Das flasht das jetzt über die serielle Schnittstelle auf den ESP32.

24:54.600 --> 24:57.600
Und jetzt kann ich mir angucken, was das Ding macht.

24:57.600 --> 25:01.600
Der sagt jetzt halt nichts großartig mehr, außer, hallo, extrem.

25:01.600 --> 25:05.600
Ich glaube mal, ich mache die Konsolenschrift ein bisschen größer, oder?

25:05.600 --> 25:07.600
Bisschen klein, oder?

25:07.600 --> 25:09.600
Also Schriftgröße hier oben ist denke ich mal gut, oder?

25:09.600 --> 25:12.600
Also hier unten könnte ich vielleicht schon ein bisschen größer machen.

25:12.600 --> 25:14.600
Oder passt das?

25:14.600 --> 25:16.600
Genau.

25:16.600 --> 25:17.600
Hexor.

25:17.600 --> 25:19.600
Ähnlich war Low Level.

25:23.600 --> 25:25.600
So, aktuell habe ich es so gemacht.

25:25.600 --> 25:27.600
Ähm.

25:27.600 --> 25:32.600
Ich habe es so gemacht, wie wahrscheinlich jeder Elektriker sagen würde, man darf es nicht machen.

25:32.600 --> 25:38.600
Ich zeige euch mal kurz den Sensor.

25:38.600 --> 25:40.600
The Moisture Sensor.

25:40.600 --> 25:41.600
Ähm.

25:41.600 --> 25:47.600
1.2.

25:47.600 --> 25:50.600
Also, dieser Sensor sieht folgendermaßen aus.

25:50.600 --> 25:51.600
Genau das ist er.

25:51.600 --> 25:54.600
Also etwas bessere Auflösung RL als hier.

25:54.600 --> 25:55.600
Ähm.

25:55.600 --> 25:57.600
Ich würde das Bild gerne...

25:57.600 --> 26:00.600
Was ist das für eine Seite, die ich da aufgemacht habe?

26:00.600 --> 26:04.600
Ich würde einfach nur das Bild aufmachen.

26:04.600 --> 26:07.600
Wer weiß, was das für komische Seiten wir da sind.

26:07.600 --> 26:09.600
Ähm.

26:09.600 --> 26:13.600
Adresse des Bilds kopieren, okay.

26:13.600 --> 26:18.600
Kann ich mal das Bild aufmachen?

26:18.600 --> 26:21.600
Ich will euch das Ding noch mal groß öffnen.

26:21.600 --> 26:23.600
Ah ja gut, hier sieht man es ganz schön.

26:23.600 --> 26:26.600
Also genau, das sind die Pins von dem Teil.

26:26.600 --> 26:27.600
Wir haben einmal hier.

26:27.600 --> 26:31.600
Ich mache nebenan noch einen ESP.

26:31.600 --> 26:34.600
Ich mache hier nebenbei noch mal den Controller auf, dass ihr das auch sehen könnt.

26:34.600 --> 26:40.600
Da kann ich euch erzählen, wie das Ganze angeschlossen ist.

26:40.600 --> 26:45.600
Mal gucken, ob ich jetzt auf der ordentlichen Seite rauskomme.

26:45.600 --> 26:46.600
Pin.

26:46.600 --> 26:50.600
Pin out.

26:50.600 --> 26:55.600
Ja, hier sieht man es ganz gut.

26:55.600 --> 26:59.600
Also Dankeschön für die Follows.

26:59.600 --> 27:01.600
Das sehe ich irgendwie gerade nicht.

27:01.600 --> 27:03.600
Aber es ist nice, dass ihr dabei seid.

27:03.600 --> 27:07.600
Da ist gerade 140 Leute zugucken, wo ich ja mal meinen Microcontroller rumbastele.

27:07.600 --> 27:08.600
Wieder heftig.

27:08.600 --> 27:10.600
Also das ist der Sensor.

27:10.600 --> 27:14.600
Und ähm.

27:14.600 --> 27:16.600
Silent Pain ist das Analog.

27:16.600 --> 27:18.600
Also das Ding hat folgende Pins.

27:18.600 --> 27:21.600
Das hat 3,3 Volt in.

27:21.600 --> 27:24.600
3,3 bis 5 Volt in.

27:24.600 --> 27:30.600
Ground und ein Analog Output.

27:30.600 --> 27:33.600
So und angeschlossen ist es aktuell folgendermaßen.

27:33.600 --> 27:36.600
Das ist angeschlossen am 3,3 Volt Pin.

27:36.600 --> 27:37.600
Logisch.

27:37.600 --> 27:38.600
Damit.

27:38.600 --> 27:42.600
VCC ist am 3,3 Volt Pin dran.

27:42.600 --> 27:46.600
Analog Out ist an GPIO 34 dran.

27:46.600 --> 27:49.600
Da.

27:49.600 --> 27:52.600
Und jetzt kommt das, wo wahrscheinlich jeder Elektriker schreien wird.

27:52.600 --> 28:05.600
Ground ist nicht etwa an Ground dran, sondern an GPIO 27.

28:05.600 --> 28:08.600
Also da.

28:08.600 --> 28:14.600
So und das hat den folgenden Hintergrund, dass ich das Ding nämlich ausschalten kann.

28:14.600 --> 28:20.600
Ansonsten bräuchte ich irgendeinen Transistor oder irgendeinen Schalter oder sowas.

28:20.600 --> 28:23.600
Das ist allerdings nicht so wild in der Stelle.

28:23.600 --> 28:39.600
Der Sensor braucht höchstens laut Datenblatt 5 mA und die ESP32 GPIO Pins dürfen bis 20.

28:39.600 --> 28:45.600
Also wir werden es überleben.

28:45.600 --> 28:47.600
Da muss ein Transistor dazwischen.

28:47.600 --> 28:50.600
Es ist jetzt nicht so, dass ich es gerade schon gesagt hätte, oder?

28:50.600 --> 28:53.600
Dass da eigentlich ein Transistor dazwischen muss.

28:53.600 --> 28:55.600
Zumindest so ist das Ganze gerade angeschlossen.

28:55.600 --> 28:58.600
Das heißt prinzipiell funktioniert es.

28:58.600 --> 29:03.600
Es hat halt den riesen Vorteil, dass ich mir was bestellen muss, dass ich jetzt ausprobieren kann.

29:03.600 --> 29:06.600
Und dass ich das Ding ein- und ausschalten kann.

29:06.600 --> 29:11.600
Weil auch 5 mA im Deep Sleep sind 5 mA zu viel.

29:11.600 --> 29:15.600
Und wozu soll das Ding Strom verbrauchen, wenn ich es eh nicht abfragen will.

29:15.600 --> 29:19.600
So und das erste was wir jetzt machen, wir fragen jetzt mal den Sensor ab.

29:19.600 --> 29:24.600
So als erstes muss ich hier mal, nehme ich noch was ein, nehme ich meine Pins.

29:24.600 --> 29:26.600
Arduino Pins.

29:26.600 --> 29:30.600
Das sind die Definitionen für mein Board.

29:30.600 --> 29:35.600
Also sprich, wie die Pins belegt sind.

29:35.600 --> 29:40.600
Also sprich, da muss ich nicht jedes Mal auf das Board gucken, sondern kann einfach den Namen vom Pin eingeben.

29:40.600 --> 29:43.600
Das ist eigentlich ganz praktisch.

29:43.600 --> 29:47.600
So.

29:47.600 --> 29:49.600
Cianox, Dankeschön, nice.

29:49.600 --> 29:54.600
Oh, wird geradet mit 19 Leuten, krasser Shit.

29:54.600 --> 30:04.600
So, genau, wo bin ich jetzt stehen geblieben?

30:04.600 --> 30:07.600
Ich wollte...

30:07.600 --> 30:09.600
Genau, wir wollten jetzt einfach mal den Sensor auslesen.

30:09.600 --> 30:13.600
Das heißt, als erstes müssen wir uns mal überlegen, was brauchen wir für einen Pin.

30:13.600 --> 30:21.600
Wir brauchen GPIO 34 und GPIO 27.

30:21.600 --> 30:24.600
27 ist der Ein- und Ausschalter.

30:24.600 --> 30:29.600
Und GPIO 34 ist der Input für das analoge Signal.

30:29.600 --> 30:41.600
Das heißt, wir probieren jetzt erstmal ganz billig, einfach zu sagen, Analog Read auf GPIO 34.

30:41.600 --> 30:43.600
Wenn ich jetzt noch richtig schreiben könnte, wäre es schon mal ganz nice.

30:43.600 --> 30:45.600
Und wir gucken mal, was da rauskommt.

30:45.600 --> 30:51.600
Ich vermute mal nicht allzu viel Sinnvolles, weil wir haben das Ding ja weder richtig ein- noch richtig ausgeschaltet.

30:51.600 --> 30:56.600
Wir haben mit dem Ding gar nichts gemacht. Mal gucken, was rauskommt.

30:56.600 --> 31:02.600
Wahrscheinlich das Maximum, was man so lesen kann von so einem GPIO.

31:02.600 --> 31:04.600
Ja, das...

31:04.600 --> 31:08.600
Also, wie erwartet, der Wert ergibt nicht wirklich Sinn.

31:08.600 --> 31:12.600
Das steckt übrigens gerade im Wasserglas, der Sensor.

31:12.600 --> 31:16.600
Cheat 195, bin ich schon zu spät? Nee, nee, wir fangen gerade an.

31:16.600 --> 31:23.600
So, und damit das Ganze funktioniert, muss ich erstmal meinen Schalter, nämlich das in dem Fall GPIO 27,

31:23.600 --> 31:27.600
muss ich erstmal auf Output stellen, also sprich...

31:27.600 --> 31:33.600
Naja, auf Output, das ist eigentlich relativ selbsterklärend an der Stelle.

31:33.600 --> 31:37.600
Und danach will ich das Ding einschalten.

31:37.600 --> 31:41.600
Also, setzen wir das Ding auf Low.

31:41.600 --> 31:44.600
Ich weiß, der Elektriker schreit, das hatten wir ja schon.

31:44.600 --> 31:48.600
So, und jetzt sollte das- oh nee, Moment, das sollte ich im Setup machen und nicht hier in der Schleife.

31:48.600 --> 31:50.600
Total beknackt ist da unten drin.

31:50.600 --> 31:54.600
Meine Corsair-Tastatur, Leute, ne?

31:54.600 --> 31:59.600
Aber ihr seht schon, dass das vom Sensor, die Ergebnisse vom Sensor, ergeben jetzt viel mehr Sinn.

31:59.600 --> 32:04.600
So, und als erstes, was wir jetzt machen müssen, wir müssen den Sensor mal irgendwie halbwegs kalibrieren.

32:04.600 --> 32:07.600
Und jetzt, ihr habt's hier gesehen, dass es doppelt eingefügt wurde.

32:07.600 --> 32:10.600
Das liegt an meiner kack Corsair-Tastatur.

32:10.600 --> 32:14.600
Ich hab das Ding halt vor der Weile schon angepriesen.

32:14.600 --> 32:19.600
Was macht so ein Propeller?

32:19.600 --> 32:24.600
Was für ein Propeller?

32:24.600 --> 32:32.600
Ne, Propeller?

32:32.600 --> 32:36.600
Naja, zumindest, die Tastatur hat seit neuestem doppelte Anschläge.

32:36.600 --> 32:39.600
Wenn ich was einfüge, kann es sein, dass es zweimal einfügt.

32:39.600 --> 32:46.600
Was beim Spiel nicht so auffällt, aber ansonsten einfach abartig nervig ist.

32:46.600 --> 32:50.600
So, flashen wir das Ganze nochmal.

32:50.600 --> 32:55.600
Also, was das Ding jetzt macht, und das ist bei allen Arduino-Boards gleich.

32:55.600 --> 33:01.600
Einmal, nachdem sich der Controller startet, wird das hier im Setup ausgeführt.

33:01.600 --> 33:06.600
Und danach wird einfach in einer Schleife immer das hier aufgerufen.

33:06.600 --> 33:11.600
Also eigentlich ist das hier nicht die Loop, die Benamung ist ein bisschen doof.

33:11.600 --> 33:17.600
Sondern das hier, was in der Loop-Funktion drinne steht, wird einfach immer wieder aufgerufen.

33:17.600 --> 33:19.600
Sobald es fertig ist, wird es wieder aufgerufen.

33:19.600 --> 33:26.600
Also im Prinzip ist da nochmal eine Endlosschleife drum herum.

33:26.600 --> 33:29.600
Das Sensor-Teil, wozu es da ist, achso.

33:29.600 --> 33:34.600
Das ist dieser Sensor und damit kann man Bodenfeuchtigkeit messen.

33:34.600 --> 33:37.600
Kostet das Teil nicht 200 Taken? Nein, das Zeug ist alles übel.

33:37.600 --> 33:41.600
Und die Tastatur, ja die Tastatur kostet nicht 200, aber irgendwie 150 oder so.

33:41.600 --> 33:51.600
Was eigentlich total indiskutabel ist.

33:51.600 --> 33:54.600
Ja, schöne Tastatur, was das kostet.

33:54.600 --> 33:59.600
Ich habe mir ja für die Arbeit eine Ducky Skyline, Ducky One Skyline oder so ähnlich gekauft.

33:59.600 --> 34:04.600
Und die ist zum Tippen einfach viel angenehmer als dieses Corsair-Ding.

34:04.600 --> 34:08.600
Das Wichtigste, was die Corsair-Tastatur hat, ist eine halbwegs ordentliche Software,

34:08.600 --> 34:13.600
weil man sich da auch ganz schön schwer tut bei manchen Sachen.

34:13.600 --> 34:15.600
Und RGB-Beleuchtung.

34:15.600 --> 34:20.600
Und halt so super krasse Speed-Trigger, sonst was Tasten, die dich zum besten Gamer ever machen sollen.

34:20.600 --> 34:22.600
Was auch immer.

34:22.600 --> 34:27.600
So, also unser Sensor, voll eingetaucht im Wasserglas übrigens gerade,

34:27.600 --> 34:34.600
gibt uns jetzt einen Wert zurück von 1900, so irgendwie in dem Dreh.

34:34.600 --> 34:37.600
1980 oder so was.

34:37.600 --> 34:44.600
Ich nehme jetzt den Sensor mal aus dem Wasserglas raus.

34:44.600 --> 34:47.600
Was benutzt du für Switches? Meinst du die Netzwerk-Dinger?

34:47.600 --> 34:50.600
Nee, du meinst wahrscheinlich, du meinst die Tastatur-Switch.

34:50.600 --> 35:00.600
Das ist Speed-Red oder irgendwie so, das was standardmäßig in dieser Tastatur angeboten wird.

35:00.600 --> 35:05.600
So, okay, jetzt mache ich mal den Sensor aus dem Wasserglas raus.

35:05.600 --> 35:09.600
So, man sieht, es geht auch gleich hoch.

35:09.600 --> 35:16.600
So, und jetzt sieht man auch, jetzt kann ich euch an der Stelle auch gleich schon mal zeigen,

35:16.600 --> 35:27.600
dass ich das Ding auch wieder besseren Wissens und zum Horror aller Elektroniker am GPIO-Pin angeschlossen habe.

35:27.600 --> 35:29.600
Nämlich, dass ich es ein- und ausschalten kann.

35:29.600 --> 35:37.600
Weil, wenn ich den Sensor jetzt wieder ins Wasser schiebe, dann sieht man erstmal eine Weile nichts.

35:37.600 --> 35:40.600
Es dauert. Das geht ultra langsam runter.

35:40.600 --> 35:47.600
So, und wenn ich den Pin, wo das dranhängt, wenn ich den Sensor kurz ein- und ausschalte vor jeder Messung,

35:47.600 --> 35:50.600
dann geht das sofort.

35:50.600 --> 35:58.600
Dann fragt mich nicht, wahrscheinlich haben wieder irgendwelche komischen Chinesen den Sensor gebaut und das ist nicht richtig.

35:58.600 --> 36:00.600
Kann man die Werte linear mappen?

36:00.600 --> 36:04.600
Naja, nicht ganz. Also wir müssen das Ding jetzt halbwegs kalibrieren.

36:04.600 --> 36:07.600
Oder nennen wir es mal kalibrieren.

36:07.600 --> 36:12.600
Also wir müssen uns erstmal überlegen, was denn so, wie macht man das eigentlich C++, so?

36:12.600 --> 36:15.600
Kann man eigentlich Static-Const machen?

36:15.600 --> 36:22.600
Passt jetzt eigentlich, also ergibt eigentlich keinen Sinn, aber kann man wahrscheinlich machen, oder?

36:22.600 --> 36:28.600
Zumindest nennen wir das jetzt mal Sensor Max, das sind 4095, haben wir gerade gelernt.

36:28.600 --> 36:35.600
Also sprich, wenn das Ding in der Luft hängt, liefert er ungefähr 4095 zurück.

36:35.600 --> 36:42.600
Das ist der maximale Wert vom Analog-Digital-Converter.

36:42.600 --> 36:54.600
Achso, wir sollten noch einstellen, mit welcher Auflösung der ADC das Ganze macht.

36:54.600 --> 36:55.600
Static-Const, was anderes.

36:55.600 --> 37:00.600
Da seht ihr, wie krasser C++-Owner ich bin.

37:00.600 --> 37:09.600
Also ich dachte eigentlich immer, dass im Prinzip Const so eine Sache ist, Compile-Time reinbacken quasi.

37:09.600 --> 37:18.600
Also wenn ich sage, das ist Const, dann ist das halt nicht mehr änderbar und zur Compile-Zeit drin.

37:18.600 --> 37:21.600
So dachte ich mir das zumindest.

37:21.600 --> 37:29.600
Und Static ist, wenn ich das jetzt mal aus der C-Sharp-Welt oder Java, meinetwegen, Gott helfe, aus der Java-Welt nehme,

37:29.600 --> 37:41.600
dann heißt eigentlich Static nur, dass das einmalig initialisiert wird beim Starten vom Programm.

37:41.600 --> 37:50.600
Das stimmt doch so ungefähr, oder?

37:50.600 --> 37:54.600
Na gut, jetzt haben wir es super, jetzt haben wir eine Static-Const-Int.

37:54.600 --> 38:05.600
Also der richtig krasse C-Owner, der wird natürlich sowas hier in der Richtung machen, der wird natürlich sowas hier sagen.

38:05.600 --> 38:17.600
Das hier, das hier ist der reine C-Style, Leute, oder?

38:17.600 --> 38:23.600
C-Owner, genau.

38:23.600 --> 38:32.600
Also ich finde, das hier ist eigentlich schon irgendwie die schönere Variante, allerdings ist das hier keine Variante,

38:32.600 --> 38:39.600
sondern das ist ein Makro und das sorgt dafür, dass überall, wo ich das hier verwende, einfach während ich compile,

38:39.600 --> 38:45.600
dass das schon eingebaut wird an der Stelle.

38:45.600 --> 38:53.600
Da hat der Werte recht, ja, das stimmt.

38:53.600 --> 39:01.600
So, wir sehen, der Sensor geht immer noch runter, wir waren so irgendwie bei 1900 oder sowas als Minimalwert.

39:01.600 --> 39:10.600
Was wir jetzt noch einstellen müssen, ist die Auflösung von unserem Analog-Digital-Converter.

39:10.600 --> 39:19.600
Und lass mal überlegen, die Auflösung, wobei, müssen wir die Auflösung überhaupt einstellen?

39:19.600 --> 39:25.600
Jetzt müssen wir ihn einstellen.

39:25.600 --> 39:31.600
Wie sehr das Ding rauscht, sollten wir vielleicht noch einstellen.

39:31.600 --> 39:38.600
Können wir machen, und zwar, man kann für jeden, das Ding hat, also so ein ESP32,

39:38.600 --> 39:45.600
hat, ich glaube, 8 Analog-Digital-Converter drauf.

39:45.600 --> 39:53.600
Noch mehr, oder? 1, 2, 3, 4, 5, 6, 7, die Benahmung ist übrigens komplett konfus,

39:53.600 --> 40:01.600
da waren die Chinesen wieder voll nicht ganz bei der Sache, ich meine 0, 3, 6, 7, 4, 5, 18, 19,

40:01.600 --> 40:13.600
und ADC 18 auf GPIO 25, RTC pin 14 oder so, Alter, brain.

40:13.600 --> 40:21.600
Also Pin-Nummerierung ergibt eigentlich überhaupt keinen Sinn.

40:21.600 --> 40:24.600
Wann kommt das nächste Video? Ich habe mir schon so viele Themen mittlerweile aufgeschrieben,

40:24.600 --> 40:31.600
aber irgendwie fehlt mir einfach die Motivation, auf YouTube gerade was zu machen.

40:31.600 --> 40:37.600
Genau, also das Ding hat hier noch 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16

40:37.600 --> 40:44.600
Analog-Digital-Converter, allerdings mit so einer kleinen Einschränkung, wenn man WLAN einschaltet,

40:44.600 --> 40:51.600
fällt die Hälfte weg. Also sprich, das WLAN Modul braucht die Hälfte davon.

40:51.600 --> 41:01.600
Weil, aber man kann WLAN jederzeit aktivieren und deaktivieren.

41:01.600 --> 41:11.600
Ich uploade das Ding mal kurz neu, dass ich sehe, was der minimale Wert von unserem Sensor ist.

41:11.600 --> 41:22.600
Also 1900 irgendwie in dem Dreh, oder auch nicht.

41:22.600 --> 41:37.600
Also 1960 so rum, 1970. Also das dürfte der untere Wert sein, weil das Ding, wie gesagt, steckt gerade im Wasserglas.

41:37.600 --> 41:45.600
Und das sollte dann wirklich der Minimalwert sein.

41:45.600 --> 41:54.600
Was hast du jetzt eigentlich mit Assembler vor? Ja, wie gesagt, den Ultra-Low-Power-Prozessor von einem ESP32 programmieren.

41:54.600 --> 42:01.600
So, ok. Also wir lesen jetzt den Sensor aus. Wir haben jetzt den Sensor so ungefähr uns mal die Minimal- und Maximalwerte rausgesucht.

42:01.600 --> 42:11.600
So über den Daumen gepeilt. Wollen wir mal gucken, was der Sensor macht, wenn ich den so anschließe, dass der Elektriker sich nicht aufregt?

42:11.600 --> 42:19.600
Probieren wir mal. Ich schließe das Ding jetzt mal nicht an den GPIO an, sondern ich schließe das Ding jetzt mal ordentlich an Cloud an.

42:19.600 --> 42:33.600
Ich muss es aber vorher mal kurz aus dem USB-Anschluss ziehen. Wo haben wir es denn hier? GPIO 27.

42:33.600 --> 42:44.600
Auf Ground umstöpseln und dann mal gucken, was der Sensor macht. Allerdings ist das hier an sich gerade keine Option, weil ich muss jetzt hier einen ausschalten können.

42:44.600 --> 42:54.600
So, mal USB wieder reinstöpseln und wieder hochladen. Max, wir vermissen dich auf YouTube. Endlich mal Konter mit Niveau.

42:54.600 --> 43:04.600
Wie gesagt, ich habe mir ganz viele Sachen schon aufgeschrieben, aber ich muss das einfach mal machen. Spätestens, also spätestens im Dezember, weil ihr wisst ja, Dezember wird schon mal ein ganzes Monat daheim.

43:04.600 --> 43:32.600
Naja, das ist ungefähr das Gleiche. Bisschen ein Ticken niedriger. Aber das kommt schon ungefähr hin, 1950. Also der Minimalwert ist 1950 und der Maxiwale war 4095.

43:32.600 --> 43:46.600
Das einzige Problem ist, dass der Sensor sich ziemlich lahm verhält. Deswegen stöpseln wir das jetzt mal wieder um. Auf GPIO 27.

43:46.600 --> 44:07.600
Das machen wir jetzt im laufenden Betrieb, in der Hoffnung es passiert nichts. Vielleicht Crash. Gut, deckt. Jetzt nur noch das Expo da, der. iDesormel, ja, viel, viel, viel, also das wäre viel besser und das wäre auch die sinnvolle Variante.

44:07.600 --> 44:17.600
Also jetzt keinen Switch, entweder ein Relay oder ein Transistor. Also im Prinzip ist ja quasi ein Transistor so was wie ein Relay.

44:17.600 --> 44:39.600
Also jetzt hauen mich wahrscheinlich die Elektriker. Von dem was es im Prinzip macht, dass du quasi schalten kannst, also dass du den anderen Stromkern schalten kannst, ohne dass du ihn selbst reinhängen musst, macht ja sowohl ein Transistor als auch ein Relay.

44:39.600 --> 44:57.600
Oder nicht? Die Elektriker sind wieder hier am Start. Naja, ich sehe schon mein Fortschritt ist gerade wieder wahnsinnig highspeed, wie das am Stream immer so ist.

44:57.600 --> 45:18.600
Also für mich ist ein Transistor wie ein Relay plus kleiner. Wenn ich mir die Funktionsweise überlegen muss, ist für mich ein Transistor ein Relay plus kleiner. Viel kleiner.

45:18.600 --> 45:27.600
Nein, das wäre kein großer Akt, also du könntest ohne Probleme einen Transistor oder einen Relay anschließen an den GPIO und darüber den Sensor ein- und ausschalten.

45:27.600 --> 45:33.600
Das wäre mit Sicherheit auch die schönerere Variante, als das Ding direkt an den GPIO zu hängen.

45:33.600 --> 45:39.600
Ich wäre da übrigens allgemein relativ vorsichtig, je nachdem was ich für einen Board habe, die Sachen direkt an den GPIO-Pins zu hängen.

45:39.600 --> 45:52.600
Bei diesen Development-Boards ist das kein Ding. Da kannst du auch aus Versehen mal hier dein USB-5-Vol-Pin auf 3,3-Vol-Dings-Logik-Pin hängen.

45:52.600 --> 46:03.600
Das passiert nichts, das ist ordentlich gemacht. Wenn man allerdings die Boards nimmt, die ein bisschen mehr raw sind oder vielleicht sogar ein...

46:03.600 --> 46:12.600
Man bastelt sich selbst was mit einem nackten ESP32, da würde ich aufpassen. Da würde ich nicht einfach 5Vol auf einen GPIO-Pin geben, weil dann ist das Ding im Arsch.

46:12.600 --> 46:22.600
Und man muss mal auch mit der Batterie aufpassen. Das muss auch zum Board passen.

46:22.600 --> 46:33.600
Für mich ist Grafikspeicher das gleiche, wie Amat-Speicher. Das ist ja im Prinzip auch das gleiche, nur schneller und für andere Sachen verwendet.

46:33.600 --> 46:36.600
So, okay, Moment. Ich bin ultra langsam verliehlaufen mit den Fahnen.

46:36.600 --> 46:42.600
Also, wir wissen jetzt, was unser Sensor ungefähr für Minimal- und Maximalwerte hat. Das ist schon mal ganz praktisch.

46:42.600 --> 46:52.600
Ich nehme den Sensor jetzt noch mal aus dem Glas raus und dann soll er mal kurz abtropfen lassen.

46:52.600 --> 46:59.600
Und jetzt mache ich mal die Hand rum und so an verschiedenen Bereichen. Wir gucken mal, was es so für Werte zwischendrin gibt.

46:59.600 --> 47:04.600
Ach Quatsch, ich muss ja erst mal das Ein- und Ausschalten einbauen, weil sonst das Messen viel zu lang dauert.

47:04.600 --> 47:21.600
Also, wir schalten GPIO 27. Übrigens die richtige Variante ist, dass man das so macht. Das sieht nämlich auch viel schöner aus.

47:21.600 --> 47:36.600
Ich nehme GPIO 27 auf Low, dann warten wir mal, keine Ahnung, 200 Millisekunden. Dann messen wir und dann, machen wir das Delay hier unten weg.

47:36.600 --> 47:46.600
Und dann setzen wir GPIO wieder auf High. Also sprich, wir schalten das Ding ein, messen und schalten es wieder aus.

47:46.600 --> 47:55.600
Kann das Arduino C++ eigentlich landen oder was? Äh, ja, ja. Also, das ist nicht das nackte Arduino C++.

47:55.600 --> 48:06.600
Das ist Platform.io, als Entwicklungsumgebung. Das ist eine Visual Studio Code Plugin, aber unter der Haube benutzt sie den gleichen Kram.

48:06.600 --> 48:17.600
Mit sehr viel Custom Zeug drumherum, dass es ein bisschen einfacher macht. Du kannst in der Extension hier einfach einstellen, was du für einen C++ Standard haben willst.

48:17.600 --> 48:29.600
Also, man kann Lambdas und Gedöns verwenden. Das funktioniert. Man kann hier, irgendwo hier in den Settings kann man einstellen, was man für einen C++ Standard verwenden will.

48:29.600 --> 48:37.600
Das ist 2017 eingestellt. Also, zumal aber die Lambda Syntax für C++ nicht richtig hinkriegt. Das müssen wir dann bei Gelegenheit mal gucken.

48:37.600 --> 48:49.600
Ähm, so. Also, wir schalten das Ding ein, messen, geben aus, schalten das Ding wieder aus. Okay, mal gucken.

48:49.600 --> 49:00.600
Die einfachen Werte kannst du machen. Du kannst alles machen, theoretisch, was C++ 2017 kann. So.

49:00.600 --> 49:09.600
Jetzt sollte die Werte deutlich schneller gemessen werden. Also, Achtung Leute, ich mach mal raus. Zack. Okay. Naja, nicht wirklich, oder?

49:09.600 --> 49:19.600
So. Ich mach's mal wieder rein. Oh, habt ihr gesehen, das geht viel schneller. Wohingegen das vorher ewig rumgerödelt ist und langsam runter.

49:19.600 --> 49:25.600
Jetzt, wenn ich das Ding ein- und ausschalte, passiert nichts. Also, geht's richtig schnell. Aus dem Wasserklass raus.

49:25.600 --> 49:36.600
Zackwerte gehen hoch. Als Wasserklass rein. Zackwerte sind direkt wieder unten. So. Ähm, ich stell doch mal die Konsole ein bisschen größer, oder?

49:36.600 --> 49:59.600
Wie macht man das? Terminal. Font. Font. Font. Editor Font Size. Terminal. Terminal Font Size. 16. 18. 20. So ist gut, oder?

49:59.600 --> 50:19.600
20 ist, denke ich, eine ganz, ganz nice Größe. So. Aus dem Wasserklass raus. Ins Wasserklass rein. Und Wert passt.

50:19.600 --> 50:29.600
Okay. Wir wissen schon mal, der Sensor passt ungefähr und wir wissen schon mal, dass die unsere Minimal- und Maximalwerte so ungefähr hinkommen.

50:29.600 --> 50:39.600
Ach so, genau. Was wir noch einstellen müssen, ist, wie empfindlich unser Analog-Digital-Converter ist. Und zwar, das macht man mit ADC...

50:39.600 --> 50:53.600
ADC, was ist das nicht? ADC-Config? Ach nee, ich muss den Header erst noch einbinden. Wo das drinnen ist. Wir sind ja hier in keiner Sprache, die einem irgendwie großartig hilft.

50:53.600 --> 51:10.600
Ist denn das für eine ESP? ADC? Nee. ADC? Tja, wie könnte denn der Header heißen? Guck mal nach. Ich habe mir so ein Beispiel schon rauskopiert.

51:10.600 --> 51:29.600
Driver. Driver. ADC heißt der. Okay. Weil. Man weiß es nicht genau. So. Und jetzt können wir unseren Analog-Digital-Converter konfigurieren. Warum? Wo ist das Problem?

51:29.600 --> 51:43.600
ADC1-Config? Ist doch. Hat ein bisschen gebraucht, bis es geladen hat. So. Und da kann man jetzt einstellen, was das Ding...

51:43.600 --> 51:55.600
Erstmal muss ich sagen, was wir für einen Channel verwenden wollen. Und das ist jetzt so die typische China-Nummerierung wieder. Überall anders verwenden man GPIO 27 und GPIO 34.

51:55.600 --> 52:11.600
Vielleicht sollten wir hier einfach auch mal 34 reinschreiben. Hier verwendet man jetzt allerdings ADC1-Channel 6. Was unter der Haube GPIO 34 ist.

52:11.600 --> 52:33.600
Das ist der gestellte GPIO 34. Der sagt nicht, dass er einfach GPIO 34 ist. Nein, er sagt, er ist ADC1-Channel 6. Weil China-Herstellung. Anders kann ich mir nicht erklären. Das ist der totale Missbrauch von Auto. Warum?

52:33.600 --> 52:48.600
Auto ist, soweit ich weiß, ein bisschen wie VAR in C-Sharp. Du hast das weiterhin statisch typisiert. Allerdings musst du den Typ nicht angeben. Was viel besser ist und weniger nervig ist.

52:48.600 --> 52:55.600
Weil ich meine, du weißt den Typ ja schon anhand vom Return-Wert der Funktion. Weißt du ja schon, was das für einen Wert ist. Deswegen musst du den nicht hervorschreiben.

52:55.600 --> 53:10.600
Jetzt muss ich mal kurz abgucken, was da sonst noch rein muss. Jetzt kann man ihm sagen, wie empfindlich das Ganze sein soll. Das geht von 0 dB bis 11 dB. Wir machen jetzt mal 11.

53:10.600 --> 53:25.600
Dann kann man noch die Auflösung sagen. Wir drehen jetzt mal alles hoch und gucken, wie sich die Werte verändern. Ich könnte mir vorstellen, dass wir die Empfindlichkeit sogar ein bisschen runter stellen wollen.

53:25.600 --> 53:40.600
Weil, wenn man sich das hier anguckt, das ist ganz schön am Rauschen der Sensor. Wobei, ihr meint, das bewegt sich jetzt im Plus-Minus-Zwanzig. Das passt schon. Das kann man dann nachher eigentlich rausfiltern.

53:40.600 --> 53:55.600
Schauen wir mal, was wir noch vom Sensor rausholen können. Jetzt kann man einstellen, wie die Auflösung vom Analog-Digital-Converter ist. Das Höchste ist 12 Bit.

53:55.600 --> 54:10.600
Wenn wir das Ganze noch mal ausführen, gucken wir mal. Ich glaube, das sind auch die Default-Settings. Da dürfte sich eigentlich nichts dran ändern.

54:10.600 --> 54:22.600
Also, choose my name, so ziemlich alles, selbst das, was von Microsoft selbst kommt, verwendet war. Fast überall, ausschließlich.

54:22.600 --> 54:32.600
Es kann sein, dass das in dem Style-Guide drinsteht. Aber in dem Style-Guide steht ja auch, glaube ich, drin. Man soll in C-Sharp für private Variablen, äh, nicht für private.

54:32.600 --> 54:53.600
Ja, doch, für private Members. Ne, für private, äh, wie heißt's? Klassenvariablen halt. Soll man auch keine Unter-Anna-Score verwenden, sondern Kleinschreiben und sowas. Also, die Microsoft Style-Guides sind nicht schlecht, sich dran zu halten, ein paar Sachen haben sich aber nicht durchgesetzt.

54:53.600 --> 55:06.600
Ich weiß gar nicht, ob es im aktuellen Style-Guide noch so ist, dass man keine Unter-Anna-Score verwenden soll. War früher auf jeden Fall so. So, im Prinzip kommt das gleich aus.

55:06.600 --> 55:23.600
So, jetzt stellen wir das Ding mal ein bisschen weniger empfindlich und gucken mal, was passiert. Was er dann macht. Er kompiliert schon wieder eine halbe Stunde, ja.

55:23.600 --> 55:40.600
Äh, ändert sich eigentlich nicht viel, oder? Na doch, es rauscht schon ein bisschen weniger, habe ich das Gefühl. Oder? Finde nicht auf. Vorher hat er so geschwankt um 20 rum.

55:40.600 --> 55:59.600
Ach nee, ist eigentlich kein großer Unterschied. Egal. Lassen wir so, wir wollen jetzt zum Sampler-Part kommen. Äh, habe ich irgendwas im Chat überlesen? Und wozu willst du jetzt den Stand deiner Wasserhöhe messen?

55:59.600 --> 56:11.600
Willst du so eine Mütze mit zwei Bechern mit? Nee, nee, nee, nee. Also ich will nicht die Wasserhöhe messen. Man misst damit, wie die, äh, wie feuchter Boden ist. Das heißt, man weiß daran, wann man wieder Blumen gießen muss, zum Beispiel.

56:11.600 --> 56:19.600
Und warum ich das Ganze machen will, okay, ich habe ja am Anfang erzählt, ich erzähl's im Laufe des Streams, warum ich das machen will, folgendermaßen.

56:19.600 --> 56:34.600
Ich will das gar nicht für meinen Garten oder für meinen Hof oder für meine Terrasse. Sondern, ähm, wie sag ich das jetzt am besten, ohne dass jetzt alle wieder denken, das ist was ganz furchtbar Schlimmes.

56:34.600 --> 56:57.600
Und auch nicht das Katzenstreue, nee. Und zwar, ähm, ich will das gar nicht bei mir ins Haus stellen. Ich will das 1,5 Kilometer weiter wegstellen und von dort hierher übertragen. Weil der Friedhof ist 1,5 Kilometer hier quasi aus der Stadt oder aus dem Ort raus.

56:57.600 --> 57:10.600
Und auf dem Friedhof ist das Grab von Opa und Oma. Und im Sommer muss man da unregelmäßig oft hin. Und man weiß eigentlich nie genau, wann man hin will oder hin muss.

57:10.600 --> 57:28.600
Deswegen habe ich mir gedacht, ich baue einfach eine kleine Box mit einem ESP32 drin. Nicht dieses fette Modul, sondern ein kleineres oder zumindest ein deutlich stromsparenderes als das NodeMCU. Genau, der IoT Graveyard. Du hast es erkannt, Cheat1995.

57:28.600 --> 57:52.600
So, da kommt dann eine 1200 mAh Batterie dran. Das Ding ist zum größten Teil im Deep Sleep und das muss dann auch wirklich energieeffizient sein. Und wenn es dann festgestellt hat, dass der Wert größer ist oder kleiner ist, um einen gewissen Faktor abweicht, zudem, den das letzte Mal gemessen hat, dann wacht er auf und schickt mir das ganze heim.

57:52.600 --> 58:02.600
Und jetzt fragt ihr euch doch sicherlich, wie will der Max 1,5 Kilometer Daten übertragen?

58:02.600 --> 58:25.600
Flo96, das mache ich auch gleich noch. SIM-Karte, nein, keine SIM-Karte. Jetzt müsst ihr beraten. Wie habe ich vor, 1,5 Kilometer zu überbrücken? Und ich habe es auch schon ausprobiert, es funktioniert. Also es ist jetzt nicht einfach, weil ich mir das in den Kopf gesetzt habe, es funktioniert auch.

58:25.600 --> 58:43.600
Glasfaserleitung 10, nein. Long Range Wi-Fi, nein. Loravan, fast. Richtig, weil es steht im Titel. Achja, das erste, was ich übrigens geguckt habe, ist, ob es auf dem Friedhof offenes WLAN gibt.

58:43.600 --> 58:57.600
Leider nicht. Es gibt leider kein offenes WLAN auf dem Friedhof. Es gibt auf dem Friedhof lustigerweise gar kein WLAN. Ich wusste überhaupt nicht, dass Orte in Deutschland existieren, wo es kein WLAN gibt.

58:57.600 --> 59:17.600
Nein, wir machen das Ganze mit Lora. Nicht mit Lora warten, sondern nur mit Lora. Das habe ich schon ausprobiert, funktioniert wunderbar. Ich habe hier einen Empfänger. Den kann ich euch mal zeigen, wenn ihr wollt.

59:17.600 --> 59:35.600
Ich mache mal den Lora Empfänger kurz an. Ich logg mich mal drauf ein und dann zeige ich euch das Ding. Das ist Lora, das sehe ich gleich.

59:35.600 --> 59:49.600
Ich muss mal kurz gucken. Ich habe hier so ein mini, mini 80x80 Display dran, damit ich sehe, wann er an ist. So, er ist an. Das ist nämlich auch ein... kommt Telnet hier. Heute kommen wirklich die absolut High-Tech-Programme her.

59:49.600 --> 01:00:13.600
Er ist aber selbst mal Telnet verwendet, um nicht einfach einen Port zu testen, sondern wirklich sich irgendwo drauf einzuloggen. Das ist nämlich auch ein ESP32, den ich als Lora-Empfänger verwende. Ich glaube, das war die IP von dem Ding. Ha, genau. Der macht aktuell nichts. Der publisht auch keine Daten, auch wenn es da steht, weil er empfängt nichts.

01:00:13.600 --> 01:00:34.600
Genau, und als Lora-Empfänger, und da kommen wir auch gleich zu dem Punkt, was Lora ist, habe ich das Ding hier ein... nicht T-Bone, T-Bone war das Mikrofon. T-Beam. Genau, das Ding habe ich dafür.

01:00:34.600 --> 01:01:03.600
Das ist ein ESP32 mit einem Lora-Modul drauf, also mit WLAN drauf und einem Lora-Modul drauf. Und hier sieht man, hier ist eigentlich die Erklärung ganz gut. Und hinten drauf, das ist eigentlich das ganz coole, auch wenn ich es nicht brauche, einen Batteriehalter für eine 18... 56 Batterie. So eine dicke. Für so dicke, dicke Akkus, die aussehen wie Batterien.

01:01:03.600 --> 01:01:18.600
Genau, und fast genau so sieht das Ding bei mir auch aus. Fast eins zu eins. Ich habe da auch so ein kleines Display dran, dass ich quasi das, was ich hier im Telnet sehe, auch auf dem Display sehe. Und genau, den verwende ich als Lora-Empfänger.

01:01:18.600 --> 01:01:36.600
Lora ist ein... Was sagen mich selber dann über sich? Long Range...

01:01:36.600 --> 01:01:53.600
Es ist im Prinzip ein Übertragungsstandard, so ein Layer, Layer 2, 1 Standard zum Übertragen von Signalen mit sehr niedriger Bandbreite, allerdings mit sehr großer Reichweite.

01:01:53.600 --> 01:02:06.600
Wie viel kostet der Spaß? Ja, das ist auch... Bevor ich etwas weiter zum Thema Lora erzähle, das ist alles ziemlich günstig, was ich hier baue bei mir daheim.

01:02:06.600 --> 01:02:17.600
Also ich versuche wirklich jetzt nicht die teuren Sachen zu verwenden, sondern möglichst günstige Sachen. Das bewegt sich im Rahmen von 20 Euro.

01:02:17.600 --> 01:02:25.600
Also das Zeug ist alles nicht teuer. Und wenn man es gar irgendwie bei AliExpress oder so kauft, ist es noch günstiger. Also diese ganzen Controller sind wirklich günstig.

01:02:25.600 --> 01:02:36.600
Guck mal hier, also... Wenn man es aus Englisch... Wahrscheinlich ist das der Banggood sind die Inder, AliExpress sind die Chinesen, Gearbest sind glaube ich auch die Chinesen.

01:02:36.600 --> 01:02:49.600
Zumindest sind das so die drei großen Seiten, wo man so kauft. Dann muss man sich aussuchen, welche Frequenz man haben will. In Europa kann man 433 MHz oder 860 MHz nehmen.

01:02:49.600 --> 01:03:04.600
In den USA sind es 915 MHz glaube ich. Kann man sich so ein Modul kaufen. Und man kann sich auch, wenn man selbst nichts zusammenbauen will als Client oder als Sender oder als Node, den man irgendwo betreibt,

01:03:04.600 --> 01:03:12.600
kann man sich auch einfach zwei Stück dafür kaufen. Eine zum Senden, eine zum Empfangen. Also das ist nicht teuer. Wir reden hier so im Bereich von 20-25 Euro.

01:03:12.600 --> 01:03:26.600
Und das ist auch noch günstiger, weil die haben immer irgendwelche Aktionen. Man kann es direkt aus England bestellen, das ist ganz praktisch.

01:03:26.600 --> 01:03:44.600
Und genau. Aus UK 26 Euro 52 Cent. Lasst euch das mal auf der Zunge zergehen. 52 Cent der Versand. Und das aus China teilweise.

01:03:44.600 --> 01:03:56.600
Oh ne, aus China kostet das ganze 1,16 Euro. Also wenn du von Deutschland nach Deutschland was verschickst mit DHL, ist das deutlich teurer als wenn die China Shops verschicken.

01:03:56.600 --> 01:04:13.600
Das kostet fast nichts bei China Shops. Genau, kann man sich so ein Ding kaufen. Ist nicht so richtig geeignet als mobiler Node, weil eben relativ stromhungrig für Batteriebetrieb.

01:04:13.600 --> 01:04:23.600
Auch wenn es einen Batteriehalter hinten dran hat. Ich würde mal sagen, selbst wenn du da einen ordentlichen Akku hinten reinstöpselst,

01:04:23.600 --> 01:04:35.600
das läuft vielleicht, nachdem das Ding halt keinerlei gescheite Stromsparmaßnahmen drauf hat, wahrscheinlich so zwei Monate oder so, dann ist er aus.

01:04:35.600 --> 01:04:48.600
Den Node, den ich jetzt zusammen bastle, der dürfte so nach, wenn ich das mal hochrechne, so irgendwie zwei Jahre laufen. Mit halt zum größten Teil Deep Sleep.

01:04:48.600 --> 01:05:06.600
Genau, ist Laura von der Bundesnetzagentur in Deutschland schon abgesegnet. Die 868 Megahertz darf jeder verwenden. Es gibt ein paar Richtlinien dazu. Du darfst glaube ich maximal, so über den Daumen gepeilt,

01:05:06.600 --> 01:05:18.600
eine Minute oder eine halbe Minute pro Stunde senden. Eine halbe Minute ist es glaube ich so über den Daumen gepeilt. Pro Stunde, aber das reicht.

01:05:18.600 --> 01:05:38.600
Dazu kommt, Laura ist relativ stromsparend und hat eine relativ große Reichweite. Was bedeutet das? Dreimal dürft ihr zusammen raten. Was bedeutet es, wenn stromsparend und große Reichweite zusammenkommen für die Bandbreite, die man übertragen kann?

01:05:38.600 --> 01:05:48.600
Also wenn ich ein Gerät habe, was relativ wenig Strom braucht und eine hohe Reichweite hat, wie hoch wird dann wohl? Genau, die Bitrate ist ziemlich niedrig.

01:05:48.600 --> 01:06:08.600
Korrekt. Allerdings ist die Bitrate gar nicht so extrem niedrig. Sie ist nur im Vergleich zu WLAN verdammt niedrig. So, wenn man sich jetzt nämlich mal die Arduino, so eine der Laura Arduino Libraries anguckt und man geht hier mal auf Bandbreite,

01:06:08.600 --> 01:06:26.600
dann sieht man Laura unterstützt von 250 Kilobit bis runter zu 7,8. Ich glaube Kilobits sind es. Ach nee, Moment. Das stimmt doch gar nicht mal, was ich erzähle.

01:06:26.600 --> 01:06:42.600
Das ist, ehm, doch. Das ist die, im Signal, wie breit, also wie, wie viel, wie breit, wie, über wie viel Frequenzen das Signal geht zum Datenübertrag. Irgendwie so. Zumindest ist es wenig.

01:06:42.600 --> 01:06:58.600
So genau kann ich es euch jetzt gar nicht sagen, aber es ist wirklich nicht genau. Es ist ziemlich wenig. Ich glaube man kann das ziemlich genauso als ungefähr Kilobits pro Sekunde.

01:06:58.600 --> 01:07:14.600
Okay, gucken wir mal. Data-Rate. So genau habe ich mir das gar nicht angeguckt. Ich weiß nur, dass es für meinen Sensor reicht. Ach hier, guckt mal, hier steht es doch, hier steht es doch. Also man hat, ha ha, Kilobit.

01:07:14.600 --> 01:07:29.600
Vergesst, was ich gesagt habe, Leute, von wegen Kilobit. Bytes. Bytes pro Sekunde. Bytes oder Bytes pro Sekunde? Ich würde jetzt mal auf Bytes pro Sekunde tippen.

01:07:29.600 --> 01:07:56.600
Letztendlich ist es wenig. Also wenn ich als Bandbreite einstelle, also 125 Kilohertz ist anscheinend so der Standard, dann kann ich einstellen, diese SF, das ist bei Laura der Faktor, wie lang, wenn ich das richtig im Kopf habe, ist das, wie lang jedes einzelne Bit übertragen wird.

01:07:56.600 --> 01:08:18.600
Also quasi wie lang der Sender sendet. Hast du wirklich? Nö, habe ich nicht. Ich weiß genau, wie wenig das überträgt. Also es ist im Vergleich zu WLAN, wo du Megabit überträgst, bis theoretisch fast schon Gigabit, weil das kein WLAN Ding wirklich unter realistischen Bedingungen auf die Reihe kriegt.

01:08:18.600 --> 01:08:33.600
Also du hast hier ungefähr, also wenn du die größte Reichweite nimmst, also dann stellst du hier SF12 ein und Bandbreite sogar noch ein bisschen runter.

01:08:33.600 --> 01:08:48.600
Also ich habe es jetzt probiert mit SF12 und 31 Kilohertz Bandbreite, dann dauert so ein Sendevorgang irgendwie, keine Ahnung, 5 Sekunden oder so für ein Byte.

01:08:48.600 --> 01:09:05.600
Irgendwie so in einem Dreh überlegt, lass es sich mal auf deinen Zunge zergehen. Irgendwie über den Daumen gefallen war das glaube ich, für einen Byte 5 Sekunden oder so. Also in der heutigen Zeit ist das halt schon echt wenig.

01:09:05.600 --> 01:09:19.600
Es kann jetzt sein, dass ich Mist erzähle und es sind 5 Byte oder so. Es ist auf jeden Fall verdammt wenig Bandbreite.

01:09:19.600 --> 01:09:43.600
Und das Schöne ist allerdings, dass die Reichweite relativ hoch ist und ich habe es ausprobiert, 1,5 Kilometer und der Empfänger, nämlich dieses Ding hier, was ich euch gerade gezeigt habe, der lag bei mir auf dem Schrank, hier im Arbeitszimmer hinten auf dem Schrank, quasi so grob in die Richtung, wo der Friedhof ist.

01:09:43.600 --> 01:10:03.600
Und den Sender hatte ich im Rucksack drin und bin dahin gelaufen. Man hat zwischendurch mal ein paar Übertragungsfehler gehabt, aber es hat funktioniert. 1,5 Kilometer, das ist echt ordentlich, da kann man sich nicht beschweren.

01:10:03.600 --> 01:10:19.600
Ja, heiliger Bimber, man darf nicht vergessen, dass mit geringerer Bandbreite ganze Sonden durchs Weltall geflogen werden. Ja. So sieht es aus, ja. Genau, und das ist Lora.

01:10:19.600 --> 01:10:34.600
Die Sachen sind relativ günstig, also wenn man jetzt nicht so ein Komplett-Ding haben will, ich meine, das ist ein ESP32 mit einem Lora-Modul drauf, mit einem SMA-Antennen-Connector mit Pins und einem Batteriehalter.

01:10:34.600 --> 01:10:52.600
Also das ist quasi ein Development Board, Batteriehalter, Lora und das ist alles in einem. Man kann das ohne Probleme auch selbst basteln. Man kann sich nämlich einfach auf Amazon zum Beispiel oder generell einen SX-Things kaufen, das ist nämlich der Lora-Chip, der überall drauf ist.

01:10:52.600 --> 01:11:06.600
Und der Chip an sich ist, das ist Schwachsinn, viel zu teuer. Der nackte Chip, der kostet irgendwie 9 Euro bei Banggood oder so. Ich würde mir allerdings welche mit Pin kaufen.

01:11:06.600 --> 01:11:22.600
Also man kann sich für 30 Euro ein ziemlich energiesparendes Lora-Board zusammen basteln und als ESP32-Board für Batteriebetrieb empfehle ich das hier, den ESP32 Fire Beetle.

01:11:22.600 --> 01:11:39.600
Sieht ein bisschen aus wie der NodeMCU, den ich gerade dran habe. Allerdings, man sieht schon, man muss die Pins selber löten. Das Schöne hier an dem Ding, an diesem Board ist, das hat einen Batterie-Connector direkt dran, so normal, die normalen LiPo Batteries, die es so gibt.

01:11:39.600 --> 01:11:54.600
Du hast allerdings auch einen USB-Anschluss, um es einfach firmware zu flashen. Das Schöne daran ist, im Batteriebetrieb deaktiviert dieses Board jegliche Developer-Hilfen. Also sprich, das deaktiviert den Spannungswander für USB, deaktiviert USB, deaktiviert alles.

01:11:54.600 --> 01:12:09.600
Dieses Board, also der Fire Beetle hat im Deep Sleep einen Verbrauch von, ich hab's gemessen mit meinem Multimeter, von 11, also 11 µA. Das ist wirklich sau-mäßig wenig.

01:12:09.600 --> 01:12:24.600
Für den ESP32 Board, ein komplettes Board mit allem dran. So, wir kommen echt nicht vorwärts. Okay, also wir haben den Sensor, achso, was hab ich, ich hab im Chat bestimmt irgendwas überlesen.

01:12:24.600 --> 01:12:44.600
Du kannst ja nicht die Solarzelle dran machen, doch, kannst du. Könnte man machen, man muss halt nur irgendwo hinlegen dann. Gibt's bestimmt auch als USB-Gedanahmen einen Raspberry dran. Nö, du kannst den Chip einfach direkt an die GPIOs von einem Raspberry dran machen, funktioniert auch.

01:12:44.600 --> 01:12:56.600
Die fertigen Libraries auf GitHub, Job-List einfach, du kaufst ja einfach hier einen SX oder du kannst ja auch einen RF-Dings, das ist der gleiche Chip im Endeffekt.

01:12:56.600 --> 01:13:10.600
Kannst du dir kaufen, genau den hab ich hier, kannst du dir kaufen. Das ist alles viel zu teuer. Ihr müsst mal wirklich bei den Chinesen gucken. Selbst auf Amazon ist es billiger.

01:13:10.600 --> 01:13:17.600
Wir haben ja mittlerweile die Produktnamen, genau, hier irgendwie 18 Euro. Aber wie gesagt, wenn ihr es bei Banggood oder AliExpress kauft, kostet es die Hälfte.

01:13:17.600 --> 01:13:25.600
Und da muss man sich einfach Pins dran löten und dann kann man das direkt an die GPIOs vom Raspberry stöpseln.

01:13:25.600 --> 01:13:41.600
Die hat unten auch eine Beschriftung dran, wie das Ganze funktioniert. Also sprich, oben links kommt die Antenne dran, dann hat es vier Crown-Pins, davon muss man nur einen connecten. Von diesen DIO-Pins muss man auch nur einen connecten, das reicht, nämlich den Nuller. Dann stöpselt man es beim Raspberry auf die 3,3 Volt-Pins.

01:13:41.600 --> 01:13:49.600
Und die anderen sind beim Raspberry genauso beschriftet und dann installiert man sich die Library von GitHub und dann kann man das Ding verwenden.

01:13:49.600 --> 01:14:03.600
Es gibt leider wenig gute Tutorials und wenig gute Videos zu dem Thema. Die besten Videos zu dem Thema hat der guy with the swiss accent auf YouTube.

01:14:03.600 --> 01:14:15.600
Der macht wirklich gute Videos, wenn man sich für Microcontroller und generell solche Elektronik-Bastelgeschichten interessiert.

01:14:15.600 --> 01:14:22.600
Der hat auch jede Menge Videos zu LoRa gemacht, also wenn man sich da einen Überblick verschaffen will, sind das wirklich gute Videos.

01:14:22.600 --> 01:14:30.600
Er zeigt auch, wie man sich künstlich... war ich auch immer, genug geschwätzt, wir machen jetzt weiter. Und mein fast, ja, man kann da auch eine kleine Solarzelle dran machen.

01:14:30.600 --> 01:14:49.600
Allerdings ist Solarzellen an sich nicht so einfach, weil man muss sich ja überlegen, wie man das Ganze dann an seinen Controller kriegt. Und wenn man sich das hier anguckt, wenn man hier den... genau.

01:14:49.600 --> 01:15:02.600
Das ist ja hier das Developer-Board, was ich gerade habe. Wie schließt du die Solarzelle an? So eine normale Solarzelle hat... nimmst du so eine normale 6V Solarzelle.

01:15:02.600 --> 01:15:15.600
Die gehen ja so von 1,5V bis, glaub, 12V, so in der normalen Größe. Dann nimmst du dir irgendwie eine 6V Solarzelle. Und da fängt schon an, wo schließt denn das Ding dran an?

01:15:15.600 --> 01:15:24.600
Die normalen Developer-Boards verkraften auch ein bisschen mehr. Du brauchst allerdings schon mal irgendwie was, was das wieder auf USB umwandelt, ja, dass du das dann in USB stöpseln kannst.

01:15:24.600 --> 01:15:30.600
Das Board läuft interne mit 3,3V, allerdings förderst du es mit 5, was auch schon irgendwie übertrieben ist.

01:15:30.600 --> 01:15:48.600
Also am besten ist, du holst dir hier so ein Board mit einem Batterie-Connector und holst dir den passenden Solar-Charging-Chip. Kostet auch nur 2€. Und da hängst du die Batterie dran und deinen Controller und der macht das für dich.

01:15:48.600 --> 01:16:02.600
Ja, cheat 1195, genau. So macht man das. Du brauchst halt irgendeinen Solar-Charging-Chip.

01:16:02.600 --> 01:16:05.600
Okay, wir basteln jetzt mal weiter. Das wollen wir mal zum eigentlichen Punkt kommen.

01:16:05.600 --> 01:16:19.600
Okay, also wir haben unseren Sensor halbwegs kalibriert. Und wenn ich mir das hier so angucke, sehe ich auch, das stimmt nicht, weil ich gesagt habe, der Minimalwert ist ungefähr 1720.

01:16:19.600 --> 01:16:36.600
Und der Maximalwert ist, mal abtropfen lassen. Ja, da sind jetzt noch ein paar Wasserperlen dran. Ja, der Maximalwert ist, wir lassen einfach mal, wir machen mal, komm, wir machen mal 3800 oder so.

01:16:36.600 --> 01:16:44.600
Okay, das ist unser Sensorwert. Darf ich fragen, für was du das Ganze machst? Ja, zum Bodenfeuchtigkeit messen.

01:16:44.600 --> 01:16:57.600
So, jetzt haben wir den ganzen Shit mal weg. Und jetzt wird es eklig. Jetzt kommen wir mal zum Assembler-Part. Also diesen ganzen Mist brauchen wir nicht.

01:16:57.600 --> 01:17:05.600
Also, ich mache das hier nicht alles komplett aus dem Kopf. Ich habe im Vorfeld schon ein bisschen rumgebastelt. Allerdings funktioniert das Ganze nicht gescheit.

01:17:05.600 --> 01:17:14.600
Und ich habe mir schon ungefähr angeschaut, wie es grob funktioniert. Weil, würde ich jetzt hier an diese Geschichte komplett blind dran gehen, könnte ich es vergessen.

01:17:14.600 --> 01:17:23.600
Ganz zu klicken. Es ist echt nicht, nicht einfach. Allein schon rauszufinden, was für Hedder man einbinden muss, wie die ganzen Makros heißen.

01:17:23.600 --> 01:17:36.600
So, also unser Ziel ist es jetzt. Achso, ich zeige euch jetzt vielleicht noch erstmal was, bevor wir anfangen. Unser Ziel ist es jetzt, dass wir unseren Controller in Deep Sleep schicken.

01:17:36.600 --> 01:17:50.600
Also sprich, dass der keinen Strom mehr verbraucht. Keinen in Anführungsstrichen. Und dass wir trotzdem den Wert vom Boden-Sensor, Bodenfeuchtigkeits-Sensor abfragen können.

01:17:50.600 --> 01:18:03.600
Und die Main-Cores. Das ist das Ziel. So, und jetzt, das ist natürlich das erste, was man sich überlegen muss. Okay, wie versetze ich denn meinen Mikro-Controller in den Deep Sleep?

01:18:03.600 --> 01:18:07.600
Das ist relativ einfach. Das kriege ich mittlerweile, glaube ich, sogar aus dem Kopf hin.

01:18:07.600 --> 01:18:21.600
Äh, Enter, Enter Sleep oder so. Deep, Deep Sleep. Ja, Deep Sleep Start. So wäre das Ganze jetzt natürlich relativ sinnfrei.

01:18:21.600 --> 01:18:38.600
Ich würde nämlich der Controller aufwachen, in den Deep Sleep gehen und nie wieder aufwachen. Also ziemlich, ziemlich beknackt.

01:18:38.600 --> 01:18:47.600
So, und nachdem wir das Ganze nicht wollen, müssen wir dem Ding auch erstmal sagen, hey, du sollst nicht einfach nur in den Deep Sleep gehen, sondern du sollst auch wieder aufwachen.

01:18:47.600 --> 01:19:06.600
Und dazu gibt es einen, ähm, Deep Sleep, wie ist das? Wake Up? Ja. ESP Sleep Enable Timer Wake Up.

01:19:06.600 --> 01:19:20.600
Und da muss man jetzt in Nanosekunden, oder? Sind das Nanosekunden? Mikrosekunden? Ich kann, also, mit Einhalten wird es dann langsam, aber sicher irgendwann auch echt kompliziert.

01:19:20.600 --> 01:19:46.600
Ähm, Mikrosekunden, ne? Ja, genau. Ähm, also, wann der aufwachen soll. Das bedeutet, wir haben schon mal tausend, also tausend Mikro, eine Milli, oder?

01:19:46.600 --> 01:19:55.600
Ach so, Scheiße. Ach so, es steht sogar Mikrosekunden, Mikrosekunden. Also, also tausend, so, also das ist jetzt dann quasi eine Milli Sekunde.

01:19:55.600 --> 01:20:06.600
Denkt mal, denkt mal mit. Ähm, so, das ist eine Milli Sekunde und ich will alle 100 Milli Sekunden aufwachen, oder alle, alle, alle Sekunde aufwachen.

01:20:06.600 --> 01:20:25.600
Also sowas hier? Sowas hier, oder? Gibt das Sinn? Probieren wir mal aus. Also, unser ESP macht jetzt nichts anderes, wie Watchdog Timer zu setzen, in Deep Sleep zu gehen und hoffentlich jede Sekunde aufzuwachen.

01:20:25.600 --> 01:20:39.600
Ja, er wacht auf. Gut. Also, der gibt Geschwobbel aus, weil die, ähm, weil ich das mit der falschen Bitrate initialisier. Ich glaub, ich kann es mir immer aus dem Kopf nicht merken.

01:20:39.600 --> 01:21:06.600
Was ist, was ist das? Was da? Ich glaub, das ist die, die, die Standard, die der, die NodeMCU hat. Nein. Ach nee, ha, fast, fast. So, das ist die Standard NodeMCU, ja.

01:21:06.600 --> 01:21:22.600
Der Fire Beetle hat 9600. Das ist halt bordspezifisch, je nachdem, wie die Typen das programmiert haben. Oder auch nicht. Ach nee, Moment. Ich muss ja, muss ja mein Projekt noch setzen.

01:21:22.600 --> 01:21:43.600
Ach, scheiß drauf. Wir bleiben jetzt mal auf 9600. Nee, Moment. Also, ich muss mein, ich muss mein Projekt, ich muss, hier, Monitor Speed oder wie, wie war das, ähm.

01:21:43.600 --> 01:22:09.600
Ah, mal gleich. Monitor Speed. Ah, Monitor Unterstrich Speed. Okay. Bilden wir das Ganze und jetzt gucken wir uns das nochmal an.

01:22:09.600 --> 01:22:22.600
Stopp. Starten. Genau. So, und jetzt sollte das Ding schlafen gehen und jede Sekunde aufwachen. Ja. Ah, funktioniert. Ah ja, übrigens, auf die Uhrzeit darf man nichts geben.

01:22:22.600 --> 01:22:35.600
Die ist standardmäßig immer nicht gesetzt, weil woher auch? Woher soll die Uhrzeit wissen? Es gibt NTP Libraries. Ähm. Äh, Kiste HD, doch, gibt's.

01:22:35.600 --> 01:22:58.600
MaxFPS.tv oder Wublords.tv, äh, fast. Ah, da gibt's die, das ist die Seite vom Sebaro, wo es die älteren, die älteren Streams gibt.

01:22:58.600 --> 01:23:08.600
Sind glaub ich fast alle drinnen. So, genau, also das funktioniert. Das Ding, das wacht jetzt jede Sekunde auf und geht wieder schlafen.

01:23:08.600 --> 01:23:17.600
Das ist natürlich jetzt für sich gesehen ziemlich beknackt. Das braucht eigentlich kein Mensch, ja. Deswegen müssen wir dem jetzt erstmal was Sinnvolles beibringen, was er machen kann.

01:23:17.600 --> 01:23:28.600
Ähm, zumindest Deep Sleep. Deep Sleep ist schon mal ganz gut. Den anderen Krempel machen wir erstmal hier weg. Ich bin halt ganz sicher, ob wir das nicht wieder brauchen.

01:23:28.600 --> 01:23:41.600
Also die letzte Amtshandlung, die das Ding machen soll, ist in Deep Sleep gehen. So, was man jetzt noch machen muss, ist, man muss ihm sagen, welche Quellen ihn aufwecken dürfen.

01:23:41.600 --> 01:23:54.600
So, und da gibt's ein paar Sachen. Ähm, Wake Up. Genau, also es gibt ein paar Sachen, wie man ihn aufwecken kann.

01:23:54.600 --> 01:24:03.600
Was, Tommy? Hörst du eigentlich Rammstein? Wenn ja, wie findest du das neue Album? Ich hab mir die zwei Sachen auf YouTube angehört. Ich war noch nie großartiger Rammstein-Fan.

01:24:03.600 --> 01:24:20.600
Ähm, und ich fand die zwei Sachen auf YouTube jetzt auch nicht, sondern echt toll. Ihr wisst, ich bin Heavy Metal-Fan, allerdings Rammstein ist nichts für mich.

01:24:20.600 --> 01:24:28.600
So, also, wie man das Ding aufwecken kann, gibt's verschiedene Varianten. Ähm, man kann zum Beispiel sagen, über einen Pin.

01:24:28.600 --> 01:24:38.600
Das ist praktisch, wenn man beispielsweise einen Schalter hat. Wenn ich jetzt zum Beispiel am Hofdorn einen Schalter hab, und ich stöpsel den an den GPIO-Pin dran,

01:24:38.600 --> 01:24:48.600
und dann kann ich ihm sagen, hey, geh in Deep Sleep, verbraucht er kaum Energie, allerdings möchte ich, dass du durch einen Interrupt von GPIO aufgeweckt werden kannst.

01:24:48.600 --> 01:25:00.600
Gibt's in der Variante X0 bedeutet für einen GPIO, nur für einen. X1 sind mehrere GPIOs, da muss ich dann genau sagen was. Per Timer, das ist das, was wir jetzt machen, ne?

01:25:00.600 --> 01:25:10.600
Timer setzen, per Touchpad, per serielle Schriftstelle oder per ULP. Und das ist das, was wir machen wollen. ULP ist der Ultra Low Power Co-Prozessor.

01:25:10.600 --> 01:25:22.600
Und das bedeutet, wir müssen jetzt unterscheiden können, warum wir aufgewacht sind. Also sprich, wurden wir durch den Schalter aufgeweckt,

01:25:22.600 --> 01:25:29.600
wurden wir einfach durch den Reset-Knopf aufgeweckt, oder wurden wir eben durch den Ultra Low Power Processor aufgeweckt.

01:25:29.600 --> 01:25:40.600
Das heißt, ich muss mir jetzt erstmal hier auslesen, warum ich aufgeweckt wurde, oder warum mein Controller aufgeweckt wurde.

01:25:40.600 --> 01:25:51.600
Und standardmäßig kann ich euch das ja mal zeigen, was das Ding ausgibt. Gut, das wird wahrscheinlich null ausgeben. Machen wir ein Delay rein.

01:25:51.600 --> 01:26:07.600
Batterieball Leer Interrupt. Genau, das ist viel zu niedrig für Batteriebetrieb. Also Wake Up Timer im Batteriebetrieb Stunde Minimum.

01:26:07.600 --> 01:26:22.600
Für die Hauptkerne. Der ULP kann öfters aufwachen. Ja, okay, Wake Up Course 4 ist glaube ich Timer.

01:26:22.600 --> 01:26:43.600
So, und wir wollen jetzt abfragen, wer hat mich aufgeweckt? Hat mich der ULP aufgeweckt? Oder besser gesagt, hat mich nicht der ULP aufgeweckt?

01:26:43.600 --> 01:26:52.600
Weil wenn mich nicht der ULP aufgeweckt hat, dann möchte ich nämlich mein ULP starten. Also von der Logik her ist es glaube ich relativ nachvollziehbar.

01:26:52.600 --> 01:27:02.600
Also sprich, wenn ich die Firmware flasche und das Ding sich das erste Mal startet, soll es quasi den Ultra Low Power Processor initialisieren,

01:27:02.600 --> 01:27:09.600
starten und danach das natürlich nicht wieder machen bei jedem Aufwecken. Oder ist irgendwie nachvollziehbar.

01:27:09.600 --> 01:27:16.600
Also sprich, wenn ich erkenne, dass ich durch den ULP aufgeweckt wurde, dann will ich eben nicht den ULP neu initialisieren, weil er läuft da schon.

01:27:16.600 --> 01:27:39.600
So und das heißt, wir machen jetzt hier mal eine neue Funktion, irgendwie Init, oder wie nennt man das Ding? Init ULP oder irgendwie sowas in der Richtung. Start Run ULP, Start ULP. Ah, Start ULP, okay. So, Alter, ich kann dir mal tippen, ey, was ist das da?

01:27:39.600 --> 01:27:48.600
So, Start ULP. Wir wollen das Ding, wir wollen das Ding nur einmal starten, nämlich wenn wir nicht von ihm aufgeweckt wurden.

01:27:48.600 --> 01:27:53.600
Weil wenn wir von ihm aufgeweckt wurden, dann wäre es ja bescheuert ihn wieder zu starten.

01:27:53.600 --> 01:28:11.600
Also Cheat 105, ich denke mal 5 Jahre sind vielleicht ein bisschen unrealistisch, allerdings ich denke 2 Jahre kriegt man schon ganz gut hin. Es gibt einen ganz guten, einen ganz guten Calculator für Batterielebensdauer.

01:28:11.600 --> 01:28:26.600
Zwar den hier. Also wenn wir jetzt zum Beispiel sagen, wir haben eine Batterie von 1200 mAh. Das ist so nen normales Ding. Ja, das sind dann solche, sowas hier zum Beispiel.

01:28:26.600 --> 01:28:41.600
Es ist auch, wie gesagt, das ist das Schöne daran, es ist alles nicht wahnsinnig teuer. So, du brauchst dafür nen Calculator, ja. Ich bin halt nicht der krass Elektri-Korz, der das kann.

01:28:41.600 --> 01:28:57.600
So, und jetzt kann man zum Beispiel sagen, ok, die Batterie schaltet sich aus, wenn sie nur 20% hat, sagen wir mal 15. Ich brauche ungefähr 150 mAh, wenn ich laufe.

01:28:57.600 --> 01:29:03.600
Das ist das Maximum. 150 mAh brauchst du ungefähr, wenn du WLAN-Daten überträgst. Also das ist das Maximum.

01:29:03.600 --> 01:29:11.600
Dann kannst du sagen, wie lang das Ganze denn läuft. Sagen wir mal 2 Sekunden. Das kommt denke ich mal ganz gut hin.

01:29:11.600 --> 01:29:17.600
Das Ding muss aufwachen und die Werte übertragen und wieder schlafen gehen. Das ist nicht so, nicht so der Wahnsinn.

01:29:17.600 --> 01:29:25.600
Dann kann man sagen, wie lange das Ding schläft. Also sagen wir mal ne Stunde. Dann wacht es wieder auf, für 2 Sekunden was aus und schläft wieder.

01:29:25.600 --> 01:29:38.600
Und im Deep Sleep brauchen wir 11 mAh. Das heißt, das Ganze läuft, so wie es konfiguriert ist, würde das Ganze ungefähr 450 Tage laufen.

01:29:38.600 --> 01:29:46.600
Das ist schon mal recht ordentlich. Man kann das und jetzt kommen wir zu dem Punkt, warum ich das mit dem Ultra Low Power Prozessor mache.

01:29:46.600 --> 01:29:55.600
Die Sleep Time ist in Wirklichkeit viel, viel höher. Weil eigentlich ja nur der Ultra Low Power Prozessor mal kurz aufwacht,

01:29:55.600 --> 01:30:06.600
checkt, wie ist die Bodenfeuchtigkeit und sich dann wieder schlafen legt. Das heißt, es wird nicht jede Stunde einmal das hier verbrauchen,

01:30:06.600 --> 01:30:14.600
sondern das wird wahrscheinlich, keine Ahnung, 2 Mal am Tag 2 Sekunden das hier verbrauchen. Also sprich, das ist eigentlich viel, viel effizienter.

01:30:14.600 --> 01:30:25.600
Und man sieht schon, wenn man das hier hoch stellt, muss du nachher Assembly programmieren. AVR Assembly, ne, was auch immer AVR in dem Fall ist.

01:30:25.600 --> 01:30:34.600
Ich mach das über C-Macros erstmal, weil sonst müssten wir komische Dinge machen. Und brauchen wir einen extra Compiler Step und extra Tools zum installieren und sonst was.

01:30:34.600 --> 01:30:38.600
Ich versuche jetzt erstmal das mit den eingebauten C-Macros, die das für mich generieren. So.

01:30:38.600 --> 01:30:47.600
Also sagen wir mal schon, guck mal, schon alle 2 Stunden läuft das ganze schon viel, viel länger. So und alle 4 Stunden, sagen wir mal, ungefähr alle 4 Stunden ist eine realistische Zeit,

01:30:47.600 --> 01:30:56.600
wo das Ding mal aufwacht und 2 Sekunden was überträgt. Okay, das ist jetzt natürlich übertrieben. Aber sag mal mal so, 1, 2 Jahre sind da schon ganz, ähm,

01:30:56.600 --> 01:31:04.600
äh, welches Assembly? Ja, das Standard, ULP, frag mich nicht Assembly. Keine Ahnung, was für eine Sprache das ist.

01:31:04.600 --> 01:31:16.600
Das hier. Keine Ahnung, was das für ein Dialekt ist. Wahrscheinlich der eigene Chinesen Dialekt. Weil ich, wie gesagt, das Instruction Set hat 8 Befehle.

01:31:16.600 --> 01:31:38.600
Ungefähr. Das ist alles, der kann das nicht. Okay. 3,3 bis 5% pro Monat, das erscheint mir jetzt allerdings ganz schön viel.

01:31:38.600 --> 01:32:00.600
Selbstentladung. Also ich, also ich hätte jetzt eher so mit einem Prozent ungefähr 1-2% gerechnet. Na gut, wie gesagt, das hier ist natürlich jetzt auch die extreme Zahl.

01:32:00.600 --> 01:32:12.600
Deswegen sag mal 1-2 Jahre ist okay. 1-2 Jahre reicht ja aber auch. Da stöpft sich einfach eine neue Batterie an und gut ist.

01:32:12.600 --> 01:32:24.600
Ich sehe ja, wie lang es hält. Denn ja, wird es auf jeden Fall locker halten. Ähm, es ist auch davon auszugehen, dass ich die Batterie nicht bis zum allerletzten Rest verwenden kann.

01:32:24.600 --> 01:32:44.600
Weil der ESP32 braucht, ich glaube, mindestens als Input, als Spannung braucht es, glaube ich, mindestens 2,5 oder 2,7 Volt.

01:32:44.600 --> 01:32:58.600
Das heißt, achso Flow 690, das mach ich. Also die Spannung wird ausgelesen über den anderen AWC und wird mit übertragen, dass ich weiß, wann ungefähr die Batterie leer geht.

01:32:58.600 --> 01:33:15.600
Genau. Ähm, gut, also wir initialisieren unseren realen Output, wir gucken, wie wir aufgeweckt wurden, gehen wieder in Deep Sleep, wachen alle. Wir wachen gar nicht mehr auf. Warum sollen wir aufwachen?

01:33:15.600 --> 01:33:31.600
Der Ultra Low Power Processor soll uns hier aufwecken. Das heißt, wir gehen einmal initial an und dann starten wir unseren Ultra Low Power Processor. Und der weckt uns dann auf, wenn der Sensor einen gewissen Wert hat.

01:33:31.600 --> 01:33:50.600
So, und jetzt muss ich, jetzt muss ich spicken, weil den Teil hab ich im Vorfeld mir schonmal angeguckt und was zusammengebastelt. Weil das würde ich jetzt alles nicht, nicht, nicht aus dem Kopf hinkriegen. Also was, was wir jetzt schonmal machen müssen, ist erstmal wieder unseren analog digital Konverter initialisieren, richtig, wie wir es haben wollen.

01:33:50.600 --> 01:34:08.600
Ähm, by the way, das sind die Default Werte, also müssten wir an der Stelle jetzt eigentlich nicht. So, und jetzt, jetzt, jetzt kommen wir gleich zum, zum Assembler-Part. Dann müssen wir noch sagen, dass der Ultra Low Power Processor überhaupt auf den ADC zugreifen darf.

01:34:08.600 --> 01:34:37.600
No Happy Meal for you, exakt. IOT Graveyard. Deswegen ist es auch wichtig, dass das Ganze, ähm, möglichst, möglichst kompakt wird. Und aktuell hab ich hier so ein ESP, hab ich so ein Modul, plus hier, das was ich euch gezeigt hab, das LoRa Modul. Und den Sensor, also das ist wirklich ziemlich, ziemlich kompakt. Das passt in so eine kleine, kleine Box.

01:34:37.600 --> 01:35:05.600
So, ich bin wieder da. Ähm, das passt in so eine kleine Box. Und deswegen will ich es auch nicht mit Solarzelle machen. Es war so die ursprüngliche Idee, dass ich noch zusätzlich für die Batterie eine Solarzelle drauflege.

01:35:05.600 --> 01:35:20.600
Dann müsste ich, könnte ich mir nämlich diesen ganzen energiesparenden Kram sparen. Ähm, allerdings sieht eine Solarzelle, und selbst wenn es nur so eine kleine 15x15cm ist, sieht es halt auf dem Krab schon ganz schön bescheuert aus.

01:35:20.600 --> 01:35:32.600
Warum die Tastatur auf Englisch ist, ist sie nicht. Das ist Debated. Tastatur ist nicht auf Englisch.

01:35:32.600 --> 01:35:45.600
So, ich muss mich mal kurz auslassen. Okay, weiter geht's.

01:35:45.600 --> 01:36:10.600
Und die Box 3D Druckert er. Äh, ne, die Box hab ich mir gekauft. Das ist eine IP65-Box von Amazon. Äh, Wasserdicht, 3D Druck, so sehr trau ich meinem 3D Drucker noch nicht. Hab ich euch eigentlich schon das, das Alien-Entführungs-3D-Drucker-Bild gezeigt?

01:36:10.600 --> 01:36:28.600
Ähm, Iris von UFO hab ich ja noch geschrieben. Sieht echt so aus.

01:36:28.600 --> 01:36:40.600
Okay, ich zeig euch das. Ich hab nicht so viel gepostet. Da. Das da. Das sieht doch echt aus wie Alien-Entführung, oder?

01:36:40.600 --> 01:37:02.600
Because Aliens. Ähm, falls man das hier nicht richtig erkennt, das ist der Druckkopf von meinem 3D Drucker. Und der druckt auch keine Kloschüssel, sondern ein Rohr. So ein Teil von einem Rohr.

01:37:02.600 --> 01:37:13.600
Ähm, und da ist ein LED-Ring drum herum. Also sprich, hier vorne hängt ne Kamera dran. Am Druckbett. Eine Raspberry-Kamera.

01:37:13.600 --> 01:37:27.600
Und hier um den Druckkopf ist einfach so ne LED, LED-Ring. Der LED-Ring selbst ist an, ähm, dort angeschlossen, wo auch der Lüfter angeschlossen ist. Also sprich, geht an, wenn der Drucker aufgeheizt ist und geht dann wieder aus.

01:37:27.600 --> 01:37:39.600
Äh, wie viel hat der Drucker gekostet? Das ist eine der günstigeren Modelle gewesen. Das ist ne...

01:37:39.600 --> 01:37:50.600
Oder mit oder ohne S? Ne, ne, das ist Blödsinn. Das ist Blödsinn, das ist viel günstiger.

01:37:50.600 --> 01:37:58.600
Also ich bilde mir ein, ich hab 250... Ja, so, hier. So in dem, in dem... Äh...

01:37:58.600 --> 01:38:10.600
Also was auch immer, also die Preise sind ein bisschen merkwürdig gerade. Also ich bilde mir ein, ich hab irgendwas, glaub, um 250 oder so bezahlt bei Amazon dafür.

01:38:10.600 --> 01:38:20.600
Ja, die Dinger sind mittlerweile relativ günstig. Genau, und wie gesagt, er druckt keine Kloschüssel, sondern ein Rohr. Und das ist halt echt, echt nice, dass man dann quasi zugucken kann, auch im Dunklen.

01:38:20.600 --> 01:38:28.600
Da dran ist ne, äh, ne Raspberry mit Kamera. Ich hab ne Halterung ausgedruckt, wo man quasi die Raspberry-Kam direkt vorne ans Druckbett machen kann.

01:38:28.600 --> 01:38:42.600
Das heißt, das fährt immer mit. Und auf dem, auf dem Pi ist dann Octoprint drauf. Das heißt, ich kann auch immer nachgucken und die ganzen Sketches hochladen. Ne, wie heißt es bei 3D-Drucker? Sketches ist es bei Arduino. Was? Ähm...

01:38:42.600 --> 01:38:53.600
Wie heißen, wie heißen die Dinger bei 3D, die gesleißten Dateien? Also im Prinzip kann ich halt die Models, sag ich mal, hochladen zum 3D-Drucker direkt übers Web-Interfacer. Das ist echt sehr praktisch.

01:38:53.600 --> 01:39:06.600
Ja, Chico will nicht, dass man auf dem Kühlschrank zu nahe kommt. Ja, ist auch, ist ne Sie, aber der Ex-Besitzer, Besitzerin hat sie Chico genannt, was irgendwie überhaupt nicht passt.

01:39:06.600 --> 01:39:12.600
Ja, Chica hätte ich verstanden, aber Chico, Chico für ne Katten, was auch immer. Was auch immer man sich die Leute dabei denken, ist auch wurscht.

01:39:12.600 --> 01:39:25.600
Okay, komm mal zum Assempler-Part. Wir sind ja jetzt schon irgendwie gefühlt. Jetzt muss man selbst mal ne Uptime gucken. Uptime ist... Hab ich eigentlich den Chat eingeplendet, Leute? Sieht man den Chat?

01:39:25.600 --> 01:39:33.600
Ja, der Chat ist eingeplendet. Also, im Prinzip eine Stunde 40 und nichts großartig gemacht.

01:39:33.600 --> 01:39:46.600
Nice, dass du mal wieder streamst. Ja, ich sollte eigentlich viel öfter streamen. Darf ich fragen, worum es hier geht? Bist du noch da, Erhano?

01:39:46.600 --> 01:39:57.600
1907, da kann ich nämlich nochmal kurz anreißen. Ähm, okay. Also, nachdem sich hier mein Micro-Controller die ganze Zeit rebootet und neu startet, machen wir mal was.

01:39:57.600 --> 01:40:10.600
Ist das nicht NodeMCU? Das ist eine ESP32 NodeMCU. Du musst die allerdings nicht in Lua programmieren. Du kannst die ganz normal mit dem Standard Arduino Zeug programmieren.

01:40:10.600 --> 01:40:24.600
Was viel angenehmer ist. Einfach wurscht Studio Code, Plattform I.O. oder Alternative, wenn man es ein bisschen roher haben will, das Arduino Plugin installieren und gut ist.

01:40:24.600 --> 01:40:38.600
Man kann, wenn man ganz hart drauf ist, das ganze auch mit dem offiziellen ESP-Framework programmieren. Das ist dann allerdings nicht Arduino-Framework drunter, kein C++. Das ist Hardcore-C für alle C-Liebhaber.

01:40:38.600 --> 01:40:48.600
Wollte das nicht neu flashen? Ähm, du flashst das Ding bei jedem Programm neu. Achso, den Bootloader. Nee, musst du den Bootloader nicht neu flashen?

01:40:48.600 --> 01:40:59.600
Einfach Arduino-Zack draufflaschen, gut ist. Also muss ich nichts neu flashen. So, okay, machen wir weiter.

01:40:59.600 --> 01:41:12.600
Als nächstes, noch ganz kurz bevor wir zum Assembler-Part kommen ist, wir müssten dem Ding jetzt erstmal sagen, da habe ich mir die Befehle dafür schon rausgesucht.

01:41:12.600 --> 01:41:18.600
Wir müssen dem Ding erstmal sagen, dass er starten soll. So, und dazu müssen wir die passenden Header einbinden.

01:41:18.600 --> 01:41:32.600
Habe ich alle schon rausgesucht, sonst wird es nämlich viel zu lange dauern. So, das brauchen wir nicht.

01:41:32.600 --> 01:41:49.600
Was ist eigentlich der Unterschied zwischen Spitze-Klammern und Anführungszeichen? Wahrscheinlich ist Anführungszeichen C-Style und C++-Style und Klammern ist C-Style oder sowas, oder? Wie ist das?

01:41:49.600 --> 01:42:11.600
Habe ich jetzt irgendwas doppelt drin? Es sieht nicht so aus. Doch, Trivers-ADC habe ich doppelt drin.

01:42:11.600 --> 01:42:21.600
Ah, okay. Ah, verstehe, verstehe. Er sucht woanders seine Header-Dateien, okay.

01:42:21.600 --> 01:42:26.600
Ihr wisst ja, so oft bin ich jetzt hier im C++-Land auch nicht unterwegs.

01:42:26.600 --> 01:42:43.600
Gut, und jetzt muss ich ihm sagen, was er für ein Programm starten soll. Und, also wie gesagt, auf dem Low-Power-Coprocessor, was er für ein Programm starten soll. Und da wird es jetzt schon eine ganze Ecke mehr Low-Level.

01:42:43.600 --> 01:42:57.600
Als erstes muss man mal einen Array definieren, in dem die Assembler-Instruktionen reinkommen, die der Prozessor später ausführt. Das lassen wir jetzt erstmal leer. Wir starten den einfach nur.

01:42:57.600 --> 01:43:21.600
Und dann schreiben wir, doch wir schreiben Wake. Wir schreiben Wake, abschreiben wir rein. Wir lassen ihn einfach aufwecken. Mehr noch nicht. So, Datentyp muss irgendwie sein. Was hier? ULP, INSNT. Alter, was ist denn Name, ey? Das ist der Wahnsinn.

01:43:21.600 --> 01:43:37.600
So, und dann hier irgendwie Code. Das habe ich vorher schon mal ausprobiert, dass ich weiß, dass das funktioniert. So, und jetzt einmal kompilieren.

01:43:37.600 --> 01:43:52.600
Was habe ich jetzt hier verkehrt gemacht? Ist nicht initialisiert, warum nicht? Habe ich irgendwas vergessen? Ah, klar, ich habe ein Header-File vergessen.

01:43:52.600 --> 01:44:12.600
Wir stehen da. Funktioniert das nämlich auch? Okay. So, die einzige Instruktion, die wir da jetzt reinschreiben, ist Wake. Danach kommt unser ganzer Assembler-Code hier rein. Wir lassen ihn jetzt einfach nur aufwecken, die Haupt-CPU.

01:44:12.600 --> 01:44:25.600
Steht dem Co-Prozessor überhaupt die volle 12-bit-Auflösung zur Verfügung? Ja. Das ist der gleiche Konverter. Das ist exakt. Ist überhaupt kein Unterschied. Was eben nicht komplett zur Verfügung steht, ist der Speicher.

01:44:25.600 --> 01:44:42.600
Sondern nur 8 kilobit. Kilobyte. Kilobit? Weiß nicht. Wenig auf jeden Fall. Ich glaube 8 kilobyte. Ich glaube 8 kilobyte Speicher. Und diese 8 kilobyte Speicher teilen sich Programmcode und Werte, die man speichern muss.

01:44:42.600 --> 01:44:56.600
Das Schöne ist, der Speicher, dieser 8 kilobyte Speicher-Bereich, die sind, solange man den Controller nicht vom Strom trennt oder von der Batterie trennt, sind die per Systemt. Also sprich, die bleiben auch zwischen Deep Sleep erhalten.

01:44:56.600 --> 01:45:18.600
Der Stream bleibt online, ja. Klar. Und wenn er auf Twitch nicht mehr da ist, ist er immer noch auf der Archiv-Seite vom Sebaro. Okay. Als nächstes muss man, das ist jetzt eine Sache, die ich aus der offiziellen Anleitung habe, also es ist jetzt nicht so, dass ich die hier irgendwo kit hab, copy pasted hab. Hab ich auch, ja. Aber das ist aus der offiziellen Anleitung so, wie man es macht.

01:45:18.600 --> 01:45:37.600
Und zwar kann man ihm hier jetzt sagen, dass er ULP run, also sprich, dass die CPU starten soll. Das funktioniert so noch nicht. Dann muss ich ihm sagen, dass er eine Wake-Up-Period hat.

01:45:37.600 --> 01:45:52.600
Und zwar eine Wake-Up-Period von, was sind die Parameter, was auch immer, Index, da muss Null rein. Und dann alle, jede Sekunde, jede Sekunde soll er aufwachen.

01:45:52.600 --> 01:46:07.600
Und wohlgemerkt, jetzt reden wir nicht davon, dass der gesamte Controller jede Sekunde aufwacht, sondern nur der Ultra Low Power Prozessor wacht jede Sekunde auf. Und der Ultra Low Power Prozessor ist wirklich Ultra Low Power.

01:46:07.600 --> 01:46:26.600
Ich weiß gar nicht, ob das, ich müsste das mal mit dem Multimeter nachmessen, aber ich hab gelesen, er braucht irgendwas um 2, 3 bis maximal 5 oder 4 mA im Vergleich zu 50 bis 150 der komplette Controller, je nachdem, was man macht.

01:46:26.600 --> 01:46:41.600
Okay, also das Ding soll aufwachen, jede Sekunde. Jetzt muss man eben noch, dass ich copypaste mir das jetzt einfach mal, weil das ist nämlich das, was ich mir aus der offiziellen Anleitung auch schon copypastet hab.

01:46:41.600 --> 01:47:01.600
Man braucht eine Adresse, Einstieg, nennen wir das auch mal Program, man braucht eine Einstiegsadresse in diesem, in diesem 8 Kilobyte Speicher, die für diesen Ultra Low Power Prozessor gedacht sind und Einstieg ins Programm ist logischerweise, oder meistens bei Adresse Null, wäre ja auch irgendwie ziemlich bescheuert.

01:47:01.600 --> 01:47:21.600
Man könnte ein paar Variablen oder so vorher speichern. Hessen meldet sich zurück, ja, so sieht's aus. So, und jetzt kommt die eigentliche Geschichte, mit der man die, das Assemblerprogramm von hier oben, also das Assemblerprogramm wird aus den, ein paar Makros da erzeugt, mit dem man das lädt, und zwar damit.

01:47:21.600 --> 01:47:50.600
Man sagt, ähm, lade mal an Adresse Null das Programm, also die Assemblerbefehle, das ist, wenn man es so will, ist das so, wahrscheinlich so eine, so eine, so eine mini, mini, mini, ähm, Compiler noch mal im Hintergrund, der dann läuft, wenn ich das eigentliche Kompilieren anwerfe, der quasi hier aus meinen 10 Makros dann das eigentliche ULP Assemblerprogramm macht.

01:47:50.600 --> 01:48:02.600
Aber im Prinzip, Wake ist, also wenn man sich die Instruktions-Set anguckt, da ist Wake drinne. Also man benutzt hier wirklich die Assemblerinstruktion, die man auch in einem eigenen Assembler-File schreiben würde.

01:48:02.600 --> 01:48:20.600
Bloß, dass sie hier halt schön in 10 Makros gerappt sind. Äh, Flixcoder, was ich dir empfehlen kann, ist, also als Einstieg ist der NodeMCU auf jeden Fall gut, der ist, der ist relativ günstig, ähm, vor allem der ESP 2866, NodeMCU ist wirklich günstig.

01:48:20.600 --> 01:48:34.600
Also übrigens, ne, ich verwende hier grad zwar ein ESP32, aber, ähm, wer einfach nur ein bisschen rumspielen will, da kann sich natürlich auch hier bei Amazon einen noch günstigeren ESP, äh, 2866 bestellen.

01:48:34.600 --> 01:48:43.600
Der hat ein bisschen weniger Pins, ein bisschen weniger ADCs, von allem ein bisschen weniger. Allerdings ist das zum Rumspielen eine super, super billige Lösung, ja.

01:48:43.600 --> 01:48:55.600
Und was ich auch noch empfehlen kann, ist als Modul, wenn man es ein bisschen, ein bisschen kleiner haben will, ist der D1 Mini, und der ist wirklich klein.

01:48:55.600 --> 01:49:07.600
Der ist, der ist nur ein Drittel so groß wie der NodeMCU, hat aber alle wichtigen Pins und einen Analog-Digital-Converter auch drauf.

01:49:07.600 --> 01:49:19.600
Gratis E-Book, das schreiben, das schreiben die immer dabei, und Gratis E-Book. Das ist, das ist, das ist, ich, ich finde, die haben ein bisschen die Chance vertan, indem sie sich ADS Delivery genannt, genannt hätten.

01:49:19.600 --> 01:49:30.600
Die hätten sich doch auch ohne Probleme EATS Delivery nennen können, oder? Easy Clap Delivery, das wäre noch viel besser, anstatt ADS.

01:49:30.600 --> 01:49:37.600
Versteht wahrscheinlich außerhalb von Twitch keiner, aber ich fände es besser. EATS Delivery, als bisher auch immer.

01:49:37.600 --> 01:49:42.600
Genau, hier 8 Kilo, 8 Kilobyte Speicher hat man, steht hier übrigens noch mal da.

01:49:42.600 --> 01:49:47.600
So, und jetzt können wir ja eigentlich mal probieren, ob das Ganze funktioniert.

01:49:47.600 --> 01:50:08.600
Also von der Idee her, mal gucken, ob das Scheiß kompiliert. Macht's. Also von der Idee her sollte alle, wir machen mal alle 10 Sekunden, sollte mein Controller alle 10 Sekunden vom Ultralow-Power-Prozessor geweckt werden.

01:50:08.600 --> 01:50:18.600
Machen wir mal jede Sekunde und oder alle 3 Sekunden aufwachen und wieder einschlafen.

01:50:18.600 --> 01:50:34.600
Da passiert jetzt zwar nicht allzu viel, allerdings, wenn das schon mal funktioniert, dann können wir weitermachen.

01:50:34.600 --> 01:50:51.600
Das NodeMCU-Developer-Bord ist so groß wie mein Daumen. Ach so, ziemlich breiten Daumen. Er wacht nicht auf. Oder? Ach so, ha.

01:50:51.600 --> 01:51:00.600
Moment. Okay, jetzt muss ich mal ein bisschen Debug-Ausgaben machen und natürlich Debug-Ausgabe, so ganz klassisch wie man das macht, per...

01:51:00.600 --> 01:51:19.600
VS Code ist viel besser, VS Code ist richtig angenehm. Die Arduino IDE ist shit.

01:51:19.600 --> 01:51:39.600
Ah, ich hab das Wichtigste vergessen. Ich hab's vorher noch groß erzählt. Man muss ihm natürlich sagen können, ULP-Wake-Up, man muss ihm natürlich noch sagen können, dass der ULP ihn überhaupt aufwecken darf.

01:51:39.600 --> 01:51:51.600
Deswegen funktioniert das auch gar nicht. Space-Leap-Enable-ULP-Wake-Up. Die Dinger sind alle relativ sprechend benannt. Und jetzt wird's wahrscheinlich auch funktionieren.

01:52:09.600 --> 01:52:17.600
Irgendwie funktioniert das nicht, oder?

01:52:39.600 --> 01:52:53.600
Ah, jetzt funktioniert's. Was auch immer gewesen ist. Keine Ahnung, aber jetzt funktioniert's. Also man sieht, dass alle drei Sekunden wird der Controller jetzt aufgeweckt.

01:52:53.600 --> 01:53:11.600
Oh, was sehen meine Augen, ein wildes Max am CM-Battle-Programm. Ja, so sieht's aus. Oh, und Assembler. Ja, ne? Vollen Kiosk. Es funktioniert. Alle drei Sekunden wird mein Controller aufgeweckt. Vom Ultra-Low-Power-Prozessor.

01:53:11.600 --> 01:53:27.600
Sehr schön. Und danach geht er wieder schlafen. Ich mach mal hier Delay. Ich glaube, ich hab nix gesehen, weil das Delay nach dem Initialisieren von der seriellen Verbindung nicht da war.

01:53:27.600 --> 01:53:45.600
Das heißt, sprich, er ist aufgewacht, hat aber nix rausgeschrieben. Probieren wir das Ganze noch mal aus, jetzt ob's funktioniert. Er hat immer noch nicht subben. Ne. Ich darf jetzt auch nicht mal gesubbt werden, weil ich wieder meine Partnergeschichte verspielt hab, indem ich nicht auf genug gestrebt hab.

01:53:45.600 --> 01:54:00.600
Okay, es funktioniert. Es wacht auf alle drei Sekunden. Das heißt, so unsere Standard, der Ablauf an sich funktioniert. Das Ding wird geflasht, beziehungsweise wird einmal eingeschaltet oder resettet mit dem Reset-Knopf.

01:54:00.600 --> 01:54:24.600
Er startet den ULP und geht und schläft. Der ULP, der Low-Power-Prozessor, wacht alle drei Sekunden auf und startet die zwei Haupt-CPUs. Also wenn ich da als Multimeter dranhalten würde, würde ich wahrscheinlich immer noch relativ viel messen, weil es halt über USB angeschlossen ist.

01:54:24.600 --> 01:54:34.600
Deswegen, die Node-MCUs sind nicht unbedingt für Batteriebetrieb gedacht. Aber wie gesagt, da kommt ja, wenn es fertig ist, eh ein anderes Board dran, was halt viel weniger verbraucht.

01:54:34.600 --> 01:54:49.600
Also jetzt dürfte ich wahrscheinlich im Deep Sleep kaum was messen. Wahrscheinlich für die kurze Zeit, da macht er nix anderes außer einen Wake ausführen. Wahrscheinlich drei Sekunden lang elf Microampere. Also wirklich sehr wenig.

01:54:49.600 --> 01:55:05.600
Okay und jetzt können wir anfangen unser Assembler-Programm zu programmieren. Kann man der Sache so halbwegs folgen? Weil es fällt mir selbst schwer, irgendwie den Überblick zu behalten.

01:55:05.600 --> 01:55:24.600
Aber zumindest was wir machen ist jetzt ja bis jetzt noch relativ simpel. Angehen, Low-Power-Prozessor starten, Sleep an. Low-Power-Prozessor wacht auf, weckt Main-Core, Main-Core stellt fest, er wurde vom Ultra-Low-Power-Prozessor weg, geht wieder schlafen.

01:55:24.600 --> 01:55:35.600
Drei Sekunden später, wird wieder aufgeweckt, geht wieder schlafen. Drei Sekunden später, wird wieder aufgeweckt, geht wieder schlafen. Also passiert nicht allzu viel.

01:55:35.600 --> 01:55:59.600
Ne, Affiliate ist doof. Wahrscheinlich kriegste keinen ordentlichen Share und du kriegst so wenig Emotes. Also wenn schon, wenn schon. Wenn schon, denn schon, denn dann richtig gepartnert. Vor allem einmal Partner, immer Partner. Der Assembler-Clickbait, da ist nichts Clickbait. Hier, da. Und jetzt gehts nämlich los. Jetzt wirds Assemblermäßig.

01:55:59.600 --> 01:56:20.600
Also, von der Idee her, was ich jetzt machen möchte ist, quasi hier drinnen, also in dem Assembler-Programm, das mein Low-Power-Prozessor ausführt, möchte ich den hier ADC1 auslesen.

01:56:20.600 --> 01:56:37.600
Den Analog-Digital-Converter 1 will ich auslesen. Und wir machen das erstmal ganz einfach. Ich lese das aus, schreibe es in Speicher, wecke den Haupt-Controller auf und gebe aus, was ich ausgelesen hab.

01:56:37.600 --> 01:56:53.600
Nein, das mit Partnerschaft verspielt, mein ich nicht so. Ich war doch noch nie Partner. Partnerschaft verspielt, mein ich, du darfst dich nur als Partner bewerben, wenn du ein gewisses Kontingent gestreamt hast.

01:56:53.600 --> 01:57:08.600
Ich könnte mich auch so Partner bewerben, weil ich könnte immer noch sagen, ich hab schon einen Follower auf Twitter und YouTube. Das würde wahrscheinlich auch funktionieren, aber ich sollte schon so in dem Modus sein, dass ich auch halbwegs oft streame. Alles andere wäre irgendwie blödsinnig.

01:57:08.600 --> 01:57:19.600
Und wenn du einmal Partner bist, kannst du die Partnerschaft eigentlich nicht mehr verlieren, es sei denn, du, was weiß ich, machst komische Dinge, was Twitch halt für dich passend hält für die Plattform.

01:57:19.600 --> 01:57:38.600
So, für was brauchst du ein Wassersensor? Kios, das können die Leute wahrscheinlich wunderbar erklären, weil das hab ich schon zehnmal oder so mittlerweile erzählt. Für Bodenfeuchtigkeit auslesen, kurz gesagt.

01:57:38.600 --> 01:57:52.600
Okay, also, jetzt müssen wir als erstes, okay, wir brauchen das Instruktionsset von voller CPU. Und die CPU kann nicht allzu viel.

01:57:52.600 --> 01:58:16.600
Nur, die kann addieren, subtrahieren, and or, left-shift, right-shift, pushen, also Dings, Werte von einem Register ins andere schieben, Werte aus dem Register ins Speicher schreiben, aus dem Speicher Werte ins Register schreiben,

01:58:16.600 --> 01:58:35.600
zu einer absoluten Adresse springen, mit Offset-Jump und irgendwelche Condition-Jumps, eine Schleife machen, das ist ja auch schonmal was, was schon, nicht jedes Ding kann, Schleife, sich beenden, den Hauptprozessor aufwachen,

01:58:35.600 --> 01:58:54.600
ähm, nichts tun, ne, gewisse Taktanzahl, Temperatursensor auslesen, WTF, wusste ich gar nicht, dass das Ding einen hat, probieren wir dann auch gleich mal, und das ist das, was wir machen wollen, ADC abfragen, das wollen wir machen,

01:58:54.600 --> 01:59:06.600
dann kann es noch iSquare-C-Buzz-Geschichten auslesen und irgendwelche Register schreiben, also man sieht, der kann nicht wirklich viel, also es hält sich wirklich in Grenzen.

01:59:06.600 --> 01:59:33.600
Ach, stimmt, der Bot ist kaputt, der Nightbot ist kaputt, Moment, Moment, ich mach den Nightbot, ich schalte den Nightbot wieder ein, Moment, wir testen mal, ob der Nightbot wieder geht, ja, der Nightbot geht wieder, der ist rausgegangen aus dem Chat, weil ich so lange nicht gestrebt hab.

01:59:37.600 --> 01:59:48.600
Mach die coole Variante, Assembly, dein Assembly-Programm, ja, was, weil ich alles machen kann, ähm, okay, also, wir brauchen das Instructionset.

01:59:48.600 --> 02:00:15.600
Das erste, was wir jetzt machen wollen, ist, mal eine Variante initialisieren, und zwar, das hab ich mir auch schon rausgepastet, wie das funktioniert, wie gesagt, wir haben hier acht Kilobyte, ähm, so, halb RAM, also RAM, der Deep Sleeps überlebt, leider halt nur acht Kilobyte, und, ähm, den kann man ansprechen hiermit.

02:00:18.600 --> 02:00:46.600
Damit, das ist ein Byte Array quasi, ähm, oder besser gesagt, ein In 32 Array, was übrigens auch ganz lustig ist, der, also der Ultra Low Power Prozessor, der hat, macht alles in 32 Bit, also sprich, die Befehle sind 32 Bit, und, und, die Adressen sind 32 Bit, und, aber, die Werte selbst sind 16 Bit.

02:00:46.600 --> 02:01:00.600
Er speichert sie allerdings in 32 Bit, das heißt, man muss immer die oberen 16 Bit wegwerfen, damit man die unteren 16 Bit auslesen kann, ganz wir, das, China-Kram, aber sie werden schon irgendeinen Grund dafür haben.

02:01:01.600 --> 02:01:10.600
Verdient man als Informatiker wirklich so vieles komplett, darauf anerstens, was für ein Informatiker man ist, äh, und viel mehr, was man macht und wo man ist.

02:01:10.600 --> 02:01:30.600
So, ähm, und dieses RTC, das ist, das steht wahrscheinlich für Realtime, äh, Clock, aber was auch immer das mit Clock zu tun hat, äh, also Realtime Memory, und das ist halt ein Array von eins bis, äh, von null bis 8.096 oder so.

02:01:30.600 --> 02:01:46.600
Und, wobei, die sind 32 Bit, das sind so, bis 2048, was auch immer, ist egal, ähm, wir nehmen jetzt einfach mal Speicherplatz 34, weil, und initialisieren das mal auf null.

02:01:46.600 --> 02:02:00.600
Und jetzt wird's interessant, jetzt müssen wir laden aus diesem Memory in Assembler. So, laden tun wir mit LD, also sprich, ILD.

02:02:01.600 --> 02:02:06.600
So, jetzt müssen wir das Register angeben, also übrigens Register hat das Ding gerade mal vier Stück.

02:02:06.600 --> 02:02:28.600
Wo verdient man denn am meisten? Also, ich glaub, aktuell am meisten verdient man entweder als Anwendungsentwickler in einer Sprache, die sonst keiner mehr kann, sowas wie Kobol, wenn man da noch Glück hat, oder was auch sehr beliebt ist im Security-Umfeld, wenn man da, wenn man da was kann.

02:02:28.600 --> 02:02:44.600
Oder eben, weil's gerade Hype ist, Cloud und Kubernetes-Gedöns ist auch sehr angesagt aktuell. Aber man kann in allem eigentlich, wenn es halt was ist, was nicht jeder kann, obwohl's ein bisschen schwierig ist, Leute zu finden, kann man eigentlich in allen Sachen ganz gut, ganz gut Geld verdienen.

02:02:44.600 --> 02:03:01.600
Es ist, wenn man halt 0.8.15 Windows-Systeme administrieren kann, dann ist es nicht so der Wahnsinn, weil davon gibt's jede Menge. Und auch, wenn man 0.8.15 Linux-Systeme administrieren kann, davon gibt's zwar weniger, aber gibt's auch immer noch genug.

02:03:01.600 --> 02:03:20.600
Im DevOps-Bereich kann man auch ganz gut was verdienen, also sprich, wenn man sowohl ganz gut ist, was Operating angeht, also sprich, das Administrative und das Betriebssystem-mäßige, plus, wenn man dann auch gut programmieren kann und dort an der passenden Stelle sitzt, kann man auch ganz gut was verdienen.

02:03:20.600 --> 02:03:35.600
Du hast nur die 34. Stelle mit 0 beschrieben, richtig. Also, diese 32, spit, hier, also, na, quasi auf diese, diese, äh, 8? 4 byte, ne? Diese 4 byte Speicherplatz, da steht jetzt im Prinzip nur 0 drinne aktuell.

02:03:35.600 --> 02:03:50.600
So, und jetzt laden wir das Ganze mal in unseren, was hab ich gesagt, DevOps? DevOps-Holz. RIP-Ops. DevOps, das wär, das, äh, gut, bei manchen Firmen ist DevOps-Holz, aber bei anderen Firmen ist DevOps-Holz.

02:03:50.600 --> 02:04:05.600
Ich muss immer aufpassen, dass ich nicht einmal ein Wasserglas, wo das Sensor drinnen steckt, trinke, weil ich hab' durst und hab' mir so, denk mir so, ey, trinke ich zwar was, aber ich will nicht unbedingt das Glas trinken, wo der China-Plastik-Sensor drinnen steckt.

02:04:05.600 --> 02:04:19.600
Ja, Sunset hat es auch recht. Ja, diese ganze, äh, äh, äh, Data Science, äh, und, und, äh, was schreibt der Data Engineering, diese Geschichte, das ist auch, es ist, im Prinzip kann man das gar nicht so klar sagen.

02:04:19.600 --> 02:04:34.600
Ja, genau, weil wir ja, der Maschinen-Learning ist auch so, das AI-Geschichten, ähm, es kommt ganz auf den Laden an, und ganz was man macht, und das ist halt auch entscheidend, davon abhängig, was man kann und wie gut man halt Sachen kann, die nicht jeder 0815 hat.

02:04:34.600 --> 02:04:48.600
Und außerdem, was, auch was wahrscheinlich noch viel wichtiger ist, wovon man sogar relativ wenig Einfluss drauf hat, ist, in welcher Region man ist, und, ähm, wie händeringend in der Region was gesucht wird.

02:04:48.600 --> 02:05:02.600
Ja, in Frankfurt hast du ja quasi an jeder Ecke, wo du hinspuckst, äh, Rechenzentren, IT-Läden, sonst was. Da finden sie keine Leute mehr. Also, es, es, ist quasi, äh, ausgetrocknet, wenn du das so willst.

02:05:02.600 --> 02:05:17.600
Wenn du da noch Leute haben willst, musst du halt ordentlich in die, ordentlich in die Tasche graben. Aber wenn du jetzt auch mal in vielleicht anderen Gebieten bist, wo es nicht so viel gibt, dann sieht es vielleicht anders aus.

02:05:17.600 --> 02:05:31.600
Okay, also, wir laden jetzt Speichern. Wir laden jetzt in Register R0. Das Ding hat nur vier Register. Ein Register ist quasi, ähm, ein Speicherplatz in der CPU.

02:05:31.600 --> 02:05:47.600
Also, man kann sich das vorstellen, wie eine Variable direkt in der CPU. Also sprich, ein Speicherbereich in der CPU, wo ich halt mein Kram rein schreiben kann.

02:05:47.600 --> 02:06:00.600
Ähm, also, wir laden jetzt in Register 0 von Adresse 34. Moment, da muss ich vorher, so mit meinen krassen Assembler-Kenntnissen, muss ich vorher erst mal Adresse 34 in ein anderes Register laden.

02:06:01.600 --> 02:06:04.600
Da muss ich mal, muss ich mal spicken, ob das stimmt, was ich hier gesagt habe.

02:06:04.600 --> 02:06:18.600
Ja, genau. Also, ich muss zuerst mal, also, in Register 3 laden wir jetzt die, das ist halt, jetzt wird es halt eklig, ne?

02:06:18.600 --> 02:06:33.600
Nee, das stimmt nicht. Ich will kein Register, ich will den festen Wert laden. Also, ich will in Register 3 34 laden. 34. 34, also, ich will in Register 3 34 laden.

02:06:33.600 --> 02:06:58.600
Nee, das stimmt nicht. Ich will kein Register, ich will den festen Wert laden. Also, ich will in Register 3 34 laden. 34. 34 ist, ähm, der Index, also, der Speicher, der Speicher-Offset, in dem ich meine, meine Werte lesen und schreiben will.

02:07:03.600 --> 02:07:22.600
So. Also, Offset 34. Das heißt, ich schreibe jetzt den Wert 34 in Register 3. So. Und jetzt sage ich mir, jetzt sage ich ihm, lade, das muss man sich jetzt erst mal hier auf der Zunge zergehen lassen,

02:07:22.600 --> 02:07:35.600
weil das ist das, was unter der Haube millionenfach auf jedem Rechner passiert, ähm, was, glaube ich, den meisten Leuten je verwehrt bleibt, das überhaupt zu verstehen, dass es sowas überhaupt gibt, ja?

02:07:36.600 --> 02:07:47.600
Ähm, und was unter der Haube auch jede moderne Programmiersprache weg abstrahiert von einem, damit ich was laden kann. Und ich meine, manche Leute haben schon mit Zeigern in C ihre Schwierigkeiten.

02:07:47.600 --> 02:07:54.600
Das ist nochmal eine ganze Ecke abgedrehter. Oder, es ist eigentlich gar nicht abgedrehter. Es ist eigentlich nah an dem dran, was so eine CPU halt macht.

02:07:55.600 --> 02:08:05.600
Ich muss ihm jetzt sagen, okay, nehme den Wert 34. Das ist einfach ein Int. Das ist eine Zahl. Ne Zahl, nehme den Wert 34 und schreibe sie in Register 3.

02:08:06.600 --> 02:08:15.600
Das macht man mit Move. Das macht man in ziemlich allen Assembler-Dialekten mit Move. Ähm, also nehme die Zahl 34. Also, im Prinzip in C würde das quasi so aussehen.

02:08:15.600 --> 02:08:39.600
Schreibe mal ein paar Kommentare dahinter, dass man versteht, was da passiert. So. Ähm, also, Register 3 steht jetzt 34 drin. Und jetzt sage ich ihm, lade in das Register R0 das, was in Speicherbereich, in dem Speicherbereich, in der Speicheradresse liegt, die in Register 3 steht.

02:08:45.600 --> 02:08:57.600
Also sprich, hier in dem Register steht die Adresse vom Speicher. Und hier sage ich ihm, lade das in Register 0, was in dieser Adresse steht. Versteht man eigentlich. Ist eigentlich relativ simpel.

02:08:58.600 --> 02:09:10.600
Ähm, ja ja Leute, jetzt lassen wir die Kirche im Dorf. Ähm, es ist vom Ablauf her prinzipiell simpel, weil du jeden Furz sagen musst. Komplexe Sachen damit zu machen, ist trotzdem Gehirnfuck ohne Ende.

02:09:10.600 --> 02:09:20.600
So. Ähm, ok, jetzt haben wir eben gesagt, lade mal das, was in diesem Speicher drin steht. Das sollte jetzt ja in dem Fall 0 sein, weil wir haben ja 0 reingeschrieben.

02:09:20.600 --> 02:09:40.600
Ja. Das hier ist ja immerhin unser Programm, was auf dem, was auf der Low-Power-CPU läuft. Das hat ja mit dem Rest hier nichts zu tun. Ich setze den Wert nur initial, einmal bevor ich die CPU starte, auf 0. Und hier lese ich ihn ein. Also eigentlich sollte das da jetzt 0 drinstehen.

02:09:40.600 --> 02:10:02.600
Nicht weil hier hinten 0 steht, dass es der Speicher aufsetzt, sondern weil ich hier 0 reingeschrieben habe. Also an die Adresse, nennen wir einfach mal Adresse 34. Ähm, wird jetzt quasi eingelesen in Register 0. Was mir jetzt gerade auffällt, ist eigentlich total beknackt. Brauche ich überhaupt nicht. Na gut, wie dem auch sei. Schön, dass wir es mal eingelesen haben.

02:10:02.600 --> 02:10:22.600
Null. Brauche ich überhaupt nicht. Egal. Wir haben es eingelesen. Hauptsache. So, was wir jetzt machen wollen, ist, jetzt gucken wir mal wieder ins Instruktions-Set. Wir wollen unseren ADC auslesen. So, und wir wissen, dass wir ADC 1, Channel 6 auslesen wollen. Das haben wir hier oben, oben schon ja eingestellt. Und ADC 1, Channel 6 ist PIN 34. Weil die Chinesen gedacht haben, das ist eine sinnvolle Idee, das alles anders zu machen.

02:10:22.600 --> 02:10:31.600
Okay. Ähm, und jetzt wollen wir ADC. Das ist ein Kommando, den die CPU kann. Das ist, das muss man in dem Fall unterscheiden zu einem Funktionsaufruf.

02:10:31.600 --> 02:10:55.600
Ein Funktionsaufruf ist ne Sache, die, die, ne Funktion ist was, was man selber gebastelt hat oder nen Framework-Entwickler, nen Library-Entwickler für einen gebastelt hat. Das ist ein Funktionsaufruf. Und das ist ein Funktionsaufruf.

02:10:55.600 --> 02:11:00.440
Die Funktion ist was, was man selber gebastelt hat oder einen Framework-Entwickler, einen

02:11:00.440 --> 02:11:02.360
Library-Entwickler für einen gebastelt hat.

02:11:02.360 --> 02:11:07.000
Das ist im Prinzip auch einfach nur ein Startpunkt im Speicher, wo dann dahinter Instruktionen

02:11:07.000 --> 02:11:08.000
stehen.

02:11:08.000 --> 02:11:10.600
Eine Funktion mit einem Namen dran.

02:11:10.600 --> 02:11:20.040
Das hier ist wirklich der Befehl, der direkt der CPU sagt, was sie machen soll und was

02:11:20.040 --> 02:11:21.040
sie machen kann.

02:11:21.040 --> 02:11:24.360
Ich kann hier nicht einfach einen Befehl reinschreiben, den die CPU nicht kann.

02:11:24.360 --> 02:11:28.600
Also sprich, die CPU hat, man kann sich das so vorstellen, so eine Mini-Mini-Mini-Firmware

02:11:28.600 --> 02:11:37.600
drinne, jede CPU, wo halt alle Opcodes und Operation-Geschichte definiert sind.

02:11:37.600 --> 02:11:42.080
Das ist unter anderem auch das, nicht dass ich Mist erzähle, korrigiert mich, wenn ich

02:11:42.080 --> 02:11:47.800
Mist erzähle, was Intel ab und zu mal patcht, wenn es Probleme gibt mit den CPUs.

02:11:47.800 --> 02:11:51.240
Also wir sind mittlerweile so weit, dass CPUs auch sowas wie eine Firmware haben.

02:11:51.240 --> 02:12:00.160
Und das ist mehr oder weniger direkt das Kommando, was die CPU ausführt.

02:12:00.160 --> 02:12:06.080
Das heißt, wenn die CPU nicht die Funktion hätte oder diesen Code nicht verstehen würde,

02:12:06.080 --> 02:12:08.520
ADC auslesen, würde das nicht funktionieren.

02:12:08.520 --> 02:12:11.440
Also ich sag der CPU jetzt schon ganz genau, was sie machen soll.

02:12:11.440 --> 02:12:16.800
Ich sag hier jetzt zum Beispiel, okay, ich möchte einen Analog-Digital-Konverter lesen

02:12:16.800 --> 02:12:23.840
und zwar macht man das mit ADC, haben wir hier gerade nachgeguckt, der Code ist ADC,

02:12:23.840 --> 02:12:28.880
man muss eben sagen, in welches Register der Wert gespeichert werden soll, also R0, wobei

02:12:28.880 --> 02:12:36.720
R0 haben wir, nee R0 haben wir nicht, in Register 0, der Index vom ADC, wie gesagt, die, ich

02:12:36.720 --> 02:12:40.960
hab ja schon gesagt, die Chinesen haben es nicht so mit Benahmung, ADC 1 Channel 6 ist

02:12:40.960 --> 02:12:51.720
in Wirklichkeit GPIO 34 und hier ist es wieder anders da, hier ist es ADC Index 0, Pad 6,

02:12:51.720 --> 02:13:09.720
weil, man weiß es nicht, weil, so, jetzt haben wir den Wert hier eingelesen und jetzt werden

02:13:09.720 --> 02:13:16.560
wir einfach diesen Wert, den wir gelesen haben, den der ADC gelesen hat, diesen Wert werden

02:13:16.560 --> 02:13:24.640
wir jetzt hier in das RAM schreiben, in den Speicher schreiben, danach wecken wir die zwei

02:13:24.640 --> 02:13:28.840
Haupt-CPU Kerne auf und geben den Inhalt aus.

02:13:28.840 --> 02:13:41.240
Soweit die Idee, also, Memory speichern, weiß gar nicht, für was ST genau steht, für was

02:13:41.240 --> 02:13:48.320
steht ein ST genau, Store, Store, genau und da muss man jetzt sagen, ok, ich möchte es

02:13:48.320 --> 02:13:59.760
speichern in Value, genau, ich möchte den Wert, der in Register 0 steht, möchte ich

02:13:59.760 --> 02:14:05.840
an die Adresse speichern, die in Register 3 steht, ohne Offset, ist am Anfang ein bisschen

02:14:05.840 --> 02:14:11.880
konfus, aber ergibt eigentlich doch Sinn, wenn man sich da ein bisschen Gedanken drüber

02:14:11.880 --> 02:14:12.880
macht.

02:14:12.880 --> 02:14:17.520
So, jetzt haben wir das da reingeschrieben, gucken wir, ob der ganze Kram kompiliert und

02:14:17.520 --> 02:14:32.720
irgendwie direkt abkackt oder so, sollte der jetzt nicht aufwachen?

02:14:32.720 --> 02:14:40.480
Ich glaube nicht, dass es kaputt ist, ich glaube irgendwie, dass es rumspackt gerade,

02:14:40.480 --> 02:15:00.880
ich drücke mal Reset kurz, ne Reset, ah, ich glaube ich habe vergessen mich zu beenden,

02:15:00.880 --> 02:15:28.320
kann das sein, was, was schreibt der da immer mit, von wegen NoHandlerFound, ah ja, ok funktioniert,

02:15:28.320 --> 02:15:36.680
ok, und jetzt lesen wir die Variable einfach mal aus und gucken, anstatt Init geben wir

02:15:36.680 --> 02:15:46.920
mal die Variable aus und gucken, ob das funktioniert, da sollte jetzt der Wert vom ADC drin stehen,

02:15:46.920 --> 02:15:51.720
ach ne, ha, ich habe was vergessen, ich habe doch gesagt, ich muss die oberen 16 Bit wegwerfen,

02:15:51.720 --> 02:16:03.280
0 passt, 0 ist ok, ja, ich muss die oberen 16 Bit wegwerfen, sonst ergibt es keinen Sinn,

02:16:03.280 --> 02:16:07.280
aber man hat schon gesehen, dass es prinzipiell funktioniert, weil am Anfang stand da 0 drin

02:16:07.280 --> 02:16:16.200
und jetzt steht da 4395007 drin, ich muss aber die oberen 16 Bit wegwerfen, weil zwar bei

02:16:16.200 --> 02:16:20.360
diesem ULP, bei dieser CPU alles in 32 Bit funktioniert, allerdings die Werte selbst

02:16:20.360 --> 02:16:27.120
irgendwie nur die unteren 16 Bit von 32, von einem Int verwenden, ich kann es nicht erklären

02:16:27.120 --> 02:16:32.280
warum, das wäre wahrscheinlich sonst auch viel zu einfach gewesen, so, und das ist relativ

02:16:32.280 --> 02:16:39.960
simple, kann man einfach sagen, und, und dann kann man hier an der Stelle sagen, uint16max

02:16:39.960 --> 02:16:46.720
oder alternativ könnte ich auch sagen ff, geht glaube ich auch, ja, müsste im Prinzip

02:16:46.720 --> 02:16:55.280
das gleiche sein, so, und da sollte jetzt der Wert vom ADC rauskommen, also irgendwas

02:16:55.280 --> 02:17:03.800
um, da steckt immer noch im Wasser irgendwas um 170 rum, ah, es könnte sein, dass es nicht

02:17:03.800 --> 02:17:08.960
funktioniert, haha, es könnte sein, dass, ich habe den GPIO Pin noch nicht gesetzt,

02:17:08.960 --> 02:17:16.000
es könnte sein, dass es nicht funktioniert, ja, guckt, also, aber doch, wir wissen, dass

02:17:16.000 --> 02:17:22.880
es prinzipiell geht, der ADC liest 4095, das liegt daran, weil ich den GPIO Pin nicht

02:17:22.880 --> 02:17:35.200
geschaltet habe, deswegen stöpsel ich das jetzt gerade mal um, und zwar von GPIO 27

02:17:35.200 --> 02:17:49.440
wieder richtig auf Ground, dann, dann funktioniert es auch, guckt, haha, seht ihr es, funktioniert,

02:17:49.440 --> 02:17:58.960
ah, also, funktioniert alles, wenn ich, ich nehme es jetzt mal aus dem Wasserbecher raus,

02:17:58.960 --> 02:18:02.880
wir machen jetzt mal, wir machen jetzt mal, dass das Ding nicht so oft aufwacht, alle

02:18:02.880 --> 02:18:09.480
10 Sekunden reicht das mal, so, alle 10 Sekunden soll das Ding jetzt aufwachen, alle 10 Sekunden,

02:18:09.480 --> 02:18:16.560
also das Ding liest jetzt im Low Power Modus, ohne dass die Haupt CPU Strom verbraucht, liest

02:18:16.560 --> 02:18:25.040
das den ADC aus, den Wert, speichert es im Speicher und weckt die Haupt CPU auf, das

02:18:25.040 --> 02:18:30.760
ist natürlich so an sich jetzt so nicht sonderlich, sonderlich nützlich, ahm, da fehlt noch ein

02:18:30.760 --> 02:18:34.440
bisschen Logik, aber ich glaube die Logik komplett kriegen wir nicht hin, weil ich hab

02:18:34.440 --> 02:18:40.680
hier ne Pizza stehen und ich hab übeles Hunger, aber mal gucken, wie weit wir kommen, so und

02:18:40.680 --> 02:18:45.160
jetzt mach ich, guckt euch den Wert an, jetzt mach ich den Sensor, den Sensor mal raus, wir

02:18:45.160 --> 02:18:51.360
machen mal die Ausgabe noch ein bisschen schöner, machen wir irgendwie sowas, ich mach ganz

02:18:51.360 --> 02:18:55.440
gerne machen, sind Gleichzeichen drüber, dass man sieht, dass es jetzt losgeht, das andere

02:18:55.440 --> 02:19:06.560
ist Bootloader Debug Ausgabe, also es geht an dem Chat ab, übelste, übelste, Assembler

02:19:06.560 --> 02:19:16.400
Diskussion, ja, ja, siehste, da kennt ihr euch besser aus als ich, ich hab da jetzt nicht

02:19:16.400 --> 02:19:22.840
so viel Erfahrung was Assembler angeht, man kann auch CPU selber basteln, viel Spaß,

02:19:22.840 --> 02:19:40.960
GLHF, außer mit nem rechten Schieber, das warte ich noch drauf, die Holz-CPU, so jetzt

02:19:40.960 --> 02:19:48.080
zieh ich das mal aus dem Wasser raus und beim nächsten Wake Up, guck 3575, warten wir noch

02:19:48.080 --> 02:19:58.200
mal den Wake Up ab, noch mal 10 Sekunden, ja, so, 8000, so wir haben gesagt, Maxivalwert

02:19:58.200 --> 02:20:05.400
ist ungefähr 3800, das kommt so ungefähr hin, so und jetzt stöpseln wir das mal wieder

02:20:05.400 --> 02:20:08.920
rein und jetzt sollte der Wert langsam runtergehen, weil ich schalte hier immer noch nicht an

02:20:08.920 --> 02:20:21.720
und aus, ja, der Wert geht langsam wieder runter, das ist natürlich sehr schön, das

02:20:21.720 --> 02:20:26.640
funktioniert, so, also wir haben jetzt unser erstes Assembler Ding zusammen gewurstet,

02:20:26.640 --> 02:20:34.160
bei Online-Games sieht man doch oft Leute mit Holz-CPU, wo man oft Leute mit CPU sieht

02:20:34.160 --> 02:20:39.240
in irgendwelche Minecraft, wie heißt das in Minecraft, Redstone Geschichten, da hab

02:20:39.240 --> 02:20:42.840
ich schon Videos gesehen, die haben irgendwie gefühlt hunderter Kilometer Minecraft voll

02:20:42.840 --> 02:21:03.720
gebaut, um quasi in Redstone eine Art CPU zu bauen, so, da haben wir ein bisschen Mini-Assembler

02:21:03.720 --> 02:21:15.880
am Start hier, sind ja nur 5 Instruktionen, ok, machen wir das Ganze jetzt mal ein bisschen

02:21:15.880 --> 02:21:29.360
anspruchsvoller, mein Ziel ist ja nicht jedes Mal, deswegen mach ich's ja mit dem Ultra-Low-Power-Prozessor,

02:21:29.360 --> 02:21:33.600
nicht jedes Mal die Haupt-CPU aufzuwecken, nachdem ich was ausgelesen hab, ich mein,

02:21:33.600 --> 02:21:38.000
das könnte ich auch auf der Haupt-CPU machen, übrigens danke für die ganzen Follows, ich

02:21:38.000 --> 02:21:45.720
guck grad mal kurz nach, das ist ja nicht sehr ums Wege der Sache, also, herzlich willkommen,

02:21:45.720 --> 02:21:56.240
wen haben wir denn hier alles, den Nico-Chan, Camel-Tec, Trust-Me-SC2, Kokupsi, nee, Kokupsi,

02:21:56.240 --> 02:22:11.080
Sunflower-Lol, Label-Alter, Aroseos, Zuckerberg-Mark, der Originale, Cyanox und Antiawear, Max,

02:22:11.080 --> 02:22:20.440
kannst du was über Wirtschaftsinformatik-Studium sagen, nee, so, und jetzt müssen wir das

02:22:20.440 --> 02:22:26.480
ein bisschen advanceder machen, und zwar müssen wir jetzt was vergleichen, die Werte, und

02:22:26.480 --> 02:22:32.200
dann müssen wir woanders hinspringen, bin mir noch nicht ganz sicher, wie wir das jetzt

02:22:32.200 --> 02:22:37.520
richtig machen, also wir probieren es jetzt mal erstmal noch ein bisschen einfacher aus,

02:22:37.520 --> 02:22:49.720
und zwar möchte ich nur die Haupt-CPU aufwecken, wenn der Wert, den ich auslese, größer ist

02:22:49.720 --> 02:22:59.160
als der letzte Wert, ich glaube, das ist noch relativ einfach zu bewerkstelligen, es wird

02:22:59.160 --> 02:23:06.800
allerdings schwierig, das Mini-Instruktions-Set das irgendwie hinzukriegen, okay, also nur

02:23:06.800 --> 02:23:12.680
Haupt-CPU starten, wenn, ich lass übrigens mal das bisschen schneller aufwachen, dass

02:23:12.680 --> 02:23:18.040
ich das schneller sehe, also, was könnten wir denn da machen, also, wir haben das hier

02:23:18.040 --> 02:23:37.600
geschrieben in den RAM, so, also, noch ein paar Kommentare, also R0 ist ADC, also im Prinzip,

02:23:37.600 --> 02:23:54.920
das da, GPIO34, das wäre so die C-Geschichte dementsprechend, ja, Storm-Memory, okay, das

02:23:54.920 --> 02:24:04.120
heißt, wenn ich jetzt wissen will, ob der aktuell ausgelesene Wert größer bzw. kleiner

02:24:04.120 --> 02:24:14.280
ist als der letzte Wert, dann muss ich erstmal den letzten Wert einlesen, und zwar muss ich

02:24:14.280 --> 02:24:20.320
das hier oben machen, weil hier unten überschreibe ich ihn ja schon, gut, dann fahren wir mal

02:24:20.320 --> 02:24:37.280
das ADC-Read ganz oben hin, so, wir laden den Crampel, oh, jetzt wird es kompliziert,

02:24:37.280 --> 02:24:45.480
okay, also, wir laden diesen, den Wert aus dem Speicher, so, und jetzt will ich vergleichen

02:24:45.480 --> 02:24:51.000
den Wert, den ich aus dem Speicher geladen habe, mit dem Moment, nee, will ich nicht,

02:24:51.000 --> 02:24:58.600
ich will es nicht nach LD0, weil dann überschreibe ich doch mal ein Kram, LD2, müssen wir uns

02:24:58.600 --> 02:25:06.840
danach mal angucken, okay, also, das heißt, ich will jetzt überprüfen, ob ich, ob der

02:25:06.840 --> 02:25:12.880
neue Wert oder der alte Wert größer ist, der neue Wert steht in Register 0, der, ich

02:25:12.880 --> 02:25:25.680
kann das hier einfach überschreiben lassen, da brauchen wir unten zum Storen noch, machen

02:25:25.680 --> 02:25:51.160
wir das mal in 1.

02:25:51.160 --> 02:25:54.840
Was wir schwierig finden, ist, zu Java zum Lernen, wer das an der Uni haben, welche

02:25:54.840 --> 02:26:01.480
Entwicklungsumgebung empfiehlt es zu mir, zu Java kann ich relativ wenig sagen, wenn

02:26:01.480 --> 02:26:06.720
es an der Uni machen, musst du es auf jeden Fall lernen, Java geht, also, Java lesen kann

02:26:06.720 --> 02:26:09.680
man, wenn man irgendeine andere Sprache, kann Java schreiben, ist die Frage, ob man das denn

02:26:09.680 --> 02:26:15.760
wirklich will, welche Entwicklungsumgebung, ich würde mal sagen, ich mach wenig Java,

02:26:15.760 --> 02:26:22.320
aber mit der Sache von JetBrains, kannst du wahrscheinlich nicht verkehrt liegen, Eclipse,

02:26:22.320 --> 02:26:50.120
wir gehen mal fort, so, also, okay, okay, okay, okay, okay, okay, okay, okay, okay,

02:26:50.120 --> 02:26:57.400
also, wir laden den Kremplatz rein, ich will jetzt eigentlich, ich will jetzt verklaren,

02:26:57.400 --> 02:27:02.940
ich möchte jetzt gucken, ist der aktuelle Wert größer, als der letzte Wert, das wird

02:27:02.940 --> 02:27:08.960
beim ersten Mal aufmachen, auf jeden Fall, weil der initiale Wert ist 0, also, der Wert,

02:27:08.960 --> 02:27:15.840
den ich einlese, ist auf jeden Fall größer, als 0, okay, also, das heißt, ich ziehe

02:27:15.840 --> 02:27:30.160
jetzt mal den einen Wert vom anderen ab. Also hier, Subtract. Also Subtract, Subtract

02:27:30.160 --> 02:27:36.280
und zwar Zielregister können wir hier irgendwas überschreiben. R1 können wir überschreiben,

02:27:36.280 --> 02:27:50.000
okay das brauchen wir erstmal dann nicht mehr. So und wir vergleichen jetzt R1 minus R0 oder?

02:27:50.000 --> 02:27:58.960
Genau, R1 ist der alte Wert und das ist der neue. Das heißt ist das negativ was rauskommt,

02:27:58.960 --> 02:28:17.840
weiß ich, dass der neue Wert größer ist. Oder? Ja, glaube schon. Ja, klingt irgendwie so sinnvoll

02:28:17.840 --> 02:28:32.680
was ich erzähle. Der Provokateur ist auch wieder back. So und jetzt können wir gucken. Jetzt,

02:28:32.680 --> 02:28:41.240
okay, jetzt muss ich den IF bauen. Oh das wird lustig, den IF in der Sampler. Also erstmal

02:28:41.240 --> 02:28:49.400
brauchen wir eine Label. Wir brauchen eine Label. Die Labels kann man hier übrigens

02:28:49.400 --> 02:28:59.640
bloß nur mal geben. Deswegen nennen wir das mal Label 100. Label 100 ist Stop und Label.

02:28:59.640 --> 02:29:04.400
Also das ist im Prinzip ein Go To wenn man es so will. Jetzt werdet ihr wahrscheinlich gleich sehen

02:29:04.400 --> 02:29:20.240
warum Go To so verschrien ist. 99. So und von diesem Label müssen wir Jump. Gibt es da vielleicht

02:29:20.240 --> 02:29:35.440
auch mal eine Hilfe, Hilfe zu? So irgendwie, ja? Ach nee, was BX? Alter wie heißt dieses komische Makro? BX?

02:29:35.440 --> 02:29:50.480
Das ist glaube ich. Nee, Nee, Jump heißt das da nicht. Das wäre zu einfach für die

02:29:50.480 --> 02:29:57.440
China CPU. Wie heißt das? Das heißt nicht Jump. Ah hier Label Number. Unconditional

02:29:57.440 --> 02:30:13.240
Plunge to Label 100. Okay. Warum, warum, kompiliert doch. Okay, das Speichern machen wir nämlich

02:30:13.240 --> 02:30:28.840
auch dann mal hier unten in dem Wake Up. Okay, so und jetzt können wir gucken was größer

02:30:28.840 --> 02:30:50.920
oder kleiner ist. Also sprich, wenn. Also was ich doch hier mache ist ich mache R1 minus R0.

02:30:50.920 --> 02:31:06.480
R0 ist ADC und R1 ist quasi Alterwert. Das heißt wenn das hier negativ ist dann ist R0 größer

02:31:06.480 --> 02:31:15.880
und ich will Jumpen. So und da muss ich jetzt mal nachgucken wie das heißt. Genau. Das Ding

02:31:15.880 --> 02:31:26.320
ist echt mega kryptisch. Genau, das ist die Jump Condition. Das ist, Hallo? Pranch to Label

02:31:26.320 --> 02:31:32.680
if overflow. Overflow heißt, das hat den ganzen Vorzeichen. Würde ich mal so interpretieren.

02:31:32.680 --> 02:31:40.160
Also ich ziehe das, das ist, das ist, oh ist das aber nicht. Ich ziehe das voneinander

02:31:40.160 --> 02:31:50.560
ab und wenn Overflow gesetzt ist, weiß ich, dass R0 größer ist als, größer als R1.

02:31:50.560 --> 02:31:57.720
Sag mal irgendwie ist die Autovervollstellung mega langsam gerade. Ich mach den ganzen

02:31:57.720 --> 02:32:12.560
Scheiß mal zu. Zu 99, dann wollen wir aufwachen. Dann wollen wir aufwachen. So und wenn das

02:32:12.560 --> 02:32:20.080
nicht der Fall ist, dann wollen wir direkt zum Ende Jumpen. So ey jetzt bin ich ja mal

02:32:20.080 --> 02:32:42.200
gespannt ob das funktioniert. Lul. Meint ihr das funktioniert? Ups, musste jetzt die

02:32:42.200 --> 02:32:50.920
serielle Konsole aufmachen, man sieht gar nichts. Ja es scheint schon mal, es wird das erste

02:32:50.920 --> 02:32:57.960
mal, scheint schon funktioniert zu haben. Weil 1918 ist größer als Null. Ein L5 Sampler,

02:32:57.960 --> 02:33:05.200
jetzt fängt ja Spaß an, ja ja. Kann er mal bitte ein bisschen was kleineres als ersten

02:33:05.200 --> 02:33:19.440
Wert auslesen, dass ich dann auch sehen kann ob das größer ist oder kleiner. Ich mach

02:33:19.440 --> 02:33:33.040
es jetzt mal aus dem Wasser raus. Ha funktioniert. Nice, funktioniert. Der Jump nur auf wake

02:33:33.040 --> 02:33:40.240
ab, wenn der Wert der ausgelesen wird größer ist als der letzte. Das ist natürlich eine

02:33:40.240 --> 02:33:45.760
schöne Sache ein Sampler. Du hast, wenn man es beim Programmieren durchdenkt, hat man

02:33:45.760 --> 02:34:04.520
relativ wenige Sachen die nicht dann so sind wie man sich das gedacht hat. Ich hab jetzt

02:34:04.520 --> 02:34:15.800
ja noch mal resettet den Sensor. Mir gefällt es einfach nicht, ich will nicht sagen dass

02:34:15.800 --> 02:34:25.760
es scheiße ist. Eclipse ist die ältere Variante, ich finde Eclipse ist ein riesen Konstrukt

02:34:25.760 --> 02:34:30.520
was jetzt auch nicht unbedingt durch wahnsinnige Geschwindigkeit glänzt. Ich kann aber im

02:34:30.520 --> 02:34:36.600
Punkt wo Java entwicklt oder nicht zu viel sagen. Ich weiß dass bei uns viele mit auf

02:34:36.600 --> 02:34:45.280
der Arbeit viele Java Fans, viele unsere Java Entwickler programmieren den Eclipse. Ja

02:34:45.280 --> 02:34:53.160
das ist so. So jetzt probieren wir das nochmal aus. Der Sensor ist jetzt im Wasser, das heißt

02:34:53.160 --> 02:34:58.480
der Wert der ausgelesen wird vom ADC ist nicht größer als der letzte Wert. Das bedeutet

02:34:58.480 --> 02:35:02.440
allerdings auch, jetzt sehen wir schon einen riesen Vorteil wenn man das mit dem Low Power

02:35:02.440 --> 02:35:09.600
Prozessor macht. Der Low Power Prozessor führt unsere Logik aus mit saumäßig niedrigem

02:35:09.600 --> 02:35:18.320
Energieverbrauch und die Haupt CPU schläft und erst wenn quasi eine spezielle Bedingung

02:35:18.320 --> 02:35:25.880
eintritt erst dann wird die Haupt CPU aufgeweckt und die Bedingung ist der eingelesene Wert

02:35:25.880 --> 02:35:30.760
muss größer sein als der zuletzt eingelesene Wert. Eigentlich ziemlich simpel, das heißt

02:35:30.760 --> 02:35:35.640
ich nehme das jetzt mal aus dem Wasser raus und zack BAM WAKE UP und immer nur wenn der

02:35:35.640 --> 02:35:39.160
Wert größer ist, sobald ich es wieder ins Wasser reinschmeiße läuft es wieder auf und

02:35:39.160 --> 02:35:42.960
schläft wieder. Also man sieht prinzipiell funktioniert der Shit den wir da gebastelt

02:35:42.960 --> 02:36:00.480
haben. Ich mach mal ein paar Kommentare dahinter, dass man das noch versteht was ich da gebastelt

02:36:00.480 --> 02:36:09.120
hab. Exit. Wir könnten jetzt natürlich auch ein bisschen, auch ein bisschen für die,

02:36:09.120 --> 02:36:15.000
für Freude bei unseren C-Fans sorgen, indem wir tatsächlich mal ein paar Makros verwenden,

02:36:15.000 --> 02:36:21.200
weil die Dinger, die Labels 99, 100 und so zu nennen ist ein bisschen doof. Wir machen

02:36:21.200 --> 02:36:32.200
ein Label WAKE UP, das kriegt die ID 99 und wir machen ein Label EXIT, ne Moment haha

02:36:32.200 --> 02:36:39.440
nicht gleich, das kriegt 100. Jetzt können wir nämlich sowas hier schreiben, WAKE UP,

02:36:39.440 --> 02:36:48.720
WAKE UP, da sieht das auch gleich ein bisschen schöner aus und hier JUMP EXIT. Ups, ah,

02:36:48.720 --> 02:37:05.480
sieht doch schon ein bisschen schicker aus als vorher. Ah, ich bin begeistert es funktioniert.

02:37:05.480 --> 02:37:14.960
So, die eigentliche Logik ist damit natürlich noch nicht abgefackelt, denn wir wollen ja

02:37:14.960 --> 02:37:24.760
eigentlich nicht sobald der Wert größer ist, die Haupt CPU aufwecken. Der letzte JUMP EXIT

02:37:24.760 --> 02:37:39.880
ist überflüssig. Er geht eh zu EXIT, stimmt. Richtig. Ah, der fällt ja hier durch. Aber

02:37:39.880 --> 02:37:46.040
ist es nicht, was ist denn schöner, so oder so? Eigentlich egal, oder? Aber du hast recht,

02:37:46.040 --> 02:37:54.280
der letzte, eine Instruktion gespart, 32bit gespart. Da müssen wir jetzt wie Bob Ross

02:37:54.280 --> 02:38:12.720
gleich mal den Speicher-Devil. 32bit gespart, Alter. Porgas. Ups, warum geht das Bild nicht

02:38:12.720 --> 02:38:18.840
weg? Umso weniger Befehle, umso weniger Stromverbrauch. Ich weiß nicht, ob du irgendein Messgerät

02:38:18.840 --> 02:38:25.280
findest, was das messen kann. Den niedrigeren Stromverbrauch von einer Instruktion. Ach so,

02:38:25.280 --> 02:38:38.080
habe ich noch gar nicht gesagt. Die CPU läuft mit 8MHz, die Low Power. Die Low Power CPU,

02:38:38.080 --> 02:38:49.000
auch der Megahertz. Der Takt ist auch ziemlich schnell. Der ist schneller. Ach, gute Taschenrechner,

02:38:49.000 --> 02:38:53.400
ein scheiß Vergleich. 8MHz ist eigentlich schon verdammt schnell für so einen kleinen

02:38:53.400 --> 02:39:12.640
Tag. Mit was könnte man das gut vergleichen? Mit was kann man 8MHz gut vergleichen? Also

02:39:12.640 --> 02:39:16.360
in dem Dreh rum werden sich die ersten paar CPUs bewegt haben, ein bisschen drunter wahrscheinlich.

02:39:16.360 --> 02:39:28.440
Ne, die waren noch weniger, oder? Kein Schimmer. Doch irgendwie 8MHz, kommt doch irgendwie

02:39:28.440 --> 02:39:40.680
hin. Zumindest 8MHz ist gar nicht langsam. Das sind immer 8 Millionen mal pro Sekunde.

02:39:40.680 --> 02:39:49.280
Ach ja, übrigens auch eine interessante Sache, wenn man Assembler programmiert. Die Instruktion,

02:39:49.280 --> 02:39:52.920
wie gesagt, man ist hier für Timing und sowas alles selbstverantwortlich, aber die CPU macht

02:39:52.920 --> 02:39:58.600
auch nicht einfach random was. Bei jeder Instruktion steht immer, wie viele CPU Cycles das Ding

02:39:58.600 --> 02:40:04.520
braucht. Also sprich hier, wenn ich zwei Sachen voneinander abziehe, braucht das 4 Cycles,

02:40:04.520 --> 02:40:13.000
um das subtrahieren auszuführen, und danach noch mal 4 Cycles, wo er den nächsten Befehl,

02:40:13.000 --> 02:40:18.080
den er ausführen soll, sich holt. Also sprich für einen Sub braucht man 6 Cycles, man hat

02:40:18.080 --> 02:40:25.440
8 Millionen pro Sekunde. Und bei der Gelegenheit kann man sich auch mal überlegen, wie verdammt

02:40:25.440 --> 02:40:34.720
schnell eine aktuelle CPU ist, die man so im Desktoprechner hat. Für unseren Kram hier

02:40:34.720 --> 02:40:40.000
sind 8MHz schon ultrabrutal schnell. Aber was in so einem Desktop drin ist, das kann

02:40:40.000 --> 02:40:55.680
man damit ja überhaupt nicht mehr vergleichen. Muss ich mal überlegen. 8MHz, äh, äh, ähm,

02:40:55.680 --> 02:41:03.920
jetzt wo es kommt, fällt mir das deutsche Wort. Was ist denn ein Cycle? Ein Tick quasi so.

02:41:03.920 --> 02:41:17.120
Was ist denn die richtige Bezeichnung auf Deutsch? Takt? Hm. Cyklus! Ah Leute, Poggers

02:41:17.120 --> 02:41:29.680
Chat. 8 Millionen pro Sekunde, das ist schon ganz schön viel. Und das ist bei der 8MHz

02:41:29.680 --> 02:41:42.360
ja. Mein i7 hat übertaktet 5000MHz. Und ich mein, die CPU lacht sich schon über das Programm

02:41:42.360 --> 02:41:51.400
hier kaputt. Man kann, man kann es ganz gut daran erkennen. Wisst ihr, woran man das ganz

02:41:51.400 --> 02:41:58.040
gut erkennen kann? Es gibt hier eine Instruktion, die nennt sich Wait bzw. Delay. Delay gibt

02:41:58.040 --> 02:42:06.000
man an, wie viele CPU Cycles quasi nichts getan werden sollen. Jetzt kann man sich das

02:42:06.000 --> 02:42:22.160
mal einfach überlegen. Also 8000, äh, 8 Millionen, 8 Millionen Instruktionen pro Sekunde. 8 Millionen

02:42:22.160 --> 02:42:32.120
Cykeln pro Sekunde macht diese CPU. Das bedeutet, ähm, so oft nichts tun ist quasi eine Sekunde

02:42:32.120 --> 02:42:42.200
rum. Das heißt, das sind 100 Millisekunden, das sind 10 Millisekunden und das hier sind

02:42:42.200 --> 02:42:53.880
5 Millisekunden. So. Das heißt, ein Delay von 40.000 Cykeln sind 5 Millisekunden. Das

02:42:53.880 --> 02:42:58.360
heißt, jetzt überlegt euch mal, ich möchte einfach mal für, hier unten warte ich irgendwo

02:42:58.360 --> 02:43:02.320
200 Millisekunden. Hier habe ich 200 Millisekunden gewartet. Also wenn ich das jetzt einfach

02:43:02.320 --> 02:43:07.360
Copy Paste müsste, dann würde ich jetzt hier, dann müsste ich eine ganz schöne, für popelige

02:43:07.360 --> 02:43:20.920
200 Millisekunden, 10, 20 Millisekunden, 30 Millisekunden, 40 Millisekunden, 50 Millisekunden,

02:43:20.920 --> 02:43:28.040
100 Millisekunden, 150, 200. Also so viele Delays müsste ich da einbauen, dass ich auf

02:43:28.040 --> 02:43:39.320
200 Millisekunden nichts tun komme. Äh, ja 5.000 Megahertz, 5 Gigahertz, genau. Ähm,

02:43:39.320 --> 02:43:47.880
also das hier, die so oft warten für 40.000 Cykeln sind nur 200 Millisekunden und das

02:43:47.880 --> 02:43:54.160
ist bei so einer billig 8 Megahertz Low Power Embedded CPU. Allein schon die Hauptchores

02:43:54.160 --> 02:44:00.040
vom ESP32 mit 42 Megahertz, also die Haupt 2 und 3 Spitzchores wohl gemerkt, sind schon

02:44:00.040 --> 02:44:04.600
nochmal vielfach schneller und jetzt kann man sich jetzt überlegt euch mal, wie lange

02:44:04.600 --> 02:44:10.640
diese Kette an Delays für den i7 mit 5 Gigahertz sein müsste. Da könntest du aber ganz schön

02:44:10.640 --> 02:44:15.320
lang scrollen, bis du das Delay von 200 Millisekunden drin hast. Gut, ich meine, das würdest du

02:44:15.320 --> 02:44:20.600
ja auch nicht untereinander schreiben. Machst du eine Schleife, aber nur mal so, hier sieht

02:44:20.600 --> 02:44:25.280
man so ungefähr die Menge, ja. Das ist bei der 8 Megahertz CPU, das heißt, den Scheiß

02:44:25.280 --> 02:44:35.200
kann ich jetzt irgendwie ver, äh, ver, äh, fast tausendfachen, fast tausendmal diesen

02:44:35.200 --> 02:44:42.600
Mist hier reinkopieren, dass ich ungefähr das gleiche Delay hab. Also, na, so eine Desktop

02:44:42.600 --> 02:44:50.040
CPU, eine aktuelle, hat schon ordentlich Wumms, da kann man nichts sagen. Ja, für die CPU

02:44:50.040 --> 02:44:54.640
musst du Sekunde warten, gefühlt, ja, Sekunde warten für eine CPU ist ewig. Zumal ja auch

02:44:54.640 --> 02:44:59.280
eine CPU nicht wartet. Es hat zwar jede, jede Programmiersprache irgendwie den Sleep oder

02:44:59.280 --> 02:45:03.080
den Wait oder sonst was, aber in Assembler erkennt man es eigentlich wirklich gut, was

02:45:03.080 --> 02:45:08.920
da passiert. Wenn ich einen Wait mache, also ja, genau, ähm, das, was ich hier eingebaut

02:45:08.920 --> 02:45:17.720
hab, also quasi einen Delay von 40.000 Taktzyklen unter der Haupe, ist das quasi so, so was

02:45:17.720 --> 02:45:34.400
hier. Ich weiß nicht, wie die No-Op. Ja, also unter der Haupe ist quasi ein, ein No-Op,

02:45:34.400 --> 02:45:38.680
also das ist, das sind 40.000 No-Ops. Jetzt überlegt euch mal, wie viele No-Ops das Ding

02:45:38.680 --> 02:45:43.760
ausführen muss, um allein schon nur auf 200 Millisekunden Delay zu kommen, weil er macht

02:45:43.760 --> 02:45:50.040
ein Megahertz Prozessor. Da kannst du, da kannst du den Messeturm mit Papier ausgedrückt

02:45:50.040 --> 02:45:56.320
voll machen, dass du 200 Millisekunden No-Op auf einem aktuellen i7 hinkriegst, wenn du

02:45:56.320 --> 02:46:00.440
es wirklich untereinander copypasten willst. Also ich glaube, wenn man sich sowas mal anguckt,

02:46:00.440 --> 02:46:04.960
begreift man vielleicht mal im Ansatz ungefähr, wie schnell aktuelle CPUs überhaupt sind.

02:46:04.960 --> 02:46:18.800
Ja, und der Flo hat recht, je nachdem, was man macht, sind 8 Megahertz auch nicht so

02:46:18.800 --> 02:46:30.240
viel. Und weil man halt sagen muss, mit 8 Megahertz kann man relativ viel machen, 8

02:46:30.240 --> 02:46:35.240
Megahertz hier in dieser Art und Weise, weil da, da kommt nichts dazwischen, ja. Das ist,

02:46:35.240 --> 02:46:38.480
da ist nichts Multithreaded natürlich, da ist kein Betriebssystem dazwischen, was irgendwie

02:46:38.480 --> 02:46:43.240
Multitask oder Sachen hin und her verwaltet. Das führt stumpf das aus, was man reinhaut

02:46:43.240 --> 02:46:49.160
und dementsprechend kann man die Sachen auch verdammt optimiert machen. Man darf nicht

02:46:49.160 --> 02:46:54.360
vergessen, das erste Rollercoaster Tycoon, ich sag immer Roller-Roaster Tycoon, dabei

02:46:54.360 --> 02:46:59.280
heißt es Rollercoaster Tycoon, das erste Rollercoaster Tycoon ist zu größten Teilen

02:46:59.280 --> 02:47:06.080
des Samplers programmiert. Du könnt ihr euch wirklich vorstellen, in so nem, na, ok, der

02:47:06.080 --> 02:47:12.800
hat ein bisschen mehr Instruktionen zur Verfügung als hier, diese Mini-CPU. Das hier, ein Spiel

02:47:12.800 --> 02:47:23.880
willst du programmieren? Ernsthaft? Da bist du doch kurz vorm Selbstmord jedes Mal. Da

02:47:23.880 --> 02:47:27.280
bist du echt immer, da ist immer der ein Finger am Abzug, wenn du da drin ein Spiel

02:47:27.280 --> 02:47:38.040
programmieren willst. Einfach gehts Kompilieren schnell. Weil du musst ja, im Prinzip, musst

02:47:38.040 --> 02:47:43.440
ja hier nichts großartig Kompilieren. Da kommen einfach, da, die kannst du eins zu

02:47:43.440 --> 02:47:48.920
eins, diese Instruktionen kannst du quasi in, in, in, in, in, in byte umwandeln, was

02:47:48.920 --> 02:47:57.360
man die CPU direkt lesen kann. Deswegen heißt es ja auch Assembler. Du schreibst im Prinzip

02:47:57.360 --> 02:48:02.440
an nackte CPU Instruktionen einfach ne Name dran. Viel mehr, in Anführungsstrichen ist

02:48:02.440 --> 02:48:14.640
es jetzt ja nicht. Also, ich muss echt mal meine Pizza essen. Aber ich geh mal davon

02:48:14.640 --> 02:48:21.240
aus, wir wollen noch ein bisschen weitermachen, oder? Wie lange bin ich denn schon on? Drei

02:48:21.240 --> 02:48:38.600
Stunden fast. Okay. Also, ich will jetzt ja nur, okay, wir machen jetzt eine Sache,

02:48:38.600 --> 02:48:44.920
mal suchen wir nochmal. Aktuell haben wir es ja so, es wird nur ein Wert ausgegeben, wenn

02:48:44.920 --> 02:48:57.440
der größer als der letzte Wert ist. Wir machen jetzt mal so ein bisschen noch nen Filter rein,

02:48:57.440 --> 02:49:03.040
und zwar nen Filter anhand unserer Werte, die wir hier ausgelesen haben. Also sprich,

02:49:03.040 --> 02:49:08.840
ist der Wert drüber, machen wir nix, und ist der Wert drunter, machen wir nix, denn es

02:49:08.840 --> 02:49:14.880
könnte ja auch mal sein, dass der, dass der ADC oder der Sensor irgendwie misst, misst,

02:49:14.880 --> 02:49:25.720
ne? Wer misst, misst, misst. Und den Wert wollen wir natürlich gar nicht erst da irgendwie

02:49:25.720 --> 02:49:36.600
drinne haben. Jawohl, Werder, wenn du mir, such mal aus dem Instruktionsset raus, wie

02:49:36.600 --> 02:49:42.080
man das macht, dann Longjumpen wir auch. Aber als erstes, was wir jetzt hier machen, wir

02:49:42.080 --> 02:49:54.400
machen jetzt nochmal nen Compare quasi, und wenn der Wert unterhalb davon liegt, dann

02:49:54.400 --> 02:49:59.480
gehen wir direkt Exit ohne Wake ab, legt der Wert oberhalb hier von, dann gehen wir auch

02:49:59.480 --> 02:50:11.120
direkt Exit, Exit, ohne. So und das machen wir direkt nach dem Read vom ADC, weil hier

02:50:11.120 --> 02:50:18.520
können wir schon feststellen, ich würde übrigens gerne noch ne Schleife machen, ne? Ich würde

02:50:18.520 --> 02:50:25.240
übrigens gerne noch ne Schleife machen, dass ich den ADC einfach, keine Ahnung, 4 mal abfrage

02:50:25.240 --> 02:50:31.200
und die Sachen dann addiere und am Ende durch 4 teile, weil dann hat man auch ein bisschen

02:50:31.200 --> 02:50:37.440
abgefangen, dass das Ding rauscht, beziehungsweise, falls der einen Mistwert mal gemessen hat,

02:50:37.440 --> 02:50:42.840
dann, na. Das probieren wir jetzt mal, mit der Schleife, weil ich nicht glaube, wir

02:50:42.840 --> 02:50:53.000
können das hinkriegen. Da muss ich erstmal gucken, wie die Makros heißen. Also, aber

02:50:53.000 --> 02:50:55.200
das andere können wir jetzt machen, weil da hab ich mir nämlich den Befehl schon mal

02:50:55.200 --> 02:51:04.040
rausgesucht im Vorfeld, wenn ich ihn finde, genau, mbge, da kann ich jetzt ihm sagen,

02:51:04.040 --> 02:51:09.400
hier Jumper zu Label 100, ne nicht 100, Exit haben wir das Label genannt, Jumper zu Exit,

02:51:09.400 --> 02:51:14.920
achso, ist Exit vielleicht schon vorbelegt? Warte mal kurz, mal gucken, ob Exit schon

02:51:14.920 --> 02:51:25.440
vorbelegt ist, ne, ist es nicht. Jumper zu Exit, wenn R0, R0 ist der Wert, den ich gelesen

02:51:25.440 --> 02:51:37.240
hab, wenn der Wert unterhalb von, wenn der Wert größer als Sensor Max ist oder alternativ,

02:51:37.240 --> 02:51:54.080
wenn der Wert kleiner als, äh, wenn der Wert kleiner ist, äh, größer gleich diesem Wert

02:51:54.080 --> 02:52:07.600
oder kleiner diesem Wert, dann gehen wir direkt, dann machen wir direkt Exit. Zwei Bits Schiften

02:52:07.600 --> 02:52:15.360
Division, jaja, gucken wir mal. Wie man eine Schleife macht, hab ich keine Ahnung da drin,

02:52:15.360 --> 02:52:19.320
das Ding hat, das Ding hat eine extra, hat extra Instruktionen für Schleifen, dass es

02:52:19.320 --> 02:52:26.440
ein bisschen einfacher ist, also sprich, normalerweise müsste man eine Schleife im Prinzip Label,

02:52:26.440 --> 02:52:34.600
ein Label machen, am Ende ein Jump, zurück, wenn, ähm, der Counter quasi größer als

02:52:34.600 --> 02:52:42.680
ist oder irgendwie sowas. Ich versuch mal zu gucken, ich such mal in der, in dem Hersteller

02:52:42.680 --> 02:53:04.160
Dokument, ob da irgendwie ein Beispiel drinne ist, wie man eine Schleife macht. Hier, oder?

02:53:04.160 --> 02:53:18.840
Hier machen sie eine Schleife, hier machen sie eine Schleife, genau, Label, genau, Label,

02:53:18.840 --> 02:53:25.000
dann haben sie hier unten, wird der Counter eins hochgezählt und dann wird geguckt, ob

02:53:25.000 --> 02:53:43.280
der Counter eins? Ich bin verwirrt. Also, äh, warum steht hier eins? Hier sollte doch

02:53:43.280 --> 02:53:50.200
R0 stehen, oder? Ach ne, das bezieht sich immer auf, ah, ne, ne, ne, das ist die Labelnummer,

02:53:50.200 --> 02:53:58.000
also das bezieht sich immer, also wenn R0 kleiner 64 ist, dann macht er das immer weiter.

02:53:58.000 --> 02:54:15.600
Ja gut, das kriegen wir auch so hin, oder? Also, probieren wir das mal aus. Ok, wie nennen

02:54:15.600 --> 02:54:37.280
wir das Label? Das wird Label eins, ADC Loop, Label, ADC Loop. Boah, ob das funktioniert

02:54:37.280 --> 02:54:45.720
oder ist das so 3? So, ja, das können wir behalten, allerdings nicht, allerdings nicht,

02:54:45.720 --> 02:54:50.200
64, Moment, wir wollen dann gar nicht exiten, wir wollen, haha, wir wollen nicht exiten,

02:54:50.200 --> 02:54:59.040
wir wollen den Wert einfach nur wegwerfen, das muss ich mir gleich mal überlegen. Also,

02:54:59.040 --> 02:55:21.040
sag mal viermal, hm? Viermal ADC auslesen und mittleren Wertbilden reicht, oder? Dann machen

02:55:21.040 --> 02:55:29.040
wir das hier. So, wir machen das aber nicht in R0, sondern wir machen, warum machen die

02:55:29.040 --> 02:55:40.720
das hier eigentlich alles in R0? Also, das heißt, wir machen hier R1, ok, das heißt,

02:55:40.720 --> 02:55:52.360
als erstes müssen wir, oh je, oh je. Also, als erstes schreiben wir mal in R1, schreiben

02:55:52.360 --> 02:56:05.240
wir 0 rein. So. Das ist das erste, was wir machen, das ist in unserem Counter, in unserem

02:56:05.240 --> 02:56:12.920
Counter schreiben wir 0 rein. Kann man das eigentlich schön formatieren lassen? So,

02:56:12.920 --> 02:56:28.640
in unsere Counter schreiben wir 0 rein. So, wir adden, wir adden eins dazu. Eieiei, Leute,

02:56:28.640 --> 02:56:36.760
ich bin ja mal gespannt, ob das funktioniert. Haben wir den Kram mal raus. Wir lassen es

02:56:36.760 --> 02:56:49.480
jetzt erstmal so, das heißt, wir müssen das Ganze ja viermal haben. Ob das jetzt funktioniert?

02:56:49.480 --> 02:56:58.800
Ich meine, unser Counter wird hochgezählt, wenn der Counter dann nicht mehr kleiner 4

02:56:58.800 --> 02:57:13.760
ist, probieren wir mal aus. Gucken, was da rauskommt. Meiner ist funktioniert. Sieht

02:57:13.760 --> 02:57:19.880
nicht so aus, als würde es funktionieren, oder? Ach so, Moment, ich habe das addieren

02:57:19.880 --> 02:57:27.400
vergessen. Ich muss ja R0, ich muss ja R0, äh, Dingsen hier. Muss es ja zusammenrechnen.

02:57:27.400 --> 02:57:42.320
Muss es ja zusammenrechnen. Ich meine, wir machen jetzt zwar eine Schleife, aber wir

02:57:42.320 --> 02:58:05.760
rechnen es ja nicht zusammen. Also, will ich add? Register zusammenzählen, R0 mit R0 plus

02:58:05.760 --> 02:58:28.240
R0. Ne, Moment. Moment. Äh, ne, ne. Ja, keine Ahnung. Alter, was ist das für eine. R2,

02:58:28.240 --> 02:58:37.120
nehmen wir das mal. R2 ziehen wir. Ne, initialisieren wir den Kram auch mal auf Null. So. Das ist

02:58:37.120 --> 02:58:48.760
Ziel in R2. Soll R2 mit R0 zusammengerechnet werden. Ja, genau. So. Ähm, und jetzt moveen

02:58:48.760 --> 02:59:04.320
wir noch mal. Jetzt moveen wir noch mal das wieder. R2 nach Null. Ey, ob das jetzt funktioniert,

02:59:04.320 --> 02:59:22.640
ich bin da echt mal gespannt. Das funktioniert irgendwie nicht, oder? Was mache ich denn verkehrt?

02:59:22.640 --> 02:59:48.440
Was mache ich denn verkehrt? Ich addiere den Kram hier. In R2. Und das Ganze mache ich

02:59:48.440 --> 02:59:58.960
so lang. Ah, Moment. Haha. Das funktioniert nicht. Mein adden funktioniert nicht. Das bezieht

02:59:58.960 --> 03:00:18.720
sich ja immer auf Null. Ne, Moment. Null muss ich das machen. Oder? Ich bin, ich bin echt

03:00:18.720 --> 03:00:31.120
kaputt. Das ist jetzt wirklich hirn, hirn. Kaputt. Genau, ich kann, ich muss R0, darf

03:00:31.120 --> 03:00:36.360
ich ja nur für diesen Jump hier unten verwenden, weil das immer auf Register Null geht. Hast

03:00:36.360 --> 03:00:41.640
du eigentlich eine englische Tastatur? Nö, nö. Das geht auf Register Null. Das heißt

03:00:41.640 --> 03:00:58.080
mein, mein. Willst du was mit Java programmieren? Nein, will ich nicht. Also kann ich den Kram

03:00:58.080 --> 03:01:20.400
hier nicht verwenden. Also dann readen wir das mal in 1. Haha, was auch immer ich hier

03:01:20.400 --> 03:01:37.040
betreibe. Dann lesen wir das in 1. Und dann adden wir 2 mit 1 plus 2. Und am Ende, wenn

03:01:37.040 --> 03:01:56.280
wir fertig sind, dann moveen wir 2 zu Null. Ok. Guck mal, ob das jetzt funktioniert. Ah,

03:01:56.280 --> 03:02:07.720
das sieht doch schon besser aus. Das sieht doch ungefähr aus wie 4 mal 2.000, oder?

03:02:07.720 --> 03:02:35.880
Ha, funktioniert. Krasse Assembler. Loopzor. Das kann man auch bestimmt schöner machen.

03:02:35.880 --> 03:02:49.080
Raids OV tut zuerst. Oh, nee. Jetzt Leute, mir reicht's. Genug. Ich mein, was man daran

03:02:49.080 --> 03:02:59.280
schon mal schön sieht ist, wie schnell so was ausatmen kann von der Länge her. Max,

03:02:59.280 --> 03:03:08.000
gib zu, dass du mit Iron Age unter einer Decke steckst. Ich muss tatsächlich sagen, dass

03:03:08.000 --> 03:03:30.200
das Board, was ich hier programmiert hab, ist ein bisschen davon inspiriert. Gut, ja,

03:03:30.200 --> 03:03:34.720
die ganzen Assembler-Pros, kann man die Schleife irgendwie ein bisschen schöner machen? Das

03:03:34.720 --> 03:03:39.560
ist schon ein bisschen... Das muss ich mir in Ruhe da noch mal angucken. Aber ich glaub,

03:03:39.560 --> 03:03:46.000
ich werd jetzt erstmal in Ruhe meine Pizza füttern. Aber ich find's echt cool, dass

03:03:46.000 --> 03:04:03.600
das funktioniert. Achso, ja, wir müssten ja noch teilen, ne? Ich würde gerne wissen,

03:04:03.600 --> 03:04:10.040
wer das während dem Spiel macht. Der hat wahrscheinlich Shortcuts. Ich hab hier für

03:04:10.040 --> 03:04:14.520
mein Mist hier auch Shortcuts. Das kannst du ja einfach während dem Spielen drücken.

03:04:14.520 --> 03:04:37.480
Macht er ja meistens, wenn er gestorben ist. Ja, gut. Und noch mal ein Sensor aus dem Glas

03:04:37.480 --> 03:04:49.160
raus. Bäm! Ha, das ist schön, wenn das funktioniert. Den Jebaited Song. Das hab ich nicht hinterlegt

03:04:49.160 --> 03:04:55.520
hier, den Jebaited Song. Ich hab aktuell nur das Jebaited-E-Mode. Und die koreanische Sprachausgabe

03:04:55.520 --> 03:05:25.480
natürlich. Was zum Teufel ist der Jebaited Song? Ich kopiere normalerweise nix. Aus

03:05:25.480 --> 03:05:35.200
dem Chat. Aber wenn's ein Mod macht, glaub ich, war das doch nix Schlimmes. Oh, du Scheiße.

03:05:35.200 --> 03:06:04.760
Oh, das tut ja weh. Ist das dämlich. Ach, du Scheiße. Das ist ja Twitch pur, ey. Das

03:06:04.760 --> 03:06:16.720
war das pureste Twitch, was wir heute hatten. Jetzt, jetzt wird ja eigentlich nur noch hier,

03:06:16.720 --> 03:06:38.880
jetzt würde eigentlich nur noch er hier fehlen, oder? Wobei, war da er hier. Ist jemand gestorben

03:06:38.880 --> 03:07:01.520
oder was geht mit der Musik ab? Speichern wir mal. Ist schön entspannend. Wisst ihr,

03:07:01.520 --> 03:07:10.880
was ich doof finde? Diese Bookmark-Bar vom Chrome, die funktioniert irgendwie schlechter

03:07:10.880 --> 03:07:18.480
als die im Firefox. Weil du kannst im Firefox, kannst du Tabs in die Bookmark-Bar ziehen,

03:07:18.480 --> 03:07:22.880
das kannst du im Chrome nicht machen. Und wenn die Bookmark-Bar voller wird, so wie hier,

03:07:22.880 --> 03:07:25.680
was eigentlich bescheuert ist, weil es eine Bar sein soll, musst du dann immer erst hier

03:07:25.680 --> 03:07:35.120
runter scrollen und dann das irgendwie hochtreppen, droppen. Hast du schon größere Projekte in

03:07:35.120 --> 03:07:39.400
Assemblern gemacht? Nein, habe ich nicht. Zu diesem Vergnügen, oder besser gesagt, das

03:07:39.400 --> 03:07:44.720
Vergnügen blieb mir bisher verwehrt. Aber wirklich scharf drauf will ich auch nicht

03:07:44.720 --> 03:07:55.640
größere Sachen in Assemblern machen. So Leute, ich hoffe, das hat für die tägliche Low-Level-Tippe

03:07:55.640 --> 03:08:18.160
Dosis heute gereicht. Übelsthunger. ASMR-Eating-Sounds. Und, ähm, mal gucken, ob ich weiter on-Stream

03:08:18.160 --> 03:08:25.320
mache. Das war die Frage. Hat euch das gefallen? Wird mich jetzt mal interessieren, weil das

03:08:25.320 --> 03:08:33.320
ist jetzt schon eine etwas abgedrehtere Geschichte, als das, was wir sonst machen. Und ich glaube,

03:08:33.320 --> 03:08:49.320
ähm, die normalen Sachen sind schon abgedreht genug. Okay, krass. War mir nicht Low-Level

03:08:49.320 --> 03:08:57.680
genug. Nächstes Mal musst du eine Hardware-Schaltung für das Bauen, für Effizienz. Das, auch wenn

03:08:57.680 --> 03:09:02.680
du es nicht ernst gemeint hast, aber das ist gar keine schlechte Idee. Ich weiß nur nicht,

03:09:02.680 --> 03:09:12.360
wie ich das, ähm, gescheit streamen sollte. Weil wir müssten hier theoretisch schon zumindest

03:09:12.360 --> 03:09:20.240
ein paar Sachen auf einem Predboard stecken. Zum Beispiel den Antennen-Anschluss, den Antennen-Connector

03:09:20.240 --> 03:09:27.560
für das LoRa-Modul müsste man ordentlich drauf decken. Und das LoRa-Modul auch. Und

03:09:27.560 --> 03:09:34.360
dann müsste man es verbinden und so Dinge auch. Ich hab extra dafür, für so kleine

03:09:34.360 --> 03:09:40.400
Projekte, wie bei Amazon, so Mini-Predboards gekauft. Die sind, keine Ahnung, so lang wie

03:09:40.400 --> 03:09:48.480
mein Daumen oder so. Aber das ist wirklich praktisch für so Kleinscheiß, der in eine

03:09:48.480 --> 03:10:00.240
Box rein soll. Predboard, Predboard. Ja, die kleinen Dinger hier. Die sind echt praktisch.

03:10:00.240 --> 03:10:15.400
Die sind klein. Guck mal, die sind hier. Steht da irgendwie eine Größe drin? Ja, 14x7cm.

03:10:15.400 --> 03:10:19.600
Die sind richtig klein und kompakt. Die normalen Predboards sind ja eher in der Größe oder

03:10:19.600 --> 03:10:24.840
die Hälfte davon. Die sind schön klein, weil man nicht viel Platz braucht, weil man

03:10:24.840 --> 03:10:28.840
einfach nur ein paar Sachen miteinander verbinden will, ohne dass man da irgendwie viel Matching

03:10:28.840 --> 03:10:34.160
hat. Sind die kleinen Dinger wirklich praktisch? Weil die passen auch in so eine kleine Box

03:10:34.160 --> 03:10:46.440
rein. Ich hab mir nämlich letztens eine Ladung hier gekauft. Nee. Das könnten die sogar

03:10:46.440 --> 03:10:55.800
sein. Nee, 20x20, glaube ich nicht. Ich hab mir letztens so eine Zehner-Bestellung-Boxen,

03:10:55.800 --> 03:11:02.080
ich glaube, die hier sind das. Irgendwie gut. Die gab es aber, glaube ich, auch mal im Pack.

03:11:02.080 --> 03:11:08.080
Und, ähm, das ist eigentlich ganz gut. Das ist eine IP65-Box, also sprich, die ist zumindest

03:11:08.080 --> 03:11:15.120
mal relativ wasser-, also staubdicht und wasserfest-, staub-, wasser-, staub-, nee, Staubwasser,

03:11:15.120 --> 03:11:22.480
ne? Also staubdicht und spritzwasserdicht bis irgendwie sonst was. Also kannst du bloß

03:11:22.480 --> 03:11:27.560
nicht unter Wasser verwenden im Endeffekt. Ähm, und die sind halt nicht groß und dafür

03:11:27.560 --> 03:11:33.200
passen halt die kleinen Prep-Boards ganz gut. Die passen da nämlich rein, inklusive, ähm,

03:11:33.200 --> 03:11:42.680
Controller und inklusive Modul. Joa. Und sowas könnte man eigentlich mal zusammenstöpseln

03:11:42.680 --> 03:11:54.080
im Stremen, aber es ist halt schwierig sowas zu filmen. Nee, CPUs auf Web-Boards kannst

03:11:54.080 --> 03:12:02.840
du vergessen. Ich mein, die, selbst die ersten paar CPUs, die waren halt auf großen Karten

03:12:02.840 --> 03:12:08.800
im Endeffekt, aber auch schon eine ganze Ecke komplexer als das, was man sich da so zusammen-,

03:12:08.800 --> 03:12:15.800
was man halt machen kann, ist sich, ähm, Teile, die quasi integriert sind, äh, zusammenstöpseln

03:12:15.800 --> 03:12:21.320
mit Sachen, die halt auf einem anderen Chip integriert sind, ne? Also zum Beispiel, dass

03:12:21.320 --> 03:12:26.240
man ein WLAN-Modul kauft und dann irgendwie ein ESP-2-, äh, den brauchen wir nicht,

03:12:26.240 --> 03:12:30.200
da brauchen wir kein WLAN-Modul. Keine Ahnung, dass man sich eine CPU kauft, ein WLAN-Modul

03:12:30.200 --> 03:12:34.360
kauft, oder dass es zusammenstöpseln ist, könnte man machen, ähm, weil das auch nicht

03:12:34.360 --> 03:12:39.480
so ohne ist. Aber wozu? Ich mein, man kauft sich ein ESP-32-Board, man hat Bluetooth,

03:12:39.480 --> 03:12:43.840
man hat WLAN, man hat zwei CPUs, ich mein, man muss sich mal überlegen, die Technik,

03:12:43.840 --> 03:12:57.280
die auf so einem Ding draufsitzt, ist halt schon übelst nice, ne? Ich mein, die Technik,

03:12:57.280 --> 03:13:02.280
die da draufsitzt, ist schon mal echt nice, und zwar muss ich mal überlegen, was da alles

03:13:02.280 --> 03:13:08.560
drauf ist auf so einem Controller. Du hast drei CPU, äh, du hast drei CPU-Kerne, drei,

03:13:08.560 --> 03:13:14.040
wohlgemerkt, auf so einem Micro-Controller, der als Modul so groß ist, wie man Daumennagel,

03:13:14.040 --> 03:13:20.720
also man muss ja sagen, dieses Board hier ist ja gar nicht das, was groß ist, das ist

03:13:20.720 --> 03:13:24.600
das raus für den GPIOs, oder ein bisschen Flash und sonst was drauf. Das da ist der

03:13:24.600 --> 03:13:32.360
ESP-32, das ist Daumennagel-groß, das Ding. Ja, das ist keine reine CPU, na klar, ist

03:13:32.360 --> 03:13:35.640
halt mit dabei. Ich mein, du hast alles möglich dabei, das ist wirklich ultra nice, das Ding,

03:13:35.640 --> 03:13:43.120
muss ich mir überlegen. Drei CPU-Kerne, du hast zwei 32-Bit mit, äh, was auch immer

03:13:43.120 --> 03:13:48.920
hier das da ist, wahrscheinlich der Hersteller oder irgendeine Technik, mit 240 MHz, sind

03:13:48.920 --> 03:13:54.560
8 MHz Low-Power-Prozessor, ähm, du hast relativ viel RAM für sowas und Speicher, steht

03:13:54.560 --> 03:14:01.920
leider nicht drauf, wie viel. Das Schöne an diesem Memory, ich blick hier auf dem Bild

03:14:01.920 --> 03:14:06.400
grad nicht so ganz durch, ist halt auch, dass es Deep Sleeps überlebt, du hast, das ist

03:14:06.400 --> 03:14:13.840
richtig nice, du hast die verbreitetsten Krypto-Geschichten als Hardware auf dem Chip,

03:14:13.840 --> 03:14:20.160
das heißt, du kannst AES-Verschlüsseln, also Synchron-Verschlüsseln, du kannst RSAA-Synchron-Verschlüsseln und du kannst

03:14:20.160 --> 03:14:25.960
Haschen, wahrscheinlich das Shard 256 oder sowas, und das Hardware beschleunigt, auch

03:14:25.960 --> 03:14:41.360
so ein kleines scheiß Ding drauf. Hat der auch noch einen Funk-Dings drauf? Nee, das

03:14:41.360 --> 03:14:49.120
ist wahrscheinlich für WLAN. Äh, du hast WLAN drauf und Bluetooth drauf. Und man, genau,

03:14:49.120 --> 03:14:56.040
so, so, so, so, wie, ich mein nicht, dass die Namen jetzt falsch, aber, Python, Node-Deal,

03:14:56.040 --> 03:15:01.920
Python-Idea, Python-O-Idea, ich weiß nicht, so wie er das sagt, man muss sich überlegen,

03:15:01.920 --> 03:15:12.120
20 Euro. Und bei AliExpress noch billiger. Das Einzige, was du nicht machen kannst, doch

03:15:12.120 --> 03:15:16.840
Multi-Swerding kannst du auch machen, du hast zwei Kerne. Es gibt sogar Multi-Swerding-Libraries

03:15:16.840 --> 03:15:32.760
für. Ja, 20 Euro, der Kram kostet dann viel. Also, nicht die CPU, sondern das Board. Okay,

03:15:32.760 --> 03:15:41.440
vergess 10 Euro, nicht 20 Euro. 10 Euro. Und bei China, in China noch weniger. Ja, in

03:15:41.440 --> 03:15:47.080
China noch 5, vergiss, was ich gesagt hab. Die bisschen Strom-sparende Variante sind

03:15:47.080 --> 03:15:52.360
teurer, genau. Und Firebeetle kostet 20, weil man das billiger kauft wahrscheinlich auch.

03:15:52.360 --> 03:16:04.800
Aber, ich mein, der Preis ist halt echt unschlagbar. Also, Multi-Swerding kannst du. Du hast zwei

03:16:04.800 --> 03:16:14.560
CPU-Kerne und es gibt eine fertige, also, eine fertige Task-Library dafür vom Hersteller.

03:16:14.560 --> 03:16:19.760
Alternativ kannst du auch eine andere verwenden. Also, funktioniert. Standardmäßig ist es

03:16:19.760 --> 03:16:29.080
so, dass der Arduino-Code wird auf CPU-Kern 1, glaube ich, ausgeführt und alle Timer

03:16:29.080 --> 03:16:34.400
und so gedönnt. Also, ich könnte zum Beispiel auch einen Timer anlegen, der mir jede Sekunde

03:16:34.400 --> 03:16:39.320
auslöst und in dem ich irgendwie einen PING schicke oder so. Irgendwas bescheuertes. Oder

03:16:39.320 --> 03:16:44.440
LED blinken lasse, ja, LED blinken lasse zum Beispiel. Der Timer läuft dann auf CPU 0,

03:16:44.440 --> 03:16:48.160
wenn ich das jetzt richtig im Kopf hab. Also, der macht standardmäßig schon ein bisschen

03:16:48.160 --> 03:16:57.600
Multi-Swerding, aber es gibt eine komplette Task-Library, wo man Multi-Swerden kann. Kommt

03:16:57.600 --> 03:17:04.120
nicht von ungefähr, weil es gibt ESP32-Kamera-Module, die gar nicht so eine schlechte Quali haben

03:17:04.120 --> 03:17:14.760
und gar nicht so schlechte FPS haben. Und guckt euch das mal an. Ah, das Video kenn ich

03:17:14.760 --> 03:17:22.240
von dem, das ist echt nicht schlecht. Der Typ hat sich hier so ein ESP32-Kamera-Modul

03:17:22.240 --> 03:17:27.040
gekauft mit einem ESP32 drauf. Das dürfte so von der Kamera her so eine Qualität wie

03:17:27.040 --> 03:17:32.200
vom Raspberry ungefähr sein, die Raspberry Zero, diese Mini-Kamera. Und, weiß nicht,

03:17:32.200 --> 03:17:40.760
ob er hier irgendwo das Web-Interface zeigt. Sieht man hier, wie viel FPS man einstellen

03:17:40.760 --> 03:17:52.520
kann? Gut, ich meine, die Auflösung ist jetzt hier nicht so hoch. Äh, hallo? Ey, ich hab

03:17:52.520 --> 03:17:57.920
das Video nicht umsonst auf 1080p stehen. So, guck mal, da hat die Auflösung relativ

03:17:57.920 --> 03:18:03.840
runter. Ich weiß nicht, ob man hier die Frames sieht. Sieht man hier die Frames? Aber das

03:18:03.840 --> 03:18:07.120
ist gar nichts übel. Und ich meine, allein schon dadurch, dass das überhaupt möglich

03:18:07.120 --> 03:18:12.200
ist. Ich meine, der Typ, der macht hier im Video, ähm, macht da mit ganz annehmbarer

03:18:12.200 --> 03:18:17.240
Auflösung und ganz annehmbarer, ähm, meine Auflösung ist halt das Problem. Du hast nicht

03:18:17.240 --> 03:18:22.440
wirklich viel Speicher auf dem Ding. Und mit annehmbarer FPS-Zahl macht der Bildbearbeitung

03:18:22.440 --> 03:18:35.280
live von einem Video-Stream auf einem Mikro-Controller. Was halt echt nice ist. Und, ähm, man kann

03:18:35.280 --> 03:18:38.480
sich halt immer fragen, okay, warum soll ich sowas nehmen an Schatz und Raspberry? Das

03:18:38.480 --> 03:18:47.880
liegt zum einen mal am Preis. Am Stromverbrauch. Und weil viele Sachen auch durch die einfache,

03:18:47.880 --> 03:18:53.400
oder durch die einfache, oder das weniger drum herum ist, sind tatsächlich einfacher.

03:18:53.400 --> 03:19:00.000
Ich meine, der Raspberry ist eindeutig das Flexiblere davon. Ja, ganz klar. Ich meine,

03:19:00.000 --> 03:19:05.160
du hast im Vergleich zu so einem, äh, zu den CPUs, die da drauf sind, hast du ja mit so

03:19:05.160 --> 03:19:09.680
einem Raspberry Pi, das ist ja schon ein Supercomputer dagegen, äh, da hast du irgendwie, was hat

03:19:09.680 --> 03:19:16.120
der aktuelle Raspberry in einem Quad-Core mit 1,2 Gigahertz oder so? Und auch der Zero

03:19:16.120 --> 03:19:22.080
dürfte das Ding hier schon, auch wenn der Zero nur einen Core hat, ziemlich in die Tasche

03:19:22.080 --> 03:19:27.480
stecken. Ähm, aber der Raspberry ist halt ziemlich schnell, aber ist halt im Vergleich

03:19:27.480 --> 03:19:32.120
zu einem ESP32 halt auch sehr, sehr flexibel. Das darf man nicht vergessen. Allerdings

03:19:32.120 --> 03:19:37.440
für kleine Sachen, die einfach funktionieren sollen, ist so ein ESP32, so die kleinere

03:19:37.440 --> 03:19:47.000
Variante, ist das richtig gut. Weil, den juckt's auch nicht, wenn du einfach mal Strom rausziehst

03:19:47.000 --> 03:19:48.880
oder irgendwas. Raspberry, da hast du ja immer Schiss, dass er kaputt geht, wenn du einfach

03:19:48.880 --> 03:19:56.400
Strom rausziehst. Also, das sind unterschiedliche Anwendungszwecke irgendwo einfach. Und, ich

03:19:56.400 --> 03:20:02.040
finde, ich finde beides hat seine Daseinsberechnung. Und dadurch, dass da halt vieles simpler ist,

03:20:02.040 --> 03:20:11.080
hat er halt auch viele Aufgaben viel simpler zu erledigen. Da macht er halt nur eins. Und

03:20:11.080 --> 03:20:14.760
zwar das, was du ihm gesagt hast. Nicht, wie ein Raspberry, der 30.000 Sachen parallel

03:20:14.760 --> 03:20:35.800
macht. Was ist tot? Port tot? Achso, vom Raspberry, ja. Das kann schon sein. Also, wir sind schon

03:20:35.800 --> 03:20:41.640
ein paar SD-Karten, ich verreckt, aber war nicht mehr bootbar, weil du Strom rausgezogen

03:20:41.640 --> 03:21:01.440
hast. Das kann einem am Raspberry relativ schnell passieren. Strom rausgezogen, zum falschen

03:21:01.440 --> 03:21:08.560
Zeitpunkt, blub. Windows, ja. Leg da ran. Normalerweise hätte ich das hätten wir das

03:21:08.560 --> 03:21:14.800
jetzt auch heute eigentlich unter Linux gemacht. Leg da ran, dass ich in der Linux-VM ein bisschen

03:21:14.800 --> 03:21:24.360
Probleme hab mit dem USB-Controller von dem anderen Board. Der funktioniert unter Linux

03:21:24.360 --> 03:21:29.600
nur sehr halbherzig. Das liegt aber am Hersteller vom USB-Controller. Unter Windows funktioniert

03:21:29.600 --> 03:21:38.920
er halt. Unter Linux geht die serielle Verbindung. Allerdings geht das Flaschen nicht über

03:21:38.920 --> 03:21:45.840
USB. Und so ein Ding musst du ja halt alle paar Minuten flaschen. Okay Leute, ich find

03:21:45.840 --> 03:21:50.280
schön, dass es euch so gut gefallen hat. War ja die eindeutige Antwort, dass wir weitermachen

03:21:50.280 --> 03:22:00.520
sollen hier on stream. Das nächste Mal, wenn wir die Low-Level-Geschichte fertig haben,

03:22:00.520 --> 03:22:08.200
das nächste Mal wird es auch noch ganz interessant, weil dann müssen wir die Übertragung programmieren,

03:22:08.200 --> 03:22:16.040
wie wir die Sachen, die wir hier vom ADC ausgelesen haben, quasi per LoRa an den Empfänger schicken.

03:22:16.040 --> 03:22:23.160
Wie gesagt, über 1,5 Kilometer läuft das Ganze dann. Und ich hab's schon ausprobiert,

03:22:23.160 --> 03:22:28.440
es funktioniert. Ja, und dann werden wir das optimieren lassen, dass möglichst wenig

03:22:28.440 --> 03:22:34.240
Batterie verbraucht. Wann wird das nächste Mal ja vielleicht? Aber ich verspreche, ihr

03:22:34.240 --> 03:22:40.040
kennt mich ja, ich kann das... Ich würde ja immer gerne am besten gleich noch weitermachen,

03:22:40.040 --> 03:22:43.240
immer wenn ich mal gestreamt habe. Wenn ich ein paar Tage wieder nicht gestreamt hab,

03:22:43.240 --> 03:22:50.760
dann bin ich irgendwie immer so motivationsmäßig, nicht so... Ja, ich weiß auch nicht. Ich glaube,

03:22:50.760 --> 03:23:02.560
zum größten Teil liegt es daran, dass ich auf YouTube nichts mache. Und ich deswegen

03:23:02.560 --> 03:23:06.080
überhaupt nicht mehr so in diesem Rhythmus drin bin, was Upload und so Sachen angeht.

03:23:06.080 --> 03:23:17.680
Was macht das Alien Links in VS Code? Das startet die Oberfläche von meiner Arduino IDE,

03:23:17.680 --> 03:23:28.280
quasi. Beziehungsweise von Platform IO. Das machts programmieren ein bisschen einfacher.

03:23:28.280 --> 03:23:57.720
Kannst aber auch einfach das Arduino Plugin nehmen. Also den...

03:23:57.720 --> 03:24:04.600
den Raspberry Pi Standalone, ohne Raspberry Zeug drauf zu verwenden, stelle ich mir schwierig

03:24:04.600 --> 03:24:10.360
vor, weil der Raspberry Pi ist gar nicht so offen, wie man das denkt. Da ist ganz viel

03:24:10.360 --> 03:24:20.480
proprietäre Geschichte von Broadcom drauf. Also die Arm-CPU ist da so eine Sache, quasi

03:24:20.480 --> 03:24:27.880
so 3. Klasse, Hardware 3. Klasse drauf auf dem Raspberry. Das fängt ja schon an, dass

03:24:27.880 --> 03:24:33.520
der eigentliche Loader proprietär ist. Wird es meinen Discord-Server geben? Ja, aber keine

03:24:33.520 --> 03:24:39.600
Ahnung, man. So Leute, schön, dass euch gefallen hat. Ich gehe jetzt mal endlich eine Pizza

03:24:39.600 --> 03:24:56.240
futtern. Machts gut, bis zum nächsten Mal. Tschüss, CU.

