WEBVTT

00:30.000 --> 00:41.760
ich bin wieder da wir machen jetzt da weiter wo wir gestern aufgehört haben aber ohne kuemo

00:41.760 --> 00:44.600
da habe ich kein nerv drauf

00:44.600 --> 00:51.640
ich muss mich in github einloggen ich hab grad ich war grad so bescheuert und hab die

00:51.640 --> 00:59.040
hab die cookies gelöscht das heißt im endeffekt jetzt muss ich das streben sie noch nicht an so

00:59.040 --> 01:04.800
wie nicht so richtig die kunde dürfte jetzt nicht zugucken

01:04.800 --> 01:21.080
so please sms github

01:21.080 --> 01:43.800
excellent okay da bin ich wieder soll diesen krempel von gestern machen wir mal zu das kann

01:43.800 --> 01:50.480
ich heute das halte ich heute noch mal aus kuemo dockerfeige schiss das ist mir das war

01:50.480 --> 01:57.440
mir gestern so anstrengend wir konzentrieren uns heute mal ein bisschen auf github actions und

01:57.440 --> 02:02.240
dann müssen wir erstmal ein bisschen ausprobieren mal kurz noch ein bisschen package updates machen

02:02.240 --> 02:13.880
ja gar nicht twitch ist dazu da live zu gucken was ist denn hier alles drauf warum also ok warum

02:13.880 --> 02:20.960
python 2 und was zum teufel ist uranium war das nicht mal in den pokemon klon und was ist arkus

02:20.960 --> 02:32.240
habe ich da alles installieren ok was ist das 3d drucker zeug 3d drucker zeug

02:32.240 --> 02:41.960
kann ich mal deinstallieren deswegen hat er wahrscheinlich auch python 2 zeug drauf

02:41.960 --> 02:51.200
und jetzt wird es weniger hängt da hat er gar keinen bock mehr aber python 2

02:51.200 --> 03:01.760
alle warum habe ich denn das drauf was ist komplett unsinnig weg weg jetzt

03:01.760 --> 03:12.200
aber wir machen mal kurz docker docker system alles weg ja das darfste updaten gut ist alle

03:12.200 --> 03:21.680
images weg aufräumen volumes weg sollte er eigentlich jetzt gemacht haben aber man weiß ja nicht

03:21.680 --> 03:32.360
ok gut wunderbar ja wir machen weiter wo wir gestern stehen geblieben sind allerdings heute

03:32.360 --> 03:40.740
mit github actions und nicht mit kuemo und docker falls doch erfalls ja aber nicht kuemo

03:40.740 --> 03:53.880
docker falls also das ziel ist ja nach wie fair nach wie vor dass ich meinen home assistant

03:53.880 --> 04:02.520
addon bauen kann für x86 und für arm über github actions so dass es auf raspberry pi

04:02.520 --> 04:09.200
läuft und halt auf einem normalen rechner und es gestaltet sich schwieriger als gedacht mit

04:09.200 --> 04:17.800
dem emulator sagt heute machen wir die nupe variante ohne emulator ich muss nicht rebooten

04:17.800 --> 04:21.480
ich habe kein kernel update gemacht das ist ja nur wenn du kernel update machst dass du

04:21.480 --> 04:26.120
rebooten musst aber wir können tatsächlich wir können trotzdem rebooten man weiß ja

04:26.120 --> 04:34.240
nie ich leg mal ein neues repo für für heute an keckel test das schmeißen aber nachher

04:34.240 --> 04:42.480
wieder weg description omega keckel ich habe gar wobei wer weiß was das aber kein description

04:42.480 --> 04:56.280
public dotnet haben die haben die den dotnet ignore file sp gibt es nicht was sie schab

04:56.280 --> 05:02.240
oder wie heißt denn das macht das normalerweise selbst weil das relativ easy ist bin rein

05:02.240 --> 05:20.800
objekt dran anscheinend nicht na gut license ja create doch doch doch musst du muss du

05:20.800 --> 05:26.240
dich zwingt keiner den restart zu machen aber wenn du den neuen kernel laden willst musst

05:26.240 --> 05:31.640
du restarten und wenn du sachen haben wenn du sachen weiter verwenden willst die irgendwelche

05:31.640 --> 05:36.320
kernel module verwenden muss auch neu starten weil dann hast du die kleinen software die

05:36.320 --> 05:40.440
verwendet irgendwelche neuen kernel module die nicht laden kann sowie docker der macht

05:40.440 --> 05:48.800
sagt er doch nee geht nicht ja es gibt so es gibt so ein paar dinger was beispielsweise

05:48.800 --> 05:58.840
bei ubuntu mittlerweile am start ist dass du manche sachen auch nicht alle manche sachen

05:58.840 --> 06:03.960
kannst du machen ohne neustart aber auch nicht alles ok was willst du machen dann erklär

06:03.960 --> 06:11.040
mal dann erzähl mal wenn du kernel update gemacht hast und du willst das ohne neustart

06:11.040 --> 06:15.520
komplett neu laden dann erzähl mal beziehungsweise dass auch alle kleinen software funktioniert

06:15.520 --> 06:34.120
da bin ich ja mal gespannt drauf jetzt das kackele wer ist wer ist ein kegel oder kackele

06:34.120 --> 06:49.400
ja wir haben ein neues repo wunderbar ja und ich sag dir es geht nicht kackele geil

06:49.400 --> 06:54.880
es geht nicht also was die dir erzählt haben ist wahrscheinlich diese geschichte die unter

06:54.880 --> 07:02.200
anderem auch ubuntu macht dass du manche dinger ohne nen reboot updaten kannst kernel aber

07:02.200 --> 07:15.560
auch nicht alles auch nicht alles aber ganz im ernst das verbenutzt eigentlich kaum einer

07:15.560 --> 07:23.280
meistens wird trotzdem bei nem kernel update rebooted was auch so ziemlich die einzige

07:23.280 --> 07:30.960
sache ist wo du rebooten musst na also den da benutze ich auch seit jahren schon den da

07:30.960 --> 07:37.480
nicht den nicht das meine aber den da ist es so standard hier der da ich meine es zwingt

07:37.480 --> 07:41.040
dich natürlich keiner zu rebooten ja du kannst das ding weiter benutzen das läuft ja weiter

07:41.040 --> 07:44.480
auch ohne reboot aber dann hast du keinen neuen kernel geladen beziehungsweise hast

07:44.480 --> 07:50.160
probleme wenn du halt software hast die irgendwelche neuen modulversion erwartet dann geht das

07:50.160 --> 08:14.400
nicht aha ich hab ja nie gehört kackele kackele kurz was trinken laute das kenne ich noch

08:14.400 --> 08:31.360
nicht das ist sicher nicht was man im laufenden betrieb mit seinen produktiven surfern machen

08:31.360 --> 08:39.880
will jetzt die musik wird auf einmal zu leise kann sich wieder nicht entscheiden muss man

08:39.880 --> 08:52.600
eine andere playlist machen erstens ist mir die deutlich zu entspannend ja beach holiday

08:52.600 --> 09:10.880
das brauchen wir jetzt wie gesagt kernel updates ist so ziemlich das größte was du

09:10.880 --> 09:16.200
unter linux machen kannst da musst du neu starten wie gesagt manche teile gehen ohne

09:16.200 --> 09:25.040
aber ansonsten willst du das eigentlich nicht machen so also wo sind verstehen geblieben

09:25.040 --> 09:28.280
genau wir haben komische docker files gebaut wir haben neues repo ich klone mal kurz mal

09:28.280 --> 09:47.160
neues repo ein 1p ssh cd repos git clone zack appear to have clone in empty repository

09:47.160 --> 09:51.600
das geht aber gar nicht wie viele kackels hab ich denn hier jetzt eigentlich kackel test

09:51.600 --> 10:00.520
bin punkt geht ignore ich bin jetzt habe ich jetzt richtig geschrieben geht ignore das erste

10:00.520 --> 10:05.880
was wir brauchen ist dass ich meine ganzen dotnet bills nicht mit einchecke zeigt mal

10:05.880 --> 10:12.400
kurz her wir klauen uns einfach die geht ignore von hier sehr schön die will ich haben excellent

10:12.400 --> 10:24.800
git add zack git commit a minus m init git push origin master so und jetzt sollte was

10:24.800 --> 10:31.200
im repo drin sein nämlich ein leeres git ignore file excellent so jetzt können wir anfangen

10:31.200 --> 10:36.840
also wie gesagt ich versuche das noch mal zusammenzufassen was der plan ist und zwar

10:36.840 --> 10:40.800
ich habe ein home assistant addon gebaut wo man unter anderem sachen aus einem fiat aus

10:40.800 --> 10:46.120
einem auto auslesen kann hat er eigentlich noch mal auf das issue geantwortet andere

10:46.120 --> 10:55.800
du nee und dieses addon gibt es für raspberry pi und für x86 aus stimmt leute meine güte

10:55.800 --> 11:00.280
jetzt sind bestimmt wieder die die github göttler sind getriggert dass ich master branch

11:00.280 --> 11:15.840
genannt habe oh nein jetzt ist vorbei leute instant instant ban und blog zwar es war eine

11:15.840 --> 11:22.520
eine super zeit leute es ist es ist vorbei gleich bin ich weg übrigens ich kann euch

11:22.520 --> 11:26.520
zeigen wie einfach das ist es um zu benennen das ist tatsächlich relativ simpel ja man

11:26.520 --> 11:31.440
kann mir einfach sagen git branch minus m minus m und dann kann man das main nennen

11:31.440 --> 11:37.640
und das war's ups mehr muss man nicht machen jetzt kann man das ganze noch mal so pushen

11:37.640 --> 11:44.280
so fertig und jetzt haben wir ein master und eine main branch da ups das ist der vier

11:44.280 --> 11:50.240
champ da jetzt haben wir einen master und haben einen main branch und jetzt kann ich kann

11:50.240 --> 12:00.760
ich zum beispiel sagen git push origin minus minus delete master also master aber weil

12:00.760 --> 12:05.640
ich initial einmal master gepusht habe und refused das habe ich tatsächlich gut als

12:05.640 --> 12:10.240
unbenennt ist einfach aber ansonsten hat irgendwelche schmerzen mir egal wir bleiben jetzt immer

12:10.240 --> 12:27.880
master kann ich mir einfach ermerken so lange man nicht gepusht hat ist es einfach so also

12:27.880 --> 12:32.080
wie gesagt ich habe hier das addon erstellt das soll gebaut werden für github über github

12:32.080 --> 12:39.600
actions für arm und für x86 bisher war es einfach da wurde es auf dem jeweiligen zielrechner

12:39.600 --> 12:45.440
gebaut was natürlich dann immer automatisch die richtige plattform war in zukunft will

12:45.440 --> 12:50.000
ich aber prebuild images anbieten was ich schon mache hier guck prebuild images aber

12:50.000 --> 12:55.480
die sind aktuell nicht sonderlich schön gebaut die baue ich lokal bei mir mit dem lokal installierten

12:55.480 --> 13:01.240
dotnet mit meinem lokalen docker und upload die dann also ob das so reproduzierbar ist

13:01.240 --> 13:06.600
bezweifle ich sondern was ich mal ausprobieren will wie kriege ich über github actions in

13:06.600 --> 13:13.720
image gebaut ein container image für arm und für x86 und vorher die anwendung kompilieren

13:13.720 --> 13:21.200
auf x86 und armen mit ku emu habe ich gestern probiert also quasi eine arm cpu auf desktop

13:21.200 --> 13:25.880
emulieren das geht theoretisch aber dotnet ist verbackt das funktioniert nicht das heißt

13:25.880 --> 13:30.080
wir werden das jetzt in folgen wir werden es jetzt folgendermaßen versuchen so habe

13:30.080 --> 13:37.560
ich mir das zumindest überlegt wir machen eine github action wo wir zuerst mal das dotnet

13:37.560 --> 13:44.720
zeug bilden und das kopieren wir dann jeweils in den armen container und in ein x86 container

13:44.720 --> 13:49.680
ohne irgendwas zu bilden mal gucken mal gucken das funktioniert ich sollte erstmal vielleicht

13:49.680 --> 13:55.080
ein testprojekt anlegen dass das funktioniert oder so ein test addon ich kopiere mir einfach

13:55.080 --> 14:02.360
mal den kram hier easy wir machen einfach so ein fake fake addon was was leer ist wo

14:02.360 --> 14:11.320
nix drin steht also hier mk dir test addon da drinnen brauchen wir das das muss euch

14:11.320 --> 14:15.240
jetzt nicht zu sehr interessieren das ist das ist homosystem spezifisch dass das dass

14:15.240 --> 14:19.680
das funktioniert aber ich leg das jetzt auch mal so an wie es wie es in dem anderen repo

14:19.680 --> 14:26.920
drinne ist ich kann mir das ich kann mir das einfach von hier kopieren konfig jammel zack

14:26.920 --> 14:37.000
zack so also das da brauchen wir alles nicht das brauchen wir auch nicht wir wollen das

14:37.000 --> 14:50.560
erstellen für arm die 64 und arm vor sieben jahre so nein neues image test champ version

14:50.560 --> 14:58.160
ja gut standardmäßig starten wir mal mal 0.0.1 brauchen wir nicht brauchen wir nicht

14:58.160 --> 15:17.520
0.0.1 wie habe ich das repo genannt kackeltest aber glaube gar nicht test addon das müsste

15:17.520 --> 15:25.320
reichen gut was brauchen wir denn sonst noch in docker file brauchen wir noch kopiere ich

15:25.320 --> 15:31.320
mal standardmäßig rein im docker file da können wir anfangen mit github actions zu

15:31.320 --> 15:37.760
basteln das kommt weg ran brauchen wir nicht ran brauchen wir auch nicht ja und das da

15:37.760 --> 15:46.640
garantiert auch nicht so sonst noch irgendwas ich glaube das war es zum testen sollte das

15:46.640 --> 15:59.840
reichach so ja natürlich wir brauchen zum test noch ein noch ein dotnet dotnet konsolenanwendung

15:59.840 --> 16:21.920
zwar mk dir ab new console das sollte reichen habe ich noch irgendwas vergessen war das

16:21.920 --> 16:26.880
liegt jetzt unter ab das heißt im endeffekt auch wir wollen was von ab bild rüber kopieren

16:26.880 --> 16:43.040
ja ok das muss jetzt aber echt gewesen sein als vorbereitung ok wunderbar komm mit lul

16:43.040 --> 16:53.640
oder nur lu lu pass startet noch ja wir starten wir starten ja gar nichts es geht mir um das

16:53.640 --> 16:58.280
bild was man machen kann lu lu in it so jetzt haben wir den kram vorbereitet jetzt würde

16:58.280 --> 17:02.920
ich sagen jetzt gucken wir uns mal ein paar github actions an also von der idee her müsste

17:02.920 --> 17:22.800
der ablauf folgendes sein ich war dann mal gucken ob ich das hier ob ich das so grob

17:22.800 --> 17:29.440
das ist ganz schön blutet standardmäßig also wir müssen ok also wir brauchen einen

17:29.440 --> 17:46.240
job der die anwendung auscheckt baut mit dotnet

17:46.240 --> 17:52.360
dann das gebildete wahrscheinlich zwischenspeichert dann in arm image macht das gebildete reinkopiert

17:52.360 --> 17:58.480
für arm das image upload und dann das image nee leute was viel besseres leute six head

17:58.480 --> 18:06.720
time wisst ihr was wir verwenden github actions strategy matrix das machen die github pros

18:06.720 --> 18:11.560
die verwenden strategy matrix ich wusste bis vor kurzem gar nicht dass das überhaupt

18:11.560 --> 18:18.040
existiert aber wisst ihr was man machen kann man kann einen job in github actions mit mehreren

18:18.040 --> 18:26.400
parametern stand starten lassen dass das ist dafür glaube ich genau richtig aber wir testen

18:26.400 --> 18:33.800
den bild erstmal also on push branches master so wollen wir eine ubuntu vm in github actions

18:33.800 --> 18:40.200
starten klingt richtig pfeifert standardmäßig kann github actions glaube ich drei verschiedene

18:40.200 --> 18:47.800
vm typen das sind das einmal ubuntu das einmal mac und einmal windows mehr gibt es nicht

18:47.800 --> 18:53.960
wenn man irgendwelche speziellen sachen machen will wie machen will wie lpein linux und sonst

18:53.960 --> 18:57.920
was dann muss man sich in docker container starten mit lpein oder in container starten

18:57.920 --> 19:07.080
mit lpein die da der dann auf dieser ubuntu vm eben läuft eigentlich richtig six head

19:07.080 --> 19:11.200
wie schnell die das hinbekommen haben bei github oder ich meine die buten die innerhalb

19:11.200 --> 19:19.240
von von drei sekunden eine komplette neue ubuntu vm gut das ist ja eigentlich auch kein

19:19.240 --> 19:24.080
großes ding wenn du wenn du alles lokal fertig gebaut liegen hast und nur noch quasi ein

19:24.080 --> 19:30.480
image an kvm dran hängen musst du kannst auch eine strategy matrix dynamisch aus jason

19:30.480 --> 19:36.720
generieren oh jetzt jetzt wird jetzt wird es advanced da musst du mir mal ein beispiel

19:36.720 --> 19:41.800
irgendwo linken da habe ich das weiß ich wir testen jetzt erstmal ob so ganz primitive

19:41.800 --> 19:47.720
sachen wie wir bilden unsere anwendung überhaupt funktioniert ja ok also wir wollen dort jetzt

19:47.720 --> 19:54.280
sieben haben für die anwendung genau erster schritt ist das geht repo aus checken was

19:54.280 --> 20:00.360
ich immer ganz gerne mache ich schreibe immer einmal name dabei also check out finde das

20:00.360 --> 20:04.480
kann man dann auch besser sehen in der übersicht ich meine gut die check out action check out

20:04.480 --> 20:07.480
nennen ist ziemlich bescheuert aber ich mache das eigentlich ganz gerne dass ich überall

20:07.480 --> 20:13.960
immer noch ein name davor schreibt so set up können wir meinetwegen sogar set up nennen

20:13.960 --> 20:18.920
restore brauchen wir nicht bild brauchen wir auch nicht das einzige was wir brauchen

20:18.920 --> 20:38.160
ist dotnet publish das da brauchen wir ja ok noch mit dem statischen identifier so

20:38.160 --> 20:48.800
bild release nennen wir das ding so speichern wir mal und was jetzt theoretisch passieren

20:48.800 --> 20:59.320
müsste wenn ich was pushe dann sollte er automatisch dieses dieses kript ausführen

20:59.320 --> 21:04.200
oder diese action ausführen was man auch sieht funktioniert der hat das repo ausgecheckt

21:04.200 --> 21:09.560
automatisch wohlgemerkt bei jedem pusch der hat das repo ausgecheckt da jetzt auch monka

21:09.560 --> 21:21.200
ist ich bin im falschen verzeichnis kann das sein notz notz specified github changelog

21:21.200 --> 21:39.200
ok was new from jason method in expressions oh das ist next level shit

21:39.200 --> 21:45.840
äußerst äußerst lesbare syntax an dieser stelle findet ihr nicht auch gut es ist halt

21:45.840 --> 21:52.120
escape des jason aber obvius was hier passiert cringe cringe wer es nicht versteht also was

21:52.120 --> 21:58.520
machen die dann hier matrix depp setman ah die generieren sich das aus irgendeinem jason

21:58.520 --> 22:03.760
oh das ist aber next level ja und dann hast du in deinem repo irgendein ein jason feil

22:03.760 --> 22:12.760
was dann die die eigentlichen jobs definiert oder wie oh das ist das ist das ist mir zu

22:12.760 --> 22:25.040
advanced aber wir gucken uns das wir gucken uns das mal an chat ich habe jetzt viel geschwätzt

22:25.040 --> 22:29.840
ich habe jetzt 20 minuten durchgelabert versteht überhaupt irgendjemand was ich vor hab zu

22:29.840 --> 22:37.800
machen konnte mir irgendjemand folgen ich habe nämlich das gefühl ich glaube es checkt

22:37.800 --> 22:50.480
gerade keiner was ich will das dachte ich wäre null ok dann versuche ich das dann versuche

22:50.480 --> 22:54.680
ich das noch mal kurz zu erklären fünf minuten wir müssen uns ja nicht gar so sehr hetzen

22:54.680 --> 23:07.680
haben ja zeit richtig genau das an image also ich hab was programmiert es ist egal was

23:07.680 --> 23:15.200
es macht das soll am ende auf dem raspberry pi laufen was welche eine armen cpu hat und

23:15.200 --> 23:19.680
es soll ganz normal auf desktop rechner laufen können oder halt auf server laufen mit intel

23:19.680 --> 23:29.120
und amd cpus also x86 64 so das soll unterstützt werden das heißt wir müssen das programm

23:29.120 --> 23:36.560
einmal kompilieren als x86 version und einmal als armen version so und damit das dann auf

23:36.560 --> 23:44.560
dem zielsystem läuft muss das ganze noch in den image eingebettet werden dass die software

23:44.560 --> 23:49.640
die das addon ausführt nur noch dieses image starten muss so nachdem man die software einmal

23:49.640 --> 23:56.040
braucht für armen cpus und einmal für x86 cpus braucht man das image auch einmal für

23:56.040 --> 24:02.880
armen cpus und einmal für x86 cpus was man braucht diesen schritt doppelt man braucht

24:02.880 --> 24:07.040
ein image für die jeweilige zielarchitektur und man braucht die software logischerweise

24:07.040 --> 24:11.360
für die jeweilige zielarchitektur von der idee her ist das einfach man könnte es mit

24:11.360 --> 24:17.240
docker bild x machen die unterstützen das die emulieren das ja genau genau genau so

24:17.240 --> 24:27.280
was gibt's man kann beispielsweise bild x verwenden mit multiarch images und wenn man

24:27.280 --> 24:33.240
dann koemu installiert dann kann er beispielsweise auf einem desktop rechner ein raspberry pi

24:33.240 --> 24:38.160
emulieren oder eine armen cpu emulieren das funktioniert normalerweise auch ziemlich gut

24:38.160 --> 24:43.320
also beziehungsweise mir ist eigentlich nix bekannt wo es nicht funktioniert außer für

24:43.320 --> 24:50.560
dotnet dotnet ist verbackt mit koemo das haben wir gestern drei stunden lang oder vier stunden

24:50.560 --> 24:58.960
probiert und das funktioniert nicht deswegen müssen wir das anders machen sonst wäre

24:58.960 --> 25:05.720
das ein docker file mit drei zeilen und fertig wofür braucht man dann docker docker brauchst

25:05.720 --> 25:15.080
du zum erstellen des images weil dieses addon das ist ein addon für home assistant os und

25:15.080 --> 25:20.720
was die machen ist alle addons werden dort in einem eigenen docker container gestartet

25:20.720 --> 25:25.800
einfach dass es besser isoliert ist und den addon nicht den host kaputt machen kann das

25:25.800 --> 25:31.360
heißt du musst ein image zur verfügung stellen für die jeweilige zielarchitektur wo deine

25:31.360 --> 25:36.400
software drin ist kompiliert für die jeweilige zielarchitektur docker ist nicht written in

25:36.400 --> 25:41.760
rust alda docker ist älter als okay nicht älter als vielleicht doch älter als rust

25:41.760 --> 25:46.400
auf jeden fall ein docker ist nicht written in rust docker ist glaube ich in go zum größten

25:46.400 --> 25:56.440
teil oder jaja es war nicht rust das ist go blazingly fast written in go geht aber auch

25:56.440 --> 26:04.840
egal blazingly fast und das allerwichtigste den hier der muss immer dabei rakete blazingly

26:04.840 --> 26:15.240
fast so hat man jetzt verstanden oder so das ding ist halt ich brauche jetzt irgendwie

26:15.240 --> 26:22.900
eine angenehme art und weise wie ich bei einer neuen version von meinem addon eben dieses

26:22.900 --> 26:32.440
image erzeugen kann dafür gibt es zwei varianten das das addon image zu erzeugen entweder man

26:32.440 --> 26:38.040
lässt das auf dem zielsystem bauen von home assistant dann ist automatisch alles immer

26:38.040 --> 26:43.320
in der richtigen architektur weil der lädt sich das docker file runter und baut das docker

26:43.320 --> 26:48.680
file quasi dann auf seinem raspberry pi das problem ist nur dass es langsam und es verbraucht

26:48.680 --> 26:53.880
ziemlich viel ram gerade für das für das kompilieren von dem programm und ich hatte

26:53.880 --> 27:01.360
jetzt ein paar issues bei mir im im projekt ja zum beispiel zum beispiel die hier die hatten

27:01.360 --> 27:07.600
ein problem die haben den raspberry pi mit 2 gigabyte ram und von dem 2 gigabyte ram

27:07.600 --> 27:15.200
ist 1,3 gigabyte schon weg für in home assistant und der rest ist vielleicht von anderen addons

27:15.200 --> 27:20.360
blockiert also dass mein addon im bild einfach mal 600 mp ram frisst ging halt nicht die konnten

27:20.360 --> 27:27.160
das nicht ausführen und es ist eh besser ein prebuilt image bereitzustellen anstatt

27:27.160 --> 27:29.600
das selbst alles machen zu lassen auf dem zielsystem

27:29.600 --> 27:36.800
Leute ich mache gleich ich wollte sagen ich mache gleich issues aus aber das ist natürlich

27:36.800 --> 27:45.080
ein sehr guter hinweis ich weiß nicht ob ihr es wusste leute aber er hat recht twitch prime

27:45.080 --> 27:52.720
ist kostenlos zumindest wenn ihr amazon prime habt also ganz kostenlos ist es auch nicht

27:52.720 --> 27:58.680
das muss man gleich mal taggen dieses issue ja das wir erstmal label als gut gut first

27:58.680 --> 28:14.080
issue und enhancement alles klar und und und moment moment so jetzt haben wir es richtig

28:14.080 --> 28:28.840
gemacht any primers gut ja weiter geht es so sieht es aus fix fail fix fail fix und irgendwann

28:28.840 --> 28:34.200
geht es vielleicht genau und das und das probieren wir heute so und am liebsten hätte

28:34.200 --> 28:38.720
ich halt dass es bei einem push von einer neuen version automatisch eben diese images

28:38.720 --> 28:44.720
erzeugt und das kann man zum beispiel über so was automatisches machen wie mit github

28:44.720 --> 28:48.880
actions wo man dann das programm aus check also den source code aus checken kann bauen

28:48.880 --> 29:01.080
kann und im endeffekt auch das image veröffentlichen kann

29:01.080 --> 29:06.800
das frage ich mich auch github actions azure devops und sonst wie ich habe ehrlich gesagt

29:06.800 --> 29:12.220
außer in der microsoft schulungen die ich war vor einer weile gemacht habe nie was von

29:12.220 --> 29:20.400
azure devops gesehen bei uns auf der arbeit ist alles komplett github und entweder mit

29:20.400 --> 29:25.120
github actions oder eben manche haben halt noch einen eigenen build server oder jenkins

29:25.120 --> 29:36.480
oder sonst was kannst du irgendwo dein jammel hinlegen ich will das nicht kopieren ich will

29:36.480 --> 29:53.760
das selbst machen ja stimmt ja github github gehört microsoft ja seit drei jahren oder

29:53.760 --> 30:01.640
so das ist schon eine weile her und die haben es nicht verkackt die haben immer mal wieder

30:01.640 --> 30:06.640
so ein paar krumme also atom wurde eingestellt ja aber wer hat wirklich atom hat jemand von

30:06.640 --> 30:15.920
euch ernsthaft atom benutzt sie haben so ein paar komische ja so ein paar komische dinger

30:15.920 --> 30:27.640
manchmal so wie wollen die trends abschaffen und sowas da weiß ich immer nicht was mit

30:27.640 --> 30:36.680
microsoft abgeht aber wir sind im falschen verzeichnis gewesen wir müssen nach cd wie

30:36.680 --> 30:44.960
habe ich denn das genannt cd test addon test addon app da wollen wir hin und dann wollen

30:44.960 --> 30:59.120
wir das publish machen so zeigt mal ob es jetzt funktioniert actions zeige ich mal her

30:59.120 --> 31:11.440
start das verdammte spiel ich will nicht dass es lebt mal schauen ob es jetzt funktioniert

31:11.440 --> 31:22.360
also mit den parzeilen jammel machte schon relativ viel das haben die schon gut gemacht

31:22.360 --> 31:29.080
also ich mein guck mal der start in ubuntu vm in der cloud das klicke ich jetzt nicht

31:29.080 --> 31:40.360
an wer weiß was man damit anfangen kann dann checkt er mal github repo aus dann installiert

31:40.360 --> 31:47.200
der dotnet dann macht ein dotnet bild und dann räumt er wieder auf ist eigentlich ziemlich

31:47.200 --> 31:55.320
cool der big tasty bewährter da kann ich mich nicht mehr dran erinnern wer das ist

31:55.320 --> 32:07.800
so also es hat funktioniert so unsere dotnet anwendung ist gebaut easy fertig so einfach

32:07.800 --> 32:32.560
ist es leider nicht kurz aus copy pasten von woanders sack hallo max bin schon lange abonnent

32:32.560 --> 32:37.600
von dir seitdem ich glaube 16 bin ja da bist du nicht der einzige es gibt total viele die

32:37.600 --> 32:45.280
erzählen früher war ich irgendwie kleiner kleines cod kind und jetzt bin ich keine ahnung

32:45.280 --> 32:48.720
fachinformatiker anwendungsentwicklung und sowas habe ich gelernt oder gerade ausbilden

32:48.720 --> 32:52.840
jetzt total viele das finde ich immer cool ich hätte gar nicht gedacht leute damals

32:52.840 --> 32:58.800
als ich die videos aufgenommen habe dass ich so viele leute quasi influence fachinformatiker

32:58.800 --> 33:07.560
zu werden das war noch zeit bevor influencer influencer hieß ich habe das einfach gemacht

33:07.560 --> 33:12.000
weil ich denke das thema interessiert die leute und ich denke mal das hat auch viele

33:12.000 --> 33:15.240
interessiert die eben gerade in dem alter waren wo man nach einer ausbildung sucht oder

33:15.240 --> 33:25.800
mit der schule fertig wird und sowas ja ist aber schön dass du den weg her gefunden hast

33:25.800 --> 33:38.320
so zu sagen haben wir das die mode überhaupt noch haben so viele poge modes ja haben wir

33:38.320 --> 33:53.440
noch oder poc poc u ist es also playlisten wo die sounds unterschiedlich laut sind die

33:53.440 --> 34:05.960
ok also jetzt wo ich mal in mich gehen wie könnten wir das ganze machen also ich will

34:05.960 --> 34:13.840
die software einmal bauen für genau also ich will meine software einmal bauen für

34:13.840 --> 34:21.560
linux x86 allerdings für lpein und dann ist es so und ich will die software einmal bauen

34:21.560 --> 34:29.560
wie macht man multi multi multi line run irgendwie irgendwie irgendwie so oder so wie ging das

34:29.560 --> 34:39.240
bei jamal jamal hat so eine ganz abartige sonntags für multiline war das so das ist

34:39.240 --> 34:43.760
wirklich immer so ein ding wo man sich denkt was was hat die leute geritten daraus multiline

34:43.760 --> 34:58.360
ach war das war das so nee nee war anscheinend schon richtig jamal und github actions multiline

34:58.360 --> 35:16.060
nee nee nee nee nee nee♡ folded style ach einfach nur den einfach nur

35:16.060 --> 35:28.080
den fail oder wie ok so also ich will das zweimal bilden einmal für x86 & einmal armbd

35:28.080 --> 35:33.400
und einmal ARMv7 Schauen wir mal ob das so weit funktioniert

35:33.400 --> 35:40.920
Der jetzt zwei Sachen baut Kann man kein YAML Array verwenden?

35:40.920 --> 35:50.240
Ne, das ist ja Shell, Shell Befehle, da bringt ja ein YAML Array nichts

35:50.240 --> 35:58.800
Mal gucken ob das Bild funktioniert Massive Build, Broken Build

35:58.800 --> 36:00.040
So funktioniert das schonmal, warum?

36:00.040 --> 36:06.880
Ah, der führt nicht mehrere Befehle nacheinander aus

36:06.880 --> 36:10.640
Sondern der will das alles in einem ausführen

36:10.640 --> 36:16.040
Wie ist denn da die richtige Söntagsführung?

36:16.040 --> 36:26.360
Ok, GitHub, Actions, Run, Multiple Commands

36:26.360 --> 36:44.440
Wenn man das jetzt noch richtig, Alter Ach doch, Pipe

36:44.440 --> 36:53.400
Alter, wer denkt sich denn bitte schön diese Söntags aus, Mann?

36:53.400 --> 37:00.200
YAML hat wirklich Pains Champ Söntags

37:00.200 --> 37:06.000
Ganz ehrlich, der einzige Vorteil den ich für mich persönlich in YAML vs. Jason sehe

37:06.000 --> 37:10.760
ist, dass du Kommentare machen kannst Der Rest ist mir tatsächlich in Jason lieber

37:10.760 --> 37:22.240
Ok, geht mal ein Bild jetzt Ja, wo ist das Problem, was hat er denn?

37:22.240 --> 37:26.320
Warum ist das, warum geht das nicht?

37:26.320 --> 37:45.840
No such file or directory Wie, vorhin ging es doch auch

37:45.840 --> 38:02.080
Ach so, ich habe es zweimal kopiert, lull

38:02.080 --> 38:05.600
Ja, und nachdem es jetzt Multi-Line ist, kann ich es auch einfach so machen

38:05.600 --> 38:25.520
So, jetzt wird es aber funktionieren Kennst du Jackal, ja, das ist irgendein CMS-Gedöns

38:25.520 --> 38:29.520
Ja, das nutzt auch YAML Ja, ganz vieles nutzt YAML

38:29.520 --> 38:36.080
Oder wenn man in der Rust-Welt unterwegs ist, dann Tommel

38:36.080 --> 38:41.400
Weil die Rust-Leute sich gedacht haben, YAML ist zu bloated und nicht Blazingly fast

38:41.400 --> 38:46.440
Written in Rust, dann muss es Tommel sein Hey, meine Builds funktionieren

38:46.440 --> 38:52.280
Also, es gibt jetzt quasi einmal das Ding per Es gibt die Software einmal für AMD V7

38:52.280 --> 39:03.720
und einmal für AMD 64, sehr schön Moin, Open-Source Likku

39:03.720 --> 39:12.800
Inifald sind Painschamp Ok, besser als XML

39:12.800 --> 39:16.560
Ja gut, wenn es darum geht, man findet immer was, was schlechter ist

39:16.560 --> 39:20.360
Man findet auch garantiert was, ja, CSV-Lateien zum Beispiel

39:20.360 --> 39:27.640
Da kann man sich jetzt drüber streiten Leute, was ist schlimmer, CSV oder XML?

39:27.640 --> 39:31.280
Es ist beides eklig Wir machen mal ne Umfrage

39:31.280 --> 39:41.840
Was, was ist schlimmer Schlimmer

39:41.840 --> 39:53.160
XML, CSV, YAML, JSON Was haben wir sonst noch zur Auswahl

39:53.160 --> 40:01.800
XML, CSV, YAML, JSON Oder was ist das Schlimmste davon

40:01.800 --> 40:13.040
Wir sind gerade dabei, wir sind gerade dabei

40:13.040 --> 40:14.040
Was gibt's?

40:14.040 --> 40:15.880
Soap, nee Soap war ja XML, das zählt nicht

40:15.880 --> 40:30.880
Inni, Inni, genau, Inni Zeigt mal her, jetzt bin ich gespannt

40:30.880 --> 40:38.640
Also ich finde CSV auch eklig, aber XML ist natürlich auch schonmal ne ganz andere Hausnummer

40:38.640 --> 40:52.280
Ich glaube, die Vorliebe des Chats für XML ist eindeutig

40:52.280 --> 41:11.800
XML-Chat, GIGA-Chat Ich glaube, die Umfrage müssen wir fast gar

41:11.800 --> 41:16.040
nicht fertig laufen lassen Also XML hat mit riesem Abstand gewonnen

41:16.040 --> 41:22.440
JSON finde ich auch toll, YAML ist okay Ich hab auch manche Sachen, die mich bei

41:22.440 --> 41:27.320
YAML nerven, aber Alles ist nice im Vergleich zu XML

41:27.320 --> 41:32.560
CSV ist auch kacke, aber XML ist wirklich der Gipfel

41:32.560 --> 41:40.920
So und dann kommt Microsoft auf die Idee und macht bei WPF quasi ein XML-Dialekt für GUI-Layouts

41:40.920 --> 41:47.480
Wo ich mich auch frage, was zum Teufel ist bei Microsoft los gewesen damals

41:47.480 --> 41:53.080
Nee, das ist der hauptsächliche Grund, warum ich WPF nie richtig mochte

41:53.080 --> 42:01.760
Ergibt das Chat, das ergibt überhaupt keinen Sinn

42:01.760 --> 42:06.160
Warum sagt keiner was, was ich hier mache Das ist komplett entgegen dem, was ich ursprünglich

42:06.160 --> 42:19.440
gesagt habe, was ich hier gerade mache Und zwar habe ich gesagt, ich will Bildmatrix

42:19.440 --> 42:22.480
verwenden Das sieht nämlich so aus

42:22.480 --> 42:29.840
Hier guckt, so Ich will nämlich diesen Job einmal starten

42:29.840 --> 42:33.280
pro Image Und das sieht dann folgendermaßen aus

42:33.280 --> 42:40.280
Ich hoffe, das stimmt, was ich hier mache unter dem Job

42:40.280 --> 42:45.640
Strategy Matrix-Versions Ersetzen wir durch das, was wir machen wollen

42:45.640 --> 42:50.560
Wir wollen einmal eine ARMv7-Version und einmal eine AMD64-Version

42:50.560 --> 43:01.640
XML ist einfach Teufel Ich mags gar nicht, ich weiß gar nicht, warum

43:01.640 --> 43:09.040
auch Leute sich heute überhaupt noch irgendwie Ja, weiß ich, es gibt Leute, die finden es

43:09.040 --> 43:12.080
einfach toll Es gibt ja auch Leute, die finden Maui toll,

43:12.080 --> 43:16.240
was ich nicht verstehen kann Avalonia ist okay, ich weiß zwar auch Sammeln,

43:16.240 --> 43:20.200
aber immerhin eine sinnvolle Implementierung Nicht so ein Crap wie Maui

43:20.200 --> 43:27.320
Aber ansonsten Die haben ja bei Encute gibt es QML, weiß

43:27.320 --> 43:31.600
ich, ob ihr das schon mal gesehen habt Die haben auch mit so einem Bullshit angefangen

43:31.600 --> 43:42.240
Nur, dass QML tatsächlich deutlich angenehmer ist als XML

43:42.240 --> 43:53.880
Das hat ein bisschen was von Flutter Das finde ich in Ordnung, das geht

43:53.880 --> 44:08.920
Ja, Vinui wird ja nicht fertig, Cap Vinui klappt ja bis heute nicht richtig

44:08.920 --> 44:17.280
Und dann ist natürlich auch WPF Style So, also, was ich eigentlich machen will ist

44:17.280 --> 44:21.560
nicht das, was da steht Guckt mal, ich will kein einzelnes Bild machen

44:21.560 --> 44:26.600
und mit zwei Bildes hintereinander Ich will diesen ganzen Job zweimal ausfüllen

44:26.600 --> 44:33.800
und zwar einmal für AMV7 und einmal für AMD64 So, Output Bild

44:33.800 --> 44:51.480
Ich brauche das hier, die Argumente dafür So und jetzt kann man das hier irgendwie

44:51.480 --> 44:56.080
als Variable einsetzen So, GitHub Variable Expansion

44:56.080 --> 45:00.400
Irgendwie so Und jetzt hört es bei mir auf

45:00.400 --> 45:07.400
Ich glaube Matrix Ja, keine Ahnung

45:07.400 --> 45:10.400
Einfach so, gell Einfach Matrix mal

45:10.400 --> 45:13.640
Wobei wir nicht Versch damit wollten wir denn das Target

45:13.640 --> 45:24.280
Oder Achtsch Ich glaube, so ist richtig

45:24.280 --> 45:29.000
So, und wenn das jetzt funktioniert, wie ich mir das gedacht habe

45:29.000 --> 45:31.720
Dann startet er diesen Job jetzt komplett zweimal

45:31.720 --> 45:36.560
Einmal dafür und einmal dafür Wahrscheinlich habe ich aber irgendeinen

45:36.560 --> 45:43.920
Mittagsfehler produziert Schauen wir mal

45:43.920 --> 45:47.120
Nee, guck mal, der startet das ganze zweimal

45:47.120 --> 45:55.360
Einmal ein Bild für ARM CPUs und einmal ein Bild für AMD CPUs

45:55.360 --> 46:06.360
First try, easy Guck mal, und es funktioniert einfach

46:06.360 --> 46:12.600
Einmal ein Bild für ARM CPUs, einmal ein Bild für X64

46:12.600 --> 46:16.080
Wobei noch ist ja nur die halbe Miet Wir haben ja noch kein Image gebaut

46:16.080 --> 46:20.800
Wir haben ja noch kein Image gebaut Bei Docker Files waren wir auch noch nicht

46:20.800 --> 46:26.600
So, okay Lass mal überlegen

46:26.600 --> 46:36.320
Wie geht es denn jetzt weiter Also wir haben den Kram kompiliert

46:36.320 --> 46:44.960
Jetzt müsste ich ein Image bauen Jetzt müsste ich mit dem Home Assistant Image

46:44.960 --> 46:51.320
Builder ein Image bauen Wo ich damit hin will

46:51.320 --> 46:54.440
Nirgends wohin, ich will innerhalb von dieser VM bleiben

46:54.440 --> 46:58.160
Und dann ein Image draus bauen Ich will jetzt ein Docker Image draus bauen

46:58.160 --> 47:03.720
und das zur GitHub Container Registry pushen So, und es gibt nämlich GitHub Home Assistant

47:03.720 --> 47:08.360
Builder, es gibt nämlich schon für Leute, die Home Assistant Addons bauen wollen

47:08.360 --> 47:14.160
Eine fertige GitHub Action, die das übernimmt, das Image bauen

47:14.160 --> 47:23.480
Sieht dann so aus Wobei wir da noch ein bisschen was anpassen

47:23.480 --> 47:25.800
müssen Das wird so garantiert nicht funktionieren

47:25.800 --> 47:30.400
Also damit habe ich auch die aktuellen Images erstellt

47:30.400 --> 47:39.840
So, das hier heißt dann Create Image Man darf übrigens Leerzeichen machen, so ist

47:39.840 --> 47:46.200
es nicht erlaubt So, also, Add Master, nee

47:46.200 --> 47:54.360
Nicht Add Master, was für Text hat das Ding Ich habe nämlich keinen Bock, dass auf einmal

47:54.360 --> 48:07.760
meine Action kaputt geht So, also, man muss das aufrufen

48:07.760 --> 48:10.920
So, Minus Minus Test ist gut Minus Minus All ist nicht gut

48:10.920 --> 48:17.920
Weil wir wollen ja nur für eine Plattform bauen Addon-Folder, Docker Hub Username

48:17.920 --> 48:25.000
Oh, ich muss mich noch einloggen bei Docker vorher, dass ich das pushen kann

48:25.000 --> 48:28.880
Aber wir bauen erst mal das Image, alles der Reihe nach

48:28.880 --> 48:33.560
Also nicht bei Docker, ich muss die GitHub Container Registry verwenden

48:33.560 --> 48:37.760
So, Test Minus Minus All wollen wir nicht haben

48:37.760 --> 48:42.240
Wir wollen nur für eine Plattform bauen in diesem Step

48:42.240 --> 48:50.920
Okay, es ist Minus Minus AMV7 und Minus Minus AMD64

48:50.920 --> 48:55.280
Das ist natürlich doof Wie?

48:55.280 --> 48:59.520
Okay Kostet die GitHub Container Registry nicht

48:59.520 --> 49:03.160
ordentlich Kohle, nee Die kannst du kostenlos verwenden

49:03.160 --> 49:10.040
Ich weiß nicht ab wann die was kostet Keine Ahnung

49:10.040 --> 49:22.120
About Billing for GitHub Packages Ah, zeig mal her

49:22.120 --> 49:28.240
Was macht das Husting anders als das hier Ah, das ist die Standard Action

49:28.240 --> 49:32.120
Der guckt zum Beispiel in der Config, im Yammel Config-File nach

49:32.120 --> 49:36.240
welche Versionsnummer dein Addon hat und tagt das dementsprechend

49:36.240 --> 49:40.600
Der schreibt glaube ich das Repo rein und so ein paar Sachen, die halt fürs Homo Assistant

49:40.600 --> 49:44.680
Addon wichtig sind Der nennt das auch so

49:44.680 --> 49:50.080
Der nennt den Kram auch richtig, dass Homo Assistant das erkennt, dass das

49:50.080 --> 49:54.000
das richtige Image ist Moin Patrick

49:54.000 --> 49:58.640
Ich glaube 2000 Minuten Free pro Monat Moment, wir reden nicht von Actions

49:58.640 --> 50:02.880
Wir reden von GitHub, von den GitHub Packages Ich weiß nicht was das kostet

50:02.880 --> 50:07.040
Hier also Storage Data Transfer Resets Every Month

50:07.040 --> 50:16.720
While Storage Usage Ach Private Packages

50:16.720 --> 50:25.760
Du kannst anscheinend so viel machen wie du willst

50:25.760 --> 50:29.480
Solang das Public ist das Package Anscheinend kein Ding

50:29.480 --> 50:35.480
Ah Leute ich hab jetzt was anderes Ich weiß nicht wie ich das gescheit machen

50:35.480 --> 50:42.280
soll GitHub hat eine eigene Container Registry

50:42.280 --> 50:47.560
Ja das haben die relativ schnell angekündigt nachdem Docker das limitiert hat

50:47.560 --> 50:51.500
Die Docker Registry wurde ja ziemlich stark reglementiert vor einem Jahr oder so oder

50:51.500 --> 50:55.520
vor zwei Jahren Und dann hat GitHub irgendwie zwei Wochen

50:55.520 --> 51:00.240
später gesagt Ach Übrigens wir haben jetzt auch eine Container Registry

51:00.240 --> 51:11.160
Gibt es eigentlich Docker Haben die diese Limits noch

51:11.160 --> 51:28.840
Haben die das noch Weil Docker hat die

51:28.840 --> 51:33.320
Die Angewohnheit sich selbst ins Knie zu schießen mit Aktionen

51:33.320 --> 51:43.080
Hier Free Users 100 Pulls pro 6 6 Hours Das ist halt nix, das ist viel zu wenig

51:43.080 --> 51:53.360
Hier ist immer noch, ist immer noch so So haben wir pro 24 Stunden

51:53.360 --> 51:56.600
Vielleicht haben sie es wieder ein bisschen gelockert Aber die haben sich mal wieder richtig

51:56.600 --> 52:01.320
selbst ins Knie geschossen Ja gut deswegen verwenden die Leute jetzt

52:01.320 --> 52:05.200
halt GitHub da kannst du so viel pullen wie du willst

52:05.200 --> 52:09.760
Ich hab beispielsweise öfters mal am Limit gekratzt

52:09.760 --> 52:16.000
Weil die ganzen Integrations und Addons in Home Assistant sind alles

52:16.000 --> 52:18.240
Nee nicht die Integrations, die Addons und die

52:18.240 --> 52:29.560
Nee eigentlich nur die Addons Zumindest hat er beim Refresh bei mir

52:29.560 --> 52:33.400
immer immer Probleme gemacht Ich hab's dann runtergestellt

52:33.400 --> 52:36.720
Auf aktualisieren halt noch einmal am Tag und so dann ging's

52:36.720 --> 52:42.160
Aber ganz im Ernst, dann verwende ich halt GitHub

52:42.160 --> 52:45.920
Und es sind halt ganz viel auf GitHub geswitcht Also Docker hat sich insofern schon öfters

52:45.920 --> 52:50.960
ins Knie geschossen die letzten Jahre über Einfach dass die ja vielleicht nachvollziehbare

52:50.960 --> 52:53.480
Sachen gemacht haben Weil das kostet was

52:53.480 --> 52:56.840
Aber sie haben sich damit immer weiter so ins Aus befördert

52:56.840 --> 53:04.360
Als vom ursprünglich mal eigentlich so das Tool und die Anlaufstelle für Container schlechthin

53:04.360 --> 53:09.280
Zu immer mehr eins unter vielen Ich mein Docker an sich wird nicht weggehen

53:09.280 --> 53:12.560
Und es wird weiter das meist benutzte Containerisierungstool auf dem Desktop bleiben

53:12.560 --> 53:15.720
Aber trotzdem Die haben da nicht so viel draus gemacht

53:15.720 --> 53:18.120
Die haben sich öfters mal ins Bein geschossen

53:18.120 --> 53:29.360
So Test Target Folder ist dann Test Addon

53:29.360 --> 53:35.040
So Docker Hub brauchen wir nicht So jetzt hab ich ein Problem

53:35.040 --> 53:42.440
Jetzt hab ich ein Problem Und zwar ich hab hier meine Variablen definiert

53:42.440 --> 53:49.440
in dieser Art und Weise Und ich brauch aber noch ne Variabel nämlich

53:49.440 --> 53:53.160
amd64 Jetzt könnte man ja auf die Idee kommen

53:53.160 --> 53:57.000
Dass man einfach ein zweites Paar von Arrays machen kann

53:57.000 --> 54:00.440
Das geht aber nicht Das geht aber nicht

54:00.440 --> 54:05.000
Was ist Muzel Das ist eine C-Library eine Minimal C-Library

54:05.000 --> 54:09.200
die Alpine Linux unter anderem verwendet Lip Muzel

54:09.200 --> 54:29.200
Das andere ist den zu GNU Das wollen sie nicht

54:29.200 --> 54:40.400
So nachdem mein fertiges Addon unter Alpine läuft

54:40.400 --> 54:44.680
muss ich das damit übersetzen Warum geht ein zweites Array nicht

54:44.680 --> 54:47.160
Genau also Das kann ich euch zeigen

54:47.160 --> 54:50.200
Man könnte jetzt davon ausgehen, davon vermuten

54:50.200 --> 55:01.880
dass man zum Beispiel sowas hier machen kann So und dass der dann eben einmal das damit

55:01.880 --> 55:07.320
füllt Man würde jetzt denken der macht zwei Durchgänge

55:07.320 --> 55:10.880
So Target ist beim einen Durchgang eben das und das

55:10.880 --> 55:14.760
Nee Target ist das Arch ist das und am nächsten Durchgang ist es das und das

55:14.760 --> 55:18.760
Ist aber nicht so Matrix macht genau das was der Name sagt

55:18.760 --> 55:23.360
Dieser Job wird jetzt ausgeführt für jede mögliche Kombination aus diesen Werten

55:23.360 --> 55:26.520
Also sprich das wird ausgeführt damit und einmal damit

55:26.520 --> 55:29.800
damit und einmal damit damit und einmal damit und damit und einmal damit

55:29.800 --> 55:32.520
Also viermal Was natürlich bescheuert ist

55:32.520 --> 55:39.160
Weil ich will ja kein X86 AMV7 Build Brain dead

55:39.160 --> 55:45.000
So jetzt ist die Frage kann man irgendwie sowas hier machen

55:45.000 --> 55:56.200
Oh keine Ahnung

55:56.200 --> 56:00.360
Nee ne Das mag er nicht

56:00.360 --> 56:15.440
Matrix Options must only contain Primitive Failures

56:15.440 --> 56:19.160
Ja

56:19.160 --> 56:20.160
Sixhead Time

56:20.160 --> 56:28.800
Irgendjemand hat auch vorhin was geschickt mit Jason Arrays

56:28.800 --> 56:32.040
Wartet mal Irgendjemand hat auch vorhin was mit Jason Arrays

56:32.040 --> 56:33.040
geschickt Wo ist es

56:33.040 --> 56:42.040
Da

56:42.040 --> 56:45.840
What Brom Jason

56:45.840 --> 56:59.160
Ok jetzt wird es eklig was Ok

56:59.160 --> 57:02.600
Github Matrix von Jason

57:02.600 --> 57:06.280
Wie gehts der Karts der gehts gut die liegt glaube ich noch im Kühlschrank drüben

57:06.280 --> 57:09.560
Oh big big font

57:09.560 --> 57:15.560
Was machen die da für Dinger

57:15.560 --> 57:19.800
Also könnte man jetzt eventuell sowas hier machen

57:19.800 --> 57:25.640
Ok machen wir mal machen wir big big big brain time

57:25.640 --> 57:28.840
Geht wir testen das mal geht denn sowas

57:28.840 --> 57:37.040
Dass wir jetzt sagen ok das ist ein komplettes Jason

57:37.040 --> 57:45.600
Jason String Nee ja

57:45.600 --> 57:46.600
Invalid type font Array

57:46.600 --> 57:58.000
But String was font

57:58.000 --> 58:00.960
Kann man da einen Jason String reinhauen Ok

58:00.960 --> 58:08.280
Also das funktioniert ich kann zum Beispiel sagen hier das

58:08.280 --> 58:13.480
Aber jetzt muss wir inline Jason machen ok das ist aber ganz schön abartig

58:13.480 --> 58:16.920
Und dann könnte ich sagen hier Arch ist

58:16.920 --> 58:34.560
Arm V7 Ok und und und nu

58:34.560 --> 58:37.200
From from ach du ok ok

58:37.200 --> 58:48.960
Warte mal und jetzt from Jason Matrix Target

58:48.960 --> 58:54.720
Und und dann so das sieht aber wirklich abartig aus

58:54.720 --> 59:08.760
Und hier machen wir dann an der Stelle anstatt

59:08.760 --> 59:10.760
Amd64 Arch

59:10.760 --> 59:16.640
Leute das versteht doch keiner oder

59:16.640 --> 59:24.920
Also lesbar lesbar ist was anderes aber schauen wir mal ob das jetzt funktioniert

59:24.920 --> 59:26.440
Machst du das einfach per include

59:26.440 --> 59:30.680
Ahja

59:30.680 --> 59:34.480
Es ist schon mal kein Syntax Fehler das ist schon mal nice

59:34.480 --> 59:37.480
Lesen kann man das nicht

59:37.480 --> 59:48.080
Das dritte Punkt bei Matrix include

59:48.080 --> 59:49.080
Was

59:49.080 --> 01:00:03.720
Das ist mir zu high IQ was

01:00:03.720 --> 01:00:07.680
Green

01:00:07.680 --> 01:00:20.960
Jetzt ich checke es nicht was was macht das

01:00:20.960 --> 01:00:24.440
Include also was schreiben die

01:00:24.440 --> 01:00:25.440
Achso

01:00:25.440 --> 01:00:37.080
Achso

01:00:37.080 --> 01:00:40.840
Das heißt ich brauche eigentlich nur include oder

01:00:40.840 --> 01:00:43.200
Ich brauche nur include gar nichts ekliges Jason

01:00:43.200 --> 01:00:50.920
Hätte denn oh oh es ist broken Leute es ist broken

01:00:50.920 --> 01:00:54.840
Oh template is not valid invalid character

01:00:54.840 --> 01:00:55.840
F

01:00:55.840 --> 01:00:58.440
Ich hab's ich hab's zerstört

01:00:58.440 --> 01:01:04.400
Ok machen wir das mal lieber mit include das klingt mir irgendwie sinniger

01:01:04.400 --> 01:01:13.760
Also da machen wir sowas hier ok wir machen arch

01:01:13.760 --> 01:01:17.000
Einfach ein leeres oops einfach ein leeres Array

01:01:17.000 --> 01:01:20.440
Oh leeres Array

01:01:20.440 --> 01:01:23.560
Ach das geht nicht oder was

01:01:23.560 --> 01:01:31.320
Include nee wie ist das

01:01:31.320 --> 01:01:49.680
Wie machen die das Moment ich check die Syntax nicht

01:01:49.680 --> 01:01:54.600
Achso

01:01:54.600 --> 01:01:58.680
Auf der Höhe auf der Höhe von

01:01:58.680 --> 01:02:06.840
Ahja ok und jetzt kann ich sagen include

01:02:06.840 --> 01:02:13.800
Du brauchst das Array für den einen Wert

01:02:13.800 --> 01:02:17.680
Kann ich nicht sagen arch nee Moment wie wie

01:02:17.680 --> 01:02:19.680
war das jetzt

01:02:19.680 --> 01:02:26.200
Alles mit so

01:02:26.200 --> 01:02:29.640
Kann ich nicht sagen arch ist

01:02:29.640 --> 01:02:34.120
V7

01:02:34.120 --> 01:02:42.040
Und ja das andere ist dann Linux

01:02:42.040 --> 01:02:48.760
Ah und dann würde ich hier sagen

01:02:48.760 --> 01:02:55.000
Matrix Punkt

01:02:55.000 --> 01:02:59.000
Links und hier

01:02:59.000 --> 01:03:10.800
Arch

01:03:10.800 --> 01:03:14.520
Das ist bestimmt bestimmt komplett broken jetzt

01:03:14.520 --> 01:03:20.360
Aha ok ok ist immerhin es läuft es läuft schon mal los

01:03:20.360 --> 01:03:22.040
Was nicht heißt Moment

01:03:22.040 --> 01:03:27.720
Nee jetzt macht er für je

01:03:27.720 --> 01:03:29.280
Das ist falsch das soll er nicht machen

01:03:29.280 --> 01:03:36.880
Doch ich hab da plötzlich im Moment das ist doch klar dass er das macht wartet mal

01:03:36.880 --> 01:03:42.400
Ich muss es so machen oder so

01:03:42.400 --> 01:03:58.400
So amd64

01:03:58.400 --> 01:04:02.560
Muss ich das so machen

01:04:02.560 --> 01:04:03.560
Start komm mit

01:04:03.560 --> 01:04:10.880
Ok postchamp postchamp

01:04:10.880 --> 01:04:15.760
Aha aha

01:04:15.760 --> 01:04:16.760
Ok

01:04:16.760 --> 01:04:19.280
Das sieht ja prinzipiell schon mal nicht so verkehrt aus

01:04:19.280 --> 01:04:27.960
Das ist natürlich deutlich ordentlicher als dieses komische Jason rumkopiere

01:04:27.960 --> 01:04:28.960
Oh

01:04:28.960 --> 01:04:32.200
Jetzt hätte ich fast meine Credentials geleakt hier guckt mal

01:04:32.200 --> 01:04:36.400
Aber es ist alles es ist alles auskommentiert

01:04:36.400 --> 01:04:40.360
So ich bin mal gespannt ob der Bild jetzt funktioniert

01:04:40.360 --> 01:04:41.360
CD

01:04:41.360 --> 01:04:42.360
Ah

01:04:42.360 --> 01:04:47.680
Hey das sieht gut aus

01:04:47.680 --> 01:04:50.200
Das sieht gut aus das funktioniert

01:04:50.200 --> 01:04:51.200
Und create image

01:04:51.200 --> 01:05:05.440
Wo steht was er ausführt

01:05:05.440 --> 01:05:07.280
Wow hab ich irgendwas geleakt

01:05:07.280 --> 01:05:09.080
Nee anscheinend nicht alles gut

01:05:09.080 --> 01:05:16.000
Das funst

01:05:16.000 --> 01:05:19.000
Das funst

01:05:19.000 --> 01:05:20.000
Easy

01:05:20.000 --> 01:05:22.600
Dockerfile wird gebaut

01:05:22.600 --> 01:05:27.120
Fertig easy

01:05:27.120 --> 01:05:29.720
Ja das ist ja nice

01:05:29.720 --> 01:05:31.840
Da kann man sich das oben mit dem Array sparen

01:05:31.840 --> 01:05:32.840
Was wird gemacht

01:05:32.840 --> 01:05:40.960
Wir bauen ein Raspberry Pi Image und ein Desktop Image für ein Home Assistant Addon automatisch

01:05:40.960 --> 01:05:41.960
Bei jedem Push

01:05:41.960 --> 01:05:43.080
Was heißt bei jedem Push

01:05:43.080 --> 01:05:45.000
Wahrscheinlich bei jedem Tag oder so nur

01:05:45.000 --> 01:05:48.000
Weil aktuell mach ich das lokal und viel zu umständlich

01:05:48.000 --> 01:05:49.280
Das ist natürlich nice

01:05:49.280 --> 01:05:53.040
Das heißt im Endeffekt so kann man die Sachen kopieren

01:05:53.040 --> 01:05:57.240
Und lässt auch nur in dieser Kombination laufen

01:05:57.240 --> 01:06:06.040
Amd64 und hier das Programm x6 und hier am v7 und hier am cpu

01:06:06.040 --> 01:06:07.680
Nice genauso soll das sein

01:06:07.680 --> 01:06:12.080
So und hier baut er ein Image für

01:06:12.080 --> 01:06:25.280
Hier baut er ein Image nur für amv7

01:06:25.280 --> 01:06:31.200
Und hier baut er ein Image nur für amd64

01:06:31.200 --> 01:06:35.720
Ja easy genau so soll das sein

01:06:35.720 --> 01:06:36.720
Das ist einfach

01:06:36.720 --> 01:06:40.960
Da muss man keine komischen JSON Syntax bauen

01:06:40.960 --> 01:06:42.680
Ja das ist gut das gefällt mir

01:06:42.680 --> 01:06:45.680
Excellent excellent

01:06:45.680 --> 01:06:48.600
So sehr schön sehr schön

01:06:48.600 --> 01:06:52.280
Jetzt müssen wir das Image noch pushen

01:06:52.280 --> 01:06:58.760
Dazu brauchen wir ein Login bei github

01:06:58.760 --> 01:07:03.240
Haben die hier vielleicht auch irgendwie ein Beispiel

01:07:03.240 --> 01:07:04.240
Token

01:07:04.240 --> 01:07:07.240
Ja

01:07:07.240 --> 01:07:12.240
So was hier github token

01:07:12.240 --> 01:07:18.520
Login to github genau so was will ich machen

01:07:18.520 --> 01:07:21.040
Login to github container registry

01:07:21.040 --> 01:07:34.040
Ja

01:07:34.040 --> 01:07:35.600
Oder kann man das irgendwie anders angeben

01:07:35.600 --> 01:07:39.040
Direkt bei dem addon

01:07:39.040 --> 01:07:40.040
User

01:07:40.040 --> 01:07:42.800
Dockerhub username or space name was

01:07:42.800 --> 01:07:48.040
Ach ne hier haben sie ja sogar das Beispiel

01:07:48.040 --> 01:07:50.040
Ja

01:07:50.040 --> 01:07:55.800
So nur mit dem Unterschied wir müssen das über github machen

01:07:55.800 --> 01:07:57.320
Also muss man das so machen

01:07:57.320 --> 01:08:01.720
Die haben das bei Actions mittlerweile relativ feifertig gemacht

01:08:01.720 --> 01:08:04.520
Man muss sich gar kein token für Actions mehr generieren

01:08:04.520 --> 01:08:08.840
Da kann sich während die Action läuft einfach weil das alles intern ist bei github

01:08:08.840 --> 01:08:15.960
Mittlerweile die temporäre Credentials für die eigene Container Registry

01:08:15.960 --> 01:08:18.960
Selbst ausstellen

01:08:18.960 --> 01:08:21.800
Früher musste es dir das mit irgendeinem User Token machen

01:08:21.800 --> 01:08:23.760
Wo du kompletten Account zugreifen konntest

01:08:23.760 --> 01:08:27.360
Das war nicht so nicht so nice

01:08:27.360 --> 01:08:36.200
Docker login login Action v2 github repository owner

01:08:36.200 --> 01:08:37.200
Github token

01:08:37.200 --> 01:08:40.760
Normalerweise muss man ja die Secrets hier unter settings hinterlegen

01:08:40.760 --> 01:08:43.800
Aber dieses github token ist irgendwie so magic variable

01:08:43.800 --> 01:08:45.360
Die ihr automatisch ausstellt

01:08:45.360 --> 01:08:48.120
So

01:08:48.120 --> 01:08:51.720
Und jetzt sollte das funktionieren wenn ich das Test rausnehme

01:08:51.720 --> 01:08:55.320
Wir probieren es noch einmal aus ob das login funktioniert

01:08:55.320 --> 01:08:58.560
Oh safe

01:08:58.560 --> 01:09:03.280
Schauen wir mal

01:09:03.280 --> 01:09:06.480
Ja

01:09:06.480 --> 01:09:09.360
Also guck mal der lässt sogar die Jobs parallel laufen

01:09:09.360 --> 01:09:12.760
Das ist sogar noch schneller als hätte ich es am Anfang normal von Hand nacheinander

01:09:12.760 --> 01:09:13.760
gemacht

01:09:13.760 --> 01:09:21.480
Ich muss für meine Masterarbeit mit Docker eine Microservice Architektur bauen

01:09:21.480 --> 01:09:23.480
Die was für Objekte

01:09:23.480 --> 01:09:27.840
Die Geo Objekte bearbeitet und am Ende in einem bestimmten Format ausspuckt

01:09:27.840 --> 01:09:31.560
Compose wirklich alles in einem einzelnen Container sind dann bestimmt 200 Container

01:09:31.560 --> 01:09:32.560
am Ende

01:09:32.560 --> 01:09:37.800
Wenn du alles in einem Container machst sind doch keine 200 Container

01:09:37.800 --> 01:09:38.800
Oder

01:09:38.800 --> 01:09:41.320
Dann ist es ein Container

01:09:41.320 --> 01:09:43.960
Oder du meinst dieser Container 200 mal gestartet dann oder

01:09:43.960 --> 01:09:49.960
Ja also kann man durchaus machen es kommt ja darauf an wie kompliziert das ganze ist

01:09:49.960 --> 01:09:56.240
In der Regel sagt man im Container soll halt ein Programm gestartet werden fertig aus

01:09:56.240 --> 01:09:57.240
Soweit

01:09:57.240 --> 01:10:01.880
Er hat die reine Lehre aber vielleicht macht die ja nicht immer Sinn

01:10:01.880 --> 01:10:07.400
Kannst du auch im Container mehrere Sachen starten

01:10:07.400 --> 01:10:08.760
Musst ja halt nur überlegen wie du das machst

01:10:08.760 --> 01:10:13.040
Du hast halt nur einen Einstiegspunkt

01:10:13.040 --> 01:10:16.160
So Leute wir haben Docker login gemacht

01:10:16.160 --> 01:10:17.360
Wie es funktioniert einfach

01:10:17.360 --> 01:10:20.080
Wie es einfach funktioniert

01:10:20.080 --> 01:10:25.120
repo auschecken.net installieren

01:10:25.120 --> 01:10:29.120
Programm bilden lassen für die Zielplattform

01:10:29.120 --> 01:10:33.360
Docker login image createn

01:10:33.360 --> 01:10:35.920
Und jetzt Image pushen da bin ich mal gespannt

01:10:35.920 --> 01:10:37.960
Das funktioniert tatsächlich zu gut ja

01:10:37.960 --> 01:10:42.240
Jetzt bin ich gespannt also wenn ich jetzt hier das Minus Minus Test raus nehme

01:10:42.240 --> 01:10:46.240
Sollte der die Images in meine private Container Registry hochladen

01:10:46.240 --> 01:10:52.640
Also die Image mit nichts drinne aber also außer einem Hello World Programm aber immerhin

01:10:52.640 --> 01:10:57.960
Zeig mal

01:10:57.960 --> 01:10:58.960
Jetzt bin ich gespannt

01:10:58.960 --> 01:11:03.840
Ja Candy for Girls

01:11:03.840 --> 01:11:08.240
Ich kann dir da schon was zu sagen ein bisschen im Detail müsstest du das erklären also

01:11:08.240 --> 01:11:10.960
Sprich was willst du alles in einem Container laufen lassen

01:11:10.960 --> 01:11:17.760
Streamer Bonus ja

01:11:17.760 --> 01:11:27.840
Bill Gates persönlich sitzt gerade sitzt gerade auf der anderen Seite der Welt

01:11:27.840 --> 01:11:41.200
Und Hacker man das bei mir funktioniert

01:11:41.200 --> 01:11:44.400
Bill Gates baut händisch mein Docker Image jetzt verrat doch nicht alles

01:11:44.400 --> 01:12:05.440
So Image wird gebaut Start Upload Start Upload Start nicht Start Upload Start Upload

01:12:05.440 --> 01:12:15.080
Das Image Image ARMv7 TestChamp 00 Upload succeeded easy

01:12:15.080 --> 01:12:18.680
Easy as fuck Es sollten wir zwei Images haben

01:12:18.680 --> 01:12:37.480
Packages Easy Image ist da

01:12:37.480 --> 01:12:38.480
Einfach Images am Stahl

01:12:38.480 --> 01:12:44.840
Jetzt natürlich die Frage ob die funktionieren Das weiß ich jetzt natürlich nicht

01:12:44.840 --> 01:12:52.040
Es können wir aber ausprobieren ob die Images funktionieren

01:12:52.040 --> 01:12:57.840
Na gut Ich bräuchte einen Raspberry Pi auf dem ich

01:12:57.840 --> 01:13:00.840
das ausprobiere aber ich hab gerade keinen Raspberry Pi auf dem ich das ausprobieren

01:13:00.840 --> 01:13:01.840
kann

01:13:01.840 --> 01:13:06.040
Doch ich kann einfach meinen Raspberry Pi anstöpseln

01:13:06.040 --> 01:13:07.960
Easy Ich stöpsel mal kurz an

01:13:07.960 --> 01:13:24.320
Da müssen wir halt auf dem Raspberry Pi Docker installieren und gucken ob ich das Image pullen

01:13:24.320 --> 01:13:25.320
kann von Hand

01:13:25.320 --> 01:13:28.520
Ich muss mal kurz im DHCP schauen

01:13:28.520 --> 01:13:41.440
Was der Raspberry Pi liest ist

01:13:41.440 --> 01:13:42.440
Pi hier

01:13:42.440 --> 01:13:44.640
Pi add Der wirds wahrscheinlich sein hier oder

01:13:44.640 --> 01:13:48.680
Ping wir den mal und hoffen dass der irgendwann hochkommt

01:13:48.680 --> 01:13:58.600
Schreib doch ne Action die die Images pullt und runnt

01:13:58.600 --> 01:13:59.600
Das könnte man auch machen

01:13:59.600 --> 01:14:06.400
Aber ich brauch was was auf ARM Basis ist und die GitHub Runners sind alle nicht auf

01:14:06.400 --> 01:14:07.560
ARM Basis

01:14:07.560 --> 01:14:12.880
Dann müssen wir wieder mit QEMO anfangen und wir wissen ja QEMO und.NET hat so seine

01:14:12.880 --> 01:14:13.880
Probleme

01:14:13.880 --> 01:14:19.880
Ey wir lassen es jetzt auf dem Raspberry Pi laufen easy

01:14:19.880 --> 01:14:24.560
Starten könnte er aber mal

01:14:24.560 --> 01:14:34.360
Macht er noch was er blinkt er blinkt wie verrückt

01:14:34.360 --> 01:14:43.520
Blink kurz also es müsste die richtige IP von dem Raspberry Pi sein

01:14:43.520 --> 01:14:56.800
Blinke blinkge

01:14:56.800 --> 01:15:01.200
Es hat sich gerade bei mir ein Server eine neue IP geholt der Eierjahr heißt

01:15:01.200 --> 01:15:07.760
Weiß nicht so genau welcher das ist aber anscheinend habe ich den mal so genannt

01:15:07.760 --> 01:15:10.320
Der Raspberry Pi blinkt immer noch ganz wild

01:15:10.320 --> 01:15:33.640
Also der braucht ganz schön lang zum starten

01:15:33.640 --> 01:15:44.280
Ich sehe jetzt hier auch nichts

01:15:44.280 --> 01:15:45.760
Moment Moment das ist doch falsch

01:15:45.760 --> 01:15:48.680
Pi add ist doch Blödsinn

01:15:48.680 --> 01:15:50.400
Der muss doch eine andere kriegen

01:15:50.400 --> 01:15:52.680
Das kann doch gar nicht im Internet sein

01:15:52.680 --> 01:16:00.520
Hier 1.55 ist gerade hochgekommen 1.155

01:16:00.520 --> 01:16:08.400
Ping schonmal nicht auch nice ggeeds

01:16:08.400 --> 01:16:09.400
Wer weiß was das ist

01:16:09.400 --> 01:16:12.440
Hat sich auf jeden Fall gerade eine IP gezogen

01:16:12.440 --> 01:16:23.040
Hier 1.13

01:16:23.040 --> 01:16:24.040
Das müsste er sein

01:16:24.040 --> 01:16:27.520
SSH Pi add

01:16:27.520 --> 01:16:49.720
Die haben ja kein Default Passwort mehr

01:16:49.720 --> 01:16:54.000
Was ist so eine dumme Idee von denen gewesen das Default Passwort rauszumachen

01:16:54.000 --> 01:16:57.840
Jetzt kann man das Image einfach nicht mehr flashen auf die SD Karte und dann sich drauf

01:16:57.840 --> 01:16:59.120
verlassen dass es funktioniert

01:16:59.120 --> 01:17:05.360
Das ist so dumm gewesen was soll der Scheiß warum ist das Standard Passwort weg

01:17:05.360 --> 01:17:31.920
Das wird jetzt nichts jetzt muss ich neu flashen

01:17:31.920 --> 01:17:33.440
Was weiß ich denn was das für ein Passwort

01:17:33.440 --> 01:17:36.040
Der hat ja standardmäßig gar kein Passwort mehr

01:18:03.440 --> 01:18:09.920
Keine Ahnung

01:18:09.920 --> 01:18:15.960
Ach das ist so dumm dass es kein Standard Passwort mehr

01:18:15.960 --> 01:18:20.320
Das ist einfach absoluter Kackmove von denen

01:18:20.320 --> 01:18:24.840
Ich muss mal kurz mal kurz mal nen Switch anschließen

01:18:24.840 --> 01:18:48.800
Da ist die Netzwege

01:18:48.800 --> 01:18:53.400
So Switch anschließen

01:18:53.400 --> 01:18:58.400
Abstöpseln

01:18:58.400 --> 01:18:59.840
Pi abstöpseln

01:18:59.840 --> 01:19:03.120
Flashen wir den Kram halt neu

01:19:03.120 --> 01:19:04.400
Flashen wir nochmal neu

01:19:04.400 --> 01:19:13.360
Pi imager

01:19:13.360 --> 01:19:15.160
Jawoll

01:19:15.160 --> 01:19:20.040
Choose OS was wollen wir haben Raspberry Pi

01:19:20.040 --> 01:19:24.200
2 und 3 spitt meinetwegen True Storage

01:19:24.200 --> 01:19:25.200
Moment

01:19:25.200 --> 01:19:27.200
Moment Leute Moment

01:19:27.200 --> 01:19:29.440
Also

01:19:29.440 --> 01:19:40.440
Pi und ich mach jetzt 1 2 3 4 5 6 Massive Passwort kommt niemand drauf

01:19:40.440 --> 01:19:41.640
WLAN brauchen wir nicht

01:19:41.640 --> 01:19:50.040
Muss ich das jetzt noch irgendwie aktivieren oder checkt er das jetzt

01:19:50.040 --> 01:20:04.920
Ja es ist egal ob 32 oder 64

01:20:04.920 --> 01:20:17.200
Wisst ihr wo ist wurscht läuft beides

01:20:17.200 --> 01:20:26.120
Und die Software also das Image ist ja ein 32 32 Bit das muss das muss da drauf laufen

01:20:26.120 --> 01:20:28.160
Ich hab kein x64 Image

01:20:28.160 --> 01:20:30.360
Ich hab nen x

01:20:30.360 --> 01:20:35.840
Ich hab nen arm v7 32 Bit Image

01:20:35.840 --> 01:20:40.160
Und AMD 64 Image das AMD 64 Image läuft da logischerweise eh nie drauf

01:20:40.160 --> 01:20:48.200
Auf gib alles

01:20:48.200 --> 01:20:54.000
SD Kartenschreiber

01:20:54.000 --> 01:21:02.160
Auf verifying

01:21:02.160 --> 01:21:04.080
Keck braucht denn sowas

01:21:04.080 --> 01:21:07.880
Ja continue

01:21:07.880 --> 01:21:12.160
Ja was denn sonst soll er verifyen

01:21:12.160 --> 01:21:15.560
Ups drunter gefallen

01:21:15.560 --> 01:21:20.920
Alles klar dann starten wir den Raspberry Pi nochmal

01:21:20.920 --> 01:21:27.200
In der Hoffnung das es jetzt funktioniert

01:21:27.200 --> 01:21:30.120
Wie rum kommt denn die SD Karte ich machs immer falsch rum

01:21:30.120 --> 01:21:32.200
Ich mach die SD Karte jedes Mal falsch rum rein

01:21:32.200 --> 01:21:41.200
Strom

01:21:41.200 --> 01:21:44.640
So und jetzt ist er im internen Netzwerk

01:21:44.640 --> 01:21:48.840
Das heißt er sollte eigentlich die hier bekommen gleich

01:21:48.840 --> 01:21:52.080
Schauen wir mal ob das funktioniert

01:21:52.080 --> 01:21:58.080
Der muss jetzt erstmal seine SD Karte resiessen und

01:21:58.080 --> 01:22:04.280
3 mal booten oder so bis er bis er initial hoch kommt aber es sollte funktionieren

01:22:04.280 --> 01:22:07.920
Pizza Hawaii

01:22:07.920 --> 01:22:11.920
Ich verstehe diese ganze Diskussion nicht ob Ananas oder keine Ananas

01:22:11.920 --> 01:22:14.960
Ja ich gette das Meme da drum herum

01:22:14.960 --> 01:22:16.960
Aber warum nicht einfach jeder worauf er Bock hat

01:22:16.960 --> 01:22:23.520
Ist ja nicht so als sterbender Leute für dass da einer davon außer vielleicht Ananas

01:22:23.520 --> 01:22:24.520
Leute

01:22:24.520 --> 01:22:29.240
Die habe ich noch nicht gesehen

01:22:29.240 --> 01:22:31.240
Du stirbst an cringe

01:22:31.240 --> 01:22:33.160
Das kommt mir auch öfters vor

01:22:33.160 --> 01:22:36.280
Kann ich eine C Sharp Entwicklungs Umgebung in docker mit docker umsetzen

01:22:36.280 --> 01:22:41.000
Ne Entwicklungs Umgebung ist ein grafisches Programm

01:22:41.000 --> 01:22:44.640
Ich meine ja ok Du kannst theoretisch den X Server in docker

01:22:44.640 --> 01:22:45.640
starten

01:22:45.640 --> 01:22:48.480
Oder X Forwarding machen

01:22:48.480 --> 01:22:50.960
Das geht schon

01:22:50.960 --> 01:22:53.520
Geschwindigkeit dürfte aber was anderes sein

01:22:53.520 --> 01:22:57.880
Achja stimmt

01:22:57.880 --> 01:23:00.040
Ich habe gar nicht mehr gesehen was er geantwortet hat

01:23:00.040 --> 01:23:07.960
Das ist ja die Frage

01:23:07.960 --> 01:23:11.360
Der Professor meint dass ein Service genau eine Sache macht

01:23:11.360 --> 01:23:16.960
Also zum Beispiel nehme ein Geos JSON-File aus einem Storage und mach daraus ein C Sharp

01:23:16.960 --> 01:23:17.960
Objekt

01:23:17.960 --> 01:23:19.440
Und übergebe das Objekt an einen anderen Service

01:23:19.440 --> 01:23:22.040
Da kommt er am Ende laut meiner eigenen Ablauf die er kam

01:23:22.040 --> 01:23:23.320
Naja also das würde ich nicht machen

01:23:23.320 --> 01:23:25.120
Es ist die Frage in dem Fall eher

01:23:25.120 --> 01:23:27.440
Was will der denn eigentlich genau sehen von dir

01:23:27.440 --> 01:23:29.760
Also ganz im Ernst

01:23:29.760 --> 01:23:32.600
Für eine einfache Sache

01:23:32.600 --> 01:23:34.400
Also man muss nicht jede einzelne

01:23:34.400 --> 01:23:38.720
Gehen einzelne Funktionen Funktionsaufrufe in einen Container packen

01:23:38.720 --> 01:23:40.880
Also man muss es nicht übertreiben

01:23:40.880 --> 01:23:44.080
Also das würde ich so nicht machen

01:23:44.080 --> 01:23:47.360
Aber wenn er das natürlich so sehen will ist das wieder was anderes

01:23:47.360 --> 01:23:52.680
Eins Lukas Dankeschön für den Sub

01:23:52.680 --> 01:23:54.880
Übrigens Leute ich weiß nicht ob ich es schon erwähnt habe

01:23:54.880 --> 01:23:58.400
Aber nur für den Fall der Fälle dass ich es noch nicht mitbekommen habe

01:23:58.400 --> 01:24:01.200
Aber Rich Prime ist kostenlos

01:24:01.200 --> 01:24:17.800
Kann man durchaus als Enhancement sehen

01:24:17.800 --> 01:24:18.800
Also das würde ich nicht machen

01:24:18.800 --> 01:24:22.360
Ich würde das so weit zusammenfassen wie es sinnvoll ist

01:24:22.360 --> 01:24:25.400
Also wenn du Sachen in.NET programmierst

01:24:25.400 --> 01:24:27.840
Da würde ich halt da mehrere Sachen

01:24:27.840 --> 01:24:30.160
Verarbeitungsschritte in einem Programm teil machen

01:24:30.160 --> 01:24:33.760
Man kann ja durchaus sowas wie

01:24:33.760 --> 01:24:35.800
Das abrufen von irgendwo

01:24:35.800 --> 01:24:39.480
Dann das posten es kommt ja auch auf die richtige Architektur an

01:24:39.480 --> 01:24:42.600
Jetzt jede Funktion in einen Container packen ist das eine

01:24:42.600 --> 01:24:44.680
Theoretisch müsstest du die Daten dann irgendwo abrufen

01:24:44.680 --> 01:24:47.360
Dann müssten die Daten in irgendeine Message Queue

01:24:47.360 --> 01:24:48.960
Dann brauchst du irgendwo einen anderen Service

01:24:48.960 --> 01:24:50.880
Der diese Message Queue ausliest

01:24:50.880 --> 01:24:54.240
Dann irgendeine Verarbeitung laufen lässt und Daten dann irgendwo hin pusht

01:24:54.240 --> 01:24:55.960
Also das ist mit einem Docker Compose

01:24:55.960 --> 01:24:56.960
Also

01:24:56.960 --> 01:25:02.160
Der Sinn von Microservices ist ja nicht dass du quasi den Programmablauf in 200 Container

01:25:02.160 --> 01:25:03.160
aufsplittest

01:25:03.160 --> 01:25:07.600
Und dann anfängst bei Container 1 aufhörst bei Container 200 das alles wieder runter

01:25:07.600 --> 01:25:08.600
fährst

01:25:08.600 --> 01:25:10.280
Also so nach dem Motto

01:25:10.280 --> 01:25:14.720
Starte die Verarbeitung erster Container startet übergibt es an zweiten übergibt

01:25:14.720 --> 01:25:16.040
es an dritten übergibt es an vierten

01:25:16.040 --> 01:25:18.720
Und dann wenn er wieder am Ende durch ist dann dann fährt er wieder alles runter

01:25:18.720 --> 01:25:20.360
Also das ist ja kein

01:25:20.360 --> 01:25:26.640
Man muss ja kein Programm einfach aufsplitten um das aufsplitten willens

01:25:26.640 --> 01:25:30.280
An den Stellen wo es sinnvoll ist ja kann man das natürlich benutzen

01:25:30.280 --> 01:25:33.400
Wie gesagt du hast irgendwie den Service der Daten abruft

01:25:33.400 --> 01:25:35.760
Der postet das in irgendeine Message Queue

01:25:35.760 --> 01:25:37.280
Die muss permanent laufen

01:25:37.280 --> 01:25:42.520
Das ist dann wieder was anderes aber einfach nur das aufsplitten

01:25:42.520 --> 01:25:43.520
Na guck mal da ist der Raspberry Pi

01:25:43.520 --> 01:25:47.560
Das aufsplitten willens

01:25:47.560 --> 01:25:53.520
Würde ich jetzt auch nicht unbedingt machen

01:25:53.520 --> 01:25:57.960
Und so ich hab gesagt 1,2,3,4,5,6 geht easy

01:25:57.960 --> 01:26:00.960
Update

01:26:00.960 --> 01:26:10.000
Und das lässt sich natürlich ohne Probleme mit Docker Compose umsetzen

01:26:10.000 --> 01:26:12.200
Da brauchst du kein Kubernetes Cluster auch wenn der Chat das sagt

01:26:12.200 --> 01:26:18.080
Nimmst du irgendwie RapidMQ oder sowas als Message Ding

01:26:18.080 --> 01:26:25.080
Im Endeffekt würde ich sagen gibt es am Ende vielleicht

01:26:25.080 --> 01:26:30.720
Naja wenn es 10 Container sind dann ist es wahrscheinlich sogar schon viel

01:26:30.720 --> 01:26:32.480
Irgendwo was was abruft

01:26:32.480 --> 01:26:34.600
Dann es in die Message Queue schickt

01:26:34.600 --> 01:26:39.920
Dein Geodaten Umformatierungs Ding liest das aus der Message Queue und schreibt es irgendwo

01:26:39.920 --> 01:26:40.920
wieder rein

01:26:40.920 --> 01:26:43.680
Weiß nicht was am Ende mit den Daten passieren soll

01:26:43.680 --> 01:26:52.120
Es sei denn euer Professor will das so haben dass ihr am Ende 200 einzelne Container habt

01:26:52.120 --> 01:26:56.160
für quasi für jedes Printline einen eigenen Container

01:26:56.160 --> 01:26:58.360
Was aber mit der Realität da nicht so viel zu tun hat

01:26:58.360 --> 01:27:02.600
So Packages

01:27:02.600 --> 01:27:05.080
Arm4Sieben Testchamp

01:27:05.080 --> 01:27:10.440
Da müssen wir jetzt erst einmal einstellen Package Settings

01:27:10.440 --> 01:27:14.920
Der Arm4Sieben Testchamp

01:27:14.920 --> 01:27:15.920
Der ist Public

01:27:15.920 --> 01:27:19.240
Yes ich understande die Konsequences

01:27:19.240 --> 01:27:22.360
Und jetzt kann ich hier nämlich nicht Docker pullen

01:27:22.360 --> 01:27:46.480
Ne wir haben kein 200 Mikroservices Geodaten Ding

01:27:46.480 --> 01:27:54.200
Dann lassen wir das Image mal laufen und gucken ob das funktioniert

01:27:54.200 --> 01:27:55.200
Container De

01:27:55.200 --> 01:28:03.600
Ja das brauchen wir gleich

01:28:03.600 --> 01:28:09.440
Kekel größer Keck weh

01:28:09.440 --> 01:28:11.360
Ja könnte ich mitgehen

01:28:11.360 --> 01:28:28.000
Allerdings Lulwe ist immer noch eindeutig das bessere Emote

01:28:28.000 --> 01:28:30.320
Ja würde ich auch nichts erwähnen

01:28:30.320 --> 01:28:31.320
Was willst du sagen

01:28:31.320 --> 01:28:35.040
Ich habe im Twitch Chat gefragt und die Leute haben mir random Zeugs erzählt

01:28:35.040 --> 01:28:39.120
Ne ne würde ich auch nicht erwähnen Lul

01:28:39.120 --> 01:28:44.440
So docker run

01:28:44.440 --> 01:28:46.440
Auf gehts und zwar docker run

01:28:46.440 --> 01:28:51.080
Mal schauen ob mein Image funktioniert

01:28:51.080 --> 01:29:14.160
Ok downloadbar ist das Image schonmal

01:29:14.160 --> 01:29:16.400
Startbar ist das Image auch

01:29:16.400 --> 01:29:18.240
So und jetzt wo habe ich das hin kopiert

01:29:18.240 --> 01:29:22.200
Bild App

01:29:22.200 --> 01:29:24.480
Hello World funktioniert

01:29:24.480 --> 01:29:26.200
Image hat getan Image Bild

01:29:26.200 --> 01:29:31.520
Ja wir sind auf einer AMD CPU

01:29:31.520 --> 01:29:36.400
Wir sind auf dem Raspberry Pi und haben das Image inklusive unserem Testprogramm ausgeführt

01:29:36.400 --> 01:29:38.080
was wir in GitHub erstellt haben

01:29:38.080 --> 01:29:39.680
Das läuft für tatsächlich zu gut

01:29:39.680 --> 01:29:44.200
Ich glaube das AMD Image müssen wir nicht wirklich ausprobieren das wird auch so funktionieren

01:29:44.200 --> 01:29:48.560
Das haben wir gemacht für den Fiat Champ genau

01:29:48.560 --> 01:29:56.800
Dass ich automatisch neue Releases pushen kann und dann ein Image gebaut wird

01:29:56.800 --> 01:29:58.880
Wobei ich mir gar nicht so sicher bin

01:29:58.880 --> 01:30:00.360
Wollen wir mal gucken wie viel RAM es braucht

01:30:00.360 --> 01:30:08.360
Ja nachdem es einfach nur in Hello World es sollte jetzt eigentlich so gut wie nix brauchen

01:30:08.360 --> 01:30:09.360
Aber schauen wir mal

01:30:09.360 --> 01:30:13.080
Schauen wir mal

01:30:13.080 --> 01:30:33.920
Machen wir mal hier unten auf

01:30:33.920 --> 01:30:34.920
Es braucht gar nix

01:30:34.920 --> 01:30:44.240
Das erscheint mir tatsächlich ein bisschen wenig

01:30:44.240 --> 01:30:50.760
Ich glaube der Raspberry Pi kann das nicht die Limits richtig auslesen oder

01:30:50.760 --> 01:30:52.920
Weil irgendwas scheint da nicht zu funktionieren

01:30:52.920 --> 01:31:02.880
Ich meine 0% RAM

01:31:02.880 --> 01:31:05.640
Es läuft zumindest eine Bash allein schon die sollte nicht null Byte haben

01:31:05.640 --> 01:31:16.040
Wir können mal ein bisschen

01:31:16.040 --> 01:31:17.040
Bisschen Rechenlast generieren

01:31:17.040 --> 01:31:21.600
Ok CPU Auslastung checkt da aber Memory Usage checkt da nicht

01:31:21.600 --> 01:31:33.680
Ne also die Anzeige ist irgendwie broken

01:31:33.680 --> 01:31:39.360
Was ist das für eine Docker Version

01:31:39.360 --> 01:31:42.000
Lass uns mal kurz was checken

01:31:42.000 --> 01:31:47.240
Docker minus minus Version 20.10

01:31:47.240 --> 01:31:50.480
Das ist glaube ich relativ aktuell

01:31:50.480 --> 01:31:54.520
Guck mal was die aktuelle Docker Version ist

01:31:54.520 --> 01:31:57.520
20.10.18

01:31:57.520 --> 01:32:04.080
Und was ist das 20.10.5

01:32:04.080 --> 01:32:05.080
Docker

01:32:05.080 --> 01:32:13.880
Ja von von 2013 ja da könnte man vielleicht

01:32:13.880 --> 01:32:15.600
Docker Stats das sind Schaumärmel

01:32:15.600 --> 01:32:18.840
Wahrscheinlich ist die Docker Version noch verbackt die beim Raspberry Pi dabei ist

01:32:18.840 --> 01:32:26.800
Ich bin aber ich bin nicht auf ARM 64

01:32:26.800 --> 01:32:30.680
Ich bin auf ARM 32

01:32:30.680 --> 01:32:32.240
Wobei das wahrscheinlich er ist auch so

01:32:32.240 --> 01:32:56.880
Yes looking like

01:32:56.880 --> 01:33:08.880
What the hell was muss man da hinzufügen

01:33:08.880 --> 01:33:13.960
Ok heute lernen wir wieder was

01:33:13.960 --> 01:33:14.960
Boot

01:33:14.960 --> 01:33:15.960
CMD

01:33:15.960 --> 01:33:20.320
Wie kein Wim installiert Grinch

01:33:20.320 --> 01:33:31.800
Chat ist wieder am Backseiten ja aber in dem Fall mal ordentliches Backseiten

01:33:31.800 --> 01:33:35.000
Effektives Backseiten

01:33:35.000 --> 01:33:44.040
Jaja ist gut Ups

01:33:44.040 --> 01:33:46.880
Da habe ich einmal zu viel Enter gedrückt

01:33:46.880 --> 01:33:51.680
Boot CMD Line

01:33:51.680 --> 01:33:53.160
Mal gucken ob der überhaupt noch bootet

01:33:53.160 --> 01:33:57.920
Crap neu generieren muss man beim Raspberry Pi ja nicht da sollte das ja auch so alles

01:33:57.920 --> 01:33:58.920
fressen oder

01:33:58.920 --> 01:34:03.440
Pi change CMD

01:34:03.440 --> 01:34:08.640
Da muss man nix machen oder muss man Crap Update machen

01:34:08.640 --> 01:34:23.560
Wird schon funktionieren Reboot

01:34:23.560 --> 01:34:43.840
Das Bild oben

01:34:43.840 --> 01:34:44.840
Was auch immer

01:34:44.840 --> 01:34:52.480
Was hat es mit Kekwe und Kekkel auf sich wie jetzt

01:34:52.480 --> 01:34:57.720
Da sind Emotes guck das hier ist Kekwe

01:34:57.720 --> 01:34:59.280
Das hier ist Kekkel

01:34:59.280 --> 01:35:02.200
Ja das sind Emotes

01:35:02.200 --> 01:35:07.480
So und warum das so beliebt ist Lulwe ist eh das beste warum das so beliebt ist

01:35:07.480 --> 01:35:10.920
Das ich weiß kennst du das Original davon

01:35:10.920 --> 01:35:11.920
Mr. Phil

01:35:11.920 --> 01:35:15.480
Oder ist das auch noch eine große Internet Meme Lücke

01:35:15.480 --> 01:35:21.120
Wenn wenn ja müssen wir die unbedingt jetzt beheben

01:35:21.120 --> 01:35:26.400
Und zwar das Original ist YouTube el risitas

01:35:26.400 --> 01:35:56.000
El risitas

01:35:56.000 --> 01:36:10.560
Oh Mann, es geht immer noch nach 100 Jahren gefühlt.

01:36:10.560 --> 01:36:16.640
Ok, der Raspberry Pi ist wieder da.

01:36:16.640 --> 01:36:40.840
Docker Stats, achso es läuft kein Container, 0, Run, hey es funktioniert, Memory Usage 3,785

01:36:40.840 --> 01:36:56.320
MB, Omg, und wenn ich.NET starte, haben wir 1,2 MB mehr Usage, richtig bloated.

01:36:56.320 --> 01:37:05.280
Was ist MIB, Mibibyte, ne Mibibyte, das ist eingeführt worden, weil die Leute sich nicht

01:37:05.280 --> 01:37:15.760
darauf einigen konnten, ob es 1000 oder 1024 ist, ich meine streng genommen ist es 1000,

01:37:15.760 --> 01:37:22.400
aber im Dezimalsystem bietet sich ja 1024 mehr an, also rein vom Wort her ist es 1000,

01:37:22.400 --> 01:37:33.040
weil Mega ist 1000, also quasi 2 hoch die Stellen, da ist es dann aber 1024, das heißt

01:37:33.040 --> 01:37:39.600
man konnte sich nie so richtig drauf einigen, manche haben es so gesagt, manche haben es

01:37:39.600 --> 01:37:46.200
so gesagt, Pinnair, Pinnair System, Dual kann man glaube ich auch sagen, und deswegen

01:37:46.200 --> 01:37:51.480
ist man auf die Idee gekommen, man könnte jetzt ja Mibibyte einführen, was definiert

01:37:51.480 --> 01:37:59.520
1024 ist und Megabyte halt 1000 machen, nur mit dem Unterschied, dass eigentlich das

01:37:59.520 --> 01:38:05.760
nicht wirklich was gebracht hat und irgendwie so gut wie jeder immer noch 1024 für Megasachs

01:38:05.760 --> 01:38:10.560
und ach Pff, scheiß drauf, zum Glück ist das ja meistens nicht so wirklich relevant,

01:38:10.560 --> 01:38:14.760
weil der Unterschied nicht so groß ist, allerdings muss man sagen, gerade bei Festplatten in

01:38:14.760 --> 01:38:20.920
Zeiten wo wir bei 16, 18TB Platten angekommen sind, da macht es ja wohl den Unterschied,

01:38:20.920 --> 01:38:42.480
ob es 1000Bytes sind oder 1024Bytes, ja stimmt, es ist natürlich plötzlich ein Kilobyte,

01:38:42.480 --> 01:38:51.720
1024, mit Kilo hast du das gleiche, da gibt es dann Kibi dafür, warte mal, es gibt Kibi-Byte

01:38:51.720 --> 01:38:52.720
oder?

01:38:52.720 --> 01:39:06.800
Ne, warte mal, es ist Kibi-Byte, Mibibyte, Gibibyte, ach du Scheiße, ganz ehrlich, Kilobyte,

01:39:06.800 --> 01:39:09.840
Megabyte, Gigabyte, Terabyte, reicht, voll und ganz.

01:39:09.840 --> 01:39:22.480
Ja ok, wir haben unseren Raspberry Pi gefixt, nice, easy, easy as fuck, kann man dazu nur

01:39:22.480 --> 01:39:35.080
sagen, alles gut, so es funktioniert, jetzt können wir den Raspberry Pi eigentlich wieder

01:39:35.080 --> 01:39:39.840
aufpowern, wobei, wir lassen mal an, vielleicht brauchen wir ihn noch, vielleicht brauchen

01:39:39.840 --> 01:39:59.320
wir ihn noch, gut, so, wir sind aber wahrscheinlich, mein Automatisierungs-DevOps2, das ich sage,

01:39:59.320 --> 01:40:06.520
das ist so aber noch nicht gut, alleine, weil, auf was für einen Push, wollen wir eigentlich

01:40:06.520 --> 01:40:13.680
reagieren, Push auf Master, wahrscheinlich nicht, weil, die Sache ist die, nur mal so

01:40:13.680 --> 01:40:19.920
für den Fall der Fälle, mir fällt da nämlich schon ein, dass es nicht richtig funktioniert,

01:40:19.920 --> 01:40:27.640
und zwar, wenn ich die Images generiere, nach einem Push auf Master, besteht die Chance,

01:40:27.640 --> 01:40:33.840
dass das Upgrade bei Leuten kaputt geht, on tech, ja wahrscheinlich ist das wirklich

01:40:33.840 --> 01:40:40.040
am besten, weil, nur mal so als Erklärung, also, die Addons funktionieren folgendermaßen,

01:40:40.040 --> 01:40:45.400
die Addons fügt man bei seiner Installation hier über die Url hinzu, und jedes Addon

01:40:45.400 --> 01:40:49.580
Repo hat hier so eine Config-Yaml, und in der Config-Yaml steht eine Versionsnummer,

01:40:49.580 --> 01:40:57.240
das heißt, wenn ich die Versionsnummer jetzt hochzähle, und das pushe, dann sehen die

01:40:57.240 --> 01:41:05.680
Leute quasi instant, dass es ein neues Addon gibt, aber, das Image-Build läuft noch, also

01:41:05.680 --> 01:41:10.920
sprich, es wird schon ein Update-Button angezeigt, obwohl das Image noch nicht fertig gebildet

01:41:10.920 --> 01:41:18.520
ist, das heißt, wer ultra schnell ist, und Upgraded innerhalb von diesen 5 Minuten, hat

01:41:18.520 --> 01:41:24.200
vielleicht bei einem Klick auf Update ein paar Fehler noch, ist nicht schlimm, das alte

01:41:24.200 --> 01:41:28.040
Addon läuft ja noch weiter, und 5 Minuten später geht's dann, was man machen könnte,

01:41:28.040 --> 01:41:35.840
ist, man könnte pushen, man könnte das, kannst du bitte das, das ist die Katze, oder?

01:41:35.840 --> 01:41:44.160
Das ist diese Katze, die so guckt, das ist ein 7TV-Emote, ich glaub, weiß gar nicht,

01:41:44.160 --> 01:42:03.000
ob es das woanders gibt, ach, ist das, ist das die Schildkröte, ich kenn das nur mit

01:42:03.000 --> 01:42:13.920
der Katze, Alter, 7TV ist einfach, teilweise echt schon ziemlich, ziemlich harter Cringe-Faktor,

01:42:13.920 --> 01:42:35.080
es gibt 5000 Versionen, ich kenn das, ich kenn das mit der Katze, das da, genau, genau

01:42:35.080 --> 01:42:50.840
das, das mein ich, FFZ, nee, ich will die Katze haben, wenn ihr die irgendwo findet,

01:42:50.840 --> 01:42:59.960
mach ich die rein, so, was wir jetzt haben, wie gesagt, eine Sache, die mir jetzt noch

01:42:59.960 --> 01:43:04.880
einfällt, auf was will ich pushen, ich will ja auf jeden Fall nicht Master pushen, entweder

01:43:04.880 --> 01:43:11.240
macht man einen Release Branch, in dem man das pusht, wartet bis die Image fertig sind

01:43:11.240 --> 01:43:20.480
und dann schiebt man es nach Master oder man sagt On Tag, das würde auch funktionieren,

01:43:20.480 --> 01:43:47.360
kann man sogar noch einen Filter einbauen, Tag, komm mal ein Beispiel für, ja, gar nicht

01:43:47.360 --> 01:43:58.200
und Master pushen, On Tag Version, oh, jetzt brauchen wir, jetzt brauchen wir 6 Head Regex,

01:43:58.200 --> 01:44:10.880
Moment, Moment, das haben doch bestimmt andere Leute schon für mich gebaut, ah, yes, obviously,

01:44:10.880 --> 01:44:33.600
so, wie, das geht nicht, Invalid Character Range, easy, ok, dann machen wir die Lite

01:44:33.600 --> 01:44:55.760
Version, also V, 0-9, beliebig oft, Punkt, 0-9, beliebig oft, Punkt, 0-9, beliebig, nee,

01:44:55.760 --> 01:45:03.480
kein Punkt, fertig, so, Massive, so, wenn ich jetzt einen Tag pushe, dann läuft das

01:45:03.480 --> 01:45:10.840
Ganze erst, ich weiß nicht, ob ich es schon erwähnt habe, aber Twitch Prime ist kostenlos,

01:45:10.840 --> 01:45:15.840
bestes Issue, Start Commit, so, jetzt sollte er das nicht mehr automatisch ausführen,

01:45:15.840 --> 01:45:33.120
wenn ich pushe, ja, Regex geht ja anscheinend, das mag er ja, da hat er nicht gemeckert,

01:45:33.120 --> 01:45:41.360
so, und jetzt bräuchte ich theoretisch so eine Art Release Script, was für mich den

01:45:41.360 --> 01:45:48.920
neuen Tag macht, Tag pusht, guckt, dass alles committed ist, aber wir müssen es ja nicht

01:45:48.920 --> 01:46:04.080
übertreiben heute, ja, das ist glaube ich sinnvoll, das so zu machen, weil, ja die Katze

01:46:04.080 --> 01:46:23.080
ist hinzugefügt Leute, jawoll, sehr gut, exellent, das Emote meine ich, das da, das da, ha ha,

01:46:23.080 --> 01:46:26.600
ihr müsst den Chat erst reloaden, dass es funktioniert, und die Emotes brauchen teilweise

01:46:26.600 --> 01:46:30.680
ein paar Minuten, bis sie funktionieren, so, und jetzt sollte es eigentlich klappen, wenn

01:46:30.680 --> 01:46:42.960
ich das jetzt tagge, naja, wir pullen mal, ging direkt, ok, nice, so, also wenn ich jetzt

01:46:42.960 --> 01:46:48.680
hier irgendwas drin ändere, sagen wir jetzt zum Beispiel, keine Ahnung, Test Addon, ja,

01:46:48.680 --> 01:46:52.360
ich wollte jetzt unbedingt das Docker File unten die Zeile löschen, ja, das ist genau

01:46:52.360 --> 01:47:01.000
was ich machen wollte, git commit, 0, so, und jetzt kann ich sagen git tag, sagen wir

01:47:01.000 --> 01:47:17.960
v1.0.0, oder v0.0.1, oder sowas, 0.0.1, ja, Release, so, v0.0.1, tag, git push origin

01:47:17.960 --> 01:47:39.080
minus minus tags, und jetzt sollte es eigentlich gecheckt haben, ja, geht, nice, ich hab's

01:47:39.080 --> 01:47:47.400
wieder geedit, ich hab's gar nicht rausgeworfen, anscheinend wurde es gelöscht, so, und jetzt

01:47:47.400 --> 01:47:53.960
gibt's nen Tag, und er baut das neue Image, das ist äußerst nice, so, und jetzt zeig

01:47:53.960 --> 01:47:59.200
ich euch mal was, der taggt das sogar jetzt richtig, das Image, guckt mal, gehen wir nochmal

01:47:59.200 --> 01:48:08.520
auf den Raspberry Pi, und eben hatten wir ja gesagt, Docker run, pass mal auf, Docker

01:48:08.520 --> 01:48:16.720
run, bla bla bla, Latest hatten wir eben gesagt, so, Latest ist es jetzt nicht, es ist v0.0.1,

01:48:16.720 --> 01:48:20.360
wenn das Bild fertig ist, warte jetzt mal ab, das mit dem taggen müsste jetzt eigentlich

01:48:20.360 --> 01:48:26.040
genau, ach nee, ich bin ja doof, meine Versionsdatei hat sich ja nicht geändert, wobei das ist

01:48:26.040 --> 01:48:31.600
egal für in dem Fall, mal kurz warten bis der fertig ist und das Image gepusht hat,

01:48:31.600 --> 01:48:37.360
das kann, nee, Moment, der checkt das mit dem tag nicht, weil meine Versionsdatei vom

01:48:37.360 --> 01:48:52.520
addon noch nicht funktioniert, mal kurz warten bis der fertig gebildet hat, so, create image,

01:48:52.520 --> 01:49:11.640
tag, er hat das gepusht unter, er hat's gecheckt, er hat es gecheckt, 0.0.1 war es davor auch,

01:49:11.640 --> 01:49:26.200
ah, ok, dann testen wir es doch gleich mal, ob das, ob das geht, ich mach mal ein zweites

01:49:26.200 --> 01:49:44.960
tab, so, tag, 0.0.2, also das sollte jetzt eigentlich nicht gehen, ich brauch da noch

01:49:44.960 --> 01:49:47.280
einen zweiten Schritt, push, nee, nee, nee, hab ich nicht, deswegen, das wird nicht, ich

01:49:47.280 --> 01:49:51.680
denke nicht, dass es funktionieren wird, aber das will ich ja auch gar nicht, ich will,

01:49:51.680 --> 01:49:57.000
dass das über das tag kommt von dem addon config file, das heißt, ich muss da wirklich

01:49:57.000 --> 01:50:02.880
noch mehr als eine Sache machen, will man nicht die release datei in der pipeline generieren,

01:50:02.880 --> 01:50:06.800
also sprich, nachdem wir container bauen, schreibt der automatici version ins file, nee, da müsste

01:50:06.800 --> 01:50:13.040
ich ja in der github actions commit machen im branche, nee, das finde ich eigentlich

01:50:13.040 --> 01:50:36.320
nicht so toll, schauen wir mal, wie weit der jetzt ist, da würde ich mir lieber ein release

01:50:36.320 --> 01:50:41.680
script basteln, was das die schritte der reihe nach macht, sonst bin ich mal gespannt, was

01:50:41.680 --> 01:50:51.480
er jetzt baut, wahrscheinlich baut er weiterhin mit 0.0.1, jetzt habe ich genug emotes geedet,

01:50:51.480 --> 01:50:59.440
reicht für heute, so, create image, was hat er jetzt gebaut, er hat gebaut, 0.0.1, ok,

01:50:59.440 --> 01:51:10.880
der tag interessiert ihn überhaupt nicht, ok, push, das heißt, wenn ich ein neues release

01:51:10.880 --> 01:51:16.280
machen will, muss ich folgendes machen, ich muss in die config datei gehen, da zum beispiel

01:51:16.280 --> 01:51:25.920
reinschreiben keine ahnung 0.5, dann muss ich das commiten, dann muss ich den tag machen,

01:51:25.920 --> 01:51:30.880
so hier, das muss man echt mit dem script machen, sonst vergisst man die hälfte, dann

01:51:30.880 --> 01:51:49.160
den tag, dann push ich das tag, so, dann läuft das bild an, push das image, doch ich habs

01:51:49.160 --> 01:51:53.760
gerade wieder aktiviert für den chat, weiß auch nicht warum das gelöscht wurde, willst

01:51:53.760 --> 01:51:58.800
du nicht erst den commit pushen, nein, will ich gerade nicht, weil das image da sein soll,

01:51:58.800 --> 01:52:05.120
das heißt, leute das neue addon sehen, sobald ich das pushe, sehen leute das neue addon

01:52:05.120 --> 01:52:09.440
und ich will bevor leute das neue addon sehen, erst das image generieren, so rum ist das

01:52:09.440 --> 01:52:10.440
schon sinnvoller.

01:52:10.440 --> 01:52:29.680
So, jetzt bau mal, gogo, ah guck mal, 0.05, sehr schön, start uploading image, nachdem

01:52:29.680 --> 01:52:37.480
es von github zu github uploadet, ist es auch kein großes ding, nice, so und jetzt kann

01:52:37.480 --> 01:52:41.840
ich euch was zeigen, man kann jetzt nämlich nicht einfach nur sagen docker run, sondern

01:52:41.840 --> 01:52:47.480
der tag das automatisch, ich kann jetzt sagen, ich will version 0.0.5 von diesem image runnen.

01:52:47.480 --> 01:53:12.200
Wo ist das problem, ach einfach nur 0.0.5, weil v, ja das muss ich anders machen, das

01:53:12.200 --> 01:53:23.920
ist ja ekeliger, da muss ich mir wirklich irgendeinen script bauen, so 0.0.5 und zack

01:53:23.920 --> 01:53:39.080
läuft das image, mit dieser versionsnummer, das ist nice, ich könnte jetzt quasi was

01:53:39.080 --> 01:53:44.440
hier machen, release.sh und mir das irgendwie mal kurz zusammenscriptoren, was ich machen

01:53:44.440 --> 01:53:49.560
will, weiß nicht, ob ich mir das heute geben will, aber so, aber das könnte man, könnte

01:53:49.560 --> 01:53:52.720
man tatsächlich machen, das wäre vielleicht, wäre vielleicht gar nicht so blöd.

01:53:52.720 --> 01:53:58.640
Du kannst das docker image beim bauen mit der version von github taggen, nee kann ich

01:53:58.640 --> 01:54:03.920
nicht, weil ich es nicht selber baue, sondern ich das mit dem home assistant addon builder

01:54:03.920 --> 01:54:14.640
mache, der die versionsnummer nimmt aus dem addon config file, was auch sinnvoll ist in

01:54:14.640 --> 01:54:25.160
dem fall, aber ich könnte mir irgendwie sowas hier zusammenscripten auf die schnelle,

01:54:25.160 --> 01:54:36.120
also wir könnten irgendwie sagen, so hier echo last tag, git describe, wenn ich mal

01:54:36.120 --> 01:54:57.960
schreiben könnte, so irgendwie echo, enter next release tag, irgendwie read, ja und speichern

01:54:57.960 --> 01:55:06.680
wir uns das irgendwie zwischen, wobei nee glaubt, glaubt, es ging einfach so, reply,

01:55:06.680 --> 01:55:13.960
wie heißt das, sieht falsch aus, reply, so, glaub so, glaub so ist die richtung, ja fife

01:55:13.960 --> 01:55:28.560
shell script, den kommt jetzt, so next tag, dann sagen wir git tag, minus a, minus m, ja,

01:55:28.560 --> 01:55:37.120
dollar next tag, wir sollten es noch checken, ob es leer ist, release tag, sowas in der

01:55:37.120 --> 01:55:45.640
richtung, könnten wir machen, wim, warum nicht wim, why not, ich weiß ja im vergleich

01:55:45.640 --> 01:55:51.160
zu anderen, wie man aus wim wieder rauskommt, so git tag, dann könnten wir das taggen,

01:55:51.160 --> 01:55:56.640
dann müssen wir, oh jetzt kommt zet magic leute, zet, wir müssen die versionsnummer

01:55:56.640 --> 01:56:21.920
in der datei ändern, zet, so, wir wollen version ersetzen durch version doppelpunkt,

01:56:21.920 --> 01:56:36.680
cluster, und dann next tag, ups, und jetzt die datei angeben, konfig, ja, funktioniert,

01:56:36.680 --> 01:56:50.400
funktioniert, massive, ich will das übrigens im hauptverzeichnis liegen haben, so, ich

01:56:50.400 --> 01:57:09.560
will, so, minus i, dass er die datei ändert, so, danach, ergibt das sinn an der stelle,

01:57:09.560 --> 01:57:17.920
da müsste ich es noch committen, git commit, und den tag, den tag machen wir logischer

01:57:17.920 --> 01:57:21.840
weise später, jetzt bastel ich mir doch irgendein komisches release skip, was ich eigentlich

01:57:21.840 --> 01:57:30.480
nicht machen wollte, so, das müsste funktionieren, und jetzt schreiben wir da noch folgendes

01:57:30.480 --> 01:57:48.320
drunter, irgendwie echo, und link zu den builds, wunderbar, wait for build to complete before

01:57:48.320 --> 01:57:59.720
pushing, bastel, irgendwie sowas, echo, zack, so, und wenn ich das jetzt mache, dann sollte

01:57:59.720 --> 01:58:04.160
eigentlich alles klappen, ich hoffe, dass, ich hoffe, dass ergibt sinn, was ich hier gebaut

01:58:04.160 --> 01:58:20.440
habe, also, release, latest tag, enter next release tag, v0.0.6, das ging jetzt aber ganz

01:58:20.440 --> 01:58:30.000
schön schnell, actions, ah, habe ich den push vergessen, ich glaube, ich habe den push vergessen,

01:58:30.000 --> 01:58:39.640
ah, das sollte ich vielleicht auch noch machen, git push origin, minus, minus tags, release

01:58:39.640 --> 01:58:50.760
v0.0.7, jawoll, es läuft jetzt für beide tags, ist natürlich in dem fall ein bisschen

01:58:50.760 --> 01:59:00.280
overkill, aber normalerweise pushst du immer einen tag, ja, es funktioniert, so, und wenn

01:59:00.280 --> 01:59:06.800
ich das jetzt, ah, guckt mal, ist natürlich doof, ich hätte, ich hätte, ich müsste vorher

01:59:06.800 --> 01:59:18.960
eigentlich noch ein ordentliches commit machen, so, jetzt läuft das durch, und wenn das durchgelaufen

01:59:18.960 --> 01:59:25.520
ist, dann kann ich master pushen und das neue addon ist da, also im endeffekt, ich kann

01:59:25.520 --> 01:59:36.160
jetzt auch unten auf meinem raspberry pi, das dann starten mit 0.0.7, nein, das ist

01:59:36.160 --> 01:59:41.680
wirklich die, wir bauen release absolute lite variante, aber so kann man weniger vergessen,

01:59:41.680 --> 01:59:47.800
und ich habe ja heute morgen schon gesagt, ich bin ein fan von simplen sachen mit bash

01:59:47.800 --> 01:59:57.800
zu machen, ja zwei builds parallel ist glaube ich das kostenlose github, nicht so, nicht

01:59:57.800 --> 02:00:18.960
so schnell, ok, jetzt auf, mach hin, gib ihm, ok, es sind schon zwei jobs completed, er

02:00:18.960 --> 02:00:26.160
braucht einfach ein bisschen, so, das ist fertig, das müsste jetzt auch gleich fertig sein,

02:00:26.160 --> 02:00:30.320
aber es geht eigentlich, ich meine, die images sind in ungefähr zwei bis drei minuten gebaut,

02:00:30.320 --> 02:00:36.520
das ist, das ist in ordnung, so, und jetzt kann ich einfach 0.0.7 starten und es, es

02:00:36.520 --> 02:00:47.640
punktiert nicht, na geil, warum denn nicht, was hab ich verkehrt gemacht, nee, da ist

02:00:47.640 --> 02:01:01.800
kein v, da ist es kein v, create image, ach jetzt ist es v, ah, jetzt ist es v, doch doch

02:01:01.800 --> 02:01:06.680
jetzt ist es v, klar, weil jetzt schreibe ich ja auch den tag da rein, ich glaube das

02:01:06.680 --> 02:01:15.800
sollte ich nicht machen, weil ich vermute, ich vermute, das addon hat probleme damit,

02:01:15.800 --> 02:01:27.440
wenn dort pow drinne steht, also, muss man das anders machen und zwar, den tag, bei dem

02:01:27.440 --> 02:01:44.560
tag kommt das v davor, aber bei der datei kommt es nicht davor, als dem endeffekt, ok,

02:01:44.560 --> 02:02:07.680
1.0.0, massive versionssprung, ok, warten wir noch mal bis das build fertig ist, resident

02:02:07.680 --> 02:02:13.400
sleeper, aber wenn es eins läuft, ist es auch halbwegs schnell, so, und dann sollte

02:02:13.400 --> 02:02:23.000
es theoretisch das ganze funktionieren mit 1.0.0 und dann bin ich zufrieden, dann kann

02:02:23.000 --> 02:02:41.560
der fiat champ so gebildet werden, warum tagst du den release nicht mit einer github

02:02:41.560 --> 02:02:50.520
action, ja, weil ich auf irgendwas ja mein build triggern muss, und wenn ich master pushe,

02:02:50.520 --> 02:02:57.060
dann zeigt die home assistant schon an, dass es ein neues release gibt, oder aber ich müsste

02:02:57.060 --> 02:03:03.560
dann noch ein set oder so in der github action machen, was die datei ändert, weil der tag

02:03:03.560 --> 02:03:10.560
alleine reicht nicht, jedes addon hat so eine datei hier, und anhand dieser versionsnummer

02:03:10.560 --> 02:03:16.680
entscheidet das ding, ob es dem user anzeigt, dass es addons gibt oder nicht, das heißt

02:03:16.680 --> 02:03:21.760
ich muss zuerst die image bauen, die image bauen, bevor ich den master pushe, weil wenn

02:03:21.760 --> 02:03:25.960
ich den master pushe, dann sehen die leute, dass es updates gibt, wenn ich master zuerst

02:03:25.960 --> 02:03:30.080
pushe, dann drückt einer vielleicht gleich auf updaten, das image ist noch nicht fertig

02:03:30.080 --> 02:03:42.560
gebaut, so das sollte jetzt funktionieren, jawoll, huge version 1 am start, warum yaml

02:03:42.560 --> 02:03:49.800
datei für die configs, das muss man so machen, dass home assistant das addon als addon erkennt,

02:03:49.800 --> 02:03:53.920
also das ist das ist pflicht, das kannst du nicht anders machen, der erwartet, dass

02:03:53.920 --> 02:03:58.880
dort eine config yaml liegt mit so einem inhalt, ansonsten zeigt er den leuten nicht an, dass

02:03:58.880 --> 02:04:07.000
es ein gültiges addon ist, was halt sagt, weil man will es ja als addon verwenden, so

02:04:07.000 --> 02:04:14.760
die app funktioniert immer noch, wunderbar, excellent, also du musst die yaml datei da

02:04:14.760 --> 02:04:22.040
liegen haben, anders geht es nicht, ja aber es funktioniert, alles gut, nice, so und jetzt

02:04:22.040 --> 02:04:28.860
hat er das image gebaut, jetzt kann ich auch das hier in master pushen und dann kriegen

02:04:28.860 --> 02:04:33.120
es die user angezeigt, wenn das da ist, nice, sehr schön, so dann werde ich die image mal

02:04:33.120 --> 02:04:41.360
wieder löschen, weil die sind komplett überflüssig, die braucht niemand, äh nicht der 4a champ,

02:04:41.360 --> 02:04:59.960
der test champ muss gelöscht werden, package settings, package settings, delete this package,

02:04:59.960 --> 02:05:13.520
test champ weg, delete this package, armv7 test champ weg, sehr schön, so und wisst ihr,

02:05:13.520 --> 02:05:20.200
was jetzt passiert mit diesem repo leute, nachdem ich jetzt weiß, dass es funktioniert,

02:05:20.200 --> 02:05:25.640
das repo fliegt auch wieder weg, also falls ich irgendjemand noch was raus kopieren will

02:05:25.640 --> 02:05:31.320
oder nochmal darauf hinweisen möchte, dass twitch prime kostenlos ist, muss ich das jetzt

02:05:31.320 --> 02:05:39.760
raus kopieren, weil das repo ist jetzt gleich wieder weg, äh nee wo ist das nochmal, hier

02:05:39.760 --> 02:05:51.600
in den settings, hier unten, delete, warte monkaS, sichere dir zuvor die action, hab

02:05:51.600 --> 02:06:05.400
ich doch hier, hab ich doch lokal, machen wir eigentlich bald was mit java, nein machen

02:06:05.400 --> 02:06:31.320
wir nicht, delete this repo, bam, github will nicht, dass ich das repo lösche, ok ich will

02:06:31.320 --> 02:06:35.480
nicht, dass meine nummer hier irgendwie revealed wird oder so, deswegen mach ich mal kurz weg,

02:06:35.480 --> 02:07:00.000
send sms, alles klar, nee wird nicht revealed, so sms ist gesendet, ok repo ist weg, exellent,

02:07:00.000 --> 02:07:11.520
so muss es sein, so da sind wir wieder leute, das war heute ein erfolgreicher stream, es

02:07:11.520 --> 02:07:19.000
hat alles funktioniert, das hätt ich jetzt nach gestern gar nicht gedacht, nachdem wir

02:07:19.000 --> 02:07:30.440
uns da mit koemo einen abgemüht haben, hab ich eigentlich package updates vorhin fertig

02:07:30.440 --> 02:07:47.600
gemacht, ja sieht so aus, was haben wir hier noch, elektron, weg damit, was hab ich da

02:07:47.600 --> 02:08:08.480
eigentlich noch installiert, was edger is missing, ach es heißt jetzt belena edger,

02:08:08.480 --> 02:08:11.960
ok ok, das brauch ich eigentlich auch gar nicht mehr, ich benutze jetzt eigentlich immer

02:08:11.960 --> 02:08:24.080
den pie imager, edger, weg, nee die bezahle ich nicht, die ersten 3 jahre sind kostenlos

02:08:24.080 --> 02:08:31.240
und danach kostet es was, ja da bin ich auch nicht scharf drauf, aber gut, mal gucken,

02:08:31.240 --> 02:08:39.600
ja wenn mal was funktioniert ist das ziemlich pog, mal gucken ob ich das dann verlänger,

02:08:39.600 --> 02:08:50.800
manjarofirmware, sollte man das wirklich löschen, ist das so eine gute idee, moment leute, das

02:08:50.800 --> 02:08:54.640
muss ich mal kurz einen samshot machen bevor ich das lösche, weiß nicht genau was ich

02:08:54.640 --> 02:09:08.320
da ehrlich gesagt lösche, aber ich lösche das einfach mal, ok, vielleicht können wir

02:09:08.320 --> 02:09:14.360
auch noch einen neuen kernel machen bei der gelegenheit gerade, gib ihm, nee wir haben

02:09:14.360 --> 02:09:20.600
den lts kernel, da bin ich zufrieden mit reboot, gucken ob es auch funktioniert, also kernel

02:09:20.600 --> 02:09:24.760
löschen, firmware löschen und so, da weiß ich immer nicht so genau, nicht dass der doch,

02:09:24.760 --> 02:09:31.560
letztens war ja bei artscheinungs auch krupp kaputt, wobei ich hier glaube gar keinen krupp

02:09:31.560 --> 02:09:39.720
verwende sondern systemd bootd, weißt du was man nach den 3 jahren zahlen muss, nee 30

02:09:39.720 --> 02:09:49.160
euro im jahr oder so, wie hast du das mit dem snapshot gemacht, hab auf snapshot machen

02:09:49.160 --> 02:10:06.320
geklickt, so nachdem der, nein nein nicht matt, max123456 massive password, password leak

02:10:06.320 --> 02:10:22.160
by the way, so anscheinend funktioniert noch alles, weiß nicht, kann den snapshot löschen,

02:10:22.160 --> 02:10:29.800
exellent, also das ist der funktion die ist in fireworkstation eingebaut, dass du snapshots

02:10:29.800 --> 02:10:36.080
machen kannst, eines der praktischsten funktionen, die es da so gibt, wenn man nicht so genau

02:10:36.080 --> 02:10:44.720
weiß ob das alles ordentlich funktioniert was man jetzt vorhat, Leute das wars, es hat

02:10:44.720 --> 02:10:51.400
funktioniert, fertig und ich hab heute auch lang genug gestreamt, wir waren heute morgen

02:10:51.400 --> 02:10:56.560
4 stunden und heute Abend noch 2 stunden, es gibt ja leute die streamen irgendwie 8 stunden,

02:10:56.560 --> 02:11:00.280
8,5 stunden am tag, ich weiß nicht wie die das schaffen, das sind wahrscheinlich alles

02:11:00.280 --> 02:11:08.880
kleine zoomer, jaja vm snapshot, ja, unter ledungs gibt es verschiedenste varianten snapshots

02:11:08.880 --> 02:11:13.000
zu machen, so einen nice snapshot wie mit fireworkstation kannst du ja nicht machen,

02:11:13.000 --> 02:11:18.040
das höchste der gefühle ist, dass du was weiß ich in btrfs oder zfs snapshot von einer

02:11:18.040 --> 02:11:22.440
disk machst, aber snapshots inklusive ram ist natürlich schwierig bei einem rechner

02:11:22.440 --> 02:11:30.400
rebootet so, wobei, also theoretisch müsste es gehen, aber ich glaube das hat noch keiner

02:11:30.400 --> 02:11:51.960
probiert, richtig, genau, also ich hab ein home assistant addon mit unter anderem software

02:11:51.960 --> 02:11:57.880
in c sharp, daraus ein, also ich hab aus meiner software, aus meiner c sharp software ein home

02:11:57.880 --> 02:12:04.680
assistant addon gebaut, was github mir quasi kompiliert und so ein docker image draus

02:12:04.680 --> 02:12:08.960
baut und das wichtigste ist ein docker image baut, das auf dem raspberry pi läuft und

02:12:08.960 --> 02:12:19.720
das auf dem desktop läuft, chainlaw was ist da wieder los, ich reload jetzt mal den chat,

02:12:19.720 --> 02:12:22.960
dass ich das auch sehe, nochmal leute, jawoll

02:12:49.720 --> 02:12:58.280
jetzt wird ganz schön gekackt chatted, giga cute chat

02:12:58.280 --> 02:13:20.120
gut leute, wir sehen uns im nächsten stream, machts gut, bis dann, see you

