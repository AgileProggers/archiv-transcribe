WEBVTT

00:00.000 --> 00:24.480
So, erstmal ne Runde husten, ich weiss auch nicht warum ich dazu jetzt warten muss bis

00:24.480 --> 00:25.480
das Stream angeht.

00:25.480 --> 00:39.120
Aber wollte vorher nicht.

00:39.120 --> 00:40.280
Massive Poggersound.

00:40.280 --> 00:55.240
Moin Marc, Jojo Moink.

00:55.240 --> 01:08.200
Kussi ist auch da, Relax ist auch am Start, jetzt kommen sich alle.

01:08.200 --> 01:18.200
So, ich zeige euch mal was, wusst ihr das Windows mittlerweile, ähm, proprietäre Emojis

01:18.200 --> 01:19.200
hat?

01:19.200 --> 01:36.240
Wie sieht bei euch der Titel aus, guckt mal.

01:36.240 --> 01:39.360
Wie sieht bei euch der Titel vom Stream aus, warte mal, ich muss mal kurz Musik ein bisschen

01:39.360 --> 01:40.360
leiser machen.

01:40.360 --> 01:58.040
Tja, passt mal auf, Windows hat proprietäre Emojis, schaut mal.

01:58.040 --> 02:04.960
So sieht der Titel bei einigen von euch aus, jetzt guckt mal an wie das unter Windows aussieht.

02:04.960 --> 02:12.760
Tja, unter Windows sieht das so aus.

02:12.760 --> 02:18.280
Microsoft hat es tatsächlich geschafft proprietäre Windows-only Emojis zu designen.

02:18.280 --> 02:23.600
Ich habe eigentlich gedacht Microsoft wäre aus dieser Zeit raus, wo sie proprietäre

02:23.600 --> 02:28.400
Windows-only Sachen gemacht haben, aber dieses ist ein Windows-only Emoji.

02:28.400 --> 02:37.880
Ja, copy-paste in Twitch-Channel ergibt das, weil Twitch das Searching replaced durch

02:37.880 --> 02:38.880
eigene Emojis.

02:38.880 --> 02:47.200
So sieht es im Titel aus und in Wirklichkeit ist es aus zwei Emojis zusammengesetzt.

02:47.200 --> 02:50.200
Lustig, oder?

02:50.200 --> 02:53.800
Dass es proprietäre Windows-only Emojis gibt.

02:53.800 --> 02:57.440
Gut, in dem Fall wundert es mich nicht, wenn das eine Katze mit Stirnband und Windows-Logo

02:57.440 --> 02:58.440
ist, aber trotzdem.

02:58.440 --> 03:03.320
Ich habe nachgeguckt, das ist irgendwas, was zum Windows-Jubiläum gekommen ist von Microsoft,

03:03.320 --> 03:04.320
was auch immer.

03:04.320 --> 03:09.320
Ich habe es aufgegeben zu versuchen nachzuvollziehen, was Microsoft da manchmal treibt.

03:09.320 --> 03:20.240
So, wir gucken uns jetzt mal ein paar neue, die neuen C-Sharp-9-Features an.

03:20.240 --> 03:24.640
Das ist gar nicht so viel, auch wenn die Seite lang aussieht, aber das ist große Schriftgröße

03:24.640 --> 03:26.800
und es ist nicht so viel wirklich Tolles.

03:26.800 --> 03:35.160
Ich habe schon mal grob drübergescrollt vorhin und ich habe auch schon vor einem Drittel

03:35.160 --> 03:38.320
oder so, vor einem Jahr mal einen Webcast dazu gesehen.

03:38.320 --> 03:40.240
Das gucken wir uns jetzt mal an.

03:40.240 --> 03:42.320
Also ich habe jetzt das neue.NET 5 installiert.

03:42.320 --> 03:55.480
Ich habe die Rider-Test-Version installiert, also sprich das hier, hier Rider-2020-3-EAP-7,

03:55.480 --> 03:56.800
das hat.NET 5 Support.

03:56.800 --> 04:00.000
Ich finde es ja ein bisschen schade, dass es nicht geschafft haben zum Release von.NET

04:00.000 --> 04:03.600
5 das fertig zu bekommen, aber wahrscheinlich hat Microsoft den auch gar nicht erzählt,

04:03.600 --> 04:10.600
wann eigentlich Release von.NET 5 ist.

04:10.600 --> 04:11.600
Denke ich mal.

04:11.600 --> 04:14.000
Wow, ein bisschen groß vielleicht.

04:14.000 --> 04:33.120
Ein bisschen Chat auf, ne, Chat, so, dass wir nichts übersehen.

04:33.120 --> 04:39.760
Gut, genau, also wie gesagt, diese Windows-Only-Emojis wollte ich euch mal zeigen und ich würde

04:39.760 --> 04:42.960
sagen, wir können auch mehr oder weniger gleich anfangen, gucken, was es so gibt.

04:42.960 --> 04:45.720
Ich muss da selbst ein bisschen drüber, wie gesagt, ich habe schon vorher mal drüber

04:45.720 --> 04:53.040
gescrollt, aber ein bisschen in Ruhe mir das angucken, weil mir manche neuen Features selber

04:53.040 --> 04:58.760
ein bisschen schleierhaft noch sind, wozu man die benutzen soll.

04:58.760 --> 05:03.040
Zum Beispiel das erste Feature, nämlich Record-Types.

05:03.040 --> 05:09.800
Also, bis jetzt, ich zeige euch erst mal, wie es bis jetzt in.NET, bzw. in C-Sharp

05:09.800 --> 05:10.800
funktioniert.

05:10.800 --> 05:15.520
WistleBasic.NET, lasst mal mal außen vor, den ganzen Müll, da kann man, ja, und F-Sharp

05:15.520 --> 05:17.520
weiß ich auch nicht, wie es funktioniert.

05:17.520 --> 05:22.920
F-Sharp habe ich mal so ein Einsteiger-Tutorial gemacht an Schkalusten, funktionale Sprachen

05:22.920 --> 05:24.160
sind einfach nix für mich.

05:24.160 --> 05:34.600
Ich habe mich auch schon mal an, äh, ne, nicht Skala Erlang versucht, ähm, also mir

05:34.600 --> 05:39.640
reicht, mir reicht das, was Funktionales in C-Sharp drin ist, oder kann es ja auch in

05:39.640 --> 05:44.200
Ruby und Groovy ein bisschen Funktionales machen, aber wirklich diese Hardcore-Funktional-Sprachen,

05:44.200 --> 05:47.360
ich werde damit nicht warm, also weder mit F-Sharp noch mit Erlang noch mit Skala noch

05:47.360 --> 05:50.920
mit Haskell oder mit irgendwas anderem, das ist irgendwie nicht meine Welt.

05:50.920 --> 05:55.560
Ich habe es mir schon lange vorgenommen, mir das Ganze mal anzugucken, aber, äh, warum

05:55.560 --> 06:00.240
ich das ein bisschen scheue ist, so, ist folgendermaßen, warum ich, also warum ich mich ein bisschen

06:00.240 --> 06:04.840
davor drücke, mich mal mit Funktional-Programmiersprachen zu beschäftigen, weil ich weiß jetzt schon,

06:04.840 --> 06:08.880
dass ich das eigentlich nicht wirklich auszahlen werde, in Form von, dass man das, was ist,

06:08.880 --> 06:14.560
was man wirklich sehr oft verwendet, das ist eher was, was man mal bei speziellen Problemen

06:14.560 --> 06:20.160
rausholt und jetzt nicht so Daily, wie sagt man so, Daily-Triver, ja, ähm, deswegen bin

06:20.160 --> 06:25.880
ich, wenn ich sehe, ob sich das wirklich lohnt, auf der anderen Seite, ich mach so viele Sachen,

06:25.880 --> 06:29.680
die sich überhaupt nicht lohnen, einfach nur weil's mir gefällt, also insofern, warum

06:29.680 --> 06:42.480
da nicht auch, hä? Ja man, C++ Beste, Kappa HD, Golden Kappa Check. C++ ist das Beste

06:42.480 --> 06:48.440
im Schlechtsein, also quasi das Beste von unten. Okay, legen wir mal eine Konsolenanwendung

06:48.440 --> 06:55.360
an und gucken uns mal an, was es hier so alles gibt. Exzellent. So, das blenden wir jetzt

06:55.360 --> 07:01.680
mal aus, das machen wir auf einen anderen Desktop, wobei eigentlich kann ich den ganzen anderen

07:01.680 --> 07:08.480
Müll mal wegmachen, ne? Ich lösche den ganzen Krams mal hier. So, Browser können wir auflassen,

07:08.480 --> 07:13.680
das lassen wir auf, das verschieben wir auch mal zu, das verschieben wir auf drei, machen

07:13.680 --> 07:21.720
so, ja, exquisite Platzeinteilung, Rider, genauso muss es sein. Gut, wunderbar, dann

07:21.720 --> 07:32.720
gehen wir jetzt hier nach Rider, Projects, QtChat,.net watch run. What? Ah. So, gucken

07:32.720 --> 07:39.520
wir uns das Ganze mal an. Ah, Moment, Moment, ich darf nicht.net watch run machen, ich

07:39.520 --> 07:50.040
muss machen.net,.net SDK,.net watch run, weil ich will ja.net 5 und nicht 3.1 verwenden,

07:50.040 --> 07:54.800
ich habe ja beides installiert, ich habe ja.net 5 erstmal als Snap installiert und Rider

07:54.800 --> 08:00.080
als Early Access, oder wie sie es heißen, wie sie es nennen, und das gibt es noch nicht

08:00.080 --> 08:04.800
im offiziellen Paketmanager, sind noch nicht so schnell. So, und das können wir hier auch

08:04.800 --> 08:11.760
rüber machen und da wieder auf. Machen wir mal ein bisschen größer. Wow. Okay, vielleicht,

08:11.760 --> 08:23.040
vielleicht doch nicht so groß, so, so, so, reicht. Der Bauer hat den Cryokühler auf

08:23.040 --> 08:28.240
den Risen gepappt, das haben wir uns doch heute noch angeguckt. Jeder, der das jetzt

08:28.240 --> 08:32.160
schreibt, ist zu früh im aufwachen Stream abgehauen. Das Video haben wir uns noch angeguckt.

08:32.160 --> 08:48.000
Chat, bin ich aufgepasst wieder. Tja. Okay, fangen wir mal an, gucken wir uns das mal,

08:48.000 --> 08:52.400
gucken wir uns das mal in Ruhe an. Also, es gibt jetzt Record Types, bisher in C Sharp,

08:52.400 --> 08:59.040
nur mal so zur Erklärung gibt es das ja folgendermaßen, es gibt zwei verschiedene, grundsätzliche,

08:59.040 --> 09:02.720
ja, wie soll man es nennen, nicht Typen, doch grundsätzlich verschiedene Typen gibt es

09:02.720 --> 09:08.440
in C Sharp, zwei Stück. So, das sind einmal, wir machen das mal hier unten, da machen wir

09:08.440 --> 09:17.760
ein bisschen Platz, so, das ist nicht hier, äh, gut, chat, ah ja, ja, so, ab hier geht

09:17.760 --> 09:22.720
es los. So, es gibt ja in C Sharp zwei, vielleicht machen wir mal ein bisschen Erklärbeerstream,

09:22.720 --> 09:28.920
gibt es ja zwei unterschiedliche Typen. Es gibt einmal Classes und es gibt für die Oldschool

09:28.920 --> 09:39.440
Leute und es gibt Strucks. So, und, ähm, der Unterschied ist auf den ersten Blick gar

09:39.440 --> 09:45.280
nicht so groß, aber wie gesagt, auf den ersten Blick. So, also man kann da mehr oder weniger

09:45.280 --> 09:49.280
ähnliche Sachen drin machen, in so einer Klasse oder in einem Struct, also zum Beispiel,

09:49.280 --> 09:53.640
ich kann da drin irgendwelche Methoden anlegen, sowas wie Public, also wir machen jetzt mal,

09:53.640 --> 10:00.760
wir machen jetzt mal so die, wirklich die Low-Brain-Einsteiger-Examples, weil sonst bin ich zu, zu, zu, nicht

10:00.760 --> 10:04.640
genug Brainpower, um mir welche auszuheilen, also wir machen jetzt sowas wie, keine Ahnung,

10:04.640 --> 10:11.360
Door, so, oder haben wir sowas wie Open zum Beispiel drin, so. Ähm, das kann man, das

10:11.360 --> 10:16.120
kann man übrigens in Structs und Classes machen, das ist kein Problem. So, also auf

10:16.120 --> 10:22.640
den ersten Blick unterscheidet sich das gar nicht mal so großartig. Der eigentliche Unterschied

10:22.640 --> 10:29.760
zwischen Classes und Structs ist folgender, dass Classes, also, also wenn ich jetzt was,

10:29.760 --> 10:34.840
wir machen das jetzt einfach mal, so, wir machen das hier, myStruct, ah, ohje, keine

10:34.840 --> 10:38.200
Ahnung, ohje, myClass, meistens eigentlich ganz guter Name, dann passt das, dann passt

10:38.200 --> 10:48.600
das nämlich ganz gut. So, wenn ich die, wenn ich die jetzt anlege, so, sowas hier, bar,

10:48.600 --> 10:56.720
myClass, so, immer, wir machen, beste, beste Variab, beste Variab in dem A, B gleich new,

10:56.720 --> 11:14.840
myStruct. So, jetzt ist die Frage, was passiert, was passiert hier? So, was passiert bei wem?

11:14.840 --> 11:20.120
Sieht ja erst mal relativ gleich aus. Man legt hier eine Instanz von Klasse an und man

11:20.120 --> 11:26.880
legt hier quasi eine Instanz von myStruct an. Wenn ich jetzt die Class zuweis in einer

11:26.880 --> 11:36.200
anderen Variabel, dann passiert hier eigentlich nix weiter. Es wird einfach, so, einen Link

11:36.200 --> 11:40.080
erzeugt, das kann ich, das kann ich euch zeigen, zum Beispiel, wir machen jetzt hier

11:40.080 --> 11:51.800
mal ne public, wie kommen wir mal, public int, ähm, keine Ahnung, test, so, ähm, so,

11:51.800 --> 11:55.880
das ist, wir machen hier zwei public Variablen, test, wir machen hier keine Ahnung, test ist

11:55.880 --> 12:03.080
null, ach nee, Moment, kann man das standardmäßig gar nicht so zuweisen? Kann man das standardmäßig

12:03.080 --> 12:10.240
nicht zuweisen? Okay, ist egal. So, ähm, wenn ich jetzt sage, bei der Klasse, wir machen

12:10.240 --> 12:16.200
das erstmal mit der Klasse, so, wenn ich jetzt sage, a, test ist gleich eins, so, dann können

12:16.200 --> 12:21.600
wir uns hier ausgeben, am Anfang, am Anfang ist test null, also das ist, null ist glaub

12:21.600 --> 12:31.040
ich default für int, so, danach ist test eins, guckt euch das mal an, erst ist test

12:31.040 --> 12:34.920
null, dann ist test eins, also, genauso, wie man das ganze erwarten würde, Highkicks,

12:34.920 --> 12:42.600
also was, wir gucken uns die 90 sharp Features an, was vor ein paar Tagen rausgekommen ist,

12:42.600 --> 12:46.840
Mark Jojo, genau, danach, danach wird, danach kommt der Test, danach wird abgefragt, jetzt

12:46.840 --> 12:51.560
Prüfung, so, also man sieht, da kommt null und eins raus, das ist ja eigentlich auch

12:51.560 --> 12:58.200
so, wie man es erwarten würde, jetzt kommt allerdings der Trick, was passiert denn jetzt,

12:58.200 --> 13:11.880
wenn ich sowas hier mache, b ist gleich a, was ist jetzt, was ist jetzt in b.test drinne,

13:11.880 --> 13:20.120
was meint ihr? Also, ich nehme a und weiß, dass b zu und dann gucke ich, was in test

13:20.120 --> 13:27.360
drin steht, da ist natürlich immer noch eins drin, weil das haben wir ja vorher reingeschrieben

13:27.360 --> 13:33.600
und a ist ja, b ist ja nur ein Zeige auf a, aber jetzt kommt, jetzt kommt der Knackpunkt,

13:33.600 --> 13:44.120
was passiert denn, wenn ich jetzt sowas hier mache, b, test, gleich 100, dann ist b test

13:44.120 --> 13:54.360
100, aber, und jetzt kommt der Witz, a test ist auch 100, also sprich, das hier, b ist

13:54.360 --> 14:00.880
einfach nur ein Zeige auf a, so, mit einem Struct sieht das schon wieder anders aus,

14:00.880 --> 14:05.400
wenn wir das Ganze jetzt nochmal machen und nehmen jetzt hier mal my struct, das muss

14:05.400 --> 14:08.200
ich jetzt mal ein bisschen als Intro erklären, dass man vielleicht das neue Feature besser

14:08.200 --> 14:13.960
versteht, weil ich kapiere es selbst noch nicht so genau, so, wenn man das Ganze jetzt

14:13.960 --> 14:18.320
mal mit structs macht, wir können das Ganze jetzt mal ein bisschen abkürzen, so, ich

14:18.320 --> 14:25.120
klicke jetzt ein neues Struct und dann sage, a ist gleich, a ist gleich links, so, jetzt

14:25.120 --> 14:32.320
sage ich a test ist gleich 100, oder a test, bleiben wir bei, ist gleich 1, so, gebe ich

14:32.320 --> 14:40.840
das hier aus, wunderbar, noch nichts neues, aber jetzt, jetzt kommt der Witz, sage ich

14:40.840 --> 14:49.840
jetzt b test gleich 100 und gebe b aus, dann ist das auch noch alles ok, aber, wenn ich

14:49.840 --> 14:59.840
jetzt a test ausgebe, werdet ihr feststellen, tja, hoch, das scheint anders zu funktionieren,

14:59.840 --> 15:07.000
nämlich da ist a noch 1, ja, und deswegen, das ist der hauptsächliche Unterschied, also

15:07.000 --> 15:13.520
sprich, wenn ich eine Klasse habe, dann ist das hier immer eine Referenz und ein Struct

15:13.520 --> 15:17.920
wird immer kopiert, das heißt, sobald ich das hier mache, hat b nichts mehr mit a zu

15:17.920 --> 15:28.240
tun, das ist so der grundsätzliche, der basic Unterschied zwischen Structs und Classes,

15:28.240 --> 15:31.520
wer braucht sowas, du brauchst Leute, die sowas können, dass du dein tägliches Smartphone

15:31.520 --> 15:38.920
Zeug spielen kannst, dass du fortan ein Mobile spielen kannst, brauchst du das, und zumindest

15:38.920 --> 15:49.080
indirekt, so, so weit zur Erklärung der ganzen Geschichte, also sprich, Structs werden immer

15:49.080 --> 15:53.640
kopiert und Classes sind immer Referenzen aufeinander, das hat natürlich den großen

15:53.640 --> 15:58.480
Vorteil oder auch einen Nachteil, je nachdem, wie man das sieht, hier muss ich immer was

15:58.480 --> 16:02.960
kopieren, wenn ich das übergebe oder zuweise oder sonst was, sprich, ich muss permanent

16:02.960 --> 16:07.040
was kapieren, und hier übergebe ich einfach nur eine Referenz, was natürlich auch heißt,

16:07.040 --> 16:13.720
die Sachen verändere ich immer automatisch mit und hier bleibt das Original unberührt,

16:13.720 --> 16:21.600
so, das ist so der grundsätzliche Unterschied, ich weiß, die Kenner werden jetzt anfangen

16:21.600 --> 16:25.400
von wegen Heap und Stack und sonst was, das ist erstmal vollkommen egal, das grundsätzliche,

16:25.400 --> 16:33.000
was man wissen muss, Structs werden kopiert und Klassen werden referenziert, exzellent,

16:33.000 --> 16:35.700
so und jetzt können wir uns mal das neue Feature angucken, das habe ich nämlich selbst noch

16:35.700 --> 16:42.240
nicht so ganz gecheckt, Structs sind für Boomer, das würde ich tatsächlich teilweise

16:42.240 --> 16:48.320
so unterschreiben, weil ganz ehrlich, Structs verwendet man sehr selten, es gibt einen großen

16:48.320 --> 16:57.320
Unterschied, den ich noch zeigen muss zwischen Structs und Classes und Structs, den ich

16:57.320 --> 17:02.600
noch nicht gezeigt habe, so, also, wir machen jetzt mal eine Klasse, wir machen jetzt mal

17:02.600 --> 17:13.240
hier, keine Ahnung, Struct 1 und Struct 2, so, was meint ihr, was hier rauskommt?

17:13.240 --> 17:24.760
Wobei, ich fange mal, ich fange, vielleicht fange ich besser anders an, ja, doch, machen

17:24.760 --> 17:31.680
wir es mal, was meint ihr, was hier rauskommt, bei dem Check, wenn ich checke, achso, darf

17:31.680 --> 17:38.440
ich so ja gar nicht, äh, okay, Equals, machen wir es so, was meint ihr, was bei dem Check

17:38.440 --> 17:47.120
rauskommt, wenn ich gucken will, ob Struct 1 gleich Struct 2 ist, tja, noch kommt da

17:47.120 --> 17:51.200
True raus, noch kommt da True raus, warum?

17:51.200 --> 17:56.800
Weil die Werte innerhalb dieses Structs in beiden Structs gleich sind, so, mache ich

17:56.800 --> 18:09.480
Struct 1, Test gleich 5, dann wird da False rauskommen, also sprich, wenn ich überprüfe,

18:09.480 --> 18:14.320
ob zwei Structs gleich sind, da werden immer die Werte miteinander überprüft, ob die

18:14.320 --> 18:27.840
gleich sind, so, und jetzt machen wir das nochmal mit den Klassen, jetzt, jetzt, äh,

18:27.840 --> 18:31.280
okay, ich pendenze mal um, so, was meint ihr, was da jetzt rauskommt?

18:31.280 --> 18:38.240
Jetzt können wir, jetzt können wir übrigens hier auch gleich, gleich machen, ja, was

18:38.240 --> 18:43.560
wird, achso, ja, das sind wir gleich, tja, da kommt jetzt False raus, so viel kann ich

18:43.560 --> 18:48.760
euch schon mal spoilern, aber, und jetzt kommt der große Unterschied zu Structs, wenn ich

18:48.760 --> 18:53.720
das hier jetzt wegmache, also sprich, jetzt sind ja die Werte zwischen Class 1 und Class

18:53.720 --> 18:58.320
2 exakt gleich, ich hab bei keinem die Werte verändert, jetzt ist das immer noch False,

18:58.320 --> 18:59.320
warum?

18:59.320 --> 19:07.280
Genau, was der Void Danny sagt, zwischen Klassen wird die Referenz verglichen, also

19:07.280 --> 19:15.360
sprich, zeig das hier mal ganz, einfach gesagt, zeig das hier auf den gleichen, äh, Startpunkt

19:15.360 --> 19:21.840
im Speicher, wenn ja, dann ist das die gleiche Instanz und es ist true, ansonsten zwei unterschiedliche

19:21.840 --> 19:26.880
Klasseninstanzen, wenn du die miteinander vergleichst, sind immer False, bei Structs

19:26.880 --> 19:30.640
ist es umgedreht, Structs ist eigentlich ziemlich wurscht, wo die ganzen Sachen im Speicher

19:30.640 --> 19:38.040
verliegen, Structs werden immer die Werte überprüft, also sprich, mit Structs lässt

19:38.040 --> 19:47.400
sich zum Beispiel relativ gut alles abbilden, was irgendwie so eine Art Wert ist, also zum

19:47.400 --> 19:57.480
Beispiel ein Datum oder so, oder irgendwie eine Uhrzeit, oder ein Intervall, oder sowas

19:57.480 --> 20:03.400
in der Richtung, ja, weil es ist so, wenn ich zum Beispiel eine Klasse habe für Uhrzeit,

20:03.400 --> 20:09.960
oder einen Struct habe für Uhrzeit und ich will überprüfen, Uhrzeit 1 ist Uhrzeit 1

20:09.960 --> 20:17.880
gleich Uhrzeit 2, dann will ich nicht überprüfen, ob das im Speicher die gleiche Adresse ist,

20:17.880 --> 20:24.920
sondern ich will wissen, ist das quasi logisch gesehen von den Zahlen her der gleiche Wert,

20:24.920 --> 20:31.160
so dementsprechend, wenn bei Structs Werte überprüft miteinander und bei Klassenreferenzen.

20:31.160 --> 20:39.440
So und jetzt kommt der Bits, was das bei C Sharp auch ein bisschen schwammiger macht,

20:39.440 --> 20:43.760
man kann, ich lösche das Struct mal, was man machen kann, also wir wissen jetzt ja,

20:43.760 --> 20:48.640
dass hier ist False, das wissen wir jetzt ja, also wir wissen, wir machen mal, ich mach

20:48.640 --> 20:53.880
mal hier so einen Start, dann sieht man es besser, Start und Ende, so, dann sieht man

20:53.880 --> 20:58.360
nämlich hier im Terminal besser, was Sache ist, so, also das wissen wir ja, das hier

20:58.360 --> 21:03.040
ist eine Referenz auf eine Instanz von Klasse, das hier ist auch eine Instanz, eine Referenz

21:03.040 --> 21:08.840
auf eine Instanz von Klasse, so und die sind nie, die sind nie gleich, weil es sind unterschiedliche

21:08.840 --> 21:13.320
Referenzen, unterschiedliche Adressen im Speicher, was man jetzt machen kann in C Sharp ist folgendes,

21:13.320 --> 21:15.920
man kann sagen, ich muss ehrlich sagen, ich hoffe ich krieg's aus dem Kopf hin, weil

21:15.920 --> 21:24.400
man macht das nicht sehr oft, kann man sagen Over, nee, Overwrite, Equals und dann kann

21:24.400 --> 21:29.400
man das Ganze ein bisschen faken, also sprich ich kann überschreiben, wie sich das hier

21:29.400 --> 21:41.400
verhält und ich kann auch ne Klasse so programmieren, dass sie sich ähnlich wie den Struct verhält

21:41.400 --> 21:49.720
beim Vergleich, wo man sich natürlich dann die Frage stellen muss, okay, macht das Sinn,

21:49.720 --> 21:56.440
das ist natürlich von, wie machen wir das jetzt eigentlich, Return, wie funktioniert

21:56.440 --> 22:00.400
das jetzt überhaupt nicht, ich mach das so selten, ich glaub man braucht hier dann irgendwie,

22:00.400 --> 22:11.840
man muss das glaube ich casten, ne, da muss man irgendwie sagen, my class, ist das richtig,

22:11.840 --> 22:20.120
man muss das irgendwie casten, also das heißt ich muss dann sagen, keine Ahnung, i, das

22:20.120 --> 22:30.000
da, irgendwie sowas in der Richtung kann man glaube ich machen, so und jetzt werden

22:30.000 --> 22:35.000
wir sehen, das ist immer noch falsch, was hab ich verkehrt gemacht, was hab ich falsch

22:35.000 --> 22:49.360
gemacht, warum kommt da jetzt nicht True raus, ach ich muss Dings überschreiben, ich muss

22:49.360 --> 22:57.960
noch gleich gleich überschreiben, jetzt kommt True raus, so und wie überschreibe ich jetzt,

22:57.960 --> 23:08.920
wie überschreibe ich jetzt gleich gleich, das geht auch irgendwie, ja ich überleg mir auch

23:08.920 --> 23:12.520
wie man das generieren kann, wie kann man das denken, ach hier kann man den bestimmt

23:12.520 --> 23:37.360
sagen, ich möchte da noch generate, wow, what the fuck, und das funzt jetzt, ne, das war

23:37.360 --> 23:53.800
ich falsch auf meinen Basics, ach man muss den Operator überladen, ach stimmt, das macht

23:53.800 --> 24:00.560
man so selten, ja, man muss den Operator überladen, also sprich ich muss jetzt machen, was Publix

24:00.560 --> 24:11.320
ist, Static, Bool, Operator, ernsthaft so, ach du große Scheiße, das mach ich ja nie,

24:11.320 --> 24:31.120
und wie geht das jetzt, C Sharp, Class, Overload, Equals, sieht man mal wie oft man sowas macht,

24:31.120 --> 24:45.360
so geht es schon mal nicht, Operator, ja, excellent, ok, wir Copy Pasting, Stack Overflow, wir wissen

24:45.360 --> 24:57.320
ja, Stack Overflow, Copy Pasting ist prinzipiell die beste Antwort auf alle Sachen, ok, Return,

24:57.320 --> 25:09.400
Object 1, wobei ne, ich kann doch da jetzt aufrufen, Equals, oder, wir machen das jetzt

25:09.400 --> 25:20.240
hier einfach noch mal, aber ich kann sowas, mach du das so, ne, das geht nicht, warum geht

25:20.240 --> 25:28.400
das nicht, ah, man muss Matching, aha, aha, oh, komm mal hier, Big Brain, man muss beides

25:28.400 --> 25:34.640
überschreiben, jetzt kommt True raus, ok, alles klar, das ist übrigens auch ne Sache,

25:34.640 --> 25:41.440
was ich an C Sharp mag, beziehungsweise an der Philosophie, was Microsoft macht, dass

25:41.440 --> 25:47.280
die hier gleich sagen, ok, wenn du Equals überlädst, oder beziehungsweise den Gleichgleich

25:47.280 --> 25:53.560
Operator überlädst, du musst auch ungleich überladen, weil es wäre ja so komplett wir,

25:53.560 --> 25:59.160
wenn auf einmal das da True wäre und das da auch True wäre, das würde ja überhaupt

25:59.160 --> 26:04.520
keinen Sinn ergeben, das kann man höchstens machen, um die Leute zu trollen, ja, so, also

26:04.520 --> 26:11.760
man sieht, man kann auch Klassen fabrizieren, die sich ein bisschen wie Struts anfühlen,

26:11.760 --> 26:19.040
aber der grundsätzliche Unterschied zwischen Klassen und Struts bleibt, Struts werden immer

26:19.040 --> 26:26.640
kopiert und Klassen sind immer quasi Verknüpfung, ja, Referenzen aufeinander, das muss man wissen

26:26.640 --> 26:32.720
und manchmal ist es tatsächlich sinnvoller einen Strut zu nehmen, aber meistens in, ah

26:32.720 --> 26:38.080
man, 99% der Fälle sind es eigentlich Klassen, die man nimmt, so, und jetzt können wir uns

26:38.080 --> 26:43.280
das neue Feature angucken, nämlich, es gibt jetzt sowas Neues, das ist quasi ein Strut

26:43.280 --> 26:47.880
als Klasse, soweit ich das verstanden habe, ich bin da nämlich im Vorfeld schon mal drüber

26:47.880 --> 26:56.480
gescrollt und zwar, es gibt jetzt Record Types, also sprich, bisher gab es ja in Public Strut,

26:56.480 --> 27:07.360
Strut, also bisher gab es ja in C Sharp nur Klassen und Struts und jetzt gibt es quasi

27:07.360 --> 27:14.440
eine verkappte Klasse als Strut, die, also, ja doch, eine Klasse, die so tut, als wäre

27:14.440 --> 27:19.520
es ein Strut, die quasi genau das macht, was ich eben gemacht habe, aber schon standardmäßig,

27:19.520 --> 27:24.480
also sprich, Record Types sind, soweit ich das verstanden habe, die legt man übrigens

27:24.480 --> 27:32.320
so an, also wir können das ja mal kurz copypasten, wie die das hier machen, so, das ist jetzt

27:32.320 --> 27:37.640
neu, also das gibt es erst seit 5 Tagen oder so, oder seit 2 Tagen, oder wie auch immer,

27:37.640 --> 27:41.960
ich glaube seit 5 Tagen gibt es das erst, so, das ist jetzt neu, also sprich, was das

27:41.960 --> 27:49.080
macht, ist, dass da unten können wir uns glaube ich sparen, das ist der Constructor hier,

27:49.080 --> 28:01.080
ja, wir machen das mal kurz weg, so, das ist jetzt ein neuer Typ, und zwar, der überschreibt

28:01.080 --> 28:08.840
das ganze jetzt, also ich kann jetzt quasi sagen, New, Rec 1, Rec 2, New, das ist jetzt

28:08.840 --> 28:14.080
wie gesagt, das ist das erste Mal, dass ich das verwende, schauen wir mal, und wir machen

28:14.080 --> 28:23.280
jetzt auch wirklich nur noch sowas hier, so, also, my record 1, my record 2, Rec 1 gleich

28:23.280 --> 28:35.880
Rec 2, und jetzt wird mir sehen, es ist true, 0W, so, also sprich, den Record ist ne Klasse,

28:35.880 --> 28:42.200
die schon Equals überschrieben hat für mich, also quasi das hier, was ich eben von Hand

28:42.200 --> 28:47.480
gemacht hab, dieser Schmodder hier, den ich hier eben von Hand gemacht hab, den macht

28:47.480 --> 28:52.360
Record schon für mich, warum will man sowas haben, ich habs auch erst nicht kapiert ehrlich

28:52.360 --> 28:56.280
gesagt, und ich bin mir da noch immer noch nicht hundertprozentig sicher, aber ich denke

28:56.280 --> 29:05.680
mal, das liegt daran, wenn man sowas hat, was eben, so gewisse Wert, wo so die Zahlen

29:05.680 --> 29:10.640
geht, die drin gespeichert werden, nicht so sehr ob es ne Referenz ist oder nicht, aber

29:10.640 --> 29:15.600
ich trotzdem es nicht bei jedem Aufruf kopieren will, also sprich, wenn ich aus Performance

29:15.600 --> 29:24.280
Gründen keine Structs verwenden mag, aber ich von der Vergleichlogik her eigentlich

29:24.280 --> 29:28.240
das verwenden will, was Structs machen, so, und deswegen haben sie das wahrscheinlich

29:28.240 --> 29:32.640
auch Record genannt, oder sie hätten es auch Data oder so nennen können, also sprich,

29:32.640 --> 29:40.160
um zu symbolisieren, dass es bei dieser Klasse nicht um die Methoden und sonst was geht,

29:40.160 --> 29:43.200
die man implementiert, sondern eigentlich hauptsächlich um die Daten, die drin enthalten

29:43.200 --> 29:49.960
sind, so, und was man jetzt damit noch großartig machen kann, muss ich mir angucken, weil hab

29:49.960 --> 29:54.960
ich auch keine Ahnung von, genau, ach ja stimmt, man kann Records glaube ich gar nicht ändern,

29:54.960 --> 30:00.280
ne, das ist ja das nächste Feature, was ich, so wie ich das gesehen hab, ich glaube man

30:00.280 --> 30:04.240
kann Records nicht ändern, also was ich jetzt, ich kann doch sowas hier nicht machen, oder?

30:04.240 --> 30:09.200
Oh doch, kann ich, warum geht das?

30:09.200 --> 30:13.360
Ich dachte, das geht nicht, ich dachte, das ist der Sinn davon gewesen, dass das nicht

30:13.360 --> 30:14.360
geht.

30:14.360 --> 30:27.520
Okay, das kann man nicht, das darf man nicht wie Public Variable machen, das muss man

30:27.520 --> 30:29.840
wohl mit irgendwelchen Properties machen.

30:29.840 --> 30:46.840
Die große Preisfrage ist, Moment mal, REC 1, ob der das überhaupt macht, okay, okay,

30:46.840 --> 30:54.680
wir lesen mal den Text dazu, was die geschrieben haben, also, wie gesagt, ich hab mich da nicht

30:54.680 --> 31:00.000
großartig mit beschäftigt, zumindest, was ich in dem Webcast gesehen hab, ist, dass

31:00.000 --> 31:04.640
eines der neuen Features von Records im Vergleich zu Structs und Klassen ist, dass man sie

31:04.640 --> 31:09.680
immutable machen kann, also sprich, dass ich, nachdem ich sie angelegt hab, sie nicht mehr

31:09.680 --> 31:10.680
ändern kann.

31:10.680 --> 31:20.120
Was zum Beispiel, wenn man Multi-Threading macht, ganz nützlich ist, so, ähm, so,

31:20.120 --> 31:28.920
also, das muss ich mir jetzt mal durchlesen, was verschreib ich denn mal, so, also, was

31:28.920 --> 31:33.760
machen wir hier in dem Beispiel, sie legen den Record an, mit zwei Properties, die, ach,

31:33.760 --> 31:42.040
die Get Only sind, ah, ich glaub, jetzt versteh ich das, okay, das probieren wir jetzt mal

31:42.040 --> 31:50.880
mit dem Beispiel aus, von denen hier, also, legen wir mal den Record an, also, Persons

31:50.880 --> 31:58.760
sind immer so dieser, alter, übelste Knees-Action, Persons sind immer so der Standard-Test von

31:58.760 --> 32:08.120
denen, irgendwie, so, und da muss ich jetzt angeben, was First und Last Name, okay, First

32:08.120 --> 32:18.840
Name, Max, Last Name, Q-Chat, so, und jetzt kann ich die Glaube nicht mehr ändern, ne,

32:18.840 --> 32:26.240
ah, genau, jetzt geht das nicht mehr, okay, also sprich, wenn ich das so mache, wie die

32:26.240 --> 32:34.200
das jetzt zeigen, also sprich, mit diesen, ähm, Get Only-Properties, dann funktioniert

32:34.200 --> 32:43.360
das nicht, so, was ganz praktisch ist, wenn ich sicherstellen will, dass nachdem die Sache

32:43.360 --> 32:47.560
initialisiert wurde, sie sich nie wieder ändern kann, was man jetzt, glaub ich, machen kann

32:47.560 --> 33:04.480
ist sowas hier, ne, warte mal, wie ging das, With, da muss ich die Syntax mir mal angucken,

33:04.480 --> 33:28.360
ach, so, genau, das geht, also sprich, man kann, hm, okay, also, also, also, also, also,

33:28.360 --> 33:40.920
okay, dann hab ich das noch nicht so genau kapiert, ehrlich gesagt, dann müssen wir

33:40.920 --> 33:44.080
uns das jetzt doch mal durchlesen, was sie hier geschrieben haben, zumindest mal so grob

33:44.080 --> 33:50.280
drüber scrollen, dass wir wissen, was da, was da Sache ist, also, das haben wir ausprobiert,

33:50.280 --> 33:54.880
das funktioniert, also, wenn ich das so anlege, kann ich das einmal anlegen und nie wieder

33:54.880 --> 34:00.160
ändern, was jetzt nicht ganz so toll ist, jaja, das mit Init, ich, ich hab, ich glaube,

34:00.160 --> 34:03.520
ich hab das schon gesehen, dass ich da Init eintragen muss, aber ich muss mir erstmal

34:03.520 --> 34:07.240
durchlesen, so grob, was die sonst noch dazwischen geschrieben haben, also, sprich, wenn ich

34:07.240 --> 34:12.560
so mache, kann ich nie wieder dieses Objekt ändern, egal, was ich mach, geht nicht, ist

34:12.560 --> 34:18.560
nicht erlaubt, was natürlich auch seinen Charme hat, das ist, das ist zum ersten Mal in C

34:18.560 --> 34:27.120
Sharp so, das, das gab's vorher in der Art und Weise nicht, dass es quasi nen Typ gibt,

34:27.120 --> 34:30.440
der standardmäßig immutable ist, also sprich, den ich initialisieren kann, aber nie wieder

34:30.440 --> 34:37.040
ändern kann, der Vorteil von sowas ist, warum man, warum man sowas zum Beispiel macht, ist,

34:37.040 --> 34:42.400
wenn man Multi-Threading betreibt, so, ich versuch euch da mal ein Beispiel zu zeigen

34:42.400 --> 34:49.400
und zwar, ne, kann ich euch kein Beispiel zeigen, das hab ich hier nicht, stelle euch

34:49.400 --> 34:54.440
mal vor, ihr lest, bleiben wir mal bei diesem Beispiel mit den Webcams, was wir hier schon

34:54.440 --> 35:00.440
mal programmiert haben, man hat einen Thread, der liest von der Webcam in den Buffer, man

35:00.440 --> 35:06.680
möchte, kennt ihr das, wenn man bei so modernen, moderneren Aufnahmegeräten, wenn man da Fernsehprogramme

35:06.680 --> 35:12.680
aufnimmt, oder, oder, dass man Fernsehprogramme, kennt ihr, dass man Fernsehprogramme anhalten

35:12.680 --> 35:16.120
kann, oder auch überhaupt, dass man Amazon-Videos anhalten kann, ne, also sprich, du lädst das

35:16.120 --> 35:24.240
Video runter, drückst du auf Pause und, ähm, dann fängt der an zu buffern, beim Fernsehprogramm

35:24.240 --> 35:28.640
zum Beispiel, also der startet im Hintergrund ne Aufnahme, so, oder, was ihr ja auch kennt

35:28.640 --> 35:36.920
ist bei Shadowplay, bei Shadowplay, wo man dann, ähm, beispielsweise bis zu, bis zu,

35:36.920 --> 35:42.320
glaub, 10 Minuten rückwärts, oder Viertelstunde rückwärts, oder so Sachen aufnehmen kann,

35:42.320 --> 35:53.840
stellt man das jetzt noch mal ein, äh, wo hat man das, wo stellt man das jetzt in Shadowplay

35:53.840 --> 36:03.120
noch mal ein, dass man, Buffer, hier, genau, guckt, also sprich, man kann hier in Shadowplay

36:03.120 --> 36:09.660
auch einstellen, dass man bis zu 20 Minuten rückwirkend aufnehmen kann, so, und das funktioniert

36:09.660 --> 36:14.000
ja auch vollendermaßen, die haben im Hintergrund was, was permanent aufnimmt, und erst wenn

36:14.000 --> 36:18.120
du dann auf rückwärts, rückwärts aufnehmen drückst, kopiert er das halt in ein neues

36:18.120 --> 36:22.400
Video-File, der muss es ja aufnehmen, weil der kann ja nicht wirklich rückwirkend aufnehmen,

36:22.400 --> 36:26.320
dann nehmt einfach in ein Temp-File auf, und wenn du sagst, jetzt aufnehmen, dann macht

36:26.320 --> 36:30.000
er eine Datei draus, so, dann stellt euch mal vor, ihr macht das auch, also sprich,

36:30.000 --> 36:35.080
ihr habt einen Thread, der im Hintergrund irgendwie was in den Buffer schreibt, und

36:35.080 --> 36:38.360
der soll natürlich möglichst unabhängig von allen zusätzlich weiter in diesen Buffer

36:38.360 --> 36:42.960
schreiben, sagen wir mal, so immer, so 20 Sekunden Buffer wollt ihr permanent haben,

36:42.960 --> 36:46.160
dass wenn einer mal auf aufnehmen drückt, zum Beispiel wenn ihr eine Kamera habt, wenn

36:46.160 --> 36:50.040
ihr eine Kamera aufnehmt, und ihr wollt auf jeden Fall den DHL-Lieferant oder den Einbrecher

36:50.040 --> 36:54.800
drauf haben, bei Motion Detection, dann nehmt ihr immer 20 Sekunden permanent auf in so

36:54.800 --> 36:59.320
einem Buffer, überschreibt das immer wieder, 20 Sekunden quasi vorne ein Paket raus, hinten

36:59.320 --> 37:05.160
ein Paket rein, so dass ihr immer 20 Sekunden habt, so, und dann gibt es ein Event, zum

37:05.160 --> 37:09.040
Beispiel, man wurde Bewegung erkannt, und dann möchte man eine neue Datei anlegen und

37:09.040 --> 37:14.360
diese 20 Sekunden quasi in die Datei kopieren und dann weiter darin aufnehmen, das macht,

37:14.360 --> 37:17.040
da brauchen wir unterschiedliche Threads für, also auf dem einen Thread läuft diese

37:17.040 --> 37:23.280
Geschichte mit dem in den Buffer reinschreiben, und der andere Thread wird dann beispielsweise

37:23.280 --> 37:28.360
das Aufnehmen in Datei schreiben machen. So, und da bietet sich sowas hier an, jetzt vielleicht

37:28.360 --> 37:33.040
nicht mit so einem Record, wie ich es hier gemacht hab, aber dass man diesen Buffer als

37:33.040 --> 37:42.080
Immutable List macht, der quasi bei jeder Änderung, also der nicht geändert wird, sondern

37:42.080 --> 37:46.600
immer eine neue erzeugt wird, das hat nämlich den großen Vorteil, ich kann einen Snapshot

37:46.600 --> 37:51.640
machen, mit Immutable Sachen kann man immer wunderbar Snapshots machen, also sprich ich

37:51.640 --> 37:58.640
mache einen Snapshot von dem Buffer, übergebe den der Funktion, die meine Aufnahme startet,

37:58.640 --> 38:04.320
währenddessen kann ich in dem anderen Thread weiter einlesen, das was von der Kamera kommt,

38:04.320 --> 38:08.440
aber im Hintergrund habe ich einen Snapshot von dem Buffer, schreibe die 20 Sekunden aus

38:08.440 --> 38:14.000
dem Buffer in der Datei, und dann nehme ich weiter auf und schreibe es hinten dran. Also,

38:14.000 --> 38:18.640
sowas bietet sich zum Beispiel an, dass man eine Immutable List oder sowas nimmt, sprich

38:18.640 --> 38:23.640
eine Liste, wo jedes Mal wenn ich ein Element anhänge oder entferne, eine neue Liste erzeugt

38:23.640 --> 38:28.160
wird, anstatt die bestehende Liste zu verändern, eigentlich den Nachteil ist es ein bisschen

38:28.160 --> 38:33.920
langsamer. Da gibt es natürlich noch andere Varianten, wie man das machen kann, man kann

38:33.920 --> 38:38.480
das ganze auch locken, sprich ich kann auch einfach sagen, ok, während die Aufnahme läuft,

38:38.480 --> 38:42.080
für die erste Sekunde, wie ihr zum Buffer schreiben braucht, locke ich den Buffer und

38:42.080 --> 38:48.360
man darf in der Zwischenzeit nichts reinschreiben. Kann ich auch machen, muss man sich dann unterscheiden,

38:48.360 --> 38:52.120
entscheiden was man dann haben will. Ja, so, jetzt gucken wir uns aber mal das Beispiel

38:52.120 --> 38:58.560
hier genauer an, was die jetzt eigentlich genau getrieben haben. Also, Public Record

38:58.560 --> 39:05.360
Person, Last, das haben wir ja gemacht. So, was das hier macht, soweit ich das sehe, ist

39:05.360 --> 39:10.680
ja ein Constructor, mit dieser neuen, ich habe vergessen wie sie heißt, diese Syntax,

39:10.680 --> 39:18.320
also sprich, anstatt das hier, kann ich auch sowas hier schreiben. Das ist neu, das gibt

39:18.320 --> 39:23.840
es hier, das gibt es glaube ich seit C Sharp 8, die lange Schreibweise davon wäre folgendes,

39:23.840 --> 39:44.880
so, das wäre die lange Schreibweise davon. Was jetzt schöner ist, kann man sich streiten,

39:44.880 --> 39:51.400
ich persönlich finde immer noch das hier ein bisschen lesbare, aber nachdem ich faul

39:51.400 --> 39:55.760
bin, finde ich die Sache hier auch ziemlich gut. Ich weiß nicht, Chat, wie es euch geht,

39:55.760 --> 40:00.160
was ihr da bevorzugt, unter der Haube ist es das gleiche, also es kommt genau das gleiche

40:00.160 --> 40:04.560
bei rum, also sprich, das ist die klassische Constructor Schreibweise und das ist diese

40:04.560 --> 40:14.280
neue, ich habe vergessen wie sie heißt, Expression Member Schreibweise, Expression Body, genau,

40:14.280 --> 40:19.000
der Void-Danny ist ja Big Brain, der kennt sich aus. Genau, also was da schöner ist,

40:19.000 --> 40:23.760
kann man sich, ich weiß nicht, was findet ihr schöner, Chat? Also sprich, jetzt kann

40:23.760 --> 40:27.680
man so machen, ja und das ist glaube ich seit C Sharp 8 oder 7 war das drinnen, dass man

40:27.680 --> 40:32.640
die Sachen so schreiben kann, also sprich, das hier sind die Werte aus dem Constructor,

40:32.640 --> 40:39.480
die man bekommt und das sind die Private, nicht die Private, das sind die Properties,

40:39.480 --> 40:49.920
die wir zugewiesen kriegen, Geschmackssache. Das hier braucht man aber gar nicht mehr,

40:49.920 --> 40:55.560
jetzt verstehe ich, warum es das gibt, genau, weil es gibt seit ein paar C Sharp Versionen

40:55.560 --> 41:00.320
die Möglichkeit sowas hier zu machen, dass man keinen Constructor mehr verwenden muss,

41:00.320 --> 41:09.480
sondern, dass man die Sachen so initialisiert, aber das, jetzt verstehe ich was sie gemacht

41:09.480 --> 41:16.240
haben, aber das funktioniert hier nicht, normalerweise könnte ich hier sowas machen, last name gleich

41:16.240 --> 41:31.840
Max, first name gleich Max, last name gleich Chat, so, das funktioniert aber nicht, weil

41:31.840 --> 41:37.840
ich gesagt habe, die Dinge hier sind read only, wenn ich jetzt sowas hier machen würde,

41:37.840 --> 41:41.880
wenn ich erlauben würde, dass man da was reinschreiben kann, dann funktioniert das ganze wunderbar,

41:41.880 --> 41:45.240
aber das will man ja nicht, man will ja, dass das ganze immutable ist, dass man es nicht

41:45.240 --> 41:49.760
ändern kann, deswegen funktioniert das nicht, und deswegen haben sie jetzt neue Schlüssel,

41:49.760 --> 41:54.240
jetzt habe ich glaube ich zum ersten Mal kapiert, warum sie das gemacht haben, jetzt haben sie

41:54.240 --> 42:05.000
nämlich ein neues Schlüsselwort eingefügt, nämlich init, das können wir alles hier skippen,

42:05.000 --> 42:11.560
wo haben sie es hier, init, jetzt gibt es nämlich noch einen dritten, wie heißt denn das auf

42:11.560 --> 42:18.880
deutsch, Zugriffsbeschränkungsoperator, frag mich nicht, wie das Ding genau heißt, jetzt

42:18.880 --> 42:25.400
kann man nämlich anstatt get set oder sowas wie private set oder so, kann man jetzt init

42:25.400 --> 42:32.600
verwenden, wenn ich init verwende, dann darf ich die Sachen so initialisieren, aber danach

42:32.600 --> 42:38.320
sie auch nie wieder ändern, wenn ich das jetzt richtig verstanden habe, oder? Ja, ok, das

42:38.320 --> 42:44.440
ist eine coole Sache, weil ich muss euch ehrlich sagen, ich verwende mittlerweile fast lieber

42:44.440 --> 42:48.280
das hier zum initialisieren, als wirklich die Sachen im Constructor, wenn es was ist, wo

42:48.280 --> 42:53.380
ein bisschen längere Einträge dazu kommen, zumal ja auch der Vorteil glaube ich relativ

42:53.380 --> 43:00.320
auf der Hand liegt, also wenn ich jetzt eine Klasse habe, mit sagen wir mal irgendwie ganz

43:00.320 --> 43:08.280
vielen, ganz vielen Sachen, mit ganz vielen Datenproperties, dann ist es natürlich viel

43:08.280 --> 43:20.440
einfacher, die so zu initialisieren, als den hier zu machen, mal exemplarisch, what the

43:20.440 --> 43:28.440
fuck, so müsste ich das ja dann machen, wenn ich einen Constructor hätte, der alle meine

43:28.440 --> 43:35.880
Datenproperties initialisieren will, das ist ja hardcore unübersichtlich, deswegen ist

43:35.880 --> 43:45.920
es so eigentlich schöner, dann würde ich so machen, 2, 2, 3, 3, 4, 4, easy, das ist doch

43:45.920 --> 44:01.920
viel besser, das finde ich nett, das hat was, das hat was, das mag ich, so, genau,

44:01.920 --> 44:08.240
so jetzt kann ich aber immer noch eine Klasse anlegen und sie hiermit initialisieren, aber

44:08.240 --> 44:13.000
ich kann danach nichts mehr ändern von dieser Klasse, guckt, wenn ich versucht was zuzuweisen,

44:13.000 --> 44:20.480
bei last name, da sagt er mir, nee, in it only geht nicht, was ist jetzt, wenn ich aber

44:20.480 --> 44:29.480
doch was anlegen möchte, mit den Werten, also wenn ich die Werte ändern will, das ist,

44:29.480 --> 44:35.920
das ist der big brain streamer am Abend heute, so und da kann ich jetzt glaube ich sagen,

44:35.920 --> 44:48.720
reg1 with last name gleich, ah jaja, so und jetzt habe ich folgendes gemacht, ich habe

44:48.720 --> 44:53.440
hier meine Klasse reg1, übrigens ich glaube die haben auch to string überschrieben, dass

44:53.440 --> 44:58.360
man die Sachen ordentlich printen kann, guck mal hier, eigentlich richtig, eigentlich eine

44:58.360 --> 45:03.360
richtig coole Sache, das ist auch was, was mir an den C sharp Entwicklern ganz gut gefällt,

45:03.360 --> 45:07.560
die machen nicht immer so riesen über neue komplizierte Dinger, das sind einfach Sachen

45:07.560 --> 45:17.120
die praktisch sind, so also jetzt habe ich hier reg1 und ich habe reg2 und reg2 ist der

45:17.120 --> 45:28.840
first name, ah jaja und in reg1 hat sich nichts geändert, genau, also sprich ich habe jetzt

45:28.840 --> 45:33.520
einen neuen record angelegt mit den Werten von record 1, also ich habe record 2 angelegt

45:33.520 --> 45:42.680
mit den Werten von record 1 und habe den first name geändert, eigentlich ganz nett, ich glaube

45:42.680 --> 45:48.240
ich werde es erstmal nicht verwenden, weil ich immer eine Weile brauche mit neuen Features,

45:48.240 --> 45:55.120
bis ich die dann natürlich, natürlich quasi einbaue, ich glaube erstmal werde ich da

45:55.120 --> 46:01.240
überhaupt gar nichts mitmachen, vermute ich jetzt einfach mal so, weil ich habe ehrlich

46:01.240 --> 46:08.240
gesagt auch noch gar keine großartige Idee wofür ich das jetzt brauchen würde, so cool

46:08.240 --> 46:14.400
das Feature an sich sein mag, wo würde ich es verwenden, mir fällt spontan nicht so

46:14.400 --> 46:23.920
viel ein ehrlich gesagt, wo würde man es verwenden, was haben die hier für Beispiele,

46:23.920 --> 46:37.560
ja gut das sind so die Standard Beispiele, record dog, record pad, das, ok was schreiben

46:37.560 --> 46:42.560
sonst noch dazu, ja chat hat von euch immer eine Ahnung wofür man das jetzt genau verwenden

46:42.560 --> 46:48.080
würde, also mir fällt jetzt spontan nicht so viel ein gerade, ich glaube das ist so

46:48.080 --> 46:52.280
ein Ding, wenn man es braucht und dran denkt, dann freut man sich, dass man jetzt dran gedacht

46:52.280 --> 46:55.960
hat, wenn man was hat, wo sich es gut für eignet, aber ich kann mir nicht vorstellen,

46:55.960 --> 47:02.680
dass das was ist, was ich täglich mehrfach nehme, choose my name sagt vielleicht, wenn

47:02.680 --> 47:13.240
man irgendwelche API anspricht oder Datenhaltung macht, zum Beispiel JSON Zeugs, vielleicht,

47:13.240 --> 47:20.720
mir fällt da jetzt nicht so viel ein zu, wenn man state halten will und properties, also

47:20.720 --> 47:25.840
in multithreading Sachen stelle ich es mir teilweise ganz praktisch vor, generell sind

47:25.840 --> 47:30.840
immutable Sachen, wenn man multithreading macht, wo man snapshots von verschiedenen

47:30.840 --> 47:51.960
Status braucht, ist das ganz nice, sowas wie der silver dog schreibt, ok hier schreiben

47:51.960 --> 47:58.680
sie auch was ein record type für einen macht, methods for value based equality comparison,

47:58.680 --> 48:02.720
das ist das, was wir gerade gesehen haben, also sprich, dass record 1 gleich gleich record

48:02.720 --> 48:08.560
2 ist, wenn der inhalt gleich ist und nicht die referenz, get hashcode überschreiben,

48:08.560 --> 48:14.680
das braucht man zum Beispiel für dictionaries und sowas, also man kann ja bei jedem Objekt,

48:14.680 --> 48:22.760
hier record 2, get hashcode, man kann ja von jedem Objekt sich quasi mehr oder weniger

48:22.760 --> 48:29.560
hoffentlich unic hashcode generieren lassen, das braucht man zum Beispiel intern verwendendes

48:29.560 --> 48:37.360
dictionaries um die Objekte einzuordnen und sowas, so das haben sie überschreiben, copy

48:37.360 --> 48:53.880
and clone members gibt es, das, das könnte sogar ganz nützlich sein, das könnte sogar

48:53.880 --> 48:58.320
ganz nützlich sein, copy, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie,

48:58.320 --> 49:12.280
wie, wie, wie, wie, wie, wie kann ich die

49:13.220 --> 49:16.940
Die list copy macht okay das muss ich nicht ist copy macht das nicht oder

49:16.940 --> 49:37.320
Ja das ist jetzt die frage legt es jetzt dann jedes mal neue records an oder nicht das

49:37.320 --> 49:38.560
müssen wir mal ausprobieren

49:38.560 --> 49:47.760
Gut UntoString überschreibt es für einen das ist tatsächlich ganz nützlich deswegen

49:47.760 --> 49:53.800
kann man sowas hier machen

49:53.800 --> 49:55.120
deswegen kann man sowas hier machen

49:55.120 --> 50:03.680
Wisst ihr was ich finde das ist sogar fast das nützlichste Feature da dran

50:03.680 --> 50:09.880
dass man es einfach printen kann

50:09.880 --> 50:14.200
So easy das jetzt aussieht und so easy das in anderen sprachen ist so einfach ist das

50:14.200 --> 50:15.480
in C sharp gar nicht

50:15.480 --> 50:19.920
wenn ich eine klasse habe und möchte die die die daten die drin gespeichert sind in so

50:19.920 --> 50:23.880
einem format ausgeben da muss ich jedes mal ToString überschreiben das ist gar nicht

50:23.880 --> 50:24.880
so einfach wie es aussieht

50:24.880 --> 50:35.080
Okay der Chat wollte irgendwas was habe gerade ein kleines RAS programmiert das über Netzwerk

50:35.080 --> 50:42.720
miteinander kommuniziert auf Linux kompil kompilieren kein Ding auf Windows muss man

50:42.720 --> 50:43.720
erst mal 30GB

50:43.720 --> 50:48.720
Ey vieles ist unter Windows was Entwicklungssachen angeht richtig eklig

50:48.720 --> 50:54.240
Da ist dort net mit Visual Studio und so wirklich eine riesen Erholung wobei man dafür ja auch

50:54.240 --> 50:57.280
30GB Visual Studio und SDK und alles installieren muss

50:57.280 --> 51:04.120
Weiter bei GTK unter Windows habe ich mal gemacht ist abfuck hoch 3 oder hoch 10 hoch

51:04.120 --> 51:05.120
100

51:05.120 --> 51:11.840
Also GTK unter Windows ist wirklich abgefuckt da musste erst mal sys msys ne wie heißt

51:11.840 --> 51:12.840
das

51:12.840 --> 51:14.720
msys 2 installieren

51:14.720 --> 51:25.320
Und ähm dann musst du GTK installieren unter msys 2 und dann hast du das Problem dass

51:25.320 --> 51:30.720
die GTK Libraries aus msys 2 mit mingw kompiliert sind wenn du das allerdings mit dem Visual

51:30.720 --> 51:36.920
Studio C++ compiler oder Visual Studio compiler benutzen willst dann geht das nicht total

51:36.920 --> 51:40.200
wie also GTK unter Windows ist echt absolute Zumutung

51:40.200 --> 51:45.560
Äh Silver Dark ja da kommen wir noch zu das habe ich auch schon gelesen dass man kein

51:45.560 --> 51:46.560
Mainmap braucht

51:46.560 --> 51:53.120
Äh also GTK ist absolut keine Konkurrenz gegen Qt und Electron

51:53.120 --> 51:55.520
GTK ist so ein Linux only Ding

51:55.520 --> 52:01.600
Ich muss euch sagen mir gefallen in der Regel die meisten GTK Programme meistens besser

52:01.600 --> 52:06.040
als die KDE Counterparts wenn es einfache Dinger sind

52:06.040 --> 52:09.520
Komplizierte Dinger sind eindeutig die KDE Programme oder die Qt Programme

52:09.520 --> 52:13.400
weil die GTK Programme meistens ultra rudimentär sind

52:13.400 --> 52:17.680
Aber generell sobald es Cross Platform ist bleibt hier nur noch Qt übrig

52:17.680 --> 52:18.680
VLC

52:18.680 --> 52:24.920
Gucken wir mal VLC 1 GUI

52:24.920 --> 52:25.920
Die erste

52:25.920 --> 52:33.000
Das erste VLC GUI ich weiß gar nicht ob es VLC 1.0 war

52:33.000 --> 52:34.400
Die das war noch ein GTK

52:34.400 --> 52:40.640
Das war noch ein GTK Interface

52:40.640 --> 52:45.920
Mittlerweile ist VLC auch Qt einzig und allein aus dem Grund weil sie gesagt haben

52:45.920 --> 52:48.040
GTK Cross Platform ist shit

52:48.040 --> 52:53.120
Wegen Ansela kein Bock mehr drauf

52:53.120 --> 52:56.080
Und ich kann jeden verstehen der keinen Bock hat auf GTK Cross Platform

52:56.080 --> 53:03.240
GTK ist eigentlich so ein Ding was du da musst du schon richtig Hardcore Gnome Fan sein

53:03.240 --> 53:06.520
Weil ich hab mal versucht mit GTK was zu machen

53:06.520 --> 53:10.680
Die sind so Bleeding Edge bei GTK

53:10.680 --> 53:15.640
Dass die quasi bei jeder Gnome Version was umbauen was es inkommatibel zum anderen macht

53:15.640 --> 53:19.320
Und das dann aber auch nicht irgendwie in ihrem Gnome abfacken

53:19.320 --> 53:26.440
Sondern im GTK und deswegen funktioniert ein GTK mit dem anderen Beispiel dann mal richtig

53:26.440 --> 53:29.920
Und sind dann auch nie richtig dokumentiert weil das schon wieder so neu ist

53:29.920 --> 53:36.320
Also GTK ist wirklich abfack was das angeht

53:36.320 --> 53:40.200
GTK unter Windows verwendet ja nicht ohne Grund kein GTK 3

53:40.200 --> 53:43.240
Ich glaub GIMP unter Windows immer noch GTK 2

53:43.240 --> 53:44.240
Oder?

53:44.240 --> 53:45.240
Oh ne

53:45.240 --> 53:50.240
Haben sie es mittlerweile

53:50.240 --> 54:02.560
Ja gut

54:02.560 --> 54:05.200
Ja gut vor ner Woche

54:05.200 --> 54:06.200
Vor ner Woche

54:06.200 --> 54:07.840
GTK 3 gibt es seit 10 Jahren oder so

54:07.840 --> 54:09.800
Haben sie es jetzt schon geschafft

54:09.800 --> 54:10.800
Weirdchamp

54:10.800 --> 54:16.240
Das hat schon seinen Grund warum das nicht funktioniert hat die ganze Zeit

54:16.240 --> 54:24.000
Ok aber zu den Record Types mit ich wie gesagt ich weiß noch nicht so wirklich vor was ich

54:24.000 --> 54:25.000
sie brauche

54:25.000 --> 54:27.240
Aber wenn ich sie brauche find ichs bestimmt cool dass sie da sind

54:27.240 --> 54:32.600
Was ich viel cooler finde ist Init Properties

54:32.600 --> 54:37.600
Also Init Only Setter find ich nice

54:37.600 --> 54:42.840
Ich hab ja schon immer gerne diese Initialisierungs Variante gemocht

54:42.840 --> 54:46.240
Also lieber als alles in Constructor schreiben

54:46.240 --> 54:52.280
Und ich denke mal dass das auch bei normalen Klassen geht oder

54:52.280 --> 54:54.320
Mach mal ne Class draus

54:54.320 --> 54:57.240
Dann geht das hier natürlich nicht mehr

54:57.240 --> 55:01.720
Ja funktioniert auch mit ner normalen Class ok

55:01.720 --> 55:07.760
Warum keine Init Only Getter

55:07.760 --> 55:11.160
Du solltest ne eigene Programmiersprache designen

55:11.160 --> 55:15.000
Ich find Init Only Getter ist ne super Idee

55:15.000 --> 55:21.120
Das sind dann quasi Getter die zur Compile Zeit schon den gleiche also im Prinzip ein

55:21.120 --> 55:22.600
Standard Getter mit Default Value

55:22.600 --> 55:23.880
Ja was auch immer

55:23.880 --> 55:32.520
Darf ich Qt nur eingeschränkt privat nutzen?

55:32.520 --> 55:38.280
Nee also bisher war es so dass jeder Qt verwenden darf

55:38.280 --> 55:40.440
Wie gesagt ich weiß nicht ob das geht hier

55:40.440 --> 55:44.800
Geht um das hier Cross Platform GUI Framework

55:44.800 --> 55:45.800
Wow

55:45.800 --> 55:48.800
Hm MonkaS

55:48.800 --> 55:53.960
Ah das war auch das Falsche oder

55:53.960 --> 55:56.960
Lul

55:56.960 --> 55:58.280
Es geht um dieses Cross Platform Framework

55:58.280 --> 56:03.600
Also bisher war es glaube ich so es darf jeder Qt verwenden

56:03.600 --> 56:07.080
So wie kommerziell als auch privat

56:07.080 --> 56:10.680
Sofern er es nicht statisch linkt

56:10.680 --> 56:12.880
So was wie statisch linken ist ein C++ Ding

56:12.880 --> 56:16.600
Das muss man sich normalerweise in anderen Programmiersprachen heutzutage gar nicht mehr

56:16.600 --> 56:17.600
Großartig mit beschäftigen

56:17.600 --> 56:23.000
Aber es ist C++ da ist sowas noch an der Tagesordnung

56:23.000 --> 56:27.280
Sachen die man 1995 machen musste macht man halt auch 2020 noch in C++

56:27.280 --> 56:28.280
Ja soweit ich weiß ist das so

56:28.280 --> 56:32.520
Wenn man Qt statisch linked braucht man irgendwie ne Lizenz

56:32.520 --> 56:37.440
Und wenn man Qt Libraries ausliefert mit ausliefert und dynamisch linked

56:37.440 --> 56:40.600
Was im Prinzip gar kein Unterschied macht wenn man die Libraries mit ausliefert

56:40.600 --> 56:43.040
Außer dass man sie austauschen könnte was eh keiner macht

56:43.040 --> 56:46.720
Und am Strich kommt es gleich heraus darf man es verwenden wie man will

56:46.720 --> 56:54.880
Nee nee du musst kein Source Code Provide

56:54.880 --> 56:55.880
Nee nee nee

56:55.880 --> 56:58.480
LGPL ist eigentlich eines der besten Sachen die es gibt

56:58.480 --> 57:01.680
LGPL ist du darfst quasi alles

57:01.680 --> 57:08.120
Also LGPL ist Commercial alles

57:08.120 --> 57:11.800
Ich weiß noch nicht mal was LGPL nicht erlaubt

57:11.800 --> 57:22.520
Genauso so ein bisschen wie diese komische BSD Lizenz da

57:22.520 --> 57:23.520
Da darf man auch alles

57:23.520 --> 57:26.240
Mal ne Frage ich mach mal kurz den Chat ein bisschen größer

57:26.240 --> 57:29.760
Mal ne Frage was sollte man in Pricen können

57:29.760 --> 57:32.480
Und wie findet man das am besten was

57:32.480 --> 57:35.400
Und wie findet man da am besten etwas zu

57:35.400 --> 57:37.080
Habe bis jetzt nur Mathe und Plotting gemacht

57:37.080 --> 57:41.560
Ok Mathe und Plotting ist jetzt meistens nicht so das was die Leute als Einstieg in Programmiersprachen

57:41.560 --> 57:42.560
machen

57:42.560 --> 57:46.520
Der Polar Fuchs hat Subscribed

57:46.520 --> 58:03.320
Dankeschön für den Prime Sub

58:03.320 --> 58:05.920
Noch mehr High IQ für den Chat heute das geht aufwärts

58:05.920 --> 58:08.680
Dankeschön

58:08.680 --> 58:19.000
Ja also Kali Rex das ist jetzt sehr vage gestellt diese Frage also die kann man eigentlich

58:19.000 --> 58:21.080
so nicht beantworten

58:21.080 --> 58:26.800
Ich mein was sollte man in Pricen können

58:26.800 --> 58:36.120
Was solltest du keine Ahnung beim Tischfußball spielen können

58:36.120 --> 58:51.280
Also es ist schwer zu sagen also das hängt ganz stark damit ab was du für einen Anspruch

58:51.280 --> 58:54.200
da an dich hast was du können solltest

58:54.200 --> 59:00.520
Und wie man da am besten was herausfindet kann man erst herausfinden wenn man überhaupt

59:00.520 --> 59:02.080
weiß was man machen will

59:02.080 --> 59:07.240
Weil wenn du nicht weißt was du machen willst ist ja auch schwierig was herauszufinden

59:07.240 --> 59:09.000
Also umgedreht geht das ja schlecht

59:09.000 --> 59:35.840
Ich bilde mir auch ein dass das so ist

59:35.840 --> 59:45.120
Das ist das was ich auch so im Kopf habe

59:45.120 --> 59:49.360
Du darfst nicht statisch linken ansonsten ist das alles in Ordnung

59:49.360 --> 01:00:02.080
Daher ist es eigentlich schwer das zu finden wozu ich es brauche

01:00:02.080 --> 01:00:07.760
Also wenn du kein Anwendungswerk hast dann brauchst du es ja auch nicht

01:00:07.760 --> 01:00:12.120
Oder ich verstehe es nicht so wirklich also warte mal anders wenn du mit Pricen anfängst

01:00:12.120 --> 01:00:14.720
du die Standardsachen die man am Anfang so macht

01:00:14.720 --> 01:00:17.760
Das sind so die das sind so eigentlich die Basics die man in jeder Programmiersprache

01:00:17.760 --> 01:00:18.760
macht

01:00:18.760 --> 01:00:23.880
Man guckt sich an so ein bisschen standardmäßig eine Ausgabe sprich wie lese ich Dateien ein

01:00:23.880 --> 01:00:25.320
wie schreibe ich Dateien

01:00:25.320 --> 01:00:31.520
Wie programmiere ich ein paar einfache if else Geschichten wie mache ich mal eine Schleife

01:00:31.520 --> 01:00:35.400
wie lese ich Sachen von der Kommandozeile ein wie gebe ich Sachen auf die Kommandozeile

01:00:35.400 --> 01:00:36.400
aus

01:00:36.400 --> 01:00:39.680
Wie schicke ich ein Webrequest wie lese ich ein Webrequest

01:00:39.680 --> 01:00:44.520
So die Basicsachen die man in jeder Programmiersprache macht aber es ist viel einfacher zu beantworten

01:00:44.520 --> 01:00:47.480
wenn man einen gewissen Anwendungszweck hat wo man was zu machen will

01:00:47.480 --> 01:00:53.920
Anstatt einfach so ins blaue also so ganz ins blaue rein ist ziemlich schwierig zu beantworten

01:00:53.920 --> 01:01:00.280
Und so einfach Pricen aussieht mittlerweile ist das auch ganz gut komplex geworden

01:01:00.280 --> 01:01:03.240
Aber es ist echt hübsch also Pricen ist wirklich entspannend zu programmieren

01:01:03.240 --> 01:01:09.040
Ich finde eines der größten positiven Punkte ist

01:01:09.040 --> 01:01:15.120
Was Pricen angeht dass die eine ziemlich gute komplette Standard Library haben

01:01:15.120 --> 01:01:22.720
Also die haben von einem DNS Client bis zu einem CSV Parser bis zu irgendwelchen abgedrehteren

01:01:22.720 --> 01:01:26.600
Kram bis zu einem HTTP Server die haben eigentlich alles drin

01:01:26.600 --> 01:01:34.760
Deswegen mag ich Pricen auch wenn ich wenig mitmach

01:01:34.760 --> 01:01:37.680
Ok In It Only Setters haben wir uns auch angeguckt

01:01:37.680 --> 01:01:41.640
Also sprich ich glaube das Feature haben wir jetzt abgefackelt halbwegs

01:01:41.640 --> 01:01:42.640
Ich scroll nochmal kurz drüber

01:01:42.640 --> 01:01:46.320
Positional Records

01:01:46.320 --> 01:01:52.400
What the hell ist das eher lang?

01:01:52.400 --> 01:01:57.680
Alter so viele Klammern

01:01:57.680 --> 01:02:02.200
Das ist irgendwelche Vererbungsgeschichten oder so

01:02:02.200 --> 01:02:03.520
Das werde ich eh nie verwenden

01:02:03.520 --> 01:02:13.120
Ja das sind irgendwelche Vererbungs Sachen

01:02:13.120 --> 01:02:22.640
Ah Moment mal das ist cool

01:02:22.640 --> 01:02:32.360
Das ist tatsächlich ganz nice

01:02:32.360 --> 01:02:33.920
Kann ich das hier auch verwenden?

01:02:33.920 --> 01:02:38.520
Das geht wahrscheinlich jetzt nicht ne?

01:02:38.520 --> 01:02:43.240
Moment das muss ich mal ausprobieren

01:02:43.240 --> 01:02:56.040
Nein das geht nicht das geht nur wenn ich das Beispiel von oben verwende was sie hier

01:02:56.040 --> 01:02:57.040
hatten

01:02:57.040 --> 01:03:10.000
Ne Moment dann habe ich es noch nicht gecheckt

01:03:10.000 --> 01:03:36.400
Ok dann habe ich es nicht kapiert was sie mir hier sagen wollen

01:03:36.400 --> 01:04:00.640
Was macht der da anders als ich?

01:04:00.640 --> 01:04:21.520
Ah das ist cool

01:04:21.520 --> 01:04:22.520
Das gefällt mir

01:04:22.520 --> 01:04:24.400
Oh das ist ja mal nice

01:04:24.400 --> 01:04:33.440
Das ist doch mal ein cooles Feature also sprich anstatt diesen Schmodder hier zu schreiben

01:04:33.440 --> 01:04:39.320
die klassische Class Declaration kann ich einfach die Abkürzung benutzen und der macht

01:04:39.320 --> 01:04:41.120
das alles für mich

01:04:41.120 --> 01:04:47.080
Also sprich das hier das hier und das hier ist genau das gleiche

01:04:47.080 --> 01:04:49.080
Ja das ist nice das gefällt mir

01:04:49.080 --> 01:04:51.680
Das ist nice

01:04:51.680 --> 01:04:55.480
Ja das spart auch wirklich tippen

01:04:55.480 --> 01:04:59.640
Ok jetzt habe ich einen Anwendungszweck dafür was ich verwenden würde

01:04:59.640 --> 01:05:05.760
Also sprich wenn ich eine Klasse mache die nur Daten enthält dann würde ich eigentlich

01:05:05.760 --> 01:05:06.760
so machen jetzt

01:05:06.760 --> 01:05:15.520
Der ist neu den gibt es seit 5 Tagen quasi

01:05:15.520 --> 01:05:22.160
Aber dass man quasi das hier schreiben kann und das hier bekommt und das hier generiert

01:05:22.160 --> 01:05:23.480
die auch schon viel unter der Haube

01:05:23.480 --> 01:05:29.520
Ja sie kriegt viele funktionale Features

01:05:29.520 --> 01:05:33.200
So und jetzt guckt mal jetzt kann ich sogar deconstructen

01:05:33.200 --> 01:05:35.640
Ja das ist das ist nice

01:05:35.640 --> 01:05:37.120
Das ist wirklich cool

01:05:37.120 --> 01:05:45.720
Also sprich ich kann jetzt also ich bekomme von irgendwo diesen Rekord mit FirstNameMax

01:05:45.720 --> 01:05:51.440
LastNameLinks und ich kann jetzt den deconstructen in zwei Variablen nämlich First und Last

01:05:51.440 --> 01:05:56.000
und kann ich nennen wie ich will die kann ich auch A und B oder so nennen das ist wurscht

01:05:56.000 --> 01:05:57.920
muss ich wirklich First und Last heißen

01:05:57.920 --> 01:06:10.000
Und jetzt kann ich direkt jetzt kann ich quasi aus diesem Rekordobjekt zwei Variablen erstellen

01:06:10.000 --> 01:06:13.320
Ach nee nicht Moment nicht fest

01:06:13.320 --> 01:06:20.080
Jetzt kann ich quasi zwei Variablen aus diesem Objekt erstellen ohne dass ich da jetzt irgendwie

01:06:20.080 --> 01:06:22.320
großartige Sachen anlegen und zuweisen muss

01:06:22.320 --> 01:06:23.920
Das ist ein cooles Feature das gefällt mir

01:06:23.920 --> 01:06:31.240
Guckt ich habe jetzt quasi dieses Rekordobjekt deconstructed in die Variable First und Last

01:06:31.240 --> 01:06:38.440
und das geht nur das geht nur weil es positional ist weil er weiß das hier ist die also das

01:06:38.440 --> 01:06:40.960
hier steht an erster Stelle das hier steht an zweiter Stelle

01:06:40.960 --> 01:06:48.200
Deswegen kann er deswegen um die Leute zu verwirren kann könnte man auch sowas machen

01:06:48.200 --> 01:06:55.120
das funktioniert genauso nur dass es jetzt umgedreht ist also sprich es ist egal wie

01:06:55.120 --> 01:07:02.360
dieser Kram hier heißt es kann auch A und B heißen wichtig ist die Position wie ich

01:07:02.360 --> 01:07:04.480
es angelegt habe

01:07:04.480 --> 01:07:10.960
Das ist ein cooles Feature ok das hat mich überzeugt

01:07:10.960 --> 01:07:20.080
Das verwende ich Last Name League oh MonkaS

01:07:20.080 --> 01:07:25.080
Das verwende ich

01:07:25.080 --> 01:07:31.360
Übrigens kennt ihr die Big Brain Taktik eine Schleife zu machen die von 1 bis 50 zählt

01:07:31.360 --> 01:07:36.400
also weil die einfache Variante ist das da ok sagen wir mal 0 bis 49 die einfache Variante

01:07:36.400 --> 01:07:37.400
ist das da

01:07:37.400 --> 01:07:43.600
So kriege ich 50 Leerzeilen jeder vor das ist die einfache Variante die Variante die

01:07:43.600 --> 01:07:48.640
glaube ich jeder checkt aber viel Big Brainigere Variante

01:07:48.640 --> 01:08:08.800
Enumerable range 0 bis 50 for each

01:08:08.800 --> 01:08:14.600
nicht dass das wirklich sinnvoll ist aber irgendwie ist es mir gerade zu den Kopf gekommen

01:08:14.600 --> 01:08:20.520
hier also wem einfache Vorschleifen zu einfach sind macht die so

01:08:20.520 --> 01:08:26.960
ja und hier drinnen zählen ist das gleiche

01:08:26.960 --> 01:08:31.240
natürlich wenn man ehrlich ist ist das hier die bessere Variante

01:08:31.240 --> 01:08:35.240
das hat andere Vorteile aber machen wir vielleicht mal anders

01:08:35.240 --> 01:08:44.280
so da gab es ein paar Fragen im Chat wo ich gerade noch was zu sagen wollte

01:08:44.280 --> 01:08:48.440
Was ist denn der große Unterschied zwischen Python und C Sharp habe nicht so viel Knowledge

01:08:48.440 --> 01:08:54.520
im Programmierbereich also das ist was was man einfach beantworten kann oder wirklich

01:08:54.520 --> 01:09:01.360
ausführlich beantworten kann das sind grundsätzlich vom Ansatz her zwei unterschiedliche Sprachen

01:09:01.360 --> 01:09:07.880
Python ist komplett dynamisch also sprich jede Variable kann zu jeder Zeit alles sein

01:09:07.880 --> 01:09:14.920
von einer Zahl zu einem String zu einem JSON Objekt oder sonst was und C Sharp ist statisch

01:09:14.920 --> 01:09:18.440
typisiert das bedeutet ich muss festlegen was welche Variable ist und die kann auch

01:09:18.440 --> 01:09:20.480
ihren Typ da nicht zwischendurch wechseln

01:09:20.480 --> 01:09:24.440
Obwohl ich bin mir gar nicht sicher kann in Python eine Variable ihren Typ wechseln?

01:09:24.440 --> 01:09:25.440
Ja oder?

01:09:25.440 --> 01:09:36.440
Ich glaube das geht

01:09:36.440 --> 01:09:40.480
also die grundsätzliche Unterschiede also den finde ich markantesten Unterschied erstmal

01:09:40.480 --> 01:09:46.080
ist unabhängig von Syntax oder sonst was C Sharp ist statisch typisiert also sprich

01:09:46.080 --> 01:09:52.200
du weißt genau welcher Datentyp in welcher Variable zu jeder Zeit ist zur Kompilzeit

01:09:52.200 --> 01:09:58.440
schon und in Python ist es halt komplett dynamisch das ist übrigens auch der Grund warum Python

01:09:58.440 --> 01:10:04.360
in vielen Bereichen so schnarchlangsam ist Python ist abfuckmäßig langsam wenn es

01:10:04.360 --> 01:10:13.800
um Performance Geschichten geht der hauptsächliche Grund ist dass es dynamisch getyped ist

01:10:13.800 --> 01:10:15.880
es gibt doch hier diesen gRPC Benchmark

01:10:15.880 --> 01:10:24.000
hier ist die Sharp da hatten die doch einen neuen

01:10:24.000 --> 01:10:43.680
wenn ihr mal lachen wollt

01:10:43.680 --> 01:10:49.680
also man sieht die Performance von dynamischen Sprachen ist ein bisschen hinten dran warum

01:10:49.680 --> 01:10:55.560
Swift so langsam ist verstehe ich übrigens nicht

01:10:55.560 --> 01:11:01.000
Swift sollte eigentlich auch halbwegs geschwind sein da ist wahrscheinlich die Implementierung

01:11:01.000 --> 01:11:07.560
kacke was macht gRPC da kannst du von einem da kannst

01:11:07.560 --> 01:11:12.000
du übers Netz da kannst du von einem kleinen übers Netzwerk Funktionen auf dem Server

01:11:12.000 --> 01:11:16.360
aufrufen und dir Antworten schicken lassen und sowas das ist ein Binary Kommunikations

01:11:16.360 --> 01:11:23.720
Protokoll

01:11:23.720 --> 01:11:25.200
also keine Webrequest Binary

01:11:25.200 --> 01:11:32.600
ich meine das

01:11:32.600 --> 01:11:36.400
das Ruby langsam ist ist mir klar und das Python langsam ist mir auch klar warum Swift

01:11:36.400 --> 01:11:37.880
so langsam ist verstehe ich nicht

01:11:37.880 --> 01:11:45.320
PHP ok aber PHP ist auch besser als ein Ruf was Speed angeht dass Node so langsam ist

01:11:45.320 --> 01:11:47.320
wobei so langsam ist

01:11:47.320 --> 01:11:51.720
Node also generell Javascript ist viel schneller als ein Ruf

01:11:51.720 --> 01:11:56.120
Javascript ist mittlerweile extrem schnell

01:11:56.120 --> 01:12:05.000
also diese Geschichte mit von wegen lamen dynamisch interpretiertem Javascript ist schon

01:12:05.000 --> 01:12:06.000
lange nicht mal so

01:12:06.000 --> 01:12:13.800
spätestens seit V8 und Google damit angefangen haben ist da da ist wirklich ich weiß ich

01:12:13.800 --> 01:12:19.240
habe schon oft extrem gesagt letztes Jahr aber extrem viel Big Brain in V8 drinne

01:12:19.240 --> 01:12:22.960
also V8 platzt das Gehirn quasi was die sich da überlegt haben

01:12:22.960 --> 01:12:28.360
die machen so abgedrehte Optimierung Sachen in in Chrome Javascript ist der Wahnsinn

01:12:28.360 --> 01:12:29.360
die haben zum Beispiel

01:12:29.360 --> 01:12:41.320
eine Erkennung drin ob der Wert in einer Schleife quasi überlaufen kann oder nicht

01:12:41.320 --> 01:12:46.160
also sprich wenn du wenn du auf irgendwas zugreift in der Schleife und zählt die Schleife

01:12:46.160 --> 01:12:47.160
hoch

01:12:47.160 --> 01:12:52.040
da haben die quasi irgendwie so eine Logik drinne eingebaut in V8 ob es möglich ist

01:12:52.040 --> 01:12:55.040
dass dieser Wert jemals overflowed

01:12:55.040 --> 01:12:59.360
wenn er overflowed bleibt das langsam weil er muss jedes mal checken ob es overflowed

01:12:59.360 --> 01:13:00.360
ist

01:13:00.360 --> 01:13:07.200
wenn diese diese Black Magic Google Logik quasi feststellt das kann niemals overflowen

01:13:07.200 --> 01:13:11.760
dann kompilieren die quasi im Hintergrund irgendwie so einen so einen Hot Pass Ausführungsding

01:13:11.760 --> 01:13:14.400
für in Node und dann ist es superschnell das ist wirklich

01:13:14.400 --> 01:13:21.360
Exploding Expanding Brain was sie in Javascript machen echt das ist das ist nicht normal

01:13:21.360 --> 01:13:23.040
das verstehen auch Normalsterbliche nicht mehr

01:13:23.040 --> 01:13:33.360
also also warum Swift zu langsam jetzt verstehe ich nicht PAP ok Node hätte ich eigentlich

01:13:33.360 --> 01:13:37.760
auch ein bisschen schneller vorgestellt aber ich bin mir nicht sicher ob in diesem Benchmark

01:13:37.760 --> 01:13:42.240
vielleicht weil es gerade einer im Chat gesagt hat irgendwelche Multithreading Sachen gemacht

01:13:42.240 --> 01:13:43.240
werden

01:13:43.240 --> 01:13:46.200
wenn Multithreading dann ist Node zumindest standardmäßig nicht so nicht so schön

01:13:46.200 --> 01:13:52.520
Lua gut wer sich wirklich geben will kann sich auch Lua geben

01:13:52.520 --> 01:14:00.240
Kotlin Java ich vermute mal Kotlin ist ein bisschen langsamer als Java entweder ist es

01:14:00.240 --> 01:14:05.800
eine eigene neue Implementierung die einfach nicht so performant ist wie hier oder aber

01:14:05.800 --> 01:14:10.100
die Magic die Kotlin angenehm macht im Vergleich zu Java schlägt halt ein bisschen Performance

01:14:10.100 --> 01:14:11.100
mäßig rein

01:14:11.100 --> 01:14:19.840
so Go, Go gRPC ist schnell muss es auch weil Go ist von Google und und na gut gRPC ist

01:14:19.840 --> 01:14:20.840
so halb von Google

01:14:20.840 --> 01:14:29.960
so und was wisst ihr was wirklich nice ist das C++, Go,.NET und Rust ungefähr alle

01:14:29.960 --> 01:14:30.960
gleich schnell sind

01:14:30.960 --> 01:14:38.160
also man sieht man kann mittlerweile auch in.NET ziemlich optimiertes Zeug fabrizieren

01:14:38.160 --> 01:14:47.480
und ich glaube mal dass C++ das Potenzial hätte sogar in der Ecke schneller zu sein

01:14:47.480 --> 01:14:54.520
hier als.NET aber C++ hat auch das Potenzial unnötig hässlich entwicklerfeindlich und

01:14:54.520 --> 01:15:01.400
kompliziert zu sein deswegen kann es durchaus sein dass die gRPC Implementierung in C++

01:15:01.400 --> 01:15:05.400
einfach suboptimal ist im Vergleich zur Implementierung von in.NET

01:15:05.400 --> 01:15:15.080
weil in.NET blickst du durch wenn du was programmierst in C++ eigentlich nicht

01:15:15.080 --> 01:15:16.080
zumindest nicht so gut

01:15:16.080 --> 01:15:31.760
genau gut Rust ist ganz vorne mit dabei also ausweichlich hat C++ hier eindeutig das Potenzial

01:15:31.760 --> 01:15:38.040
auf der gleichen Ebene von Rust zu sein

01:15:38.040 --> 01:15:43.640
aber es hat wahrscheinlich keiner Bock eine neue performantere gRPC Implementierung für

01:15:43.640 --> 01:15:49.240
C++ zu programmieren weil C++ so maßlos sackt und keiner C++ programmieren will

01:15:49.240 --> 01:15:53.040
so und Kirby Musik ist vorbei muss ich wieder anmachen

01:15:53.040 --> 01:16:00.280
gibt es ein schnelleres Minibot als den Raspberry Pi 4

01:16:00.280 --> 01:16:05.680
ja total viele total viele musst du einfach mal suchen danach

01:16:05.680 --> 01:16:12.040
aber ich würde trotzdem nichts anderes nehmen weil die Kombination aus Support, Tutorials,

01:16:12.040 --> 01:16:16.800
Partikel, Boards und generell Community Unterstützung ist einfach durch nichts zu schlagen

01:16:16.800 --> 01:16:21.600
ach da steht Single Threaded Multi Threaded ah ich sehe es hier

01:16:21.600 --> 01:16:32.400
also C++ Multi Threaded ist genauso gut wie Go Multi Threaded ohne MT und.NET Multi Threaded

01:16:32.400 --> 01:16:36.800
es ist nicht alles Single Threaded Multi Threaded manches ist auch unbekannt Threaded

01:16:36.800 --> 01:16:42.840
ja zumindest worauf ich eigentlich raus wollte jetzt mit dieser ganzen Performance mit ganzen

01:16:42.840 --> 01:16:46.600
Performance Vergleich

01:16:46.600 --> 01:16:51.560
und Ruby Ruby auch in vielen Bereichen wobei Ruby jetzt mit der nächsten Ruby Version

01:16:51.560 --> 01:16:56.400
einen dicken Performance Boost kriegt ich hoffe dass Ruby dadurch wieder ein bisschen

01:16:56.400 --> 01:17:02.040
beliebter wird weil persönlich bei mir gibt es zwei Sprachen die ich am liebsten benutze

01:17:02.040 --> 01:17:07.440
das ist C Sharp und Ruby Ruby genau leider kann man Ruby nicht mal so gut verwenden in

01:17:07.440 --> 01:17:17.800
letzter Zeit Rails ist komplett gefallen ne wie sagt man da so komplett aus der Mode

01:17:17.800 --> 01:17:25.880
gekommen genau und so normales Scripting Zeug macht jetzt eigentlich fast jeder irgendwie

01:17:25.880 --> 01:17:26.880
in Preisen

01:17:26.880 --> 01:17:31.560
schon mal mit Crystal gearbeitet ja habe ich mir vor Jahren mal angeguckt das größte

01:17:31.560 --> 01:17:35.600
Problem was ich bei Crystal hatte ist dass sie so halb kompatibel zu Ruby sind aber

01:17:35.600 --> 01:17:42.640
nicht richtig und dass sie nicht unter Winnows funktionieren

01:17:42.640 --> 01:17:43.640
vielleicht ist mittlerweile alles anders

01:17:43.640 --> 01:17:50.840
du hast keine Ideen was du programmieren könntest

01:17:50.840 --> 01:17:52.320
das ist natürlich ein Problem

01:17:52.320 --> 01:17:56.080
was hältst du von Webseiten

01:17:56.080 --> 01:18:00.600
ich finde Webseiten immer am schönsten zu machen zum Einstieg weil dann sieht man was

01:18:00.600 --> 01:18:01.600
das passiert

01:18:01.600 --> 01:18:03.960
weil du kannst ja dann Python Backend machen

01:18:03.960 --> 01:18:07.360
oder schwierig zu sein

01:18:07.360 --> 01:18:15.360
spielen wir das neue Cod ich habe es noch nicht mal installiert ich will unbedingt die Kampagne

01:18:15.360 --> 01:18:17.400
spielen vielleicht spiele ich sogar im Stream

01:18:17.400 --> 01:18:23.280
ich habe es doch Hissi habe ich gerade beantwortet es gibt total viele Boards die schneller sind

01:18:23.280 --> 01:18:24.720
als der Raspberry Pi 4

01:18:24.720 --> 01:18:29.080
aber ich würde trotzdem keines empfehlen weil die von Support und Community Unterstützung

01:18:29.080 --> 01:18:34.200
und Tutorials und Software die einfach läuft und Hardware Erweiterungen so einfach nicht

01:18:34.200 --> 01:18:35.200
so gut sind

01:18:35.200 --> 01:18:39.120
und meistens ist der Raspberry Pi 4 ja nicht irgendwie der limitierende Faktor bei dem

01:18:39.120 --> 01:18:40.120
was man machen will

01:18:40.120 --> 01:18:46.920
was haben sie hier sonst noch GAPC Benchmarks bla

01:18:46.920 --> 01:18:50.960
ja und Python ist halt manchmal echt krass langsam so wie man hier sieht

01:18:50.960 --> 01:18:54.120
und das liegt um jetzt mal auf die ursprüngliche Frage zurück zu kommen was der große Unterschied

01:18:54.120 --> 01:18:55.120
zwischen.NET

01:18:55.120 --> 01:19:00.120
und C-Sharp und Python ist das liegt zum größten Teil daran dass Python dynamisch ist

01:19:00.120 --> 01:19:06.920
du kannst einfach den Ablauf von einem Programm viel schlechter optimisieren wenn du nicht

01:19:06.920 --> 01:19:07.920
weißt

01:19:07.920 --> 01:19:12.200
was für einen Datentyp und also quasi wie viel Speicher ja letztendlich

01:19:12.200 --> 01:19:19.560
eine gewisse Variable zu welchem Zeit benötigt das ist einfach kacke zu optimieren

01:19:19.560 --> 01:19:32.440
also dass das Python dynamisch ist ist der größte Vor- und Nachteil an der ganzen Sache

01:19:32.440 --> 01:19:38.200
das ist schön elegant und das ist schon einfach zu programmieren und auch sehr prägnant

01:19:38.200 --> 01:19:43.120
und aussagekräftig aber es ist halt optimierbar nur in Grenzen

01:19:43.120 --> 01:19:47.520
ja und ob kompiliert oder interpretiert würde ich jetzt gar nicht mal in der heutigen Zeit

01:19:47.520 --> 01:19:55.520
mal so hoch einschätzen weil viele Sachen haben da so einen hybriden Modus also sogar

01:19:55.520 --> 01:20:00.880
in JavaScript ist es ja mittlerweile auch so JavaScript in V8 wird ja auch nicht rein

01:20:00.880 --> 01:20:05.640
interpretiert da wird ja auch dann viele Sachen werden dann wenn sie gecheckt wurden quasi

01:20:05.640 --> 01:20:11.720
kompiliert dass es dann recht optimierten Code gibt also vieles ist so hybridmäßig

01:20:11.720 --> 01:20:15.480
man kann heute gar nicht mehr sagen hey das ist rein interpretiert und das ist rein ahead

01:20:15.480 --> 01:20:24.480
of time kompiliert das ist oft mal so ein Ding und beispielsweise ist es in.NET ähnlich

01:20:24.480 --> 01:20:31.160
bei.NET würde nie jemand sagen das ist eine interpretierte Sprache in.NET ist es so wenn

01:20:31.160 --> 01:20:37.400
du ein Programm startest dann haben die noch keinen für deine Plattform optimierten Code

01:20:37.400 --> 01:20:43.440
erzeugt das heißt dann läuft das ganze erstmal ein bisschen langsamer nicht wirklich interpretiert

01:20:43.440 --> 01:20:52.960
aber quasi in so einem Art Bytecode Interpreter ist das läuft das dann und sobald du deswegen

01:20:52.960 --> 01:20:58.280
ist es in C-Sharp auch oder in.NET auch oft so wenn du zumindest war das bisher so wenn

01:20:58.280 --> 01:21:03.920
du eine Methode zweimal aufrufst ist sie beim zweiten mal viel schneller ja das gucken wir

01:21:03.920 --> 01:21:17.920
uns gleich an mit Main und so da sieht man das ist also fließend was da zwischen interpretieren

01:21:17.920 --> 01:21:23.840
kompilieren Bytecode4M und so da tricksten heute viele Sprachen rum und es gibt ja auch

01:21:23.840 --> 01:21:29.040
schon ein paar ahead of time Compiler für Python die machen Python aber auch nicht zu

01:21:29.040 --> 01:21:38.440
einer ultra schnellen Sprache es gibt so ein paar Versuche habe ich letztens gesehen zum

01:21:38.440 --> 01:21:46.040
Beispiel jemand der hat einen Python Compiler gebastelt und aber mit der Beschränkung dass

01:21:46.040 --> 01:21:50.560
man manche Features nicht verwenden darf man darf quasi nur so ein Subset von Python verwenden

01:21:50.560 --> 01:21:54.840
das ist dann schön schnell ja ich bin mal auf die nächste Ruby Version gespannt weil

01:21:54.840 --> 01:21:58.480
die nächste Ruby Version soll angeblich irgendwie zehnmal schneller sein oder so da bin ich

01:21:58.480 --> 01:22:01.880
mal gespannt vielleicht also wenn Ruby es schaffen würde hier auf dieser Ebene irgendwie

01:22:01.880 --> 01:22:08.680
zu landen wäre schon huge ja und in.NET haben sie halt die letzten die letzten Versionen

01:22:08.680 --> 01:22:18.440
über ziemlich viel eingeführt was der Performance zugute kommt zum Beispiel was sind wir da

01:22:18.440 --> 01:22:22.760
mal also diese ganze Task Geschichte ist ja ist ja schon alt zum Beispiel ihr ganzes

01:22:22.760 --> 01:22:29.360
Memory Management früher war das ja so du hast für alles und jeden hast du irgendwelche

01:22:29.360 --> 01:22:34.440
Objekte erzeugt in C Sharp oder in.NET die dann garbage collected werden müssen so und

01:22:34.440 --> 01:22:41.200
was ganz ganz eklig war in.NET ist wenn du sowas hier machen musstest also sagen wir

01:22:41.200 --> 01:22:50.320
jetzt mal wir machen jetzt mal eine Liste Liste int oder Array komm wir machen Array

01:22:50.320 --> 01:22:57.960
mit Array geht das mit Liste geht das gar nicht also du hast ein Array sagen wir das

01:22:57.960 --> 01:23:08.600
sind jetzt irgendwie 20.000 Elemente drin so und jetzt willst du dieses Array verarbeiten

01:23:08.600 --> 01:23:18.960
an unterschiedlichen Stellen in deinem Programm unterschiedliche Abschnitte das ist gar nicht

01:23:18.960 --> 01:23:26.280
so einfach gewesen wenn du das alles übersichtlich untereinander machst dann kannst du natürlich

01:23:26.280 --> 01:23:32.680
da irgendwie zig vorschleifen bauen die dann wussten wo die andere gerade ist und sowas

01:23:32.680 --> 01:23:37.440
das hat funktioniert da haben wir jetzt aber gesagt ok solche Low Level Sachen müssen

01:23:37.440 --> 01:23:43.680
wir anders handhaben und deswegen haben sie jetzt sowas hier gemacht das ist quasi eine

01:23:43.680 --> 01:23:51.120
Abstraction für Speicher Zugriff vorbei vielleicht soll ich eher auf Byte machen also sprich

01:23:51.120 --> 01:23:58.960
wenn ich auf Speicher zugreife und das Splitten will und an unterschiedlichen Stellen verarbeiten

01:23:58.960 --> 01:24:03.920
möchte dann kann ich das damit machen und ich kann da quasi da neue Slices erzeugen

01:24:03.920 --> 01:24:08.360
neue Abschnitte von diesem Array an unterschiedliche Teile übergeben an unterschiedlichen Teilen

01:24:08.360 --> 01:24:15.560
bearbeiten und unten drunter ist das im Prinzip immer noch das gleiche Array also sprich ich

01:24:15.560 --> 01:24:20.520
muss hier nichts kopieren ich muss hier nichts neu anlegen an Speicher ich greife unter der

01:24:20.520 --> 01:24:26.320
Haube immer noch auf das gleiche Array zu was natürlich irgendwelche Parser oder Sachen

01:24:26.320 --> 01:24:34.640
die halt Multithreaded Byte Buffer Zeug verarbeiten viel viel schneller macht so das ist so ein

01:24:34.640 --> 01:24:38.760
Feature was er eingeführt im C-Shop was echt Performance geboostet hat das nächste was

01:24:38.760 --> 01:24:51.720
sie eingeführt haben ist dass wenn du Multithreaded wenn du Sachen Multithreaded machst dass du

01:24:51.720 --> 01:24:56.840
gibt es dafür nicht auch GetRange kann schon sein ich weiß es ehrlich gesagt nicht ob

01:24:56.840 --> 01:25:04.120
es sowas wie GetRange gibt GetRange nein das erzeugt eine neue Liste das ist genau das

01:25:04.120 --> 01:25:09.640
was ich meine das erzeugt eine neue Liste mit Referenz auf die Elemente aus der alten

01:25:09.640 --> 01:25:17.720
Liste das heißt du musst jedes mal wenn du das benutzt eine neue Liste erzeugen mit Referenzen

01:25:17.720 --> 01:25:23.440
auf die alten Elemente was natürlich wenn du das keine Ahnung 30 Millionen mal pro

01:25:23.440 --> 01:25:28.560
Sekunde machst oder so auch für den Garbage Collector nervig wird wenn er den ganzen Kram

01:25:28.560 --> 01:25:35.240
aufräumen muss und sie haben selbst gesagt ich muss euch ehrlich sagen ich verwende

01:25:35.240 --> 01:25:39.240
diese Span Geschichte auch relativ selten wo ich es verwendet habe ist zum Beispiel

01:25:39.240 --> 01:25:47.520
bei meinem FFmpeg Video Einlese Zeug für den Buffer den man wiederbekommt von den Unmanaged

01:25:47.520 --> 01:25:52.400
Buffer von FFmpeg mit dem komprimierten Video dafür verwende ich es an einer Stelle ansonsten

01:25:52.400 --> 01:25:56.960
verwende ich es auch relativ selten aber sie haben gesagt dass sie beispielsweise ihre

01:25:56.960 --> 01:26:01.640
Web Request bei ASP.NET Core um ein Vielfaches beschleunigen konnten dadurch dass sie Span

01:26:01.640 --> 01:26:07.840
verwendet haben so noch eine Sache die sie eingebaut haben ist was in den letzten Jahren

01:26:07.840 --> 01:26:14.680
wirklich viel Performance Boost gebracht hat bei NC Sharp ist du hattest bisher immer so

01:26:14.680 --> 01:26:18.800
ein bisschen das Problem wenn du Multithreading gemacht hast NC Sharp du hast einen neuen

01:26:18.800 --> 01:26:24.800
Task aufgemacht ein neuer Task ist ja NC Sharp eine Abstraktion zu einem Thread du weißt

01:26:24.800 --> 01:26:31.280
nicht genau ob es ein eigener Thread ist oder nicht in der Regel läuft der Task in einem

01:26:31.280 --> 01:26:37.480
eigenen Thread Pool also sprich wenn ein Task fertig ist dann gibt er den Thread zurück

01:26:37.480 --> 01:26:40.640
in den Pool und wenn ein neuer Task anfängt kann er sich den wieder rausnehmen und der

01:26:40.640 --> 01:26:44.600
Standard Thread Pool hat keine Ahnung ich weiß es nicht ich sag jetzt einfach mal 500

01:26:44.600 --> 01:26:48.440
offene Threads ich hab ehrlich gesagt kein Plassen Schimmer wie groß der Standard Thread

01:26:48.440 --> 01:26:53.360
Pool ist das hat den Vorteil man muss nicht immer neue Threads erstellen und so ja so

01:26:53.360 --> 01:26:59.400
aber du weißt das nicht so genau so und eine Sache ist jetzt wenn du Sachen programmiert

01:26:59.400 --> 01:27:08.760
hast die asynchron laufen in Task zum Beispiel NC Sharp dann musstest du ja als Rückgabe

01:27:08.760 --> 01:27:19.800
von so machen wir mal irgendwie hier was Static, Void, Static, Task, Blob und wenn jetzt hier

01:27:19.800 --> 01:27:31.920
irgendwas machst was ein Task erzeugt so hier kann ein Return, Task, Run so wenn ich das

01:27:31.920 --> 01:27:37.880
hier jetzt aufrufe diese Methode Blob die gibt mir den Task zurück und dieser Task läuft

01:27:37.880 --> 01:27:51.520
ein Asynchron es sei denn ich warte drauf also zum Beispiel kann ich dann hier sagen

01:27:51.520 --> 01:27:59.440
Wait Blob was das jetzt macht ist Blob erzeugt einen Task der Asynchron läuft und ich warte

01:27:59.440 --> 01:28:04.400
hier bis der Task vorbei ist also was heißt ich warte nicht warten ist das falsche Wort

01:28:04.400 --> 01:28:08.160
ich springe quasi aus der Methode raus und wenn das fertig ist mache ich dann an der

01:28:08.160 --> 01:28:16.640
Stelle weiter so was das Problem ist wenn ich das 20 wenn ich das fünf Millionen mal

01:28:16.640 --> 01:28:26.440
mache keine Ahnung alle paar Sekunden dann ja Async, Void jetzt fangen sie wieder alle

01:28:26.440 --> 01:28:32.160
an ne in dem Fall ist Async, Void ok hier ist Async, Void vollkommen ok weil ich await

01:28:32.160 --> 01:28:47.360
ja den Task was willst du sonst machen ja mach da mach da by await das kann ich gleich

01:28:47.360 --> 01:28:52.120
auch nochmal erzählen so zumindest wenn man das jetzt wenn man das jetzt irgendwie 100.000

01:28:52.120 --> 01:28:57.680
mal die Sekunde macht das erzeugt ganz schön viel Overhead vor allem wenn man sich mal

01:28:57.680 --> 01:29:03.920
überlegt wenn ich was habe was ich 50.000 mal 100.000 mal die Sekunde mache was ich

01:29:03.920 --> 01:29:11.080
Asynchron machen möchte in einem extra Task dann ist halt eh die Frage wie Asynchron das

01:29:11.080 --> 01:29:17.640
ist weil das muss ja verdammt schnell fertig sein sonst wird sich ja nicht lohnen das 50.000

01:29:17.640 --> 01:29:21.800
mal pro Sekunde zu machen deswegen haben die jetzt was neues eingeführt und zwar Value

01:29:21.800 --> 01:29:26.480
Task ich werde aber einfach nur erwähnen dass es das gibt Value Task ist quasi ein

01:29:26.480 --> 01:29:39.080
Rapper um Task der den Fall optimiert dass der Task instant schon fertig ist also sprich

01:29:39.080 --> 01:29:44.600
wenn ich was habe was ich sau oft mache pro Sekunde und ich würde dafür jedes mal einen

01:29:44.600 --> 01:29:54.360
neuen Task erzeugen aber das Ergebnis was ich mit diesem Task berechnen will ist so schnell

01:29:54.360 --> 01:30:02.360
meistens zumindest so schnell da dass es quasi Synchron ist da kann ich das mit Value Task

01:30:02.360 --> 01:30:08.760
machen weil der optimiert diesen Fall dass ich Sachen quasi so fake Asynchron mache

01:30:08.760 --> 01:30:14.920
obwohl sie eigentlich Synchron sind und dann muss der auch keine 30 Billiarden Sachen erstellen

01:30:14.920 --> 01:30:20.360
pro Sekunde so und das ist auch eine Sache wo sie viel Performance optimieren konnten

01:30:20.360 --> 01:30:27.560
in dotnet so dann haben wir jetzt hier noch eine Frage von springt er bei Await wieder

01:30:27.560 --> 01:30:33.240
in die Methode ja Await ist eigentlich viel einfacher als es auf den ersten Blick also

01:30:33.240 --> 01:30:38.600
umgedreht Await hört sich Await hört sich erstmal einfach an wenn man sich damit beschäftigt

01:30:38.600 --> 01:30:43.280
stellt man fest fuck das ist doch gar nicht so einfach und wenn man sich dann ein bisschen

01:30:43.280 --> 01:30:50.000
damit beschäftigt dann stellt man fest dass es viel einfacher ist wenn man sich so vorstellt

01:30:50.000 --> 01:30:55.200
also dieses Konstrukt gibt es nicht in C-Sharp aber das ist im Prinzip das was ein Await

01:30:55.200 --> 01:31:10.440
macht ein Await ist ein Return ein Await ist ein Return mit einem Callback wenn es weitergeht

01:31:10.440 --> 01:31:18.080
also ein Return beendet die Methode ja komplett so und ein Await also es wäre eigentlich

01:31:18.080 --> 01:31:23.720
fast aussagekräftiger man würde Return Await schreiben aber es ist halt in dem Fall nur

01:31:23.720 --> 01:31:28.320
Await was dann Await macht ist folgendes also sagen wir mal so ich ruf jetzt diese Sache

01:31:28.320 --> 01:31:34.840
hier dreimal auf und danach sage ich dann irgendwie fertig wir machen jetzt mal Task

01:31:34.840 --> 01:31:43.240
Run Big Brain Code machen wir jetzt Threadsleep 100 Threadsleep 1000 also ich weiß ich mache

01:31:43.240 --> 01:31:50.760
noch einen Task der ne Sekunde wartet und jetzt rufen wir das Ganze mal auf achso äh

01:31:50.760 --> 01:32:00.560
Moment jetzt muss ich danach warten äh Moment äh Task ne äh äh erst mal ah stimmt das

01:32:00.560 --> 01:32:07.840
geht jetzt ja ne nicht was hab ich verkehrt gemacht achso ha das kann ich jetzt nicht

01:32:07.840 --> 01:32:14.480
erwarten doch wuppi du hast vollkommen recht das funktioniert ja so nicht keck weh jetzt

01:32:14.480 --> 01:32:19.400
beendet er sich nämlich ja äh fuck wie mach ich das jetzt wie zeige ich das jetzt am besten

01:32:19.400 --> 01:32:25.520
Console Readline dann beendet er sich nicht ja du hast recht in dem Fall ist es tatsächlich

01:32:25.520 --> 01:32:31.960
blöd gewesen ja ähm so ich hätte dir wirklich Task zurückgeben sollen ja jetzt weil jetzt

01:32:31.960 --> 01:32:38.840
kann ich jetzt auch erwarten wuppi und ich hab noch gesagt ist okay und gleich kommt

01:32:38.840 --> 01:32:52.080
bäm ist nicht okay so also was der hier macht ist jetzt vielleicht soll ich hier noch was

01:32:52.080 --> 01:32:58.680
dazwischen ausgeben also so das ist das ist äh quasi das erste mal wenn er rausspringt

01:32:58.680 --> 01:33:01.960
das ist das zweite mal wenn er rausspringt und das ist das dritte mal wenn er rausspringt

01:33:01.960 --> 01:33:18.440
so was der macht ist folgendes eins zwei drei also wenn der hier Test aufruft geht er erst

01:33:18.440 --> 01:33:23.600
mal hin blub so blub startet ne neuen Thread ne neuen Task der ne Sekunde wartet also im

01:33:23.600 --> 01:33:29.320
Prinzip block das quasi ne Sekunde wenn man es so will so was der jetzt hier an der Stelle

01:33:29.320 --> 01:33:35.480
bei dem Await macht ist wenn der hier das Await sieht dann startet er das und geht wieder

01:33:35.480 --> 01:33:39.680
raus hier mal hier mal warte ich jetzt auch also sprich an der Stelle passiert nichts

01:33:39.680 --> 01:33:55.080
der returned und er bekommt ne Callback wenn blub fertig ist und wenn blub fertig ist macht

01:33:55.080 --> 01:34:17.520
er hier weiter im Prinzip ist Await blub exakt das gleiche wie das hier

01:34:17.520 --> 01:34:21.000
aber man sieht schon wie eklig das jetzt wird ne man sieht man sieht man sieht schon man

01:34:21.000 --> 01:34:32.800
sieht schon wie eklig das jetzt wird ne Moment ich machs ja sogar falsch also man siehts

01:34:32.800 --> 01:34:36.920
glaube ich schon man siehts glaube ich schon dass es dass es eklig wird mit der Zeit ne

01:34:36.920 --> 01:34:42.640
das ist nämlich fast schon ein Java Callback ich kann es aber nicht mal richtig schreiben

01:34:42.640 --> 01:34:53.120
also das hier ist das gleiche wie wenn ich das mit Await mache

01:34:53.120 --> 01:34:57.760
also der führt blub aus wenn blub fertig ist macht führt er das hier aus wenn blub

01:34:57.760 --> 01:35:02.760
hier fertig ist führt er das hier aus das ist genau das gleiche wie wenn ich so schreibe

01:35:02.760 --> 01:35:08.960
also ja der returned immer an der Stelle bekommt ne Callback wenn das fertig ist und macht

01:35:08.960 --> 01:35:16.560
dann das hier weiter intern wenn man sich das ich hab jetzt ehrlich gesagt keine Ahnung

01:35:16.560 --> 01:35:27.040
ob Ryder nen D-Compiler dabei hat da sieht man das auch schön der hat dann ein riesig

01:35:27.040 --> 01:35:32.400
langes Switch Statement wo er sich den Statement beim rein und rausspringen und wozu braucht

01:35:32.400 --> 01:35:39.160
man da einen Tags der Arbeit doch von oben nach unten das sieht so aus der arbeitet von

01:35:39.160 --> 01:35:44.600
oben nach unten aber es ist insofern asynchron mal angenommen du hättest jetzt ne grafische

01:35:44.600 --> 01:35:49.720
Oberfläche ne grafische Oberfläche mit nem Knopf so und wenn du den Knopf drückst dann

01:35:49.720 --> 01:35:58.320
würde hier dann würde der hier Test aufrufen und Test macht jetzt nicht das hier Test macht

01:35:58.320 --> 01:36:04.400
nicht das hier sondern Test macht mal einfach mal ganz hardcoded sleep 50.000 so was jetzt

01:36:04.400 --> 01:36:11.560
passieren würde in deiner grafischen Oberfläche ist das GUI würde 5 Sekunden hängen und wäre

01:36:11.560 --> 01:36:16.160
absolut unresponsive und Windows würde wahrscheinlich sagen die Anwendung reagiert nicht wollen

01:36:16.160 --> 01:36:24.520
sie die Anwendung beenden so nicht so mit Await weil Await plockt nicht der arbeitet

01:36:24.520 --> 01:36:30.560
zwar von oben nach unten ab aber nicht indem er hier wartet deswegen ist Await ist schwierig

01:36:30.560 --> 01:36:36.840
das Wort ja der wartet hier nicht der plockt nicht an der Stelle der geht raus aus der

01:36:36.840 --> 01:36:43.080
Methode und du machst hier oben weiter jetzt nicht das kann man ohne GUI schlecht schlecht

01:36:43.080 --> 01:36:48.240
demonstrieren mir fällt jetzt auch kein gutes Beispiel dazu ein du hast den Vorteil in nem

01:36:48.240 --> 01:36:57.160
GUI dass hier das return zu dem thread der aufruft deswegen return Await verfasst verfasst

01:36:57.160 --> 01:37:12.680
irgendwie prägnanter

01:37:12.680 --> 01:37:25.640
ich überleg gerade ob ihr ein gutes gutes Beispiel einfällt

01:37:25.640 --> 01:37:29.880
ja ok wir machen wir machen mal eins also alter die Musik

01:37:29.880 --> 01:37:43.720
so wir machen mal was so wir machen jetzt hier oben mal nen wir tun jetzt mal als hätten

01:37:43.720 --> 01:37:52.760
wir nen UI Task nen GUI Task der irgendwas macht der macht nun der macht ne Endlosschleife

01:37:52.760 --> 01:38:00.760
wo nix passiert außer dass er die Schleife einmal pro Sekunde durchläuft und da ruf

01:38:00.760 --> 01:38:10.360
ich jetzt hier unten Test auf ich sollte vielleicht noch ne Ausgabe machen 1 2 3 so und was man

01:38:10.360 --> 01:38:25.120
jetzt hier schön sieht ist so was man jetzt hier schön sieht ist das ist ja gut hier kommt

01:38:25.120 --> 01:38:29.440
fertig dazwischen ne das ist jetzt do also was man hier sieht ist er müsste er müsste

01:38:29.440 --> 01:38:35.120
ja eigentlich müsste der hier drei Sekunden plocken macht er aber nicht ich nehm mal kurz

01:38:35.120 --> 01:38:41.840
die ne mal kurz hier die dinger hier raus ne also von der Idee her müsste der jetzt

01:38:41.840 --> 01:38:49.080
drei Sekunden plocken nach meinem 1 2 3 aber das 1 2 3 kommt einmal in der Sekunde Sekunde

01:38:49.080 --> 01:38:54.280
Sekunde Sekunde aber eigentlich müsste der ja plocken weil ich ruf hier dreimal ne Methode

01:38:54.280 --> 01:39:00.440
auf die die ne Sekunde dauert aber der plockt nicht der ruft das auf der führt das hier

01:39:00.440 --> 01:39:04.600
zwar in der richtigen Reihenfolge aus aber jedes mal wenn er auf nen Await trifft macht

01:39:04.600 --> 01:39:15.920
den Return zurück an den Task also sprich der ruft Test auf der sieht nen Await und

01:39:15.920 --> 01:39:23.880
Returned so dann irgendwann kriegt der hier nen Callback Plop ist fertig dann springt

01:39:23.880 --> 01:39:32.640
er hier rein und macht weiter Returned wieder kriegt wieder nen Callback macht weiter also

01:39:32.640 --> 01:39:37.320
sprich das ganze ist asynchron ohne dass man sich großartig drum kümmern muss das macht

01:39:37.320 --> 01:39:43.160
finde ich aber auch dementsprechend komplex weil es schwierig ist durchzusteigen wann

01:39:43.160 --> 01:39:46.920
er was an welcher Stelle macht und ich benutze das jetzt schon eine Weile und ich muss euch

01:39:46.920 --> 01:39:51.160
ehrlich sagen ich tu mir manchmal auch schwer warum manche Ergebnisse rauskommen so wie

01:39:51.160 --> 01:39:55.240
sie rauskommen also das ist nicht so easy wie man sich wie es auf den ersten Blick vielleicht

01:39:55.240 --> 01:40:03.640
aussieht aber wenn man sich den Await als Return vorstellt ist das eigentlich einfacher

01:40:03.640 --> 01:40:10.560
finde ich als also wenn man sich als Return Await vorstellt ist es einfacher so hätten

01:40:10.560 --> 01:40:19.960
wir jetzt ist hier ein D-Compiler dabei in also der der beste Anwendungsfall den man sich

01:40:19.960 --> 01:40:23.280
vorstellen kann wo man auch sofort sieht dass es was bringt ist wenn man sich vorstellt

01:40:23.280 --> 01:40:28.560
man hat eine grafische Oberfläche man klickt einen Knopf und man möchte was machen was

01:40:28.560 --> 01:40:35.660
fünf Sekunden dauert wenn man den Knopf drückt wenn man das einfach so macht dann hängt

01:40:35.660 --> 01:40:42.720
das GUI fünf Sekunden wenn man das in einem eigenen Task macht dann hängt das GUI nicht

01:40:42.720 --> 01:40:46.620
dann hast du allerdings das Problem dass du dann die Reihenfolge nicht mehr richtig hin

01:40:46.620 --> 01:40:52.400
bekommst und das ist halt mit Await einfacher weil im Prinzip kannst du mit Await den Code

01:40:52.400 --> 01:41:00.760
schreiben wie du ihn synchron schreiben würdest also von oben nach unten aber jedes mal hier

01:41:00.760 --> 01:41:08.240
blockt er nicht sondern Return eins oben drüber ist halt ein bisschen Eingewöhnungssache

01:41:08.240 --> 01:41:16.240
aber mittlerweile ist fast alles was es so im.NET Framework gibt Async aber GUI ist

01:41:16.240 --> 01:41:23.080
auch das beste Beispiel für zum Beispiel noch ein anderes Beispiel wäre zum Beispiel

01:41:23.080 --> 01:41:28.840
du hast irgendeinen Webrequest du hast irgendeinen Webrequest und du willst halt nicht dass der

01:41:28.840 --> 01:41:45.040
Webrequest zehn Sekunden hängt bei dein eigener Task reicht aber mit dem GUI lässt

01:41:45.040 --> 01:41:51.720
ich glaube ich am besten am besten erklären so weiß jemand ob Rider einen D-Compiler dabei

01:41:51.720 --> 01:42:06.440
hat hat Rider einen Explore und Decode Assembly da kann ich euch das nämlich zeigen was der mit

01:42:06.440 --> 01:42:15.320
dem Await macht ich habe keine Ahnung wie das funktioniert habe ich noch nie gemacht wenn man

01:42:15.320 --> 01:42:19.800
das nämlich dekompiliert was.NET hier draus macht ist das immer noch ziemlich lesbar und

01:42:19.800 --> 01:42:37.080
man sieht was aus dem Await wird mit Rider irgendwas dekompilieren keine Ahnung kann man das?

01:42:37.080 --> 01:42:47.680
Ah das ja ja ok das ist gut das ist richtig gut das habe ich schon in ein paar Streams gesehen ok

01:42:47.680 --> 01:42:51.320
das machen wir jetzt mal also wir machen jetzt hier Task plupp wir kopieren uns jetzt mal den

01:42:51.320 --> 01:43:09.800
Kram rein Using System Threading glaube ich ne wo ist wo ist Task drinnen? Weiß das gar nicht

01:43:09.800 --> 01:43:17.960
ich lasse das immer so wo ist dann Task drinnen? Using System Threading Task ist es glaube ich

01:43:17.960 --> 01:43:40.280
und was hat er hier für Schmerzen? Ich hab das noch nie verwendet geht das? Public Class C Await M ok dann machen wir das so, pluppieren wir das nämlich hier rein

01:43:40.280 --> 01:44:04.680
Public kann das auch für mich formatieren Using System Threading Task und threading genau da kann man sich nämlich schön angucken was der da draus macht so und jetzt noch die Methode die das ganze aufruft

01:44:10.880 --> 01:44:11.380
naja

01:44:16.880 --> 01:44:24.360
ok hier sieht man es guckt es sieht übelst wie aus aber das ist was Await unter der Haube macht

01:44:24.360 --> 01:44:33.000
so hier ist das ist jetzt halt IL Code was rauskommt also sprich das zwischenkompilierte

01:44:33.000 --> 01:44:41.520
ding von von C-Sharp wo sind wir jetzt ok void main ist egal task test gut das hier ist meine

01:44:41.520 --> 01:44:49.560
meine testmethode hier und das hier ist plupp plupp ist relativ easy plupp sieht dekompiliert

01:44:49.560 --> 01:44:59.160
ungefähr so aus wie plupp im source code also so so ungefähr nicht so viel unterschied man

01:44:59.160 --> 01:45:06.240
erkennt es immer noch so aber hier wirds jetzt hier wirds jetzt interessanter man sieht hier

01:45:06.240 --> 01:45:12.720
oben schon dieses async state machine und das sieht jetzt schon ein bisschen anders aus das ist nämlich

01:45:12.720 --> 01:45:21.760
die hier mit das ist die Methode also sprich Await plupp Print 1 Await plupp Print 2 Await plupp Print 2 fertig so und man sieht irgendwie

01:45:21.760 --> 01:45:30.640
sieht diese Methode und diese so komplett anders aus warum weil der diese Methode quasi in einer

01:45:30.640 --> 01:45:38.200
extra class wrapped und das ist die logik von Async und Await was hier oben reinkommt

01:45:38.200 --> 01:45:49.280
also das hier ist quasi dies das ist diese klasse die regeneriert aus diesem also das hier ist mein

01:45:49.280 --> 01:45:55.160
Async Await code wird das hier draus gemacht so und hier sieht man auch schon so ein bisschen die logik was

01:45:55.160 --> 01:45:59.360
passiert da muss ich das jetzt gar nicht so sehr im detailer gucken 100 prozent alles kann ich euch

01:45:59.360 --> 01:46:05.960
davon auch nicht erklären er hat zumindest eine neue klasse generiert die Async state machine

01:46:05.960 --> 01:46:12.440
implementiert so und move next das ist quasi so der iterator den er hier aufruft also sprich

01:46:12.440 --> 01:46:20.840
ich rufe test auf er legt eine neue state machine an nach dinger die ich jetzt auch nicht alle

01:46:20.840 --> 01:46:29.600
erklären kann zumindest der erste das erste Await sieht man hier wo ist mein erstes Await

01:46:29.600 --> 01:46:43.360
wo ist Print Result Moment wo ist mein console write line siehts ihr mal wo ist mein console

01:46:43.360 --> 01:47:01.480
write line eins wo ist es hier ist mein console write line eins hier ist irgendwo mein console

01:47:01.480 --> 01:47:13.280
write line zwei genau da geht hier rein in dieses switch und wenn der dann das ist ganz eklig

01:47:13.280 --> 01:47:21.200
gebaut auch mit mit go tos und sonst was also sprich der geht in dieses switch rein und return

01:47:21.200 --> 01:47:28.000
zwischendurch oder macht der irgendwelche go tos und sonst was also man sieht zwischendrin

01:47:28.000 --> 01:47:35.360
immer der geht wieder raus also der der beendet die methode wirklich stimmt wo kann man auf dark

01:47:35.360 --> 01:47:55.560
stellen o f mein zeug ist weg top warum ist mein zeug weg super toll ne zumindest ich hoffe man hat

01:47:55.560 --> 01:48:02.040
es jetzt ein bisschen besser besser verstanden also sprich der macht gar nicht wirklich das hier

01:48:02.040 --> 01:48:05.880
nacheinander sondern der macht jedes mal einen return wenn hier ein Await kommt wenn es noch nicht

01:48:05.880 --> 01:48:10.800
fertig ist und dann springt er wieder zurück rein es ist es ist ein bisschen komplizierter was was

01:48:10.800 --> 01:48:20.000
man aber daran schön sieht ist dass Async Await reine compiler magic ist. Async Await ist nichts

01:48:20.000 --> 01:48:26.800
was jetzt großartig da runtime wobei mittlerweile wahrscheinlich schon ich kann es euch nicht

01:48:26.800 --> 01:48:33.640
genau sagen was da großartig runtime mäßig unterstützt werden muss sondern das ist reine

01:48:33.640 --> 01:48:49.680
compiler magic Async Await. Await hast du ja ja allerdings return das zu dem thread oben drüber

01:48:49.680 --> 01:48:58.800
den es nicht gibt also das ist ja hier schon main also das ist ja schon der main thread

01:48:58.800 --> 01:49:08.480
da kann er nicht mehr weitermachen hätte ich da jetzt noch mal was drüber was aus dem anderen

01:49:08.480 --> 01:49:13.360
task aufruft dann wird er da return aber hier muss er ja warten bis fertig ist weil hier will

01:49:13.360 --> 01:49:17.120
ich ja vielleicht auch das ergebnis verwenden danach weil hier muss er sich ja dran halten an

01:49:17.120 --> 01:49:23.280
die reinfolge ja wir könnten sonst jetzt ich weiß nicht kann man das hier komplett rein kopieren

01:49:23.280 --> 01:49:31.200
ne das funktioniert nicht oder stimmt das kann auch kein csharp 6 das kann auch kein csharp 6

01:49:31.200 --> 01:49:49.480
neun dotnet fünf csharp neun so ja siehst du aus dieser müll kommt aus dem ganzen Async Await

01:49:49.480 --> 01:50:07.720
hinten raus return state machine builder task ist ganz interessant aber ganz ehrlich man muss

01:50:07.720 --> 01:50:13.600
es nicht übertreiben das ist ja gerade auch eines der vorteile von csharp dass es gut verständlich

01:50:13.600 --> 01:50:21.600
ist ohne dass man sich die details jetzt so extrem anguckt zumindest was man sich bei Await

01:50:21.600 --> 01:50:28.400
einfach merken kann ist dass ein Await im prinzip ein return Await ist also eigentlich ist es so

01:50:28.400 --> 01:50:39.800
was hier wir haben übrigens auch immer nicht weiter gemacht mit dotnet 5 csharp 9 ok gab's

01:50:39.800 --> 01:50:52.000
irgendwelche anderen sachen ich weiß es ehrlich gesagt nicht wie go to naja intern wenn die

01:50:52.000 --> 01:50:55.560
irgendwelche compiler magic machen und das verhalten klar abgegrenzt ist was passiert

01:50:55.560 --> 01:51:01.160
warum kein go to das wäre auch ohne go to eklig hab schon mal gefragt aber was hältst du von

01:51:01.160 --> 01:51:12.200
co-routines in kotlin ich habe mit kotlin noch nie was gemacht ich bin quasi kotlin jungfrau

01:51:12.200 --> 01:51:27.560
das ist kirby multithreading ist immer verwirrend ja korrekt könnte man keepers mit zwei faktor

01:51:27.560 --> 01:51:37.920
erweitern weiß das jemand keine ahnung wie gesagt also wollte ich ich habe es dir zu gut

01:51:37.920 --> 01:51:44.360
erklärt wie ich konnte ich hoffe man hat man hat es halblich verstanden oder gut machen wir

01:51:44.360 --> 01:51:51.040
weiter also positionen rekords ja jetzt machen wir dieses ganze async-await zeug mal wieder weg

01:51:51.040 --> 01:51:54.760
um mal zu der eigentlichen sache zu kommen die wir heute ausbringen das hier finde ich ein

01:51:54.760 --> 01:52:04.080
richtig nice feature positionen rekords was sagt er mir überhaupt make class sealed ja stimmt also

01:52:04.080 --> 01:52:09.760
positionen rekords finde ich poggers ich kann eine ganz kurze prägnante sache schreiben ohne

01:52:09.760 --> 01:52:17.560
hier zigtausend sachen zu implementieren und rauskommt eine klasse die ich einfach als daten

01:52:17.560 --> 01:52:27.280
container verwenden kann finde ich nice der immutable klasse wohlgemerkt gut machen wir mal weiter also

01:52:27.280 --> 01:52:34.560
das haben wir uns angeguckt in it in it only setter haben wir uns auch angeguckt top level

01:52:34.560 --> 01:52:40.560
statements jetzt kommt was für die python fans unter uns so muss man es jetzt machen

01:52:40.560 --> 01:52:55.360
und man kann jetzt main top level machen das ist jetzt in valid C sharp programm

01:52:55.360 --> 01:53:10.920
das funktioniert wie ihr seht ich sage doch das was für unsere python fans das

01:53:10.920 --> 01:53:20.520
ist jetzt in valid C sharp programm allerdings unter der haube wir können uns das ganze mal

01:53:20.520 --> 01:53:26.160
in diesem schapland aber schapland ist doch nicht dort net 5 aber es ist doch kein dotnet

01:53:26.160 --> 01:53:51.160
5 kam in dotnet standard irgendwie umstellen geht das aber doch exzellent das macht der

01:53:51.160 --> 01:53:58.160
C sharp compiler aus dem da also der macht ein ganz normales internal static class program

01:53:58.160 --> 01:54:05.760
private static void main hello world raus also im prinzip wird das hier durch compiler magic

01:54:05.760 --> 01:54:33.280
nur transferiert in ja so was da aber das wie gesagt das wird unsere python fans freuen

01:54:33.280 --> 01:54:43.720
bei way was man nicht machen kann ist mehrere top level methods zu haben dann weiß er nämlich

01:54:43.720 --> 01:54:52.320
nicht was davon main ist also wenn ich jetzt glaube ich neu noch eine zweite datei oder

01:54:52.320 --> 01:54:59.760
so anlege ich habe ich in dem webkasten das geht nicht wobei das hier finde ich persönlich

01:54:59.760 --> 01:55:11.280
ziemlich cool also man kann jetzt hier ganz normal dass die scharpe zeug machen das cw

01:55:11.280 --> 01:55:22.200
lull die frage ist das kann ich erwarten ich kann sogar das ist ein erstes main das

01:55:22.200 --> 01:55:30.800
ist doch mal was also für schnelle sachen ausprobieren ist das doch sehr nice das ist

01:55:30.800 --> 01:55:37.560
jetzt well it's the sharp ohne ohne ganz viel boilerplate drumrum ziemlich cool kleine

01:55:37.560 --> 01:55:44.320
änderung man sieht eigentlich nur compiler magic also reine compiler magic da ist nix

01:55:44.320 --> 01:55:55.200
runtime support aber aber coole sachen das sieht so ungewohnt sauber aus

01:55:55.200 --> 01:56:19.200
aus jetzt mal eins für alle funktioniert gut ich glaube die katze ist an der tür

01:39:38.140 --> 01:56:52.640
jetzt legt sie sich auf den schrank bei mir und schläft gleich ja dann macht

01:56:52.640 --> 01:57:00.440
das mal cico hast du dir eine neue katze geholt die habe ich jetzt schon über ein jahr bei

01:57:00.440 --> 01:57:11.960
die cico ja genau übrigens übrigens katze heißt cico was meint ihr ob es ist weibchen

01:57:11.960 --> 01:57:25.040
oder männlein cico also ich kann sagen es ist es ist ein grill es ist ein grill aber

01:57:25.040 --> 01:57:30.000
sie heißt cico was irgendwie nicht so passt weil er müsste nicht eigentlich cica heißen

01:57:30.000 --> 01:57:35.120
trans kender genau kenne kanzler soll jetzt auch cico kommt mich nicht so bös an den

01:57:35.120 --> 01:57:43.640
bist du nicht alles gut alles ist gut guck nicht so bös meine katze ist beleidigt ja

01:57:43.640 --> 01:57:58.320
genau ich habe assumed das hat sehr hat sehr aufgeregt ok so machen wir weiter also was

01:57:58.320 --> 01:58:02.880
haben wir hier als nächstes noch schönes top level sicherprogramm also das passt alles

01:58:02.880 --> 01:58:05.600
das haben wir uns anguckt da gibt es glaube ich nicht so viel dazu zu sagen ich kann jetzt

01:58:05.600 --> 01:58:16.000
mal die tür wieder zumachen weil die katze hat sich auf den schrank gelegt

01:58:16.000 --> 01:58:35.960
so nicht jetzt gerade auf dem schrank ob ich das bild das bild hier nicht drin so

01:58:35.960 --> 01:59:04.040
legt sie gerade auf den schrank mich an ja ok schauen wir mal weiter moment man kann

01:59:04.040 --> 01:59:16.800
jetzt komplett one liner machen ist das los den guck mal cute chat ajaja das ist gültiges

01:59:16.800 --> 01:59:34.960
die schaap jetzt einfach eine zeile ich sag doch die pyson fans freuen sich jetzt genau

01:59:34.960 --> 01:59:38.960
only one file in die application may use top level statement also das heißt wenn ich jetzt

01:59:38.960 --> 01:59:44.160
eine zweite datei anlege und auch so was reinschreibe probieren wir das mal aus was er dann macht

01:59:44.160 --> 02:00:00.760
dann sagt er wahrscheinlich geht nicht omega lull

02:00:00.760 --> 02:00:07.200
wieso ja weil er unter der haube da wieder eine ganz normale meinmethode draus macht

02:00:07.200 --> 02:00:22.080
eigentlich tibet das ist reine compiler magic reine compiler magic so also was was gibt es

02:00:22.080 --> 02:00:29.000
sonst noch neues das ist ein feature das ist jetzt für das da explodiert der kopf leute

02:00:29.000 --> 02:00:36.120
ich sag es euch der platzt bei diesem feature das kapiert nämlich auch nicht richtig das

02:00:36.120 --> 02:00:47.520
ist total abgedreht was man als machen kann pattern matching enhancements also pattern

02:00:47.520 --> 02:00:55.040
matching vielleicht ein bisschen mal ein bisschen was zu zeigen ist das wie in rust es ist mittlerweile

02:00:55.040 --> 02:01:01.320
ähnlicher als ähnlicher wie in rust als vorher also zum beispiel so die einfachste pattern

02:01:01.320 --> 02:01:06.320
matching geschichte kann man in dem if machen so was machen wir da für schönes beispiel

02:01:06.320 --> 02:01:24.840
ok wir machen jetzt hier war gleich eins ich kann jetzt zum beispiel mit gucken if

02:01:24.840 --> 02:01:38.840
das ist jetzt bescheuertes beispiel der zeit ist int das ist jetzt natürlich doof weil

02:01:38.840 --> 02:01:44.520
ich habe hier oben ja selbst belegt das sagt ja auch es ist es ist es ist es ist es ist

02:01:44.520 --> 02:01:51.280
always true oder so und das ist jetzt neue genau also ich kann sagen ist int und wenn

02:01:51.280 --> 02:01:59.720
int ist wenn int wenn wenn i ein int ist dann schreiben wir den wert in b das ist jetzt

02:01:59.720 --> 02:02:04.200
natürlich ziemlich sinnlos in dem beispiel was ich hier gezeigt habe so es wird es wird

02:02:04.200 --> 02:02:15.960
noch advanceder es wird advanceder wenn wir einen switch draus machen switch so jetzt

02:02:15.960 --> 02:02:19.160
kann man natürlich nicht jetzt kann man natürlich nicht cases generieren wenn wir machen wir

02:02:19.160 --> 02:02:26.640
einen int draus ich glaube da kann man das besser zeigen so lul so emotes emotes emotes

02:02:26.640 --> 02:02:44.040
int emotes ayaya monkaS lulw kekw so das reicht jetzt als beispiel switch emotes nee quatsch

02:02:44.040 --> 02:02:57.560
ich muss ja erst mal was an deswegen im neuen top level verwirrt mich mega emotes ob geht

02:02:57.560 --> 02:03:25.920
das nicht was ist happening was hat etwas okay das verstehe nicht warum geht das nicht

02:03:25.920 --> 02:03:53.640
ob geht das nicht public ich glaube der compiler ist nicht magic genug ja ich glaube der compiler

02:03:53.640 --> 02:04:09.400
ist echt nicht magic genug top level status must precede precede namespace and type declarations

02:04:09.400 --> 02:04:14.760
ah ich kann keine neuen sachen anlegen okay da muss ich das so rum machen meinetwegen

02:04:14.760 --> 02:04:22.640
so rum ist auch okay so ist auch okay so general switch labels so das ist das ist die klassische

02:04:22.640 --> 02:04:29.720
art zu checken was denn beispielsweise gerade also wenn ich die und also mal angenommen

02:04:29.720 --> 02:04:36.560
ich hätte eine methode und ich kann unterschiedliche werte haben so da kann ich das quasi so die

02:04:36.560 --> 02:04:42.360
klassische art zu checken okay ist das ist es ayaya ist es monkaS ist es lulw ist es

02:04:42.360 --> 02:04:48.800
kekw oder so was in der richtung so die neue syntax ist jetzt quasi so was in der richtung

02:04:48.800 --> 02:04:54.880
was jetzt schwierig zu zeigen ist ehrlich gesagt ihr macht immer anders wir machen

02:04:54.880 --> 02:05:01.320
objekt objekt draus kann jetzt ja alles sein potenziell ja wenn ich das da als obje reinkriege

02:05:01.320 --> 02:05:09.760
so das kann ich zum beispiel sagen okay das war value beste beste name aller zeiten das

02:05:09.760 --> 02:05:22.160
kann ich mal sagen case value ist emotes oh fuck wie geht es weiter ich bin dazu low

02:05:22.160 --> 02:05:32.680
brain für wie immer deshalb schreiben value ist emotes where ne when ach du große kacke

02:05:32.680 --> 02:05:53.440
emotes weh wenn weh ich krieg es nicht gebacken ich verwende das nicht so oft ich verwende

02:05:53.440 --> 02:06:07.760
sich oft genug warum sollte man das tun warum man das tun soll ist um zu prüfen was das

02:06:07.760 --> 02:06:11.600
für ein objekt ist zum beispiel also mal angenommen ist das könnte den ins sein das

02:06:11.600 --> 02:06:18.200
könnte den enum sein das könnte den string sein oder sonst was also ich kann zum beispiel

02:06:18.200 --> 02:06:29.920
sagen if case ach nee im moment ist case ist so kann ich glaube ich mache oder ist string

02:06:29.920 --> 02:06:45.440
b ging das so ich bin zu low brain dafür wie ging das denn jetzt nochmal ok beispiel gucken

02:06:45.440 --> 02:06:57.440
funktioniert das nicht wie sql synthax nee was du meinst ist link alter hör mal auf

02:06:57.440 --> 02:07:02.840
ich will euch erstmal das alte zeigen bevor wir jetzt komplett mein mein plot switch pattern

02:07:02.840 --> 02:07:20.440
matching c sharp ja genau so wie sind sie so wie sind sie schon acht war case apple man

02:07:20.440 --> 02:07:27.320
braucht das ist gar nicht ok das heißt ich kann jetzt überprüfen ist es ein string ich

02:07:27.320 --> 02:07:33.480
kann jetzt überprüfen ist das ein emotes in am zum beispiel und so was ok ok genauso

02:07:33.480 --> 02:07:40.120
war das so und dann kann ich noch sagen ok wenn value den string man ist ja objekt es

02:07:40.120 --> 02:07:47.120
könnte ja alles sein so wenn es wenn es ein string ist dann kann ich sagen wenn string

02:07:47.120 --> 02:07:57.960
dann wenn string contains a ja ja und dann gebe ich 123 aus warum ist das warum ist das

02:07:57.960 --> 02:08:07.520
jetzt warum ist das denn hier jetzt eigentlich grau remove unreachable code der weil der

02:08:07.520 --> 02:08:14.240
weiß weil value der weiß weil value ist nie ist nie string der ist writer ist zu writer

02:08:14.240 --> 02:08:27.200
ist zu big brain dafür writer ist zu schlau gut dann machen wir das jetzt anders public

02:08:27.200 --> 02:08:43.000
void test objekt oh so ist gut jetzt jetzt ist writer nicht mehr jetzt ist writer dumm

02:08:43.000 --> 02:08:47.520
jetzt kann writer das nicht mehr so also ich habe eine methode wo ich ein objekt reingeworfen

02:08:47.520 --> 02:08:52.880
bekomme so jetzt kann ich überprüfen ok ist das objekt ein string und wenn es ein string

02:08:52.880 --> 02:08:59.840
ist dann gucke ich auch ob es a ja ja enthält so dann kann ich noch gucken ok ist es ein

02:08:59.840 --> 02:09:08.160
emote wenn es ein emote ist dann will ich gucken ob es gleich monka es ist so das ist so das

02:09:08.160 --> 02:09:25.660
ist so ich habe sechs added

02:09:25.660 --> 02:09:33.020
gibt es in C Sharp kein Object Slicing, ich weiß nicht, was du mit Object Slicing meinst.

02:09:33.020 --> 02:09:43.620
Es gibt sowohl Slices über Arbeitsspeicher, also über Memory, es gibt Slices über Arrays,

02:09:43.620 --> 02:09:49.740
es gibt Range Operator für Arrays, das ist übrigens auch ein super neues Feature, ein

02:09:49.740 --> 02:09:53.380
tolles neues Feature von C Sharp 8 gewesen, was kaum jemand verwendet.

02:09:53.380 --> 02:10:07.840
Also wenn ich hier eine Liste habe, wenn ich jetzt eine Liste habe und ich möchte von

02:10:07.840 --> 02:10:15.380
dieser Liste das erste bis zum fünften Element rausholen, dann kann ich sowas hier machen.

02:10:15.380 --> 02:10:31.900
Int B, naja, das ist neu seit C Sharp 8 glaube, das ist eigentlich richtig cool und total

02:10:31.900 --> 02:10:32.900
underrated.

02:10:32.900 --> 02:10:39.540
In Ruby und Python verwendet das jeder, aber diese Range Operators ist in C Sharp total

02:10:39.540 --> 02:10:48.500
wenig verbreitet, man kann sogar sagen, ich möchte von eins bis zum Ende, da kenne ich

02:10:48.500 --> 02:10:53.700
diese, da genau, ich glaube, ich bin mir nicht ganz sicher, ich möchte vom ersten Element

02:10:53.700 --> 02:10:59.500
bis eins vors Ende und solche Dinger, oder war es der Raute, nee es war glaube ich das,

02:10:59.500 --> 02:11:06.540
also sprich das ist jetzt vom, oder vom Anfang, ach nee genau, das kann man auch weglassen,

02:11:06.540 --> 02:11:13.060
aber das sieht mega kryptisch aus, das sagt, ich möchte vom Anfang der Liste bis zum vorletzten

02:11:13.060 --> 02:11:14.060
Element alles haben.

02:11:14.060 --> 02:11:23.460
Ich finde es ziemlich nice, aber total underrated in C Sharp.

02:11:23.460 --> 02:11:26.820
Ok, kommen wir mal zu diesem Pattern-Matching-Gedöns zurück.

02:11:26.820 --> 02:11:36.580
So, was man natürlich auch machen kann ist zu sagen, ok, ich will da noch gucken, Case

02:11:36.580 --> 02:11:44.140
ist Null, ich glaube, das ging so, oder nee einfach nur Null, so und was jetzt neu ist,

02:11:44.140 --> 02:11:51.180
weil ich jetzt gesehen habe, was neu ist, ich kann sagen, Not Null geht auch, hier sitzt

02:11:51.180 --> 02:12:03.380
ja aber auf dem, ja ist, so, also das ist jetzt neu, dass man checken kann, ob es Not

02:12:03.380 --> 02:12:09.660
Null ist, so ok, das war jetzt schon Big Brain Pattern-Matching, ach das kann man übrigens

02:12:09.660 --> 02:12:19.940
noch beliebig, beliebig weiter treiben, man kann glaube ich jetzt sogar checken, wir legen

02:12:19.940 --> 02:12:28.140
nochmal so einen Rekord-Typ an, den wir vorher auch hatten, man kann jetzt sogar checken,

02:12:28.140 --> 02:12:51.140
if ist das Person, so und jetzt kommt neue Big Brain Magic, alter Break, jetzt kann ich

02:12:51.140 --> 02:12:58.140
mal gucken, ob das Person ist Max, so und das matcht jetzt nur, wenn es eine Person ist und

02:12:58.140 --> 02:13:04.420
nur, wenn First Name Max ist, so und mit diesem, mit dieser Sorte Pattern-Matching kannst du

02:13:04.420 --> 02:13:19.380
die abgrundtief hässlichsten, kompliziertesten Konstrukte aller Zeiten bauen, da platzt euch

02:13:19.380 --> 02:13:30.660
der Kopf und ich glaube, da kann man auch weitermachen, when, nee, geht nicht weiter,

02:13:30.660 --> 02:13:43.740
aber kann man end, aber man kann sagen, end, geht das, nee das geht nicht, ok und das,

02:13:43.740 --> 02:13:50.460
es wird noch viel abgedreht, also ich hab da Beispiele gesehen, wo die checken quasi,

02:13:50.460 --> 02:13:57.540
es ist größer, es ist kleiner, es ist gleich, so und man kann quasi hier drinnen auch nochmal

02:13:57.540 --> 02:14:03.220
switchen, wir gucken uns, wir gucken uns mal die Beispiele an, also das ist jetzt wirklich

02:14:03.220 --> 02:14:07.940
nur an der Oberfläche gekratzt, was man damit machen kann, das ist das eindeutig, das Big

02:14:07.940 --> 02:14:13.700
Nächste Feature von C sharp 9, so also das ist so der Klassiker, jetzt haben wir ja gerade

02:14:13.700 --> 02:14:18.860
gemacht, gucken ob das ein Apple ist, ok, seit C sharp 7 geht das, ja das haben wir

02:14:18.860 --> 02:14:27.820
gerade gemacht, Moment, das ist das falsche Dokument, so also jetzt kann man neues Pattern-Matching

02:14:27.820 --> 02:14:38.700
machen, Type Patterns, Match a variable is a type, das machen wir hier, String, Klammer,

02:14:38.700 --> 02:14:45.900
Patterns, Presence of Pattern Combination, Conjunction, End Patterns, All Patterns, Not

02:14:45.900 --> 02:14:58.780
Patterns, Relational Pattern, ok was auch immer, so dann kann man jetzt solche Dinger machen,

02:14:58.780 --> 02:15:09.460
is letter, ach du große Scheiße, is letter C, also das ist wieder so eine, das ist eine

02:15:09.460 --> 02:15:15.300
Methode mit Expression Body Dings, also im Prinzip könnte man das auch mit Klammern

02:15:15.300 --> 02:15:19.700
schreiben, aber die haben sich gedacht, ey jetzt übertreiben wir das richtig, jetzt

02:15:19.700 --> 02:15:27.020
schreiben wir das nicht mit Klammern, jetzt schreiben wir das auch komplett so, Moment,

02:15:27.020 --> 02:15:38.420
ist das eine Extension Method oder was, this Char, das ist eine Extension Method oder, deswegen

02:15:38.420 --> 02:15:45.860
muss Static sein, Phoenix, das ist eine Extension Method, du hast weil du gerade gefragt hast

02:15:45.860 --> 02:15:52.700
hier, das ist eine Extension Method, bloß eine echt big brainste Schreibweise von einer

02:15:52.700 --> 02:15:56.300
Extension Method aller Zeiten, also nochmal zur Erklärung, das ist auch ein, finde ich

02:15:56.300 --> 02:16:02.420
ein ziemlich underrated, das ist die Sharp Feature und zwar, ich versuche euch das mal

02:16:02.420 --> 02:16:07.180
zu zeigen, ich glaube das geht hier schlicht und ergreifend nicht drinnen, ich glaube

02:16:07.180 --> 02:16:14.860
das kann man hier gar nicht, das darf man hier gar nicht drinnen machen, ok, ok, ich

02:16:14.860 --> 02:16:23.500
zeige euch das mal, und zwar, wenn ihr hier ein Character anlegt, dann habt ihr ein gewisses

02:16:23.500 --> 02:16:30.540
Set an Methoden für diesen Character, was ist, also Char ist ja eine eingebaute Klasse

02:16:30.540 --> 02:16:34.700
in.NET oder in C-Sharp, also sprich, die könnt ihr nicht einfach ändern, aber ihr

02:16:34.700 --> 02:16:42.100
könnt die erweitern, nämlich mit einer Extension Method und zwar, machen wir mal hier Public

02:16:42.100 --> 02:16:49.660
Class Extensions, ich hoffe das darf man hier überhaupt jetzt so machen, moment, übrigens

02:16:49.660 --> 02:16:53.700
so schon mal gar nicht, Extensions und dann machen wir das hier rein und dann darf man

02:16:53.700 --> 02:17:07.220
das auch nicht, Moment, was, ah Static, Static, jetzt gehts, so und jetzt werdet ihr feststellen,

02:17:07.220 --> 02:17:15.660
wenn ich jetzt auf A gehe, gibts da auf einmal Is Letter, obwohl das ein eingebauter Typ

02:17:15.660 --> 02:17:22.380
in.NET ist, habe ich den gerade erweitert und das macht man mit einer Extension Method,

02:17:22.380 --> 02:17:27.820
übrigens das komplette Link sind Extension Methods, also das hier, das hier sind alles

02:17:27.820 --> 02:17:33.020
Extension Methods, es ist nicht so, dass Array diesen ganzen Scheiß implementiert, List

02:17:33.020 --> 02:17:36.660
diesen ganzen Scheiß implementiert, Dictionary diesen ganzen Scheiß implementiert, das sind

02:17:36.660 --> 02:17:42.220
Extension Methods, ohne dass man den Typ an sich verändern muss, sprich, ich habe jetzt

02:17:42.220 --> 02:17:48.660
eine Extension Method für den Datentyp Char programmiert und this ist einfach nur bei

02:17:48.660 --> 02:17:57.220
Extension Methods, der, die Syntax, das damit das aktuelle Objekt gemeint ist, also sprich,

02:17:57.220 --> 02:18:01.140
hier wird quasi die aktuelle Instanz, wo ich drauf arbeite, reingeschoben, dass die

02:18:01.140 --> 02:18:06.460
Methode damit arbeiten kann, Extension Methods ist auch ein ziemlich underratedes Ding, was

02:18:06.460 --> 02:18:12.780
nicht so oft verwendet wird, was aber richtig praktisch ist, das ist übrigens auch eine

02:18:12.780 --> 02:18:18.540
der Sachen, die ich extrem vermisse in C++, gerade in C++ wäre es richtig cool, wenn

02:18:18.540 --> 02:18:25.700
man eingebaute Datentypen erweitern könnte, zum Beispiel ist die C++ String Klasse, die

02:18:25.700 --> 02:18:32.300
Standard String Klasse, unglaublich scheiße, die ist, die hat keine Ahnung von jeglichen

02:18:32.300 --> 02:18:37.420
Unicode Sachen, gut C++ sollte sagen, müssen sie auch nicht, es ist ja im Prinzip nur ein

02:18:37.420 --> 02:18:44.580
schöneres Byte Array, die hat keinerlei guten Methoden, also sprich, es gibt noch nicht

02:18:44.580 --> 02:18:50.600
mal to upper to lower und so was in C++ und hätte man in C++ Extension Methods, könnte

02:18:50.600 --> 02:18:55.220
man das wunderbar machen, hat man nicht, nee, nee, das muss nicht Extensions heißen, das

02:18:55.220 --> 02:19:00.300
kann auch so heißen, vollkommen egal wie das heißt, wie du das nennst, ist egal, das ist

02:19:00.300 --> 02:19:12.020
reine optische Sache, reine Optik, kannst du nennen wie du willst, kannst du sagen Omega

02:19:12.020 --> 02:19:32.340
Lul Klasse oder Ayayaya Poggers, bin ich Pegas, Poggers, Keck www kann das heißen, so und

02:19:32.340 --> 02:19:38.460
das ist jetzt anscheinend diese neue Syntax für Pattern Matching und das ist wirklich

02:19:38.460 --> 02:19:46.580
bisschen Mind Blown, also sprich, was es macht, kann ich erkennen, aber es ist schon echt

02:19:46.580 --> 02:19:49.660
Hardcore, übrigens wir können es ein bisschen schöner machen, wir machen jetzt erstmal

02:19:49.660 --> 02:19:55.820
eine normale Methode draus, ja, erstmal nur mal, dass man so Busy Busy Busy besser lesen

02:19:55.820 --> 02:20:07.740
kann, ok, jetzt erkennt man schon mal, dass es eine Methode ist, ja, das ist eine gute

02:20:07.740 --> 02:20:16.820
Frage, ich würde sagen es gibt einen Compiler Fehler, ich habe das noch nie ausprobiert,

02:20:16.820 --> 02:20:27.340
ich würde sagen es gibt einen Compiler Fehler, wenn die exakt gleich ist, nope, ok, ich sollte

02:20:27.340 --> 02:20:35.060
es vielleicht anders machen, wir machen so noch ein bisschen anders, ok, es gibt keinen

02:20:35.060 --> 02:20:51.740
Compiler Fehler, ich habe keine Ahnung, welche davon genommen wird, ich habe keine Ahnung,

02:20:51.740 --> 02:21:00.420
beides, ah, jetzt wird er aber meckern, dass er nicht weiß, was er aufrufen soll, genau,

02:21:00.420 --> 02:21:30.140
ah, Moment, was mache ich verkehrt?

02:21:30.140 --> 02:21:44.780
Ach, Moment, Moment, Schwachsinn, ich muss ja da gar nichts rein machen, das ist ja die

02:21:44.780 --> 02:21:56.300
Referenz auf sich selber, ah, guck, jetzt sagt er, es ist doppeldeutig, also sprich

02:21:56.300 --> 02:22:02.340
nicht das Anlegen von einer mehrdeutigen Extension-Message führt zum Compiler-Fehler, sondern das Aufrufen

02:22:02.340 --> 02:22:08.260
einer mehrdeutigen Extension-Message führt zum Compiler-Fehler, er sagt halt keine Ahnung,

02:22:08.260 --> 02:22:13.580
was ich nehmen soll, die Implementierung aus Iaiya Pogas Keg WWW oder die Implementierung

02:22:13.580 --> 02:22:20.780
aus Iaiya Pogas Keg WWW 2, natürlich empfehle ich jedem seine Klassen auch immer so schön

02:22:20.780 --> 02:22:26.900
zu nennen, wie hier, wusste ich auch noch nicht, habe ich mir das noch nicht ausprobiert,

02:22:26.900 --> 02:22:35.340
gut zu wissen, so, aber das hier ist wirklich Next Level Shit, Alter, is letter, C is größer

02:22:35.340 --> 02:22:42.140
a and kleiner z or größer a and kleiner, ach du große Scheiße, in dem Fall ist das

02:22:42.140 --> 02:22:46.660
ja noch klar, aber ich weiß genau, dass die Leute das Zweck empfremden werden, bis zum

02:22:46.660 --> 02:22:57.340
geht nicht mehr, was für ein Casing, Twitch Chat Case, Twitch Case hat die, die hat kein

02:22:57.340 --> 02:23:10.340
Camel Case, kein K-Bub Case, kein Pascal Case, die hat Twitch Case, mal gucken, ob die noch

02:23:10.340 --> 02:23:24.220
mehr am Beispiel, ach du Scheiße, boah, ey, what, mein, was zum Teufel, bin ich sehend,

02:23:24.220 --> 02:23:39.100
das sieht aus wie Opfoskated, ja, das sieht wirklich aus wie, ach du Scheiße, also, ich

02:23:39.100 --> 02:23:44.380
meine, man erkennt, was er macht, er guckt, ob C und dann ist es hier kropiert, ok, größer

02:23:44.380 --> 02:23:51.860
a, ein kleiner gleich z oder das, das oder Punkt oder Komma, boah, fuck, ok, das ist

02:23:51.860 --> 02:23:56.500
jetzt neu, das habe ich euch ja schon gezeigt, dass man checken kann, is not null, das ist

02:23:56.500 --> 02:24:02.220
tatsächlich richtig gut, glaubt man gar nicht, aber mal so als Beispiel, man konnte früher

02:24:02.220 --> 02:24:09.260
checken, Case null, man konnte nicht checken, Case not null, das heißt, man musste immer,

02:24:09.260 --> 02:24:13.900
ich weiß gar nicht, ob man das im Case überhaupt machen kann, man musste irgendwelche komischen

02:24:13.900 --> 02:24:20.900
Konstrukte bauen, um zu checken, ob es, ob es not null ist, wenn man das in einem Patternmatching

02:24:20.900 --> 02:24:29.500
verwenden will, also man muss zum Beispiel gucken, hier kann, if a is not null, kann

02:24:29.500 --> 02:24:40.420
man jetzt machen, is not null, ne, wie, das geht immer noch nicht, ah, Moment, das geht

02:24:40.420 --> 02:24:48.500
nicht, weil es not nullable ist, Objekt, ich nehme jetzt einfach, oh, das haben wir

02:24:48.500 --> 02:24:53.300
doch hier oben, genau, das kann man jetzt machen, das ging letztes die Sharp Version

02:24:53.300 --> 02:24:56.980
nicht, da gab es das not Keyword nicht an der Stelle, da musste man dann solche Dinger

02:24:56.980 --> 02:25:04.860
hier machen, is null, not, oder so, ich krieg die Syntax Tasche schon gar nicht mehr hin

02:25:04.860 --> 02:25:12.060
aus dem Kopf, irgendwie sowas musste man da, musste man letztes die Sharp Version machen,

02:25:12.060 --> 02:25:16.660
hat kein Mensch benutzt, so und jetzt kann man sagen, is not, is not null, ist ein bisschen

02:25:16.660 --> 02:25:22.860
schöner, ja, man muss übrigens sagen, dass es an der Stelle natürlich, ah guck mal hier,

02:25:22.860 --> 02:25:26.380
der Chat ist big brain, er muss natürlich sagen, dass an der Stelle macht es jetzt relativ

02:25:26.380 --> 02:25:30.860
wenig Sinn, genau so ging das, ist hässlich wie die Nacht, an der Stelle macht das wenig

02:25:30.860 --> 02:25:36.020
Sinn, weil hier könnte ich ja auch einfach überprüfen, ah, is oh, gleich, gleich null,

02:25:36.020 --> 02:25:40.860
ah, das wäre hier die, oder ungleich null, das wäre hier die einfache Variante, aber

02:25:40.860 --> 02:25:52.220
das kann ich halt nicht in Bestandteil von so einem Pattern Matching Gedöns machen,

02:25:52.220 --> 02:26:00.540
so Performance, okay, sie sparen sich größere Beispiele dafür, also ich hab Beispiele

02:26:00.540 --> 02:26:05.340
gesehen davon, das war abartig, was die Leute hier mitgemacht haben, ich versuch's euch

02:26:05.340 --> 02:26:10.340
mal zu zeigen, ich hab auf YouTube ein Video gesehen, wo sich die Sharp 9 vorgestellt hat

02:26:10.340 --> 02:26:18.700
und da hatten die den Pattern Matching, das war ein ziemlich langes Video, Pattern Matching,

02:26:18.700 --> 02:26:32.140
guck mal was der für ein Beispiel drin hat, siehste Leute, es wird schon ekliger, du kannst

02:26:32.140 --> 02:26:38.380
nämlich nicht nur ne Switch machen, du kannst nämlich auch irgendwie auf, als Expression

02:26:38.380 --> 02:26:44.020
switchen, also kein Switch Statement, sondern du kannst jetzt ne Switch Expression verwenden,

02:26:44.020 --> 02:26:53.700
dann wird's schon ekeliger, guckt euch das mal an hier, also das hier war noch poggers

02:26:53.700 --> 02:27:00.020
lesbar was wir hier gehabt haben, was ist der Vorteil, ja das muss ich glaube ich im einzigen,

02:27:00.020 --> 02:27:06.980
im einzelnen Fall rausstellen, ja Switch Expression sind die Sharp 8, das ist richtig, ja also

02:27:06.980 --> 02:27:13.180
die möglichen, man kann jetzt mehr mitmachen, der Switched auf Return, genau, also sprich

02:27:13.180 --> 02:27:19.700
der Switched, der nimmt, der setzt quasi das was hier rauskommt dann da ein, also man kann

02:27:19.700 --> 02:27:23.540
quasi Variablen damit irgendwie befüllen dann oder so, ich verwende das so gut wie

02:27:23.540 --> 02:27:32.660
nie, muss ich ehrlich sagen, ich will aber mal das offizielle Video mir angucken, das

02:27:32.660 --> 02:27:46.700
war wirklich extrem Big Brain, wie heißt der Typ, Metz, Into the Future, genau, das ist

02:27:46.700 --> 02:27:51.380
der Oberst die Sharp, die Sharp 8, ach Leute übrigens, hab ich es euch eigentlich schon

02:27:51.380 --> 02:28:01.580
gezeigt, pass mal auf jetzt kommt's, die hat ne Konferenz und ich hab ne Frage gestellt

02:28:01.580 --> 02:28:12.300
in der Konferenz, ich hab ne Frage gestellt in der C-Sharp, in der.NET, in der.NET,

02:28:12.300 --> 02:28:16.780
.NET 5 Release Konferenz, hab ich ne Frage gestellt, die müssen wir uns jetzt mal anhören.

02:28:16.780 --> 02:28:34.860
It's updating and not, there we go, can we use emojis in Variablen?

02:28:34.860 --> 02:28:36.300
Alright guys, I'll let you get back to it.

02:28:36.300 --> 02:28:57.100
Und wisst ihr was das beste ist, Moment, Moment, ich muss euch das andere noch zeigen, wisst

02:28:57.100 --> 02:29:03.940
ihr was das beste ist, das war ja die übelste Trollfrage überhaupt, ja und ich hab das

02:29:03.940 --> 02:29:07.940
auch nur zum Trollen geschrieben, nicht weil ich, weil ich wirklich wollte, dass sie das

02:29:07.940 --> 02:29:13.580
beantworten, aber jetzt kommt's, wartet mal, guckt euch mal die Antwort an, ich muss die

02:29:13.580 --> 02:29:22.060
Antwort suchen, wartet mal, wo ist die Antwort, so viele Tweets, sticks out for Harambee,

02:29:22.060 --> 02:29:50.100
Alter, ja, ja, Tweet, ich hab ne 25 Dollar Giftcard mit dieser Frage gewonnen, das ist

02:29:50.100 --> 02:29:58.700
nicht geil, ich hab die übelste Trollfrage gestellt, die haben die Trollfrage beantwortet

02:29:58.700 --> 02:30:08.820
und ich hab noch ne 25 Dollar Giftcard gewonnen, so kann's gehen, Alter, nein, das sind Ami

02:30:08.820 --> 02:30:16.700
25,00, hätt ich 2500 gewonnen, hätt ich auch nichts dagegen gesagt, heißt die Singleton,

02:30:16.700 --> 02:30:38.300
ja, die heißt Singleton mit Nachname, hat mich auch erstmal voll überrascht, ja, tja

02:30:38.300 --> 02:30:43.260
und natürlich, wenn die so ein Bild mit Maske und so drin hat, ich hab mal nach der gegoogelt,

02:30:43.260 --> 02:30:52.940
die sieht echt hübsch aus, müsst mal googeln danach, Microsoft Stonks Frau, naja, aber

02:30:52.940 --> 02:30:57.780
schon nice, oder, 25 Dollar Giftcard und Trollfrage beantwortet, besser geht's doch eigentlich

02:30:57.780 --> 02:31:05.300
gar nicht, ok, ich wollt euch jetzt ja das Beispiel mit Pattern Matching zeigen, was

02:31:05.300 --> 02:31:10.620
sie hier vorgestellt haben, also das ist der Ober C Sharp Language Designer, seitdem es

02:31:10.620 --> 02:31:14.540
der Anders Halsberg nicht mehr macht, der ist es ja nicht mehr, der wartet, dass der

02:31:14.540 --> 02:31:19.820
ist die Sharp Erfinder, ich weiß gar nicht, ob ihn Halsberg ausspricht oder Hilsberg,

02:31:19.820 --> 02:31:42.820
Pattern Matching, Pattern Matching, Gibt kein Pattern Matching, habt ihr das doch irgendwo

02:31:42.820 --> 02:32:03.580
gesehen, hier vielleicht, die hatten ein richtig gutes Beispiel was Pattern Matching angeht,

02:32:03.580 --> 02:32:12.540
so ein richtig langes, total abartiges Beispiel, wo ich mir gedacht hab, Monka S, da blickste

02:32:12.540 --> 02:32:20.420
dann mal durch, das war ein Beispiel mit irgendeiner Maut, mit irgendeiner LKW Maut und Berufsverkehr

02:32:20.420 --> 02:32:28.260
war das Beispiel, vielleicht kennt ihr einer das Video, total abartig, ey hier ist es nicht

02:32:28.260 --> 02:32:52.460
drin, ah die Inder sind natürlich auch am Start, das hier, war das das hier, ok die

02:32:52.460 --> 02:33:03.700
arbeiten sich noch in Record Types ab, hier, hier, das geht ab hier, genau, Return Vehicle

02:33:03.700 --> 02:33:19.500
Switch, Bus, boah, da krieg ich mir Angst zu tun, wenn ich sowas sehe, und das ist noch

02:33:19.500 --> 02:33:27.780
ein Beispiel was gut lesbar ist, also man kann glaube ich sogar switchen in einem Switch,

02:33:27.780 --> 02:33:33.460
ja guck hier, also ich sag, also das erste ist, so wie ich das hier mache, ist es ja

02:33:33.460 --> 02:33:38.700
noch ne normale Statement, so ein ganz normales Switch Statement, ich kann allerdings auch

02:33:38.700 --> 02:33:44.140
sagen ok, ich will, keine Ahnung, ich return jetzt hier ein Int und um rauszubekommen was

02:33:44.140 --> 02:33:57.340
für ein Int ich returnen will, sag ich jetzt, return, dann switch, ne, Switch, ne, genau,

02:33:57.340 --> 02:34:07.100
return, ach du scheiße, ich kann nicht so ein Tag sein, ich mach, ok, return, v, switch

02:34:07.100 --> 02:34:16.820
und dann kann ich hier drinnen switchen, ne, muss ich v machen, ich weiß gar nicht, ok,

02:34:16.820 --> 02:34:22.140
ich weiß, ach ne, ich switch, ich brauch irgendwas worauf ich switchen kann, ok, o, o, switch

02:34:22.140 --> 02:34:34.500
of o, ok, so, das heißt jetzt return ich, je nach, je nachdem was o ist, oh, gibt es

02:34:34.500 --> 02:34:57.460
Tiefenlimitationen, so wie ich die kennen nicht, so, so, also, nehmen wir mal jetzt

02:34:57.460 --> 02:35:04.500
irgendwie sowas, keine Ahnung, ich hab hier, switch ist ein Int, so, und dann kann ich

02:35:04.500 --> 02:35:18.860
jetzt quasi gucken, ist das größer als 3000, ne, ist das, ne, wie mach ich denn das jetzt,

02:35:18.860 --> 02:35:36.180
ist das, ist das kleiner als 3000, dann, ach du kacke, ich bin da zu dumm für, muss ich

02:35:36.180 --> 02:35:53.980
jetzt sowas machen, eins, und dann, kleiner, 3000 oder so, ne, ok, ich, klammern, wie benutze

02:35:53.980 --> 02:36:02.780
ich das überhaupt, ah, ich weiß gar nicht wie es funktioniert, gibt es keine Interfaces,

02:36:02.780 --> 02:36:05.980
ich hab doch klar, aber das ist halt, ich weiß noch nicht mal was ich überhaupt machen

02:36:05.980 --> 02:36:22.740
muss, was, kleiner, kleiner, 3000, und dann, eins, ah, aber ich kann doch auch sagen, kleiner

02:36:22.740 --> 02:36:38.260
3000, end, größer als 5000, ne, geht das nicht, ach so, end geht nicht, oh, muss es

02:36:38.260 --> 02:36:48.700
sein, huiuiuiuiuiui, übrigens, wir können es noch, wir können es noch ganz abgedrehter

02:36:48.700 --> 02:36:54.340
werden, wir können sagen, objekt, ich geb nen objekt zurück, ok, ich geb nen int zurück,

02:36:54.340 --> 02:37:03.660
ich geb eins zurück, wenn es kleiner 3000 oder größer 5000 ist, so, oder ich geb ein,

02:37:03.660 --> 02:37:12.220
ähm, genau, new, was machen wir denn, new, string, ne, ergibt eigentlich keinen Sinn,

02:37:12.220 --> 02:37:25.580
welche Syntax ist das hier, ok, ok, ok, oah, ey, ich bin, ok, ok, hä, monka giga, ok,

02:37:25.580 --> 02:37:30.900
Bus, im Bus, ich kann Bus zurückgeben, Bus, kann ich, kann ich, kann ich auch sowas machen,

02:37:30.900 --> 02:37:38.020
ok, es ist größer als 10.000, größer als 10.000, und dann geb ich jetzt nen string

02:37:38.020 --> 02:37:59.620
zurück, geht das auch, oder muss der, ah, ne, ok, ok, der return, ne, komm ma, ok, komm

02:37:59.620 --> 02:38:09.820
ma, komm ma, pattern has already been handled, achso, oder größer 5000, ja ok, das ist klar,

02:38:09.820 --> 02:38:16.020
also kleiner, kleiner, kleiner 10.000, ok, kleiner 10.000, alles klar, ähm, ist zwei,

02:38:16.020 --> 02:38:18.860
an string kann ich ja nicht, doch ich kann auch an string zurückgehen, na gut, es ist

02:38:18.860 --> 02:38:33.140
ein Objekt, ok, das wird, das wird kompliziert, so, und da kann ich jetzt noch, da noch andere

02:38:33.140 --> 02:38:37.740
Checks drinne einbauen, oder wie, also wenn wir jetzt zum Beispiel diesen record type

02:38:37.740 --> 02:38:42.940
da unten nehmen, ich hab doch irgendwie record person, so, person, also kann ich sagen, person,

02:38:42.940 --> 02:38:58.380
ach ne, ich muss sagen, kleiner, kleiner dem, oh, das ist mir zu big brain, und dann kann

02:38:58.380 --> 02:39:11.340
ich ne person zurückgeben, oder wie, new person, ja, funktioniert, kann ich jetzt darauf

02:39:11.340 --> 02:39:23.980
wieder switchen, kann ich darauf wieder switchen, geht das jetzt, ne, oder, das, das wäre dann

02:39:23.980 --> 02:39:30.420
glaube ich dann doch, wobei doch, das geht doch, oder, ach ne, ne, ne, ne, das geht nur,

02:39:30.420 --> 02:39:44.900
wenn das, das ist, was da, was da reingegeben wird, oder, also quasi switch, ach, guck mal,

02:39:44.900 --> 02:39:48.620
das kann, das kann ich nicht einmal richtig formatieren, das kann ich nicht einmal richtig

02:39:48.620 --> 02:39:59.860
formatieren, so abgedreht ist das, generative patterns, kann ich nicht, boah, ist das, ok,

02:39:59.860 --> 02:40:06.140
ich geb zu, dass, ok, man kann abartige Sachen mit konstruieren, zumindest das Beispiel ist

02:40:06.140 --> 02:40:11.380
das, was ich euch zeigen wollte, also eigentlich richtig cool, was man damit machen kann, aber

02:40:11.380 --> 02:40:29.580
es wird schon schnell, also man wechselt schnell in den, in den big brain modus, ich find's

02:40:29.580 --> 02:40:34.820
auch cool, ja, ich find's richtig nice, also die ganzen funktionalen programmierer dudes

02:40:34.820 --> 02:40:43.220
hier, die freuen sich jetzt in ast ab, ach ja, das gibt's ja auch noch, stimmt, es gibt

02:40:43.220 --> 02:40:46.620
ja noch mehr neue features, sind sogar ein paar ganz coole mit dabei, halten wir uns

02:40:46.620 --> 02:40:52.260
jetzt mal nicht zu lange an abgedrehtem pattern matching zeug auf, genau, es gibt native sized

02:40:52.260 --> 02:40:57.100
ints, gut, das ist was, was ich relativ selten brauchen werde, das braucht man wahrscheinlich

02:40:57.100 --> 02:41:04.620
bei performance kritischen sachen, also sprich, ein int auf ein 32 spit system ist halt, dann,

02:41:04.620 --> 02:41:12.940
also native int ist dann auf ein 32 spit system als 32 spit und 64 spit system, ok, bestimmt

02:41:12.940 --> 02:41:20.620
für native sachen performancemäßig ganz gut, dann haben wir noch ein bisschen andere sachen,

02:41:20.620 --> 02:41:28.180
die jetzt nicht so spannend sind, fit and finish features, also es gibt jetzt diese

02:41:28.180 --> 02:41:35.940
möglichkeit hier und das find ich eigentlich recht nice, also man kann jetzt, man kann

02:41:35.940 --> 02:41:38.780
jetzt die kurzvariante schreiben, also ich zeige euch jetzt mal wofür ich denke, dass

02:41:38.780 --> 02:41:51.100
man das gut verwenden kann, so, machen wir mal den kram hier weg und das ist void und

02:41:51.100 --> 02:42:02.300
das ding hier will, keine ahnung, ein i enumerable von int, so, list, immer und man kann jetzt

02:42:02.300 --> 02:42:11.260
die liste, also bisher hat man die liste so angelegt, list gleich new lists int, was man

02:42:11.260 --> 02:42:15.780
jetzt machen kann ist, aber das ergibt da noch wenig sinn an der stelle, was man jetzt

02:42:15.780 --> 02:42:24.700
machen kann ist das hier, also der ist jetzt quasi so schlau und erkennt, ok, wenn der

02:42:24.700 --> 02:42:34.220
hier new macht, dann will der wahrscheinlich ne list int haben, das ist insofern ganz cool,

02:42:34.220 --> 02:42:40.140
wenn man klassen macht, ich hoffe, wir müssen mal kurz gucken, ob das da geht, so, also

02:42:40.140 --> 02:42:46.580
für eine sache, wo ich mir vorstelle, wo das cool ist, public class, plupp, so und dann

02:42:46.580 --> 02:42:57.340
hat man sowas wie hier ne private read only concurrent dictionary aus int und frag mich

02:42:57.340 --> 02:43:08.060
nicht int und irgendein tuppel aus string s und string b, sowas, macht man jetzt vielleicht

02:43:08.060 --> 02:43:16.780
nicht so oft, aber kommt vor, so, was hat der für schmerzen, das ist auch gar keine

02:43:16.780 --> 02:43:28.620
methode, so, dict gleich new, so und normalerweise muss man sowas hier machen, also quasi, so,

02:43:28.620 --> 02:43:32.700
normalerweise muss man sowas machen und das ist ein bisschen kompliziert, so, jetzt kann

02:43:32.700 --> 02:43:37.260
man da einfach nur noch, wenn ich das jetzt richtig verstehe, das da machen, das ist ganz

02:43:37.260 --> 02:43:52.220
praktisch, das ist cool, so und wo ich mir jetzt noch, wo ich mir jetzt noch ganz praktisch

02:43:52.220 --> 02:44:00.660
vorstelle, ist folgendes, wenn ich jetzt hier ne methode hab, die ne liste haben will

02:44:00.660 --> 02:44:05.740
und ich will dann ne leere liste oder ne list initializer oder so übergeben, dass ich dann

02:44:05.740 --> 02:44:12.540
sagen kann, test new, das ist jetzt ne leere, neue liste, ohne dass ichs angeben muss und

02:44:12.540 --> 02:44:19.860
das ist automatisch quasi, so und ich kann jetzt wahrscheinlich sowas hier machen, ah

02:44:19.860 --> 02:44:26.700
ne, das geht nicht, das geht nur wenn es list ist oder, ah ok, ist aber eigentlich auch

02:44:26.700 --> 02:44:37.060
ganz nützlich, das ist wirklich highly sophisticated, big brain, also das ist quasi die kurzform

02:44:37.060 --> 02:44:43.620
davon, eigentlich auch ganz nett, das sind so kleine features, die einfach das leben

02:44:43.620 --> 02:44:51.460
ein bisschen einfacher machen, die jetzt im prinzip auch irgendwie compiler magic sind,

02:44:51.460 --> 02:44:56.140
weiß nicht wie ich mir das ganze neues zeugs merken soll, 1337 geht mir ähnlich, deswegen

02:44:56.140 --> 02:45:02.220
gibt es sicherlich features aus, die sharp 678, die ich kaum verwende, weil vieles untergeht,

02:45:02.220 --> 02:45:11.980
dazu kommt ja noch, das hier ist jetzt, fuck was wollte ich sagen, das hier ist jetzt nur

02:45:11.980 --> 02:45:19.100
die sprach features, was wir noch gar nicht haben ist, die ganze framework library zusätze,

02:45:19.100 --> 02:45:23.420
die es bestimmt auch gibt, also es gibt bestimmt wieder zig neue klassen im framework, die

02:45:23.420 --> 02:45:37.820
man verwenden kann, grpc, kengin ist großer grpc fan, list gleich array, what, ne, ne,

02:45:37.820 --> 02:45:45.740
das ist eine neue synthax, das ist die kurzform hierfür, new list int, der kann jetzt seit

02:45:45.740 --> 02:45:53.020
der neuen c sharp version, der bronc, kann man das weglassen und der ist so schlau und

02:45:53.020 --> 02:45:58.500
erkennt, diese methode will eine list int haben und ich kann jetzt nur new schreiben

02:45:58.500 --> 02:46:04.820
mit list initializer und er kapiert, dass mein new an der stelle eigentlich ein new

02:46:04.820 --> 02:46:17.500
list int ist, es hat den nachteil, es ist nicht unbedingt gut lesbar ohne ide support,

02:46:17.500 --> 02:46:26.220
ich mein guck mal selbst rider checkt das nicht, doch hier schon, also sprich jetzt

02:46:26.220 --> 02:46:30.780
gehen wir mal von aus, test ist irgendwo da unten deklariert, wir wissen nicht wo, dann

02:46:30.780 --> 02:46:39.900
ist uns jetzt nicht so wirklich klar auf den ersten blick, was das da für ein typ ist,

02:46:39.900 --> 02:46:44.300
aber das ist eine sache, wo ich mir vorstellen kann, dass es ganz cool ist, aber das hier

02:46:44.300 --> 02:46:51.100
ist für mich das was wirklich lesbarkeit auch was bringt, danno ich weiß nicht wie du das

02:46:51.100 --> 02:47:01.260
siehst aber für den fall findest du es wahrscheinlich auch ganz praktisch oder, also hier finde

02:47:01.260 --> 02:47:06.620
ich es cool, weil gerade wenn man solche langen sachen hat, das ist einfach abartig zu lesen

02:47:06.620 --> 02:47:19.060
hier und total redundant gleicher scheiß und da ist das hier eigentlich, das ist nice ja,

02:47:19.060 --> 02:47:35.220
so was haben wir noch für features, das haben wir uns grade angeguckt,

02:47:35.220 --> 02:47:48.460
haben wir uns auch grad angeguckt, anosa, was, anosa leute, anosa, anosa nice, anosa

02:47:48.460 --> 02:48:11.660
nice use, ah yes yes, das ist cool, das ist cool, guck mal wir haben noch hier unsere

02:48:11.660 --> 02:48:18.660
person class, wenn ich jetzt, wenn die metode jetzt ne person haben möchte, die jetzt list

02:48:18.660 --> 02:48:41.620
heißt, p besser, dann kann ich jetzt sagen new, auch nicht, warum nicht, ah weil, ah

02:48:41.620 --> 02:48:53.700
die muss ich im constructor machen, die sind gar nicht in it only, ah die sind gar nicht

02:48:53.700 --> 02:49:07.900
in it only, oh das ist ja doof, gut aber ich mein es ist immer noch kürzer, es ist immer

02:49:07.900 --> 02:49:23.540
noch kürzer als new person, ich hätte jetzt eigentlich gedacht, man kann, kann new person,

02:49:23.540 --> 02:49:48.340
warum, ich hätte jetzt eigentlich gedacht, das funktioniert, weil wo ist denn jetzt der

02:49:48.340 --> 02:50:04.780
sinn davon, ja das darf ich nämlich nicht ändern, ok das verstehe ich jetzt nicht,

02:50:04.780 --> 02:50:22.020
ach ich bin ja auch doof, ich darf keine klammern machen, oder doch, ok dann weiß ich auch nicht

02:50:22.020 --> 02:50:36.100
so genau, ok dann muss ich die dinger quasi hier über den constructor machen, ok was

02:50:36.100 --> 02:50:53.020
kommt da jetzt bei raus, ok ist das jetzt null oder ist es blub und lull, probieren wir mal

02:50:53.020 --> 02:51:17.260
mal, es ist blub und lull, wie kann ich das optional machen, nee, nee oder, das glaube

02:51:17.260 --> 02:51:32.500
ich nicht, dass es so gedacht ist, eh ok, ich glaube das erfordert noch ein wenig im

02:51:32.500 --> 02:51:43.180
detailplanung, das ist irgendwie komisch, weil das richtig coole wäre, wenn man das

02:51:43.180 --> 02:51:50.940
quasi standardmäßig so anlegen könnte und ich könnte das hier callen so, ohne dass ich

02:51:50.940 --> 02:52:07.220
das da eintragen muss, das wäre cool wenn das geht, das ist schön kompakt und eigentlich

02:52:07.220 --> 02:52:12.620
auch ganz gut lesbar, sag mal kennt jemand einen trick wie man rider dazu überreden

02:52:12.620 --> 02:52:32.340
kann, dass es beim speichern auto format macht, das geht mir nämlich voll auf den sack, ok

02:52:32.340 --> 02:52:56.220
was haben wir ansonsten noch für fiaturis, das haben wir uns jetzt angeguckt, why is

02:52:56.220 --> 02:53:04.460
das denn, nee das plugin gibt es für rider nicht, ich kann einen static von lambda expression

02:53:04.460 --> 02:53:17.500
machen, also also, ok das check ich noch nicht so genau, warum verwende lambda expression

02:53:17.500 --> 02:53:27.020
doch als callbacks oder sowas, so also das nächste ergibt für mich schon mehr sinn,

02:53:27.020 --> 02:53:30.900
also ich kann zum beispiel sowas machen, das ist auch ein feature, was selten verwendet

02:53:30.900 --> 02:53:37.420
wird, was man auch nicht oft braucht, aber was ich ganz nützlich finde, so also zum

02:53:37.420 --> 02:53:53.780
beispiel, was machen wir denn jetzt mal, was gibt es denn ein schönes beispiel für, ja

02:53:53.780 --> 02:54:03.860
also zum beispiel process start lull, also das lässt jetzt, das startet jetzt das programm

02:54:03.860 --> 02:54:14.340
mit dem namen lull, so und ich subscribe jetzt das event für, nee das ist ein scheiß beispiel,

02:54:14.340 --> 02:54:24.380
das ist doofs beispiel, ok mir fällt kein gutes beispiel ein, aber manchmal braucht

02:54:24.380 --> 02:54:31.860
man hier innerhalb von so ner metode noch eine und das kann man schon seit glaube ich

02:54:31.860 --> 02:54:40.180
6 oder 7 machen, man kann jetzt hier drinne quasi so kleine lokale helper methoden noch

02:54:40.180 --> 02:54:50.620
anlegen, also ich kann zum beispiel sagen int generate number, irgendwie sowas, so return

02:54:50.620 --> 02:54:57.620
1, das geht, also man kann so nested functions machen, das geht schon ein bisschen länger,

02:54:57.620 --> 02:55:04.060
und die kann man jetzt static machen, aha ok habe ich noch nie gebraucht, aber wenn

02:55:04.060 --> 02:55:11.140
ich es brauche, ist es vielleicht ganz nice, also man kann jetzt quasi lokale helperfunktion

02:55:11.140 --> 02:55:18.940
in, also helperfunktion in methoden machen, was auch ungewöhnlich ist für c-sharp in

02:55:18.940 --> 02:55:24.220
sofern, weil die haben lambdafunktionen, also diese geschichten schon, bekommen bevor sie

02:55:24.220 --> 02:55:28.220
anonyme funktionen hatten, normalerweise ist das eigentlich eher umgedreht, sprachen haben

02:55:28.220 --> 02:55:38.900
zuerst das und bekommen dann das, müsste doch auch für rider punkt 2, gucken wir mal

02:55:38.900 --> 02:55:50.860
rein, punkt 2, nein das geht nicht für rider, weil dieses plugin gibt es nicht für rider,

02:55:50.860 --> 02:55:59.180
dieses plugin gibt es quasi für so ziemlich alles, nur nicht für rider, warum auch immer

02:55:59.180 --> 02:56:11.980
nicht, um mich zu ärgern wahrscheinlich, ja ok das kann man jetzt static machen, mir

02:56:11.980 --> 02:56:24.340
fällt jetzt gerade kein wirklicher anwendungszweck ein, warum ich das haben möchte, fällt euch

02:56:24.340 --> 02:56:36.220
irgendwas ein, warum will ich eine lokal, static, local, so eine helperfunktion haben,

02:56:36.220 --> 02:56:40.420
das ist wahrscheinlich der typische fall von, wenn man es braucht dann freut man sich, dass

02:56:40.420 --> 02:57:04.260
es da ist, ich kann euch jetzt mal ein ganz gutes anwendungsbeispiel zeigen für so eine

02:57:04.260 --> 02:57:10.900
anonyme lokalen funktion, ich glaube ich habe, ich weiß nicht ob ich das schon gepusht habe,

02:57:10.900 --> 02:57:31.220
oh nein habe ich nicht, da kann ich es euch nicht zeigen, weil das hier verursacht einen

02:57:31.220 --> 02:57:39.060
memory leak, was ich hier gebastelt habe, weil ich den callback nie unsubscriber, na gut

02:57:39.060 --> 02:57:43.300
kann ich euch nicht zeigen, habe ich nicht gepusht, so was haben wir sonst noch für

02:57:43.300 --> 02:57:47.900
neue sachen, können jetzt static sein, ok da habe ich wirklich keine ahnung wozu das

02:57:47.900 --> 02:58:00.220
jetzt gut sein soll, dann warten wir mal ab, in addition for each loop, dass ich kann jetzt

02:58:00.220 --> 02:58:07.820
for each verwenden, wenn ich irgendeinen typ habe, der die nötigen metoden implementiert,

02:58:07.820 --> 02:58:17.260
ok, next you can use this card as parameters to lambda, oh das ist nice, das ist wirklich

02:58:17.260 --> 02:58:22.860
cool, das hätte ich mir schon öfters mal gewünscht, also zum beispiel wenn man, ähm

02:58:22.860 --> 02:58:33.220
action, int int int, das ist jetzt nur mal exemplarisch für ein callback oder für lambda,

02:58:33.220 --> 02:58:40.340
so und wenn ich den jetzt hier aufrufe, dann muss ich immer, dann muss ich bisher immer

02:58:40.340 --> 02:58:53.300
die parameter mit angeben, moment, jetzt, ach nee, moment, gleich, ähm, so, ähm,

02:58:53.300 --> 02:58:57.420
da muss ich bisher immer die parameter mit angeben, selbst wenn ich die parameter gar

02:58:57.420 --> 02:59:04.340
nicht haben will, und jetzt kann man so machen, wenn man die parameter nicht haben will, das

02:59:04.340 --> 02:59:22.620
ist cool, ähm, nee, wie, ach so, das hier, ja, das, das, jetzt wo du es sagst, fällt

02:59:22.620 --> 02:59:26.180
es mir wieder ein, jaja, also du meinst jetzt nicht an event, du meinst, dass man quasi

02:59:26.180 --> 02:59:45.060
hier dran jetzt was, was anhängen kann, oder, ja, oder auch nicht, ich weiß aber was du

02:59:45.060 --> 02:59:49.180
meinst, nee, das, ähm, war mir so jetzt nicht im kopf, ich hab das schon mal gesehen, ja,

02:59:49.180 --> 02:59:52.220
wo, mir fällt es wieder ein, wo du es gesagt hast, aber ehrlich gesagt hab ich noch nie

02:59:52.220 --> 02:59:59.180
benutzt, kopf gameplay auf youtube, ja, mal gucken, mal gucken, so, was haben wir sonst

02:59:59.180 --> 03:00:08.780
noch schönes, also das mit discard parametern ist wirklich sehr nice, you can now apply

03:00:08.780 --> 03:00:16.740
attributes to local functions, boah, jetzt wirds aber abgedreht, alter, nullable attribute

03:00:16.740 --> 03:00:22.660
annotation, ähm, mal, frage an euch, die, die vielleicht die eine oder andere ist, die

03:00:22.660 --> 03:00:29.340
sharp verwendet, verwendet ihr dieses nullable, not nullable feature eigentlich, ich muss

03:00:29.340 --> 03:00:42.620
mich ja mal outen, ich verwende es gar nicht, dabei haben die sich so viel mühe gegeben

03:00:42.620 --> 03:00:56.940
mit not nullable, aber ich finde man merkt, dass es irgendwie drauf gestülpt ist auf

03:00:56.940 --> 03:01:09.700
ne sprache, die nicht so designt ist, hat das dann nen default wert statt 0, nee, kein

03:01:09.700 --> 03:01:20.740
default wert, wenn du not nullable eingeschaltet hast, dann musst du, wenn nen referenztyp

03:01:20.740 --> 03:01:25.980
null werden kann, musst du explizit markieren mit nem fragezeichen, also zum beispiel, wenn

03:01:25.980 --> 03:01:34.940
ich not nullable einschalte, dann muss ich sowas hier schreiben, und das sagt dann, ok,

03:01:34.940 --> 03:01:42.100
best ist ne funktion, der kann ich, kann ich null übergeben, als person, normalerweise

03:01:42.100 --> 03:01:47.020
ist das der default verhalten, ne, also, die person kann ne instanz von person sein oder

03:01:47.020 --> 03:01:56.740
null, und mit not nullable haben sie es umgedreht, ich muss das, ähm, angeben, wenn es null

03:01:56.740 --> 03:02:03.660
sein darf, und wenn ich das mache, dann macht der compiler und, äh, die ide und sowas,

03:02:03.660 --> 03:02:08.940
machen paar checks für mich, dass ich mich nicht vertippe, aber ich verwende das so gut

03:02:08.940 --> 03:02:17.700
wie nie, guck der sagt mir auch, ich muss, äh, nullable sachen einschalten, jetzt hab

03:02:17.700 --> 03:02:32.060
ichs eingeschaltet, jetzt weiß ich nicht wie ichs wieder auskriege, ach hier oben,

03:02:32.060 --> 03:02:37.820
genau, weil jetzt, jetzt kann ich sagen, ey guck mal, hier ist null erlauben, null übergeben

03:02:37.820 --> 03:02:43.820
erlaubt, das bedeutet, wenn ich test aufrufe mit null, anstatt der person, sagt er mir,

03:02:43.820 --> 03:02:50.380
ok, wenn ich das fragezeichen wegmache, sagt er mir, äh, eigentlich darf man hier kein

03:02:50.380 --> 03:03:01.100
null reinmachen, aber wie du siehst, es funktioniert trotzdem, das ist nur ne warnung, nur ne warnung,

03:03:01.100 --> 03:03:09.700
deswegen ich verwende das so gut, ich verwende das gar nicht, ehrlich gesagt, ich hab ja

03:03:09.700 --> 03:03:15.980
jahrelang auch gerne null zurückgegeben, ähm, mittlerweile versuche ich es ein bisschen

03:03:15.980 --> 03:03:21.500
ordentlicher zu machen, entweder ist es was, was man logischerweise in irgendein default

03:03:21.500 --> 03:03:28.540
wert zurückgeben kann, oder ich mach das, zumindest meistens einzig richtige, ne exception

03:03:28.540 --> 03:03:35.580
schmeißen, wenn du nix zurückgeben kannst, ja, also wenn man hier zum beispiel diese,

03:03:35.580 --> 03:03:42.140
ich hab doch hier eben euch gezeigt auf github, ne, zum beispiel hier, getoutput, so mittlerweile

03:03:42.140 --> 03:03:48.020
sieht das anders aus, getoutput gibt nen channel reader zurück, so, aber getoutput kann ich

03:03:48.020 --> 03:03:54.420
nur was zurückgeben, wenn denn überhaupt gerade zu ner kamera connected ist, so, wenn

03:03:54.420 --> 03:03:59.020
das hier nicht fehlschlägt, was geb ich denn dann zurück, eigentlich muss ich da ne exception

03:03:59.020 --> 03:04:03.260
schmeißen, so nach dem motto camera not connected oder sowas, weil ich kann nichts sinnvoll

03:04:03.260 --> 03:04:10.580
zurückgeben, ja ne null reference exception passt ja nicht so ganz, das ist eher so ne

03:04:10.580 --> 03:04:30.300
art io exception oder sowas, schwierig, also wie gesagt ich verwende das so gut wie gar

03:04:30.300 --> 03:04:40.020
nicht, ups, hab ich zugemacht, hier, also ich glaube das wars im großen und ganzen,

03:04:40.020 --> 03:04:45.020
ja, wenn man jetzt mal zum beispiel zurück geht zu csharp 8, da kam ein bisschen mehr

03:04:45.020 --> 03:04:52.900
rein, ne, in csharp gab es diese ganzen features für nullable und sonst was, übrigens auch

03:04:52.900 --> 03:04:59.300
ein feature was kaum verwendet wird, was ziemlich geil ist, wenn man mal ehrlich ist, kennt

03:04:59.300 --> 03:05:10.860
ihr diese geschichte, also ihr habt sowas hier, void tritest, so, das gibt nen bool

03:05:10.860 --> 03:05:18.900
zurück, also sprich tritest gibt zurück ja oder nein, also sprich, das war erfolgreich,

03:05:18.900 --> 03:05:24.380
wenn es erfolgreich war, dann gibt es irgendeinen wert, machen wir mal, wir machen mal ein beispiel,

03:05:24.380 --> 03:05:33.260
tryopen, was programmierst du, wir gucken uns gerade csharp 9 features an, so tryopen,

03:05:33.260 --> 03:05:40.500
so und tryopen ist dann quasi kann ich sagen hier if, if tryopen und dann kann ich was

03:05:40.500 --> 03:05:57.940
machen mit, so bisher hat man das so gemacht, tryopen, out, outperson, so bisher hat man

03:05:57.940 --> 03:06:05.180
das so gemacht, ich hab gesagt if tryopen und dann hat man gesagt out, so in der richtung,

03:06:05.180 --> 03:06:10.700
so das heißt ich kann jetzt erstmal checken, ok klappt der zugriff, wenn der zugriff klappt,

03:06:10.700 --> 03:06:15.660
dann krieg ich als outport hier nen objekt, also person ist jetzt doof, das müsste eigentlich

03:06:15.660 --> 03:06:24.420
eher sowas wie nen file oder so sein, ja, irgendwie sowas, also string, file, pass,

03:06:24.420 --> 03:06:37.580
out, out ist nen file, wobei file kann man nicht, aber ich glaub ihr wisst was ich mein,

03:06:37.580 --> 03:06:46.100
wir faken das jetzt einfach, lull, dann kann man es besser lesen, dann versteht man besser

03:06:46.100 --> 03:06:56.500
was ich mein, so also new file, so das wär so ne typische methodik, also sprich ich geb

03:06:56.500 --> 03:07:03.820
jetzt hier den fad ein, so keine ahnung, home, max, keqw.txt und die versuch ich zu öffnen

03:07:03.820 --> 03:07:08.260
und wenn das funktioniert dann bekomm ich nen file zurück, so das wär so ne typische

03:07:08.260 --> 03:07:14.620
tryopen geschichte, die es auch total oft im framework gibt, ist glaub ich relativ logisch

03:07:14.620 --> 03:07:23.020
was es machen würde, es gibt seit csharp 8 ein richtig geiles feature, für ähnliche

03:07:23.020 --> 03:07:28.420
fälle, der hier ist eigentlich ziemlich gut so wie er ist, aber es gibt jetzt die möglichkeit

03:07:28.420 --> 03:07:37.220
man kann mehr als eine sache zurückgeben, also ich kann zum beispiel, ich müsste jetzt

03:07:37.220 --> 03:07:54.460
nicht das hier zurückgeben, sondern könnte jetzt bool und das file zurückgeben, so und

03:07:54.460 --> 03:08:01.300
wie sieht der return aus, der return sieht dann so aus, also man kann jetzt zwei sachen

03:08:01.300 --> 03:08:12.620
zurückgeben, das funktioniert, so und dann würde ich nämlich sagen tryopen result und

03:08:12.620 --> 03:08:18.900
dann sieht man mein result ist jetzt ein tuppel mit item 1 und 2, dementsprechend kann ich

03:08:18.900 --> 03:08:27.580
jetzt auch sagen, mal gucken ob der das für mich machen kann, kann ich jetzt auch sagen

03:08:27.580 --> 03:08:36.900
result und file und jetzt kann ich hier drauf zugreifen, result und file, das geht glaub

03:08:36.900 --> 03:08:50.500
ich mit bis zu 9, ja ich kanns benennen, stimmt das ist auch ein feature, das kann ich mal

03:08:50.500 --> 03:09:06.860
sagen, also ich glaube es geht bis zu 9 return sachen, ok nein es geht noch mehr, excellent

03:09:06.860 --> 03:09:17.700
alles klar, so muss das sein, so und was auch richtig cool ist, man kann die hier benennen,

03:09:17.700 --> 03:09:26.780
man kann sagen result und man kann sagen hier file handle oder so und wenn ich das jetzt

03:09:26.780 --> 03:09:32.860
ausführe, dann kann der das automatisch eigentlich deconstructen unter dem name, ne das geht

03:09:32.860 --> 03:09:43.820
nicht oder, aber ich glaube rider ist so schlau und kapiert das, konnte rider die dinger nicht

03:09:43.820 --> 03:09:54.740
deconstructen für mich, ne oder, aber zumindest wenn ich hier das objekt jetzt hab, dann seh

03:09:54.740 --> 03:10:00.620
ich, dann sind die dinger sogar hier richtig benannt, also man kann sogar die return parameter

03:10:00.620 --> 03:10:06.780
benennen, allerdings ist das ne reine kosmetik, unter der haube heißen die nach wie vor weiter

03:10:06.780 --> 03:10:21.500
item 1 und item 2, kann ich das irgendwie deconstructen, kann das rider, doch easy, kann rider für

03:10:21.500 --> 03:10:27.180
mich machen, so und jetzt hab ich hier den result und den file handle, jetzt kann ich

03:10:27.180 --> 03:10:37.140
wieder quasi sagen, if result file handle, ja das ist ein ziemlich underratedes feature

03:10:37.140 --> 03:10:47.300
finde ich, wofür das ziemlich gut ist, ist es für solche sachen hier, also zum beispiel

03:10:47.300 --> 03:10:53.940
ich hab hier nen dictionary mit nem key, möchte aber jetzt nicht, also die standard variante

03:10:53.940 --> 03:10:58.940
wäre, wenn ich nen dictionary hab mit nem key und möchte hier als value mehr als einen

03:10:58.940 --> 03:11:02.700
wert speichern, dann würde ich irgendwie ne klasse machen, keine ahnung was weiß ich

03:11:02.700 --> 03:11:13.260
hier, dict info und dann dort 2 sachen anlegen und hier sagen, es ist nen dict info, so, so

03:11:13.260 --> 03:11:18.060
wird man das normalerweise machen, aber wenn das was ganz easy ist, was aus 2 sachen besteht,

03:11:18.060 --> 03:11:28.540
dann kann man das auch hier so machen, so und wenn man jetzt hier drauf zugreifen will,

03:11:28.540 --> 03:11:37.540
sieht man zum beispiel dict, genau und try oder hier get und wenn ich hier drauf zugreife,

03:11:37.540 --> 03:11:45.180
sieht man hier, dass ich b und s kriege, also sprich das was ich hier benannt hab, das ist

03:11:45.180 --> 03:11:49.620
ziemlich underratedes feature, ok und hier sind 30 milliarden sachen noch drin, das

03:11:49.620 --> 03:11:54.740
gucken wir uns jetzt nicht an, eines meiner lieblings sachen in csharp 8 ist das hier,

03:11:54.740 --> 03:12:03.820
das ist richtig nice, async enumerator, das ist quasi, da kann ich quasi ne for each

03:12:03.820 --> 03:12:15.340
schleife machen, in der ich awaiten kann, das ist sehr praktisch, ja das geht auch,

03:12:15.340 --> 03:12:27.580
fips das funktioniert auch, man kann auch sagen, man kann auch sagen, das, ach geht

03:12:27.580 --> 03:12:36.940
das nicht, ah moment, was mache ich denn da, ich bin doch falsch, ich kann auch sagen,

03:12:36.940 --> 03:12:51.260
das filehandel interessiert mich nicht, das geht auch, channels sind richtig nice, channels

03:12:51.260 --> 03:13:15.380
haben wir hier irgendwo schon mal drin eingebaut, ah meine ordnung, ja channels, da haben wir

03:13:15.380 --> 03:13:22.860
schon channels eingebaut und irgendwo machen wir auch async hier, das ist eines der geilsten

03:13:22.860 --> 03:13:33.180
features aus csharp 8, man kann jetzt ne for each machen, in der man quasi sowohl return

03:13:33.180 --> 03:13:50.500
mit await, als auch mit nem neuen element, das ist ziemlich cool, ja, boah leute, das

03:13:50.500 --> 03:13:55.500
war jetzt big brain stream, was ist hängen geblieben von den neuen csharp features, lasst

03:13:55.500 --> 03:14:04.020
mal überlegen, also, was ist hängen geblieben, also, records, coole sache, die kurzschreibweise,

03:14:04.020 --> 03:14:09.620
rest weiß ich nicht so wirklich, init only setups, werde ich wahrscheinlich hier nur

03:14:09.620 --> 03:14:14.180
im zusammenhang mit records verwenden, ich glaube nicht, dass ich das oft da anwendungszweck

03:14:14.180 --> 03:14:20.420
finde, top level statements finde ich cool, aber nachdem ich selten konsolenanwendungen

03:14:20.420 --> 03:14:25.660
mache in letzter zeit und wenn es zum beispiel ne asp.net anwendung ist, dass eh das template

03:14:25.660 --> 03:14:31.300
für einen generiert, eher für vorführezwecke, pattern matching werde ich wahrscheinlich

03:14:31.300 --> 03:14:35.180
in zukunft häufiger verwenden, allerdings dauert es ein bisschen bis ich da mein hirn

03:14:35.180 --> 03:14:43.500
rum gerappt habe, dass ich das checke, wann man wie was verwenden kann, csharp hat sich

03:14:43.500 --> 03:14:55.940
pyson generieren, bisschen vielleicht eigentlich nicht, eher, eher rust vielleicht oder skala

03:14:55.940 --> 03:15:07.220
oder so, irgendwas in dieser richtung, hier lernt man was, guck mal was ich für techs

03:15:07.220 --> 03:15:14.300
drinne hab, lehrreich, educational habe ich als tech drinne vom video, da muss das ja

03:15:14.300 --> 03:15:20.860
auch mal, muss ja auch educational sein, so native size integers habe ich eigentlich

03:15:20.860 --> 03:15:24.500
keine verwendung für, function habe ich mir gar nicht angeschaut, äh brauchen wir die,

03:15:24.500 --> 03:15:31.900
brauchen wir nicht, ähm target type new expressions stelle ich mir cool für, gerade für ne variabler

03:15:31.900 --> 03:15:38.020
in der klasse, das jetzt nicht, dictionary von dictionary mit dictionary gleich new dictionary

03:15:38.020 --> 03:15:41.700
von dictionary mit dictionary schreiben muss, sondern einfach nur gleich new, finde ich

03:15:41.700 --> 03:15:47.140
cool, static anonymos functions, ich hab keinen plastenschimmer, wozu man das braucht, ich

03:15:47.140 --> 03:15:55.780
hab da gerade überhaupt kein anwendungszweck im kopf, ähm target type conditional expressions,

03:15:55.780 --> 03:16:03.780
dann hab ich schon wieder vergessen was es ist, ähm hab ich auch schon wieder vergessen

03:16:03.780 --> 03:16:08.500
was es ist, hab ich auch schon wieder vergessen was es ist, ok, discard parameter für lambdas,

03:16:08.500 --> 03:16:12.500
das werde ich auf jeden fall oft verwenden, das ist nice, weil meistens brauchst du gar

03:16:12.500 --> 03:16:19.740
nicht alles was da so zurückkommt, oder oftmals, oftmals, so attributes on local function werde

03:16:19.740 --> 03:16:23.580
ich wahrscheinlich auch so gut wie nie verwenden, module final initializer weiß gar nicht mehr

03:16:23.580 --> 03:16:28.980
was es ist und new features for partial method interessiert mich auch nicht, also man muss

03:16:28.980 --> 03:16:35.580
sagen c sharp 9, äh bei weitem nicht so dieses riesen feature release wie jetzt c sharp 8,

03:16:35.580 --> 03:16:48.060
aber trotzdem nice Sachen und es ist ne ganze ecke funktionaler geworden, als es davor war,

03:16:48.060 --> 03:16:52.660
also gerade diese pattern matching geschichte und auch diese record types, also man sieht

03:16:52.660 --> 03:16:56.060
und das ist ne sache die ich wirklich cool finde an c sharp, man sieht das die nicht

03:16:56.060 --> 03:17:00.820
stehen bleiben mit der sprache, man sieht das die aktuelle trends auch aufgreifen die

03:17:00.820 --> 03:17:09.060
sich bewährt haben, dass sie cool sind, dass sie gut funktionieren und sie bauen das ein,

03:17:09.060 --> 03:17:14.420
und zwar mit hirn bauen sie das ein, nicht so wie das t++ cremium wo jeder was anderes

03:17:14.420 --> 03:17:24.820
einbaut und du überhaupt nicht mehr verstehst was eigentlich sache ist, ahja interface default

03:17:24.820 --> 03:17:30.020
implementation, ähm weißt du elsa weißt du warum ich glaube warum die das gemacht

03:17:30.020 --> 03:17:35.060
haben, ich glaube das hat also interface default implementation der einzige grund warum die

03:17:35.060 --> 03:17:44.400
das gemacht haben ist eigennutz, weil microsoft gerade was office angeht 75 interfaces hat

03:17:44.400 --> 03:17:50.060
die interfaces erweitern die schon da war, also die haben dann office interface 1, office

03:17:50.060 --> 03:17:59.140
interface 1x, office interface xx, office interface xx, office interface 5x, office 555x, so und

03:17:59.140 --> 03:18:02.300
die hatten einfach keinen bock mehr drauf und haben deswegen die default implementations

03:18:02.300 --> 03:18:06.860
für interfaces eingebaut, ich glaube kein mensch verwende das außer microsoft selbst,

03:18:06.860 --> 03:18:13.180
verwende einer von euch die default implementations in interfaces, ergibt eigentlich keinen sinn

03:18:13.180 --> 03:18:17.100
das das gibt aber ok, also es gibt ja die möglichkeit ein interface anzulegen in c

03:18:17.100 --> 03:18:30.340
sharp, so ai interface beste, so und ähm, da kann ich jetzt neuerdings defaultsachen

03:18:30.340 --> 03:18:34.420
implementations, ich weiß gar nicht wie es funktioniert wenn ich ehrlich bin, einfach

03:18:34.420 --> 03:18:42.260
so ok, total wir, gibt es interfaces mit default implementations, habe ich noch nie

03:18:42.260 --> 03:18:51.340
verwendet, ja bei comobjekten ist das ja generell bei microsoft native sachen ist das total

03:18:51.340 --> 03:18:57.740
beliebt dass die ihre interfaces 1, 2, 3 bis 5075x, xx, xx, xx haben und ich glaube das

03:18:57.740 --> 03:19:02.060
haben die aus reinem eigennutz gemacht, das ist keine abstract class, nee das ist keine

03:19:02.060 --> 03:19:05.660
abstract class, das ist ein interface, ich kanns dir nicht genau erklären ehrlich gesagt

03:19:05.660 --> 03:19:08.460
da muss ich jetzt mal nachgucken, ich hab, ich verwende das nicht, glaub der unterschied

03:19:08.460 --> 03:19:14.460
ist zwischen der abstract class und dem interface, dass du, ähm, gut du kannst ein paar sachen

03:19:14.460 --> 03:19:19.540
im interfacing machen wie private methoden und sowas in der richtung, das ist der prinzipielle

03:19:19.540 --> 03:19:26.300
unterschied und dass das hier weiter rückwärts kompatibel ist, also ne abstract class ist

03:19:26.300 --> 03:19:32.580
so, wenn du ne abstract class erweiterst, dann muss alles was virtual ist implementiert

03:19:32.580 --> 03:19:38.700
werden, so bei nem interface ist es jetzt so, mal angenommen ich hab hier nen interface

03:19:38.700 --> 03:19:47.900
voidplub, so, so sah das interface mal ursprünglich aus, so und jetzt komm ich auf die idee ich

03:19:47.900 --> 03:19:53.900
möchte eigentlich das interface erweitern mit lull, jetzt ist ja die sache so, ich hab

03:19:53.900 --> 03:19:58.980
schon ganz viele klassen dieses interface implementieren und ne eigene lull, ne eigene

03:19:58.980 --> 03:20:05.940
plub methode haben, wenn ich das interface jetzt erweitern will ohne, dass ich 50 oder

03:20:05.940 --> 03:20:12.500
500 klassen die das interface implementieren anfassen will, dann kann ich ne default implementation

03:20:12.500 --> 03:20:19.700
hier reinhauen und dann geht nix kaputt, wie gut sich das umsetzen lässt und wie gut sich

03:20:19.700 --> 03:20:23.700
das dann in die alten klassen integriert sei mal dahingestellt, hab ich keine erfahrungen

03:20:23.700 --> 03:20:26.060
mit hab ich noch nie verwendet, chat ich weiß nicht wie es bei euch aussieht ob das einer

03:20:26.060 --> 03:20:40.260
von euch verwendet, hab ich noch nie verwendet, hab ich noch nie benutzt, kein klassen shimmer

03:20:40.260 --> 03:20:55.940
ich hab keine ahnung was taugt, ja, so chat das war echt anstrengend big brain stream

03:20:55.940 --> 03:21:12.860
dreieinhalb stunden, solange haben wir uns jetzt die sharp features eingeguckt, chat war

03:21:12.860 --> 03:21:19.260
anstrengend, ich hoffe euch hat es gefallen, ich muss mich da selbst erstmal ein bisschen

03:21:19.260 --> 03:21:26.260
dran tasten was es da für neue sachen gibt, sagt mir mal chat, hat man wenigstens ein

03:21:26.260 --> 03:21:30.060
bisschen was gelernt bei, ja auf jeden fall nice wenn der ein oder andere vielleicht noch

03:21:30.060 --> 03:21:37.380
was gelernt hätte, war ja immerhin educational stream, ja und ihr merkt vielleicht ich mein

03:21:37.380 --> 03:21:42.180
ich weiß das auch nicht bei allem, also bei sachen die ich selten verwende hab ich da

03:21:42.180 --> 03:21:47.700
auch oftmals keinen plan, geht glaube ich jedem so, die sachen die man nicht oft macht

03:21:47.700 --> 03:21:53.940
die man kann sie nicht alles wissen, ist ja letztendlich das wo man auch mal irgendwie

03:21:53.940 --> 03:21:58.180
drauf klarkommen muss, man kann einfach nicht alles wissen und es ist auch letztendlich

03:21:58.180 --> 03:22:08.940
keine schande, man muss einfach nur wissen wie man sucht, poggers google skills sind

03:22:08.940 --> 03:22:13.100
das wichtigste was man haben kann wenn man in der IT arbeitet, das sag ich auch den azubis

03:22:13.100 --> 03:22:22.900
immer, ihr müsst so weit ahnung haben, dass ihr wisst wonach ihr suchen müsst, kannst

03:22:22.900 --> 03:22:31.540
du mal deine meinung zur ps5 sagen, ja und ne weil ich hab mich weder mit der neuen xbox

03:22:31.540 --> 03:22:35.860
noch mit der playstation großartig beschäftigt, ich finde nur dass die playstation 5 ultra

03:22:35.860 --> 03:22:43.540
groß ist oder der japaner das vorgestellt hat war ziemlich klein, ansonsten kann ich

03:22:43.540 --> 03:22:57.060
da gar nichts zu sagen, es sind im prinzip beides mehr oder weniger stink normale pcs,

03:22:57.060 --> 03:23:05.820
halt mit exklusiv sachen, stack overflow triffen programming ja sieht so aus, ist

03:23:05.820 --> 03:23:17.340
aber so, wenn man mal ehrlich ist, die leute denken zwar programmieren würde so aussehen,

03:23:17.340 --> 03:23:24.580
krasse Hacker man am start, die leute denken in wirklichkeit so sieht programmieren aus

03:23:24.580 --> 03:23:50.140
ja ja aber in wirklichkeit sieht programmieren so aus

03:23:50.140 --> 03:24:01.180
das ist das somit eigentlich programmieren ja, true 0w, jeder der es macht weiß dass

03:24:01.180 --> 03:24:10.660
es so ist, jeder der in dem bereich arbeitet, was man was macht privat ist egal, jeder weiß

03:24:10.660 --> 03:24:17.020
dass es so ist, die außenstehenden noobs denken man ist ein richtiger hacker man, in

03:24:17.020 --> 03:24:23.500
wirklichkeit programmieren, eigentlich klaut man sich nicht auf stack overflow zusammen,

03:24:23.500 --> 03:24:35.140
man guckt sich da was an und ändert das dann auf das was man braucht, genau das genau

03:24:35.140 --> 03:24:49.660
wie in dem video ist das, übrigens bestes programm hier, ah yes, ich hoffe ihr seid

03:24:49.660 --> 03:25:03.940
auch die krassen hacker mans wie ich hier, vor allem der matrix bildschirm schon da unten,

03:25:03.940 --> 03:25:12.340
der ist ganz ganz wichtig, ich hab legit keine ahnung was da passiert, das ist ein h-top,

03:25:12.340 --> 03:25:25.260
was auch immer da überhaupt passiert, er generiert nicht, was ist speedometer 2.8,

03:25:25.260 --> 03:25:42.980
irgendeinen hacksdump, ist das eine weltkarte, ist das ein ascii video oder matrix bildschirm

03:25:42.980 --> 03:26:09.580
schon naja, ja so muss das sein, das ist der richtige hacker mode, ja so ist es in wirklichkeit

03:26:09.580 --> 03:26:24.340
und dann arrow geht nicht, vor allem ist es auch noch java, so genau so siehts aus, ist

03:26:24.340 --> 03:26:39.500
sein haus fertig renoviert, jaja klar seit jahren schon, ich mein 2013 sind wir eingezogen,

03:26:39.500 --> 03:26:47.500
das war dark, ich muss sagen, egal wie ordentlich ich was programmiere, wenn ich da nach einer

03:26:47.500 --> 03:26:55.180
gewissen zeit wieder ran muss hab ich nie bock, wann kommt das gartenstells video 3.0, ja

03:26:55.180 --> 03:26:59.740
ich hatte ja vor im december viele videos zu machen, von denen ich noch so gut wie nichts

03:26:59.740 --> 03:27:06.100
erledigt hab, ihr kennt mich, vielleicht gibt es dann auch wieder ein gartenvideo, arayan

03:27:06.100 --> 03:27:26.300
twitch prime, dankeschön, für den sub, eigentlich wollte ich jetzt Schluss machen, eigentlich

03:27:26.300 --> 03:27:32.500
wollte ich jetzt Schluss machen für heute, 21.55, ich bin müde, ich mein guck doch mal

03:27:32.500 --> 03:27:50.620
an wie lang ich heute gestreamt hab, war hier, heute morgen, heute morgen 4 Stunden und jetzt

03:27:50.620 --> 03:27:58.060
noch mal 3.5 Stunden, morgen cold war story stream, könnten wir eigentlich machen, ja

03:27:58.060 --> 03:28:11.300
ich freu mich wirklich auf die cold war story, ich fand black ops 2, 3 nicht schön von der

03:28:11.300 --> 03:28:19.020
story, 3 hab ich glaub ich die story gar nicht gespielt, aber 2, wirklich nice fand

03:28:19.020 --> 03:28:24.100
ich die black ops 1 story, also black ops 1 story find ich mit die beste cold of duty

03:28:24.100 --> 03:28:49.500
story, überhaupt ja, ok leute wisst ihr was, ich geh jetzt ins bett, machts gut, wir sehen

03:28:49.500 --> 03:28:56.260
uns, see you.

