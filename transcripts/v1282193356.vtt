WEBVTT

00:30.000 --> 00:41.760
So, kurz was trinken, müsst ihr mich dran erinnern, ich muss regelmäßig ertrinken

00:41.760 --> 00:47.160
im Livestream, sonst kriege ich so einen trockenen Hals und das merkt man spätestens so nach

00:47.160 --> 00:50.840
1-1,5 Stunden merke ich das und dann ist aber eigentlich zu spät.

00:50.840 --> 00:59.720
Deswegen jetzt ordentlich hydraten.

00:59.720 --> 01:11.480
Ich glaube Twitch hat noch gar nicht gecheckt, dass der Stream überhaupt online ist.

01:11.480 --> 01:18.000
Oh doch, jetzt ist es in 7 Leuten da, ganz davon abgesehen, so viele werden wir wahrscheinlich

01:18.000 --> 01:25.200
heute auch nicht werden, weil es ist 12.30 montags, oh das ist ein nice Seamote, wo kommt

01:25.200 --> 01:26.200
das her?

01:26.200 --> 01:28.840
Okay, sagt mir gar nichts, aber das finde ich gut.

01:28.840 --> 01:46.240
Also das war ein bisschen rare people, extra rare, also nicht gegrillt, sondern selbe,

01:46.240 --> 01:50.160
okay, ich glaube Twitch hat doch noch nicht gecheckt, dass der Stream online ist.

01:50.160 --> 01:53.080
Snacks, wie hast du es gefunden, zufällig oder über Notification?

01:53.080 --> 02:02.280
Weil das dauert immer unterschiedlich lang, mal dauert das 15 Sekunden, dann hat Twitch

02:02.280 --> 02:06.440
kapiert, mal dauert es aber auch 5 Minuten und es hat auch teilweise schon mal an die

02:06.440 --> 02:07.440
10 Minuten gedauert.

02:07.440 --> 02:14.360
Ich sehe das immer daran, wenn erstens wenn Notifications rausgehen und wenn auf einen

02:14.360 --> 02:19.480
Schwung irgendwie 40-50 Leute kommen, dann weiß ich immer, ah, jetzt hat es Discord,

02:19.480 --> 02:22.440
Discord hat es jetzt auch mitgekriegt, Stripes kriegt das immer über Discord mit.

02:22.440 --> 02:40.120
Hast du Urlaub oder ist das ein Pausestream, weder, noch, jetzt überleg mal scharf was

02:40.120 --> 02:45.400
sonst noch sein könnte, der Chat spoilert schon wieder, ich gehe montags nicht arbeiten.

02:45.400 --> 02:57.960
Ich kriege aber auch kein Geld für montags dann logischerweise.

02:57.960 --> 03:07.200
Hey Max fand es echt cool, das ist ein ITler YouTuber, ja ich bin ja so halbe halbe, gibt

03:07.200 --> 03:14.800
er in der Nähe wohnt, ja siehste, Pog wo wohnst du?

03:14.800 --> 03:20.480
Redux ist auch am Start, jetzt hat Twitch auf jeden Fall mitgekriegt, Moin aus der Pause,

03:20.480 --> 03:45.640
nice, Pausechamp, also quasi richtig echter Pausechamp, aus dem Gym, 12.35 montags, wer

03:45.640 --> 03:55.440
ist denn da im Findestudio, Hanau, ja da Hanau kenne ich auch, es ist lustig, dass ich als

03:55.440 --> 04:00.040
Benchmark für die Discord Notifications genutzt werde, ich weiß, dass du das immer über

04:00.040 --> 04:05.600
Discord kriegst, du bist Schauswängler, ja das kannst du bestimmt unter Weiterbildung

04:05.600 --> 04:30.480
buchen oder so, heute steppen wir mal wieder etwas unser Frontend Game ab und machen bisschen

04:30.480 --> 04:34.880
Datenbank Kram, ich zeige euch gleich wo wir stehen geblieben sind, ist nichts großartiges,

04:34.880 --> 04:40.680
also versteht man wahrscheinlich in zwei Minuten, haben nicht viel gemacht, wir haben bis jetzt

04:40.680 --> 04:45.920
mal ein bisschen Postgres rumgebastelt und ein Autocomplete Feld im Browser gebaut,

04:45.920 --> 04:50.600
ich zeig das gleich nochmal, aber ich hab eine, finde ich, müssen wir mal gucken ob

04:50.600 --> 04:57.000
das klappt, aber ich habe da eine Idee gehabt, wie wir das noch viel viel schneller machen

04:57.000 --> 05:06.080
können, aktuell haben wir Autocomplete Zeiten so von 70 Millisekunden oder sowas und ich

05:06.080 --> 05:08.960
hoffe wir kriegen es damit deutlich schneller, nicht dass man das bräuchte, es ist einfach

05:08.960 --> 05:24.640
nur dass es funktioniert, dass das geht, agiler Twitch Coder, ja genau, der Taunuskreis war

05:24.640 --> 05:28.880
dann alter Ausbildungsbetrieb, ok ich wusste gar nicht, dass die Physis oder sowas ausbinden,

05:28.880 --> 05:37.640
ja ich hab gern Mario Kart Playlist an, das ist nicht zu aufdringlich und nicht zu einschläfernd,

05:37.640 --> 05:43.800
also das ist optimale Mischung, finde ich für sowas, übrigens wusstet ihr, das muss ich

05:43.800 --> 05:50.680
jetzt mal revealen an der Stelle, ich hab vor zwei drei Tagen erfahren, dass mein Ur-Opa,

05:50.680 --> 05:58.280
nicht mein Opa, mein Ur-Opa, kurz gucken ob die Lautstärke von der Musik passt, ja ist

05:58.280 --> 06:09.760
ok, ich hab erfahren, dass mein Ur-Opa aus Südafrika gekommen ist und ich bin mir jetzt

06:09.760 --> 06:19.720
nicht sicher, ich bin ja eigentlich quasi ein Achtel Südafrikaner jetzt, Zulul, genau

06:19.720 --> 06:36.880
Zulul, verbotene Emotes hier, das muss vor dem zweiten Weltkrieg gewesen sein, das muss

06:36.880 --> 06:41.120
vor dem zweiten Weltkrieg gewesen sein, weil mein Opa war im zweiten Weltkrieg irgendwie

06:41.120 --> 06:54.440
so, keine Ahnung, 20 oder so, das muss also vor dem zweiten Weltkrieg gewesen sein, wo

06:54.440 --> 07:05.720
er in Südafrika war, mein Ur-Opa, Max hast du schon von dem Politiker in Afrika gehört,

07:05.720 --> 07:16.520
da gibt es nö, aber da gibt es einige, keine Ahnung, war relativ beliebt dahin auszuwandern

07:16.520 --> 07:27.880
und ein paar Jahre später wieder zurück, ernsthaft, vielleicht etwas unglücklicher

07:27.880 --> 07:38.840
Name auch für einen südafrikanischen Politiker, auf der anderen Seite wahrscheinlich hat

07:38.840 --> 07:43.560
er sich nicht ausgesucht, das ist aber doch schon ganz schön Payne's Champ, wenn man

07:43.560 --> 07:51.600
so heißt, was der ist Präsident von irgendeinem Land, sehr ernsthaft, ja, wo es nicht alles

07:51.600 --> 08:11.600
gibt, wie gesagt, ich bin ja auch zu einem Achtel Afrikaner, der war wegen Corona in den

08:11.600 --> 08:19.480
Medien, aha, wahrscheinlich wüsste sonst gar keiner, dass es den gibt, so, aber widmen

08:19.480 --> 08:28.080
wir uns mal wieder unserem Upsteppen des Frontend Games, Max wie powerst du deine ESP so, wenn

08:28.080 --> 08:31.840
ich jetzt sage mit Strom, wird dir das wahrscheinlich nichts helfen, du willst wahrscheinlich wissen,

08:31.840 --> 08:49.680
ob USB oder Batterie oder sowas in der Richtung, die meisten per USB, nahezu alle per USB, ich

08:49.680 --> 08:57.360
habe mir irgendwo mal so ein PoE Kit gekauft, da kann man das dann quasi, also da steckst

08:57.360 --> 09:01.920
du Kabel rein, Netzwerkkabel rein, machst PoE am Router oder am Switch an und der zwackt

09:01.920 --> 09:06.520
das ab und konvertiert dir das dann quasi in so einem Stecker in drinnen schon irgendwie

09:06.520 --> 09:16.360
in 5 Volt oder so, habe ich nie verwendet, ähm, ansonsten USB, ich habe eigentlich nur

09:16.360 --> 09:24.440
USB, USB für den ESP, Vollkornmilch pro Dange für den Zap, hat es wieder nicht gebimmelt

09:24.440 --> 09:31.680
heute, das ist sehr unzuverlässig gerade Steamlabs, oder ich habe es nicht gehört, ich habe nämlich

09:31.680 --> 09:36.080
gerade MassivePepoFat gemacht, Leute, es kann sein, dass ich ein bisschen hart gebimmelt,

09:36.080 --> 10:00.880
aber es kann sein, dass ich ein bisschen müde bin, weil Verdauung gerade einsetzt.

10:00.880 --> 10:13.760
Mein Stromverbrauch müsste relativ hoch sein, geht eigentlich, nee, warum, ich mein, weder

10:13.760 --> 10:22.200
Raspberry Piles noch ESPs brauchen nur sonderlich viel, dass es großartig auffällt, ich weiß

10:22.200 --> 10:30.920
aus dem Kopf nicht, keine Ahnung, also Gaspreise sind krass teuer geworden, wie sieht es mit

10:30.920 --> 10:37.720
PoE am Freitag aus, nee habe ich gerade Zeit für, kein PoE, mit dem ganzen Server, ja,

10:37.720 --> 10:45.880
das ist ein Inter-Low-Power-Server, der Eidl 8 Watt braucht, also das wird sich jetzt nicht

10:45.880 --> 10:50.720
nennenswert auf den Stromverbrauch auswirken, klar, sag mal so, ähm, die Festplatten, wenn

10:50.720 --> 10:55.800
die laufen, brauchen sie ein bisschen mehr, der braucht 8 Watt Eidl, Stripestesser, der

10:55.800 --> 11:01.480
braucht nix, inklusive SSD, allerdings ohne Platten, mit den Platten braucht er dann natürlich

11:01.480 --> 11:07.040
mehr, aber die Platten sind ja zum größten Teil im Sleep, da braucht mein 10G-Switch

11:07.040 --> 11:12.200
mehr, also ich glaube, das Netzwerkequipment braucht eine ganze Ecke mehr, ich mein, das

11:12.200 --> 11:20.920
ist der MikroTik-Router, der 10G-Switch, dann die 3 Access Points, die am Router über PoE

11:20.920 --> 11:28.920
dranhängen, und dann halt, dann noch die Fritzbox und dieses Ding von Unity Media, also da kommen

11:28.920 --> 11:33.400
wahrscheinlich, da kommen wahrscheinlich 50, 50 Watt Netzwerkgeräte zusammen, und

11:33.400 --> 11:41.560
der Server fällt da kaum ins Gewicht, ja, in dem Gehäuse ist tatsächlich 80% Luft

11:41.560 --> 11:48.320
drin, in dem Gehäuse ist ja noch, das Netzteil liegt ja auch mit drin noch und alles, so,

11:48.320 --> 11:56.040
ich mach mal kurz meine VM an, und dann erzähl ich euch, genug hier Lederhosen, Winkpippe

11:56.040 --> 12:01.360
gehabt, dann zeig ich euch mal, wo wir stehen geblieben sind, kann sein, ich glaube, ich

12:01.360 --> 12:06.840
muss erstmal VM kurz update und neu starten, habe ich so im, irgendwie das Gefühl, dass

12:06.840 --> 12:19.560
ich das machen muss, heute steppen wir mal wieder unser Frontend Game ab, genau, der

12:19.560 --> 12:25.320
Desktop, ja, der ist, finde ich schon, der ist sehr strukturiert, der mag jetzt vielleicht

12:25.320 --> 12:35.000
dem ein oder anderen nicht ordentlich erscheinen, aber der hat schon sein System, dein ganzes

12:35.000 --> 12:44.720
System, das ist aber ordentlich, ah, hier ist ja noch unser Datenbankgedöns, vorletztes

12:44.720 --> 12:55.160
Mal, alles klar, so, ich mach mal kurz, alles klar, eh, mal kurz, mal kurz, Update, ja,

12:55.160 --> 13:04.920
dachte ich mir, oh, Polkit, ja, das sollte man updaten, wieder mal Zeit, so, Polkit,

13:04.920 --> 13:10.120
Ghostman, wird auch wieder geupdatet, du hast alle Weihnachtseamots rausgeworfen, ich hab's

13:10.120 --> 13:16.680
gesehen, richtig Massive, Pog, weil ich hätte das nie gemacht, ihr kennt mich, wenn ich

13:16.680 --> 13:20.040
sowas mache, dann dauert das da ein halbes Jahr und dann ist eigentlich schon wieder

13:20.040 --> 13:33.880
Weihnachten, du hast auch schon einmal, ja, das macht keiner gerne, wofür nützt du deinen

13:33.880 --> 13:39.400
Surfer aktiv oder mehr oder weniger just for fun, Ackerman Blog, also, wenn du es genau

13:39.400 --> 13:45.680
wissen willst, was ich laufen hab daheim, dann gehst du auf meinen YouTube Channel und

13:45.680 --> 13:55.920
guckst dir das vor, vor vorletzte Video an, das, das Home-Surfer-Enjoyer-Video und da

13:55.920 --> 14:16.600
zeige ich dir 26, 25 Minuten lang, was ich wie wo hab. So, ich starte mal, ich starte

14:16.600 --> 14:26.640
mal kurz das Ding hier neu, jaja, hat er jetzt geupdatet? Okay, hoffe ich mal, ich starte

14:26.640 --> 14:40.920
mal kurz neu. Nächstes Jahr Weihnachten, dieses Jahr Weihnachten, ja, dann wird's da wieder

14:40.920 --> 14:45.000
eklig, weil das kann das Zebaro machen, das Zebaro ist die ganze Zeit schon immer afk

14:45.000 --> 14:50.080
und macht komische Dinger, was, was seh ich da im Hintergrund, was ist das? Das ist das

14:50.080 --> 14:53.680
Bing Image of the Day, also nicht, dass ihr denkt, ich wüsste, was auf meinem Desktop

14:53.680 --> 15:03.680
Hintergrund ist, was seh ich da? Leute mit Hut, die, ich hab keine Ahnung, irgendwelche

15:03.680 --> 15:15.480
Stimmen, Segel, nee, was ist das? Saffran, ja wirklich, ernsthaft, Lumen-Air, ist das

15:15.480 --> 15:25.640
so? Ich hätte jetzt eher gedacht, die stecken, die stecken das da rein. Alter Chat, Chat

15:25.640 --> 15:29.520
ist wieder richtig high IQ, Chat weiß sofort, was es ist, die ganzen Prime-Subs haben sich

15:29.520 --> 15:40.580
gelohnt, zahlt sich aus. Lohnt sich Ryder? Ja finde ich schon. Du kannst dir, wenn du

15:40.580 --> 15:46.080
viel von JetBrains verwendest, du kannst ein bisschen Kohle sparen, wenn du das Desktop

15:46.080 --> 15:57.980
Package kaufst. Also wenn du mehr als eins verwendest. Und kauf dir die Privatversion,

15:57.980 --> 16:03.760
wenn du es privat verwendest. Also hier für persönliche Nutzung, nicht hier Organisation.

16:03.760 --> 16:09.240
Für persönliche Nutzung kriegst du das All Products Pack für 250 Euro im Jahr und ab

16:09.240 --> 16:16.720
dem zweiten Jahr, also bis auf 60% geht das runter im dritten Jahr. Ich finde das lohnt

16:16.720 --> 16:23.000
sich, wenn man mehr als eins von denen verwendet. Weil allein schon, ich glaube JetBrains Ryder

16:23.000 --> 16:28.800
alleine kostet auch irgendwie 150 Euro oder sowas. Zeig mal, wo ist es denn? Entwicklertools.

16:28.800 --> 16:37.280
Muss mal kurz gucken, ich weiß es selbst gar nicht, was es kostet. Kaufen. Ja, nee, hier,

16:37.280 --> 16:45.160
fast. Guckt, also wenn man mehr als eins verwendet, lohnt sich eigentlich das All Products Pack

16:45.160 --> 16:56.600
schon wieder. Ich finde es nicht schlecht und ganz ehrlich, wenn man damit professionell

16:56.600 --> 17:04.240
oder semi professionell arbeitet, so viel sind 250 Euro bzw. wird dann immer weniger, geht

17:04.240 --> 17:09.320
dann irgendwie runter bis auf 190 oder irgendwie was. Ist das im Jahr jetzt auch nicht, wenn

17:09.320 --> 17:19.120
man das täglich oder öfters verwendet? Ist Ryder nicht dasselbe wie das Code? Nee. Ryder

17:19.120 --> 17:23.920
ist eher das wie Wishl Studio. Ryder ist quasi die Konkurrenz zu Wishl Studio, nicht

17:23.920 --> 17:31.000
zu Wishl Studio Code. Nur mit dem Unterschied, dass mir Ryder von den Funktionen und der

17:31.000 --> 17:37.200
Handhabung mittlerweile besser gefällt als Wishl Studio. Ich habe jahrelang auch für

17:37.200 --> 17:42.400
.NET und sowas Wishl Studio verwendet, aber seitdem ich jetzt hauptsächlich.NET, und

17:42.400 --> 17:45.960
das ist auch schon wieder jetzt die letzten paar Jahre,.NET hauptsächlich unter Linux,

17:45.960 --> 17:53.920
fast exklusiv unter Linux entwickle, ist halt Wishl Studio selbst keine Option mehr. Wishl

17:53.920 --> 18:00.160
Studio Code ist für.NET nicht so fein und Ryder ist super. Das verwenden wir mittlerweile

18:00.160 --> 18:09.360
unter Windows auch. Ja, aber noch nicht selbst aus, ich habe mir ein paar Videos zu angeguckt.

18:09.360 --> 18:14.280
Da bin ich mal gespannt, ob sie es da schaffen, Wishl Studio Code ein bisschen Konkurrenz

18:14.280 --> 18:21.520
zu machen. Für Java Script und Frontend zeug ich wahrscheinlich weniger, aber es gibt ja

18:21.520 --> 18:26.800
auch viele Plugins für Wishl Studio Code, die beliebt sind. Ja, von Go bis Rust und

18:26.800 --> 18:34.480
sonst was, vielleicht da. Für Go haben sie ja eine eigene IDE. So, ich zeige euch mal

18:34.480 --> 18:37.640
kurz wo wir stehen geblieben sind. Ich muss mal kurz die Musik da noch einen Ticken leiser

18:37.640 --> 18:51.560
machen. Das ist mir das zu anstrengend. So, oh, Leute. Ich muss, gestern hat schon einer

18:51.560 --> 18:57.680
gemeint, ich höre mich anders an. Das liegt daran, weil Teams mit der an meinem Mikrofon

18:57.680 --> 19:17.960
rumgestellt hat. Teams macht das gerne, weil Teams einfach nur zackt in der Richtung.

19:17.960 --> 19:23.400
Ich lege komplett von Windows zu Linux. Ja, dann überleg mal. Also, kann man jetzt ja

19:23.400 --> 19:31.000
auch hier gar nichts dazu sagen, wenn du nicht, zumindest ein bisschen erzählst, um was du

19:31.000 --> 19:38.120
machen willst. Also, einfach so ins kalte Wasser springen würde ich auf jeden Fall nicht.

19:38.120 --> 19:42.480
Ich würde mir erstmal, ich würde noch nicht mal das machen, ich würde es erstmal so machen

19:42.480 --> 19:46.800
wie ich Linux in eine VM packen unter Windows und mir das ein bisschen angucken, weil du

19:46.800 --> 19:52.960
kannst nahezu alles relativ gut in einer VM machen. Außer Videos gucken und sowas, dann

19:52.960 --> 19:59.160
ist ganz schön hohe CPU-Last. Aber zum Ausprobieren ist eine VM das beste, was du machen kannst.

19:59.160 --> 20:07.720
Das hast du schon gemacht, ja. Wenn es da nichts mehr gibt, was du exklusiv unter Windows

20:07.720 --> 20:13.400
machst, ja, warum nicht? Kann man ja machen. Aber dann gleich Art-Schließungs, Art-Schließungs

20:13.400 --> 20:19.360
by the way. Und dann die Menschheit bekehren, dass alle Art-Schließungs verwenden. So,

20:19.360 --> 20:22.840
ich zeige euch mal kurz wo wir stehen geblieben sind. Wie habe ich denn das Projekt genannt?

20:22.840 --> 20:37.400
SearchChamp. Also.net run. Und jetzt, wie ist das Frontend-Ding? Ah, Frontend, da hätte

20:37.400 --> 20:42.480
ich auch selbst drauf kommen können. So, also ich zeige euch mal kurz was wir das letzte

20:42.480 --> 20:49.600
Mal gebaut haben. Wir haben ein Autocomplete-Feld, ob ich das Studio Code vielleicht aufmache

20:49.600 --> 20:58.200
neben dran. Ja, also wir haben ein Autocomplete-Feld gebaut, was Sachen vom Server autocompleted,

20:58.200 --> 21:15.640
ja. Wenn ich jetzt hier z.B. eintippe A oder S, dann sollte das normalerweise autocompleten.

21:15.640 --> 21:26.040
Was ist, oh, oh, was ist hier los? Ah, ich weiß woran es liegt. Chat, warum sagt mir

21:26.040 --> 21:43.360
das denn keiner? Die Datenbank läuft nicht. Wie? Hä? Warum ist mein Datenbank-Image weg?

21:43.360 --> 21:58.520
Jetzt bin ich verwirrt. Wo ist mein Datenbank-Image hin? Wo waren wir denn hier? Temp, pg, data.

21:58.520 --> 22:13.800
Äh ja, sudo, denkst dir. Ok, die Datenbank-Daten sind noch da. Die Datenbank-Daten sind noch

22:13.800 --> 22:19.440
da, hier, 1,6 Gigabyte, ok. Docker-Run? Ah, weil ich ja M gemacht habe. Keg-Wait. Warum

22:19.440 --> 22:27.440
mache ich auch so ein Mist? Ja gut, aber das schöne an Containerkram ist, die Daten sind

22:27.440 --> 22:32.920
ja noch da. Rest kann ich einfach so lassen. Bam, wieder starten. Und dann sollte das eigentlich

22:32.920 --> 22:43.040
wieder funktionieren. Schauen wir mal, ob es jetzt autocompleted, neu laden, ha, ha,

22:43.040 --> 22:48.000
der Harold, da ist er. Also wir haben so ein autocomplete-Ding gebaut, da kann man z.B.

22:48.000 --> 22:55.000
dann sowas hier eingeben. So hier, Ashley, autocompleted ist oder Dom oder so oder Punkt

22:55.000 --> 23:02.960
Name. Das sind übrigens random Daten, die er da generiert. Host, ne Host haben wir da

23:02.960 --> 23:08.280
nicht drinne. Das sind random, hier Punkt Net oder so. So, wir haben so ein autocomplete-Ding

23:08.280 --> 23:20.120
gebaut und das autocomplete-Ding ist halt relativ schnell, weil wir haben 1,6 Gigabyte,

23:20.120 --> 23:30.880
Penny Punkt Name, Klassik. Penny. Oh ja, beste, beste. Ganz schön viele Leute die gleiche

23:30.880 --> 23:43.640
Domain, oder? Penny Punkt Name. Ja, und das autocomplete ist relativ schnell, obwohl wir

23:43.640 --> 23:52.400
haben eine Postgres-Datenbank mit 1,6 Gigabyte und ich glaube irgendwie 4,5 Millionen Einträgen

23:52.400 --> 24:02.720
oder so. Was ist denn 3000 mal 1500? Ja, also wir haben, habe ich doch richtig im Kopf, wir

24:02.720 --> 24:07.920
haben 4,5 Millionen Einträge in der Datenbank, die alle gleich aussehen, die alle aus einem

24:07.920 --> 24:11.600
Vorname bestehen und einer Domain. Die Daten sind eigentlich relativ egal, das geht ja

24:11.600 --> 24:16.760
nur, dass man da schnell autocompleten kann. So, also wir haben eine Datenbank mit 4,5 Millionen

24:16.760 --> 24:24.840
Elementen drin und die ist insgesamt 1,6 Gigabyte groß und ihr seht, so das autocomplete ist

24:24.840 --> 24:31.560
schon sehr schnell. Wir brauchen für einen Datenbank-Query ungefähr 7 und 3, also 28

24:31.560 --> 24:37.560
bis 37 Millisekunden. Am langsamsten sind die Queries, wo man nur ein Buchstabe eingibt,

24:37.560 --> 24:45.240
der dauert 284 Millisekunden, weil der dann halt relativ viel zu suchen hat. Und da habe

24:45.240 --> 24:55.280
ich mir gedacht, das können wir jetzt noch ein bisschen optimieren. Das ist eine gute

24:55.280 --> 25:03.200
Frage. Ok, das ist die high IQ Chatfrage. Wäre das auch noch schnell, wenn deine Anwendung

25:03.200 --> 25:12.240
bei 100.000 User hätte oder skaliert deine Lösung Scheiße? Naja, das ist Read-Only,

25:12.240 --> 25:16.560
das spricht schon mal dafür, dass das relativ schnell sein müsste, auch bei mehreren Usern

25:16.560 --> 25:22.480
gleichzeitig. Postgres Read-Only ist ja kein Ding. Also ich würde sagen, das müsste auch

25:22.480 --> 25:31.960
bei 100.000 Usern relativ schnell gehen. Ob das jetzt mega krass diagonal, horizontal

25:31.960 --> 25:35.680
und vertikal skaliert, müsste man ausprobieren. Aber im Prinzip würde ich sagen, ja, das

25:35.680 --> 25:41.880
wird wahrscheinlich auch mit 100.000 Usern relativ schnell gehen. Wäre für so eine Anwendung

25:41.880 --> 25:49.160
nicht Redis perfekt? Naja, Redis wäre insofern von der Idee her nicht schlecht, weil es rein

25:49.160 --> 26:01.880
in Memory ist. Aber das Problem an Redis ist, mach mal 4,5 Millionen Einträge rein in Memory

26:01.880 --> 26:09.640
sind. Das braucht schon ein bisschen RAM, das ist das erste. Und das zweite ist, wahrscheinlich

26:09.640 --> 26:16.640
ist es sogar langsamer als Postgres in dem Fall, weil Postgres explizit einen Modus hat

26:16.640 --> 26:25.320
für Textsuche, der das ganze beschleunigt. Soll ich euch mal versuchen, so weit wie ich

26:25.320 --> 26:28.600
es verstanden habe, zu grob zu erklären, wie das Postgres macht. Das ist eigentlich

26:28.600 --> 26:37.720
relativ sechsköpfig. Und zwar, wenn man Postgres sagt, dass man jetzt Text in die Datenbank

26:37.720 --> 26:44.120
speichert, zum Beispiel das Wort Hallo möchte man in die Datenbank speichern. Allerdings

26:44.120 --> 26:50.640
so, dass man es schnell wieder finden kann, schnell wieder durchsuchen kann. Dann speichert

26:50.640 --> 26:56.000
Redis, dann speichert Postgres das normalerweise halt einfach als Feldtext. Einfach Hallo

26:56.000 --> 27:00.000
drin und gut ist. Dann kannst du aber nicht schnell suchen, weil dann musst du ja vom

27:00.000 --> 27:09.440
ersten Eintrag der Datenbank bis zum letzten Eintrag der Datenbank suchen. Und was Postgres

27:09.440 --> 27:17.840
macht, ist jetzt folgendes, damit Postgres das macht, muss man folgendes setzen, man

27:17.840 --> 27:24.080
muss diese zwei Sachen in Postgres einschalten. Also man muss diese Postgres Erweiterung laden,

27:24.080 --> 27:32.480
und man muss sagen, dass er ein Textsuche, wie auch immer, Index anlegen soll da drauf.

27:32.480 --> 27:37.320
So, und was Postgres jetzt macht, ist, um das schnell durchsuchbar zu machen, der macht

27:37.320 --> 27:46.520
aus diesem Wort 3er Buchstabenpaare. Das heißt, Postgres macht daraus dann irgendwie

27:46.520 --> 28:02.600
sowas, macht irgendwie h, und dann h a, a h, glaube ich, und dann h l, a, und so, so.

28:02.600 --> 28:07.160
Diese Varianten werden da irgendwie rausgebastelt. Das kann man sich, Moment, das kann man sich

28:07.160 --> 28:12.400
sogar anzeigen lassen. Ich warte mal, ich lasse mir das mal anzeigen. Da gibt es nämlich

28:12.400 --> 28:18.920
eine fertige Funktion, die das macht. Wartet mal, das machen wir jetzt. EF, Functions, Show,

28:18.920 --> 28:26.800
hier, so. Also das, was Postgres speichert, hör hallo. Natürlich speichern wir den Text

28:26.800 --> 28:31.720
nur in klein, weil wir ja case insensitiv suchen wollen. Was kommt da übrigens zurück

28:31.720 --> 28:38.200
jetzt? Ein String Array, ok. Schleife, gucken wir uns das mal an, was Postgres daraus macht.

28:38.200 --> 28:48.200
Ja, lul, cw, lul, return, zack. So, gehen wir uns das mal aus. Also aus hallo, macht

28:48.200 --> 29:02.240
Postgres. Was? Ach, das muss man in einem Query machen, das kann man nicht einfach so

29:02.240 --> 29:28.160
machen, oder wie? Wie soll ich denn daraus einen Query bauen? Hä? Ok, wir gucken uns

29:28.160 --> 29:35.520
jetzt einfach ein Beispiel an. Example. Gibt es ja schon genug Leute, die das machen. Kennst

29:35.520 --> 29:46.080
du mich mit QuestDB aus? Nein. Hier, also. Das macht immer so dreier Buchstabenpaare

29:46.080 --> 29:55.120
daraus. Und dann speichert es das in irgendeinem sortierten Index oder so ab. Zumindest hat

29:55.120 --> 29:59.320
das den Vorteil, dass man dementsprechend relativ schnell Wildcards suchen machen kann.

29:59.320 --> 30:05.880
So nach dem Motto enthält ein Wort den Buchstabe a oder enthält ein Wort die Zeichenfolge

30:05.880 --> 30:11.160
ca oder sowas. Das geht dann relativ schnell, weil er die Wörter ja schon so aufgesplittet

30:11.160 --> 30:16.400
speichert und sich in seinem Index per Binary Search relativ schnell da lang hangeln kann.

30:16.400 --> 30:22.520
So reime ich mir das zumindest zusammen. Nachteil ist, Rides dauern länger und die Datenbank

30:22.520 --> 30:27.360
wird viel größer. Das ist ja oftmals so. Das ist immer so ein bisschen Tradeoff zwischen

30:27.360 --> 30:37.560
Größe und Aufwand, dass man es dann schneller wieder rauskriegt. Select Word. Ok, das probieren

30:37.560 --> 30:44.760
wir jetzt mal aus, ob das funktioniert. Also ich soll da einen Query daraus machen. Ok.

30:44.760 --> 30:57.280
Raw SQL. Database. Raw SQL. Execute Raw SQL. Ok, also. Mal schauen. Hab ich noch nie gemacht.

30:57.280 --> 31:05.160
Mal gucken, ob wir das Postgres irgendwie entlockt kriegen. Was ist denn das? Show.

31:05.160 --> 31:18.640
Hier. Ok. Select. Alles klar. So. Wir wollen nicht Word-Similarity, sondern Show drücken.

31:18.640 --> 31:25.360
Für Hallo. Für Hallo. So. Gucken, ob das funktioniert. Das knallt jetzt wahrscheinlich

31:25.360 --> 31:29.480
gleich wieder. Und was kommt da als Ergebnis raus? Ein String oder was? Oder wie Execute

31:29.480 --> 31:54.360
Raw SQL. Ne. Ey, keine Ahnung, wie das funktioniert. Ja, Update, Update. Weiß nicht, wie ich das

31:54.360 --> 32:01.560
dem beibringen kann. Ja, super, aber da kriege ich doch jetzt keine Ausgabe von. Ja, nice,

32:01.560 --> 32:08.320
nice. Das Query funktioniert, aber ohne dass die Ausgabe. Ok. Execute Raw SQL. Output.

32:08.320 --> 32:36.240
EF Core Output. Also mal gucken, wie das haut. Oh, jetzt wird es High IQ. Moment. Was?

32:36.240 --> 32:51.800
Da kommt ein Int zurück. Warum kommt da eigentlich ein Int zurück? Warum kommt da ein Int zurück?

32:51.800 --> 32:59.200
Warum kommt da nicht irgendein Text Output zurück? Aber wir können das ja einfach mal

32:59.200 --> 33:06.800
mit pet-docker machen und uns connecten in die Datenbank. Hier, Docker, PS, noch mal

33:06.800 --> 33:21.040
Bash. Bin, Bash. So, Docker, Exec, Postgres. Ne, Container-ID Bin-Bash. Ne, das war. Ach,

33:21.040 --> 33:33.640
wie ging das noch mal? Minus. Number of Affected Roles kommt zurück. Ja, super. Ich will aber

33:33.640 --> 33:43.400
den Text, den Text. Wie ging das? IT, IT war das. Genau. Ja. So, PSQL. Failed. Wie

33:43.400 --> 33:51.520
jetzt? Ich darf mich nicht auf meine eigene Datenbank verbinden oder was? Minus U. Postgres.

33:51.520 --> 33:57.480
Ne, was ist, was ist User? Wir machen wieder Zeug, was ich überhaupt nicht machen wollte,

33:57.480 --> 34:07.240
aber ok. User. U. Da sind wir. Postgres. So. Kommandosignal. Select. Sternchen. From.

34:07.240 --> 34:15.320
Was? Ah, wir müssen uns erst mal zur Datenbank verbinden. Sekunde, erst mal wieder öffnen.

34:15.320 --> 34:24.520
Was ist das Minus? Wie gibt man die Datenbank an, wohin man sich verbinden will? DB Name,

34:24.520 --> 34:37.400
Minus D. So, und unsere Datenbank heißt wie? Unsere Datenbank heißt QChat Database. So,

34:37.400 --> 34:47.720
ok. Jetzt aber. Select. Jetzt funktioniert's. Nice. Also, das sind diese, das sind diese

34:47.720 --> 34:54.920
Triple Buchstabenpaare, die Postgres für das Wort Hallo speichert in der Datenbank.

34:54.920 --> 35:00.560
Also HA, HA, AL und dann HAL und dann LO und so. So, und wenn er das jetzt abspeichert,

35:00.560 --> 35:05.280
dann kannst du relativ easy feststellen, ob ein Wort eben beispielsweise einen Buchstaben

35:05.280 --> 35:13.800
enthält. Der kann dann einfach in seinem, wenn du wissen willst, enthält ein Wort A,

35:13.800 --> 35:22.520
dann guckt er in seinem Index nach und stellt fest, ah ja klar, A fängt mit A an. Das heißt,

35:22.520 --> 35:25.920
er kann dann wahrscheinlich per Binary Search oder wie auch immer, die die das genau machen,

35:25.920 --> 35:33.240
ziemlich schnell finden, auch wenn du das, was du suchst, mitten im Wort ist. Und du

35:33.240 --> 35:38.520
kannst trotzdem auch Wort teilen, also wenn du wissen willst, enthält das, enthält das

35:38.520 --> 35:46.240
irgendwie LO oder LL oder so. Dann kann er hier auch nachgucken. Dementsprechend sind

35:46.240 --> 35:52.160
die Queries auch so schnell, weil er für jeden Texteintrag so ein Ding hier erstellt. Also,

35:52.160 --> 35:56.120
du hast zwar nur einen Text, aber in der Datenbank speichert er ganz viele verschiedene Abwandlungen

35:56.120 --> 36:02.120
bzw. Teile davon. Und deswegen dauert ein Insert länger und deswegen ist die Datenbank

36:02.120 --> 36:09.040
auch größer, weil er nicht einfach nur Text in irgendeinem Datenbankfeld drin speichert, sondern da

36:09.040 --> 36:13.000
noch ein paar Sachen für machen muss und auch mehr Sachen speichern muss. Aber deswegen sind

36:13.000 --> 36:18.520
die Queries, wenn du wissen willst, enthält das ein A, enthält das ein H, enthält das HL oder so,

36:18.520 --> 36:25.280
viel schneller. So, so weit zur Theorie. Ich habe mir jetzt folgendes überlegt, was man machen

36:25.280 --> 36:32.360
könnte ist. Also aktuell sehen wir ja, die Queries dauern irgendwie, ich höre das mal wieder aus,

36:32.360 --> 36:42.480
das ist Donkey Kong Musik, oder? So, die Queries dauern hier so ungefähr, wenn man hier mal nach

36:42.480 --> 36:50.000
Name sucht. Hier 100, 100, Name gibt es halt oft, 191 Millisekunden. Wenn man sich mal überlegt,

36:50.000 --> 36:55.640
das ist relativ gut eigentlich schon für eine Datenbank mit 4,5 Millionen Texteinträgen und die

36:55.640 --> 37:01.240
1,6 Gigabyte groß ist. Aber ich glaube, wir können das noch viel, viel, viel schneller machen,

37:01.240 --> 37:06.920
wenn ich die Datenbankabfrage sinnvoll mache, weil meine Datenbankabfrage ist ziemlich dumm. Ich bin

37:06.920 --> 37:12.160
nach dem letzten Stream aufgefallen, weil ich zeige jetzt, ich zeige mal hier, wie das hier

37:12.160 --> 37:18.400
im Frontend funktioniert. Wenn man hier in diesem Suchfeld was eingibt, dann ruft er,

37:18.400 --> 37:24.440
es ist natürlich groß hier, guck, das ist mit HTML und CSS und JavaScript zusammen mit 127 Zeilen,

37:24.440 --> 37:30.560
der ruft diese Funktion auf bei jedem Tastendruck quasi in diesem Inputfeld hier, Query Server,

37:30.560 --> 37:40.520
und, muss ich mal kurz überlegen, hier ist das Value vom Inputfeld, genau. So, und er ruft diesen

37:40.520 --> 37:45.120
Endpunkt auf in unserem Backend, ja, slash api slash search und dann übergibt er das Value,

37:45.120 --> 37:52.480
was hier oben im Inputfeld drinne steht. Und das hier ist die Funktion, die auf dem Server

37:52.480 --> 37:57.960
aufgerufen wird, api slash search query. Das ist übrigens auch richtig dumm gemacht. Ich

37:57.960 --> 38:04.200
müsste jetzt eigentlich irgendwie so, ich weiß gerade gar nicht, wie da die richtige Syntax für

38:04.200 --> 38:11.280
ist. So, und was würde es länger dauern, wenn die DB-Einträge vom Wort an sich länger wären und

38:11.280 --> 38:19.320
spielte das? Naja, das ist ja das Schöne daran. Es dauert länger beim Einfügen und es wird größer,

38:19.320 --> 38:25.200
umso länger das Ganze ist. Aber die Suche, die wird wahrscheinlich auch minimal langsamer,

38:25.200 --> 38:31.880
aber im Prinzip bleibt die Suchzeit relativ konstant. Das ist ja gerade das Gute daran.

38:31.880 --> 38:39.960
Weil normalerweise, wenn du linear die Datenbank durchsuchen würdest, dann wird es halt mit der

38:39.960 --> 38:48.640
Länge immer länger. Majorink, danke für den Sub. So, und jetzt gucken wir uns bei meinen

38:48.640 --> 38:52.960
Datenbankquery an. Das ist nämlich ziemlich dumm, ist mir im Nachhinein eingefallen. Also,

38:52.960 --> 38:59.800
was wir abfragen ist folgendes Text-Values ist die Tabelle. Nee, nicht die, doch. Nee,

38:59.800 --> 39:07.360
nicht Tabelle. Wie nennt man das? Doch Tabelle, ne? Text-Values. Text-Values ist die Tabelle. In

39:07.360 --> 39:16.360
dem Fall bei ASP.io heißt es DB-Set. So, Text-Values sieht in.NET sieht dann so aus. Das ist eigentlich

39:16.360 --> 39:23.880
nur eine Klasse mit einer ID und dem Text zum Durchsuchen. Hält sich wirklich in Grenzen. Da

39:23.880 --> 39:30.640
ist wenig, wenig, was wir extra gemacht haben, um uns aufs Eigentliche zu konzentrieren. So,

39:30.640 --> 39:36.080
und die Datenbankabfrage ist ziemlich doof. Also, in dieser Tabelle mit Text-Values, also das,

39:36.080 --> 39:40.680
quasi das einzige, was in der Datenbank steht, machen wir ein Wear. Sagen, okay, wir suchen alle

39:40.680 --> 39:47.800
Einträge, die, und das ist Postgres, das ist Postgres-Magic. Was macht das DB-Set? Du musst

39:47.800 --> 39:55.160
in Entity Framework Core, wenn du das verwenden willst, und damit du Queries gegen eine Datenbank

39:55.160 --> 40:01.240
machen kannst, muss das in einem DB-Set sein. Das ist halt so von den Framework-Erstellern gedacht.

40:01.240 --> 40:08.160
DB-Set stellt dir dann Methoden zur Verfügung, worauf du Datenbank-Queries machen kannst. Also,

40:08.160 --> 40:14.040
Wear, Order, Buy und so was in der Richtung. Das geht nur, weil es ein DB-Set ist. Also,

40:14.040 --> 40:20.560
wir gucken Einträge, die, und das hier, wie gesagt, ist Postgres-Magic, die unser Query enthalten. Also,

40:20.560 --> 40:26.720
in dem Fall wäre das jetzt Name. Und davor und danach ist ein Prozent. Prozent ist in Postgres

40:26.720 --> 40:34.000
Wildcard. Also, sprich, das Query kann irgendwo stehen. Also, Name kann irgendwo hier drinstehen,

40:34.000 --> 40:38.680
ist vollkommen egal. Also, wenn ich nach Geo suche, zum Beispiel, funktioniert das halt richtig,

40:38.680 --> 40:43.480
weil ich sortiere, aber der würde auch Sachen hier drinnen finden. Aber ich ordne das hier

40:43.480 --> 40:47.800
eben, wenn es ihn anfängt. Wir können auch HTTP suchen, zum Beispiel. Also, seht ihr,

40:47.800 --> 41:02.600
also er findet die Sachen, egal wo sie stehen. Was ist dieses Get und Set? Da? Das? Das ist ein,

41:02.600 --> 41:09.040
wie heißt das in C-Sharp? Automatic Property oder sowas? Weiß gar nicht, wie man das offiziell

41:09.040 --> 41:15.200
nennt. Also, das ist Getter und Setter, wie es das in Java auch gibt. Auto-Property, Auto-Property,

41:15.200 --> 41:19.520
genau. Das ist Get Set, wie es das in so fast jeder objektorientierten Sprache gibt. Nur

41:19.520 --> 41:27.880
mit dem Unterschied, dass der im Hintergrund das eigentliche, die eigentliche Variable anlegt. Die

41:27.880 --> 41:35.040
musst du nicht mal selbst machen. Also, das hier ist die Kurzvariante von, weiß gar nicht, ob man

41:35.040 --> 41:45.360
das hier, genau. Das ist die Kurzvariante von dem hier. Du hast ein privates, eine private Variable

41:45.360 --> 41:51.920
Text und dann hast du Getter und Setter für diesen Text. Früher hat man das übrigens nicht so

41:51.920 --> 42:08.320
geschrieben. Es geht noch länger. Früher hat man das übrigens so geschrieben. Ups. Früher

42:08.320 --> 42:18.080
hat man das so geschrieben. Da musst du halt so viel Gedöns schreiben, obwohl du eigentlich

42:18.080 --> 42:29.600
auch einfach nur das schreiben könntest. Was ist da von der Unterschied zu einfach String Text?

42:29.600 --> 42:36.560
Von der Funktion her ist das das gleiche. Du könntest auch sowas hier machen. Unterschied

42:36.560 --> 42:40.680
zeige ich dir gleich. Du könntest auch sowas hier machen. Keine Ahnung, sowas. Public Variable

42:40.680 --> 42:48.840
könntest du auch machen. Der Unterschied ist, in dem Beispiel eigentlich keiner, der Unterschied

42:48.840 --> 42:57.320
ist, dass du in dem Fall noch zusätzlich was machen könntest, wenn du willst. Also,

42:57.320 --> 43:04.000
du könntest zum Beispiel anstatt, du könntest das Set zum Beispiel weglassen, dann wäre das

43:04.000 --> 43:11.240
Read Only und du könntest hier drinnen zum Beispiel gar keine Variable machen, sondern einfach Return,

43:11.240 --> 43:17.920
was Statisches oder so zurückgeben. Also, du kannst hier drinnen dann quasi zur Get und Set

43:17.920 --> 43:24.640
Zeit noch beliebigen, beliebigen Code laufen lassen. Du könntest hier an der Stelle auch machen,

43:24.640 --> 43:44.960
hier get google.de HTTP Request und dann die Antwort Return oder sowas. In der Regel sagt

43:44.960 --> 43:56.720
man halt, dass Public Variablen nicht best practice sind und dass man die Variablen privat

43:56.720 --> 44:01.320
machen sollte in die Klasse und wenn man darauf zugreift, das Ganze entweder über irgendeine

44:01.320 --> 44:07.080
Funktion macht, die dann oftmals Get und Set heißt und deswegen haben die sich bei Microsoft

44:07.080 --> 44:13.400
überlegt, dass es ein sinnvolles Feature ist, das direkt in die Sprache einzubauen. In Java

44:13.400 --> 44:16.880
würdest du, ich weiß übrigens nicht, ob sowas, ich sagte das nur vor ein paar Jahren, ich mache

44:16.880 --> 44:21.680
wenig, so gut wie gar kein Java. Also, in Java würdest du dann sowas hier machen, zum Beispiel

44:21.680 --> 44:41.320
String Get Text und da würdest du dann sagen Return Private Text oder so. Ja, du könntest in einem

44:41.320 --> 44:51.040
Set auch checken, ob es Null ist und sowas. Ja, kannst du alles machen. Ja, dann ist es sehr

44:51.040 --> 45:01.480
ähnlich in Java. Zumindest sind Public Variablen in der Regel nicht gerne gesehen. Der einzige

45:01.480 --> 45:08.440
Unterschied ist, also wo ich das tatsächlich okay und sinnig finde, wenn man lokale Variablen

45:08.440 --> 45:19.280
Public macht, ist das in irgendwelchen Interop Szenarien. Also, wenn du jetzt irgendeinen Struct

45:19.280 --> 45:29.200
hast oder irgendeine Klasse, die du an irgendwelche unsafe FFmpeg Bindings übergibst, um dann da

45:29.200 --> 45:34.160
irgendwie Video Frames reinzuschreiben oder sowas in der Richtung, da kannst du dem Zeug

45:34.160 --> 45:44.400
nicht mit C-Sharp, Getter und Setter kommen. Da musst du Oldschool, Public, Int, Bloop machen.

45:44.400 --> 45:55.840
Aber solange man sich im ganz normalen Managed-Land bewegt, würde ich das immer so machen. Hat

45:55.840 --> 46:03.640
bestimmt noch mehr Vorteile, die ich gerade nicht draufkomme. Ja, okay, aber wenn wir uns

46:03.640 --> 46:15.080
das Datenbank-Query angucken, ich muss was drehen. Chat sagt mir, dass ich trinken muss.

46:15.080 --> 46:26.880
Bisschen kompliziert. Die.net-Schreibweise finde ich nicht so ganz gut. Kannste ja eigentlich

46:26.880 --> 46:38.480
merken, sobald es Public ist, schreibst du es so. Fertig. Also, das Query, und ich zeige,

46:38.480 --> 46:42.280
ich verrate euch jetzt auch klein, warum ich denke, dass das langsam ist. Ob das so ist,

46:42.280 --> 46:50.680
müssen wir ausprobieren. Also, Datenbank-Query. Text-Values-Saw. Wo das Postgres Magic Wildcard,

46:50.680 --> 46:54.000
also das habe ich ja gerade schon erklärt. Er nimmt das Query, in dem Fall hier Name

46:54.000 --> 47:04.040
oder HTTP ist es jetzt, sagt, ich suche Wörter, die davor egal, danach egal, aber irgendwo

47:04.040 --> 47:10.680
dazwischen, zwischen egal, HTTP enthalten. Also, das ist quasi Wildcard-Character in

47:10.680 --> 47:18.840
Postgres. HTTP, was davor kommt, ist egal, was danach kommt, ist egal. So, das an sich

47:18.840 --> 47:24.520
ist relativ schnell. Dadurch, dass wir das eben hier mit dieser, ich habe es jetzt nicht

47:24.520 --> 47:30.720
mehr angezeigt, mit dieser Treecrime-Funktion von Postgres machen. Was ich allerdings ziemlich

47:30.720 --> 47:39.720
bescheuer das mache, ist das hier. Danach sage ich, order by descending, und zwar in

47:39.720 --> 47:44.640
der Richtung, wenn der Text mit dem Query anfängt. Also, ihr seht es ja zum Beispiel,

47:44.640 --> 47:49.520
wenn ich jetzt nach hier Hazen, nach Huts suche zum Beispiel, dann sind die Einträge,

47:49.520 --> 47:54.880
die damit anfangen, oben. Und damit das der Fall ist, das ist was, was ich haben will,

47:54.880 --> 48:01.160
damit das der Fall ist, sage ich, order by. Und in dem Fall sage ich mir, okay, sortiere

48:01.160 --> 48:09.320
mir das, danach die Einträge nach oben, wo der Text eben dieses Query am Anfang stehen

48:09.320 --> 48:14.760
hat. Das ist schon ziemlich doof, weil auf der einen Seite suche ich Wildcard und danach

48:14.760 --> 48:18.240
sortiere ich die, da habe ich das letzte Mal auch nicht drüber nachgedacht, und danach

48:18.240 --> 48:22.960
sortiere ich die nach Dingern, die quasi damit anfangen, da könnte ich das Wear schon komplett

48:22.960 --> 48:30.760
anders schreiben. Und, wenn ich zum Beispiel hier jetzt mal nur nach H suche, und ich keine

48:30.760 --> 48:38.200
Ahnung, jetzt 2 Millionen, 2 Millionen Einträge in der Datenbank finde, dann sortiert der

48:38.200 --> 48:45.880
mir hier 2 Millionen Einträge absteigend und von diesen Dingern, die er sortiert hat,

48:45.880 --> 48:52.200
nimmt er dann am Ende nur 10. Also das ist jetzt nicht unbedingt gerade das alleroptimalste,

48:52.200 --> 49:00.320
was man so machen kann. Und danach gibt er nur den Text zurück, anstatt, aber unten

49:00.320 --> 49:05.000
ist erstmal wurscht. Also das hier ist das, was es langsam macht. Und wir können jetzt

49:05.000 --> 49:09.160
mal überprüfen, ob das wirklich das ist, was es langsam macht, weil ich nehme das einfach

49:09.160 --> 49:13.800
mal raus. Und dann gucken wir mal, ob das schneller ist. Also aktuell sind Queries mit einzelnen

49:13.800 --> 49:20.920
Buchstaben so 315, 400, irgendwas Millisekunden lang. Und jetzt machen wir mal die Queries

49:20.920 --> 49:25.680
ohne dieses Sortieren. Das ist nicht das, was ich haben will als Ergebnis, aber nur mal,

49:25.680 --> 49:33.720
dass man die Hausnummer sieht. So, guck mal, und jetzt sind einzelne Queries für ein Buchstabe

49:33.720 --> 49:40.120
sind schon nur noch 3 Millisekunden lang. Also das Order By macht es einfach um den Faktor,

49:40.120 --> 49:47.280
keine Ahnung, 100, 200, langsamer. Das ist jetzt allerdings nicht das, was ich haben will.

49:47.280 --> 49:58.240
Weil, wenn ich hier nach Huts suche, es ist nicht die Einträge, die mit Huts anfangen

49:58.240 --> 50:03.720
oben. Und das ist ja das, was ich eigentlich will. Deswegen habe ich mir überlegt, wir

50:03.720 --> 50:07.360
könnten das folgendermaßen machen. Und da bin ich mir nicht sicher, ob das gescheit

50:07.360 --> 50:12.440
funktioniert. Also das Order By ist ja auf jeden Fall eine ziemlich dumme Idee gewesen,

50:12.440 --> 50:16.600
wie ihr jetzt seht. Aber es ist vielleicht noch mal, damit man da mitkommt. Ich weiß

50:16.600 --> 50:23.640
nicht, Chat, hat man das verstanden, warum das langsam ist? Ja, mit Index ist auch so

50:23.640 --> 50:26.320
ein Ding. Das könnte man bestimmt sogar, das Order könnte man wahrscheinlich auch

50:26.320 --> 50:31.000
noch beschleunigen. Ja, aber es ist langsam, weil er hier 2 Millionen Einträge findet,

50:31.000 --> 50:41.960
die erst einmal alle sortiert und danach nur 10 Stück davon nimmt. Ja. Ich könnte mir

50:41.960 --> 50:45.760
vorstellen, dass der Index hier drauf vielleicht sogar das schneller macht. Aber wir können

50:45.760 --> 50:56.600
das, glaube ich, deutlich besser machen. Zwar, warum hast du auch mal vor, ein kleines Spiel

50:56.600 --> 51:03.560
zu programmieren? Nee, Spieleprogrammierung, obwohl ich quasi täglich MMO, Kreiselgrinden,

51:03.560 --> 51:06.800
alles mögliche mache, ich spiele ja viel. Aber Spieleprogrammierung ist tatsächlich

51:06.800 --> 51:22.360
etwas, was mich gar nicht so sehr interessiert. Ist nicht meins. Top hat jeder so seins, aber

51:22.360 --> 51:27.440
Spieleprogrammierung ist auf jeden Fall nicht meins. So, aber jetzt mal zu dieser Datenbankgeschichte.

51:27.440 --> 51:30.920
Guck mal. Eigentlich, das ist mir nach dem letzten Stream eingefallen, als ich mir das

51:30.920 --> 51:35.880
noch mal angeguckt habe. Das ist richtig bescheuert. Guck mal. Wir suchen uns alle Einträge raus

51:35.880 --> 51:48.680
wo irgendwo drinnen, in dem Fall jetzt HTTP vorkommt, nur um sie danach alle zu sortieren,

51:48.680 --> 51:57.320
danach ob der Antrag, ob das damit anfängt. Also eigentlich könnten wir uns das doch komplett

51:57.320 --> 52:05.200
sparen und zwei Queries machen. Nämlich ein Query, was einfach nur checkt, fängt das

52:05.200 --> 52:17.800
damit an und findet da 10 Elemente. Und wenn er weniger als 10 Elemente findet, dann macht

52:17.800 --> 52:26.120
er noch ein zweites Query, nur, dass er dann ein Wildcard Query macht. Kannst du nicht

52:26.120 --> 52:31.680
auch einfach, nachdem du 10 genommen hast, sortieren? Nee, weil dann sortiert er ja nur

52:31.680 --> 52:37.480
die 10 und da sind nicht zwangsläufig die, die damit anfangen oben. Das funktioniert

52:37.480 --> 52:45.480
nicht. So, wenn ich das hier jetzt ausführe, dann sollte zumindest ein Teil davon schonmal

52:45.480 --> 52:52.120
stimmen. Hoffe ich mal. Wenn ich jetzt nämlich nach Hats suche, dann ist Hats am Anfang und

52:52.120 --> 53:06.360
es ist immerhin noch relativ geschwind. Warum brauchen das nur sieben und Hats und Hats

53:06.360 --> 53:15.760
brauchen 29? Zumindest man sieht, die eigentlichen Queries jetzt für ein Buchstaben und so sind

53:15.760 --> 53:24.640
saumäßig schnell und es sind die, die damit anfangen oben. Natürlich kann es jetzt sein,

53:24.640 --> 53:31.480
dass wenn man zum Beispiel nach so was wie HTTP sucht, er findet nix. Warum findet er

53:31.480 --> 53:38.760
mit HTTP nix? Weil HTTP in der Mitte ist und HTTP eben nicht vorne steht. Deswegen klappt

53:38.760 --> 53:42.760
das nicht. So, und ich hab mir gedacht, man könnte doch, man könnte doch, da müssen wir

53:42.760 --> 53:47.000
ein bisschen basteln. Das ist alles, was ich mir im Vorfeld überlegt hab. Man könnte

53:47.000 --> 53:56.280
doch jetzt einfach gucken, findet er 10 Einträge hiermit? Wenn es weniger als 10 sind, dann

53:56.280 --> 54:03.720
macht er nochmal das gleiche, nur mit einem Wildcardquery. So, und das mit sortieren schenken

54:03.720 --> 54:08.080
wir uns einfach. Das brauch ich ja dann nicht. Ich muss ja nicht sortieren, weil ich ja schon

54:08.080 --> 54:13.200
automatisch hiermit alle, die damit anfangen, oben hab. Ich suche ja nur die Dinge, die damit

54:13.200 --> 54:18.040
anfangen. Ich muss ja nicht Wildcard suchen, um dann danach zu sortieren, sondern ich kann

54:18.040 --> 54:24.080
einfach direkt suchen, nach fängt an. Hast du da nicht in der zweiten Query die Ergebnisse

54:24.080 --> 54:30.080
der ersten nochmal drinne? Es kann sein. Das kann zumindest passieren, dann müssen wir

54:30.080 --> 54:38.600
das irgendwie uniken oder so. Mal gucken. Also, das sieht ja in soweit schon mal ganz

54:38.600 --> 54:43.880
sinnvoll aus. Wir machen nochmal, wir führen nochmal was zum Testen ein. Nennen wir mal

54:43.880 --> 54:51.440
hier Max Results und das sind aktuell 10. Aber, dass ich da mal ein bisschen hoch und

54:51.440 --> 54:55.640
runter schalten kann an Ausgaben und gucken, ob das passt. Doppelte muss ich wahrscheinlich

54:55.640 --> 55:04.520
filtern. Genau. So, das hier lassen wir erstmal weg. Das muss ich mir unten merken. So, also

55:04.520 --> 55:22.760
das ist das erste Query. Okay, und jetzt gucken wir, ob Result Count, oder macht das so Sinn?

55:22.760 --> 55:27.440
Wenn das kleiner Max Results ist, und wenn das kleiner ist, dann weiß ich, das hier hat

55:27.440 --> 55:31.960
keine 10 Ergebnisse, oder in dem Fall 10 Ergebnisse gebracht. Wenn das keine 10 Ergebnisse

55:31.960 --> 55:42.560
gebracht hat, dann muss ich nochmal, dann muss ich nochmal einen Query machen. So. Was sagst

55:42.560 --> 55:53.160
du eigentlich zu, zu was? Zu CutefishOS. Was für ein Ding. Hab ich doch nie gehört. Oh,

55:53.160 --> 56:13.480
China-Chinesen-Kram. Cutefish. Warum nicht CutechatOS? CutefishOS. Oh, das lädt ja schon

56:13.480 --> 56:22.160
mal sehr geschwind. Highspeed aus China. Wird bestimmt über irgendeine ESP32 Steckdose

56:22.160 --> 56:36.120
ausgeliefert oder so. Ach, so sieht China-Milch aus. Make a better DesktopOS. Simplicity, Beauty

56:36.120 --> 56:44.600
and Practicality. User Experience. CutefishOS. Noch mehr Standard-Applikationen nachgebaut.

56:44.600 --> 56:57.280
Eine Güte, ey. Muss das denn sein? Cutefish Desktop. Global Menu. Habe ich noch nie ausprobiert,

56:57.280 --> 57:05.200
aber ich bin auch immer skeptisch über China-Destributionen. Ernsthaft. Den Download gibt es über Mega oder

57:05.200 --> 57:25.320
Google Drive. Das ist ja sehr sicher und sehr vertrauenswürdig. Auch GitHub haben sie auch

57:25.320 --> 57:35.840
am Start. Mega Upload. Ja, den brauchen wir auch mal wieder. Den brauchen wir auch mal.

57:35.840 --> 57:43.640
Sekunde, Leute. Das muss jetzt mal kurz sein. Mega Upload Song. Kim wird uns schon nicht

57:43.640 --> 57:58.040
Copyright striken. Ich glaube, das ist der letzte, der das macht. Yeah.

58:13.640 --> 58:26.880
Mega Upload. Der Kerl hat garantiert keine Ahnung, woran er da drinnen gelandet ist,

58:26.880 --> 58:33.720
warum er das überhaupt sagen sollte. Die haben so keinen Plan gehabt, von was die eigentlich

58:33.720 --> 59:01.840
reden. So, genug jetzt. Genug Mega Upload Song. Das muss jetzt einmal wieder sein. Wie

59:01.840 --> 59:06.000
viel Geld hat er ihnen in die Hand gedrückt? Ich glaube eher, wahrscheinlich war es nicht

59:06.000 --> 59:10.360
umsonst, aber ich glaube eher, dass das so diese typische Geschichte war, wie hier auf

59:10.360 --> 59:15.040
Twitch auch manchmal Leute in Chat kommen und so nach dem Motto, kannst du mal kurz

59:15.040 --> 59:22.320
Max grüßen oder sowas. Die waren, die sind dann dann irgendwelche Agents von denen ran

59:22.320 --> 59:26.240
und haben gesagt, ja hier, wir sind ein Radiosender oder was auch immer, könnt ihr mal kurz irgendwie

59:26.240 --> 59:29.640
das und das sagen? Und dann haben wir das, da werden die wahrscheinlich nicht nein sagen,

59:29.640 --> 59:37.240
ich habe keine Ahnung gehabt, worum es ging. Der hat ihnen bestimmt nicht gesagt, ja ich

59:37.240 --> 59:41.920
habe hier einen Hostingservice, wo die Leute quasi eure Musik hochladen können und ihr

59:41.920 --> 59:47.720
verdient da nichts dran und das ist nice. Bewerbt das mal. Das hat er ihnen bestimmt

59:47.720 --> 01:00:00.840
nicht gesagt. War ganz davon abgesehen. Ich habe damit keine Schmerzen. Man sieht es aktuell

01:00:00.840 --> 01:00:09.720
an der ganzen Thematik aus Abos, die man holen soll, von Amazon bis Netflix bis Disney plus

01:00:09.720 --> 01:00:17.480
bis sonst was in der Richtung und jetzt wundern sie sich alle, oh nein, Sicherheitskopieren

01:00:17.480 --> 01:00:25.480
verbreiten sich wieder mehr als vorher. Nein, wirklich, da hätte ja keiner drauf kommen

01:00:25.480 --> 01:00:29.600
können, dass die Leute lieber wieder den Scheiß illegal runterladen, als sich 3000

01:00:29.600 --> 01:00:34.920
Abos zu kaufen. Das haben wir ja noch nie gehabt und da wären wir nie im Vorfeld drauf

01:00:34.920 --> 01:00:43.600
gekommen, dass das so wird. Ja und da wundern sie sich jetzt. Das ist so, wie die Musikindustrie

01:00:43.600 --> 01:00:49.400
sich gewundert hat zu Zeiten von Napster, dass die Leute keinen Bock mehr haben, Audio-CDs

01:00:49.400 --> 01:00:54.840
zu kaufen und dann auch noch in Werbespots als Mama-wo-ist-Papa im Knastweiler Raub kopiert

01:00:54.840 --> 01:01:04.640
hat dargestellt zu werden. Und siehe da, es funktioniert. Kaum gibt es da gescheite Abos

01:01:04.640 --> 01:01:11.720
in der Richtung, schon ist das deutlich weniger geworden und was Filme und sowas angeht,

01:01:11.720 --> 01:01:18.520
da bewegen sie sich aktuell davon weg. Das heißt, mich wundert das nicht, dass das zunimmt.

01:01:18.520 --> 01:01:27.920
Ob das jetzt, ja mal sagen, ob das jetzt ethisch verdrehtbar ist oder wie auch immer, sich

01:01:27.920 --> 01:01:31.920
die Sachen da illegal runterzuladen, das kann jeder für sich selbst überlegen, das ist

01:01:31.920 --> 01:01:36.040
mir vollkommen egal, das könnt ihr machen oder sein lassen, wie ihr lustig seid. Aber

01:01:36.040 --> 01:01:43.160
die Tatsache, dass es so sein wird, hätte auch die Filmindustrie meilenweit im Voraus

01:01:43.160 --> 01:01:54.160
sehen können. Das ist wirklich jetzt nichts Überraschendes gewesen. So ist es ja im Endeffekt

01:01:54.160 --> 01:01:59.640
und seit man zu Zeiten, wo man keine Ahnung mit einem Netflix-Abo oder mit einem Amazon-Abo

01:01:59.640 --> 01:02:03.680
sich das meiste, was man gucken wollte, angucken konnte, am besten auch noch in Originalsprache

01:02:03.680 --> 01:02:11.280
und sowas, was ja eben viele wollen. Alles okay? Aber jetzt muss sie wieder anfangen

01:02:11.280 --> 01:02:15.320
mit, nein, wir nehmen unsere Filme raus und du brauchst lieber 500 Abos. Das wundert

01:02:15.320 --> 01:02:21.600
mich nicht, dass die Leute wieder mehr anfangen, auf Sicherheitskopien zu setzen. Das ist gut

01:02:21.600 --> 01:02:26.200
oder schlecht, das hat damit überhaupt nichts zu tun. Es ist offensichtlich, dass es so

01:02:26.200 --> 01:02:33.880
passieren wird und es ist auch so passiert. Bist du nicht Max FPS? Doch, nein, das stimmt,

01:02:33.880 --> 01:02:40.240
das gibt's gar nicht, ich bin Wubblers. Was Linus meinte, das war bestimmt G-Baded, bei

01:02:40.240 --> 01:02:46.960
ihm kann ich mir das nicht vorstellen, dass er wirklich mit, wobei, keine Ahnung. Mich

01:02:46.960 --> 01:02:50.560
juckt das nicht, wenn einer meinen Twitch-Stream mit Ad-Blog guckt oder meine YouTube-Videos

01:02:50.560 --> 01:02:59.080
mit Ad-Blog guckt es mir vollkommen egal. Können ruhig alle machen.

01:02:59.080 --> 01:03:26.120
Ja, meine ich ja, das war klar, dass das so sein wird. Naja, egal, aber das war finde

01:03:26.120 --> 01:03:32.160
ich offensichtlich, dass das so kommen wird. Ja und Cutefish OS werde ich mir nicht geben,

01:03:32.160 --> 01:03:38.840
weil ganz ehrlich, ein China-Chinesen-OS, das nur über Mega und Google Drive vertrieben

01:03:38.840 --> 01:03:58.080
wird, ist mir irgendwie ein wenig Suspekt oder Sus, wie man heutzutage sagt. Okay,

01:03:58.080 --> 01:04:07.920
machen wir mal weiter. Also Datenbank-Krempel. Also die Queries sind jetzt auf jeden Fall

01:04:07.920 --> 01:04:14.200
schon mal deutlich schneller. Guckt hier, Bäm, sieben Millisekunden. Suchen wir mal nach,

01:04:14.200 --> 01:04:21.720
was? Ah, Delia, 29 Millisekunden. Also die Queries sind fast as fuck, könnte man sagen.

01:04:21.720 --> 01:04:40.000
Ja, wir finden nur Sachen, die am Anfang stehen, nicht Sachen, die in der Mitte stehen.

01:04:40.000 --> 01:04:44.120
Geben wir mal die Request-Time auf der Web aus. Ja, das könnte ich machen, da müsste

01:04:44.120 --> 01:04:48.600
ich mir aber irgendwie einen besseren Return-Wert überlegen, anstatt einfach nur den Text.

01:04:48.600 --> 01:05:02.480
Ach so, jetzt weiß ich auch, warum das so langsam ist. Nee, Stack. Wait a minute. Warum

01:05:02.480 --> 01:05:18.440
funktioniert denn das überhaupt? Warum funktioniert das? Das sollte eigentlich gar nicht funktionieren.

01:05:18.440 --> 01:05:48.240
Äh. Hä? Moment. Mal kurz, mal kurz die Response angucken hier. So. Response? Hab ich nicht

01:05:48.240 --> 01:06:04.200
neu gestartet? Ich glaube, ich hab's nicht neu gestartet, ne? Ah, ja, ja, okay. Ja,

01:06:04.200 --> 01:06:07.920
ich hab's nicht neu gestartet, weil ich filter gar nicht den Text raus, ich geb aktuell

01:06:07.920 --> 01:06:11.800
die kompletten Objekte zurück. Deswegen hab ich mich gewundert, wie er so schlau ist und

01:06:11.800 --> 01:06:18.560
checkt, dass es den Text davon nehmen soll. Ist er aber nicht. Okay, okay, gut, gut, gut.

01:06:18.560 --> 01:06:21.720
Jetzt ergibt das Sinn. Ich will aber gar nicht die kompletten Objekte zurückgeben.

01:06:21.720 --> 01:06:28.800
Ich hab mich nur gefragt, warum ist das aktuell so? Das waren wir hier unten rein. Select,

01:06:28.800 --> 01:06:34.800
Text. So, wunderbar. So, wenn ich jetzt neu starte, dann funktioniert's nämlich auch wieder.

01:06:34.800 --> 01:06:46.560
So. A. Das erste Query ist immer ein bisschen langsam. H. Sechzehn Millisekunden. A. Achtfünfzig

01:06:46.560 --> 01:06:53.080
Millisekunden. L. Vierundvierzig Millisekunden. Das ist relativ schnell. Okay. Ähm. Wichtig

01:06:53.080 --> 01:06:56.960
ist, dass so diese einzelnen Buchstaben, die haben ja vorteilweise vierundfünfzig Millisekunden

01:06:56.960 --> 01:07:01.840
gedauert. So, und jetzt hab ich mir überlegt, wir gucken jetzt einfach, ob es weniger als

01:07:01.840 --> 01:07:05.520
zehn Sachen gefunden werden. Und wenn weniger als zehn Sachen gefunden werden, dann machen

01:07:05.520 --> 01:07:16.800
wir das Query einfach nochmal neu. Allerdings jetzt mit dem Wildcard Operator drin. Also

01:07:16.800 --> 01:07:23.000
kopieren wir das jetzt nochmal. Kann man das, kann man das überhaupt, kann ich das jetzt

01:07:23.000 --> 01:07:31.280
nochmal so machen? Und sollte ich hier count machen oder sollte ich das hier schon? Mal

01:07:31.280 --> 01:07:36.720
gucken, mal gucken. Mir müssen wir ein bisschen ausprobieren. So. Das heißt, wenn ich jetzt

01:07:36.720 --> 01:07:47.840
weniger als zehn hab, dann will ich Wildcard suchen. So. Setz doch die Abfrage komplett

01:07:47.840 --> 01:07:52.320
in die If-Abfrage rein, lass die obere weg, oder dann funktioniert's doch nicht. Was soll

01:07:52.320 --> 01:08:00.560
denn das bringen? Wenn ich die obere weglasse. Wenn ich nur die mach, dann hab ich die Dinger

01:08:00.560 --> 01:08:04.960
nicht sortiert in der Reihenfolge, wie ich sie haben will. Wenn ich es so mach, dann

01:08:04.960 --> 01:08:15.400
hab ich sie in der Reihenfolge sortiert, wie ich es haben will. Du solltest Result auf

01:08:15.400 --> 01:08:27.600
jeden Fall den oberen Toolist machen. Schreib ich mir mal auf. Kann aber sein, dass es nicht

01:08:27.600 --> 01:08:38.080
funktioniert. Muss man mal gucken. Also. Moment, Moment. Ich muss mal kurz überlegen. Also.

01:08:38.080 --> 01:08:43.600
Wenn das weniger als zehn hat, wenn das hier weniger als zehn hat, dann machen wir nochmal

01:08:43.600 --> 01:09:06.720
eine Abfrage mit dem da, jetzt allerdings Wildcard-Abfrage. Take zehn. Ha. Jetzt muss

01:09:06.720 --> 01:09:12.120
ich die, irgendjemand im Chat hat vorhin geschrieben, jetzt hab ich Ergebnisse doppelt. Das kann

01:09:12.120 --> 01:09:17.920
passieren. Ich müsste die jetzt irgendwie UNIQ machen, so. Irgendwie, wie mach ich denn

01:09:17.920 --> 01:09:32.600
UNIQ gescheit? Wie stelle ich jetzt sicher, dass Ergebnisse nur einmal drin sind? Set?

01:09:32.600 --> 01:09:40.280
Wie Set? Du meinst so eine Art Dictionary? Nee, das muss schon, nein, das muss schon

01:09:40.280 --> 01:09:55.200
in SQL sein. Distinkt. Nee, ich will ja nicht Distinkt, ich will ja, ich will ja, ok, wenn

01:09:55.200 --> 01:10:04.040
wir das jetzt Mengenlehre technisch machen, will ich ja eine, wie heißen das beide Mengen

01:10:04.040 --> 01:10:24.600
zusammen? Ähm. Nee, warte mal, wie heißt das? Schnittmenge? Nee, Schnittmenge will

01:10:24.600 --> 01:10:31.640
ich nicht, das sind beide, die sich überschneiden. Ich will beide Mengen zusammen, aber die Elemente,

01:10:31.640 --> 01:10:41.160
die doppelt sind, will ich nur einmal haben. Ja, so combine sowas in der Richtung, jaja,

01:10:41.160 --> 01:10:59.920
genau. Ähm. Wie nennt man das denn? Ok, wir müssen jetzt, ok, Wikipedia, Mengenlehre.

01:10:59.920 --> 01:11:17.920
Was denn? Mengenlehre. Union, ja, Kompliment Mengenlehre. Ah, yes, excellent. Ja, das ist

01:11:17.920 --> 01:11:42.360
genau das, genau das will ich haben, ja, ja, ja. Obvious, obvious. Gachibas Mengenlehre.

01:11:42.360 --> 01:11:56.880
Union, ok, Union Mengenlehre. Kompliment. Gibt es da nicht ein paar gescheite, aha, ok,

01:11:56.880 --> 01:12:07.280
eine echte Teilmenge, Schnittmenge, Vereinigung, ich will eine Vereinigungsmenge haben. So sieht

01:12:07.280 --> 01:12:20.360
es aus, das will ich haben. Eine Vereinigungsmenge haben. Excellent, alles klar, Union sagt der

01:12:20.360 --> 01:12:34.640
Chat. Das heißt, in dem Fall, ist das sowas? Oh, guck mal da, Union von Result, von dem

01:12:34.640 --> 01:12:46.680
ursprünglichen. Und das könnten jetzt ja mehr sein als 10, also ich nehme hier von maximal

01:12:46.680 --> 01:12:53.360
10, davon maximal 10, das könnten also im schlimmsten Fall 20 sein, also muss ich am

01:12:53.360 --> 01:13:11.160
Ende nochmal ein Take-Things machen, oder? Ob das so funktioniert? Keine Ahnung. Der Chat

01:13:11.160 --> 01:13:21.160
sagt schon, das geht nicht. Ja, warum eigentlich? Wir probieren das jetzt mal aus. Erst Union,

01:13:21.160 --> 01:13:33.840
dann Take. Ne, ne, wenn ich erst Union mache, dann ist es ja wieder lahm as fuck, weil dann

01:13:33.840 --> 01:13:39.120
mache ich ja die Union im Zweifelsfall wieder auf 2,5 Millionen gefundenen Elemente. Ok,

01:13:39.120 --> 01:13:53.840
so guck mal, wie schnell wir jetzt sind. Also, HTTP. Aushalt funktioniert. HTTP. Ihh, das

01:13:53.840 --> 01:14:18.240
ist ja slow. Slow AF. 935. Ihh. Warum ist das so langsam? Wäh? Warum ist das jetzt so

01:14:18.240 --> 01:14:36.800
langsam? Aber der macht ja Union mit nichts. Ok, Moment, ich lasse das mit Union mal kurz

01:14:36.800 --> 01:15:00.640
raus. Testen. Ok. Das ist ja immer... Warum ist das so mega langsam?

01:15:00.640 --> 01:15:26.760
Hä? 946? Alter, das ist ja... Hab ich jetzt irgendwas da nicht richtig durchdacht? Moment,

01:15:26.760 --> 01:15:38.280
das muss ich noch mal wegmachen. Das ist ja im Prinzip das gleiche, wie wenn ich das hier

01:15:38.280 --> 01:15:47.200
dahin mache. Warum? Warum ist das jetzt so langsam? Schneller als mit Union. Ja, aber

01:15:47.200 --> 01:16:00.960
eine Sekunde Query Time. Ich glaube, es geht los. Jetzt ist es fast as fuck. Ähh. Moment,

01:16:00.960 --> 01:16:09.880
das verstehe ich jetzt nicht. Warum macht das überhaupt einen Unterschied? Also, das

01:16:09.880 --> 01:16:17.560
müsste jetzt, das dürfte höchstens, das dürfte höchstens 10 Millisekunden sein oder

01:16:17.560 --> 01:16:27.600
so. Warum ist das in dem If drin so viel langsamer? Das check ich nicht. Das ist doch genau das.

01:16:27.600 --> 01:16:33.760
Ob der das jetzt vorher macht und nichts... Ah, nee. Das liegt da dran, weil der nichts

01:16:33.760 --> 01:16:41.000
findet. Moment, Moment, Moment. Ich weiß, woran das liegt. Wartet mal. Wenn der nichts

01:16:41.000 --> 01:17:08.480
findet, ist es langsam. Kann das sein? Wartet ihr PS? Alter. Fulltext Search bringt hier

01:17:08.480 --> 01:17:18.400
an der Stelle nichts. Weil das Full in Fulltext Search bezieht sich auf ganze Wörter. Nee,

01:17:18.400 --> 01:17:23.600
da dran liegt... Warum ist das denn so langsam jetzt? Warum wird das langsam dadurch? Das

01:17:23.600 --> 01:17:36.720
verstehe ich nicht. Hab ich hier irgendwas Blödsinniges drinne? Ja, das Count, das

01:17:36.720 --> 01:17:51.600
Count wird es ja auch nicht sein. Das Count ist Null dann, das kannst du jetzt... Warum

01:17:51.600 --> 01:18:02.120
ist das so langsam? Ist das wirklich das Count? Ist das das Count, was so langsam ist? Okay,

01:18:02.120 --> 01:18:22.480
Null wie Count. Das ist das Count, was so... Warum ist denn das Zählen von nichts? Na gut,

01:18:22.480 --> 01:18:25.680
da muss die komplette Datenbank durchgehen, um festzustellen, dass es wirklich nichts

01:18:25.680 --> 01:18:39.880
gibt. Aber das es nichts gibt, müsste er doch eigentlich relativ schnell rausbekommen.

01:18:39.880 --> 01:18:54.000
Weil er in seinem Index nachguckt und feststellt, es gibt keine Wörter oder es gibt nichts,

01:18:54.000 --> 01:19:00.440
was mit... Vielleicht, weil es mehr als drei Buchstaben sind? Moment, Moment, das muss

01:19:00.440 --> 01:19:10.720
ich jetzt mal ausprobieren. Beim Count wird es das erste Mal ausgeführt, ja. Warte,

01:19:10.720 --> 01:19:26.720
warte. Das ist auch nicht viel langsamer. Warum ist das so langsam? Macht das erste Result

01:19:26.720 --> 01:19:32.680
zu einer Liste? Ja, das habe ich mir auch schon überlegt, aber die Sache ist halt die, aus

01:19:32.680 --> 01:19:38.000
irgendwelchen Gründen dauert das komplette Ding auszuführen so langsam. Das würde ich

01:19:38.000 --> 01:19:44.920
jetzt auch als nächstes... Aber hä? Warum ist das Count Query so krass langsam? Wird

01:19:44.920 --> 01:19:49.280
es überhaupt indiziert, wenn man mit einem Triggum im String sucht? Ja, wird es. Aber

01:19:49.280 --> 01:19:55.040
anders als ein normaler Index. Das muss ich jetzt mal zeigen für alle, die neu dabei

01:19:55.040 --> 01:20:03.480
sind. Der benutzt, wo habe ich es denn hier? Da. Der benutzt, um das zu indizieren, eine

01:20:03.480 --> 01:20:09.440
Postgres-Extension, nämlich PG Triggum, woran für jedes Wort immer Dreierpaare speichert

01:20:09.440 --> 01:20:16.240
in einem Index und deswegen relativ schnell Wörter durchsuchen kann, auch bei Wildcard

01:20:16.240 --> 01:20:22.800
in der Mitte. Dadurch sind Inserts langsamer und die Datenbank wird insgesamt größer,

01:20:22.800 --> 01:20:43.160
und die Suche ist viel, viel, viel, viel, viel schneller. Ich habe irgendwas bestimmt

01:20:43.160 --> 01:20:48.640
nicht richtig beachtet. Ich habe irgendwo da was Blödes drin. Ein Count davon kann

01:20:48.640 --> 01:20:58.240
auch nicht so langsam sein. Gut, das ist jetzt die übliche Geschichte. So, da findet er

01:20:58.240 --> 01:21:08.440
was. So, jetzt HTT. Das ist langsam? Okay, das verstehe ich jetzt nicht so genau. Das

01:21:08.440 --> 01:21:19.680
ist langsam. Alles klar. Ich weiß nicht warum, aber aus irgendwelchen Gründen ist das hier

01:21:19.680 --> 01:21:46.120
langsam. Warum? Warum ist das langsam? Das liegt nicht wirklich am Count. Das liegt an

01:21:46.120 --> 01:22:12.000
dem eigentlichen Query. Warum ist das so langsam? HTT. Watt? Watt? Hä? Achso, ja,

01:22:12.000 --> 01:22:23.440
das ist ja... Moment, Moment, Moment. Das muss ich hier unten reinmachen. Am Ende, hier

01:22:23.440 --> 01:22:31.160
wird ja das Query erst ausgeführt. Aber, okay. Der müsste doch relativ schnell feststellen,

01:22:31.160 --> 01:22:45.960
dass er nichts findet. Ah, das ist. Das ist einfach lahm, wenn er nichts findet. Gut,

01:22:45.960 --> 01:22:55.600
das verstehe ich jetzt nicht. Sehr spannend. Habe ich jetzt nicht gedacht. Ich hätte jetzt

01:22:55.600 --> 01:23:02.040
eigentlich vermutet, dass er dadurch, dass er das quasi so special indiziert, sehr schnell

01:23:02.040 --> 01:23:16.000
feststellen kann, wenn es eben keine Worte gibt, die das enthalten. Wir machen gar kein

01:23:16.000 --> 01:23:22.920
Count. Am Count liegt es nicht. Das Query, wenn er nichts findet, ist lahm as fuck. Und

01:23:22.920 --> 01:23:36.480
ich weiß nicht so genau warum, wenn ich ehrlich bin. Man würde denken, es ist langsam, weil

01:23:36.480 --> 01:23:41.120
er alles durchgehen muss, um zu gucken, ob er wirklich nichts findet. Aber dadurch, dass

01:23:41.120 --> 01:23:47.360
er die Wörter in so Dreierbuchstabenpaare zerlegt, müsste der Instant eigentlich nachgucken

01:23:47.360 --> 01:23:53.040
können, dass es eben nichts gibt, was damit anfängt. Aber das ist Instant halt ziemlich

01:23:53.040 --> 01:24:07.440
schnell. Ja, das weiß ich jetzt auch nicht. Keine Ahnung. Wie sieht es aus, wenn du das

01:24:07.440 --> 01:24:12.840
Query meinst, und da bin ich zu blöd für. Natürlich ist es dafür gemacht, es gibt

01:24:12.840 --> 01:24:25.560
extra eine Extension dafür. So. Hey, welchen Editor IDE nutzt ihr? Komme von Java, NetBeans

01:24:25.560 --> 01:24:29.800
und bin auf der Suche nach möglichen... Ne, guck dir das... Also gerade, wenn du aus dem

01:24:29.800 --> 01:24:38.560
Java-Umfeld kommst, kennst du wahrscheinlich IntelliJ. Und die Hersteller von IntelliJ,

01:24:38.560 --> 01:24:50.160
die haben ganz viele IDE's. Zum Beispiel haben die auch eine.NET IDE und eine Go-IDE und

01:24:50.160 --> 01:24:56.560
auch eine C-IDE und auch eine Python-IDE. Und wenn du dir... Also hier siehst du ja,

01:24:56.560 --> 01:25:03.400
was die alles am Start haben. Das ist C, das ist ihr komischer Visual Studio Code Konkurrenz.

01:25:03.400 --> 01:25:09.160
Dann haben die Goland am Start, IntelliJ für Java, PHPStorm, PyCharm, Rider, RubyMine,

01:25:09.160 --> 01:25:15.600
falls jemand Ruby machen will, WebStorm. So, und wenn du das alles haben willst, weil du

01:25:15.600 --> 01:25:20.960
sagst ja, du willst Java, du willst Java, Python und C machen, dann kannst du dir zum Beispiel

01:25:20.960 --> 01:25:28.000
hier... Das für dich interessant wäre dann hier sowas wie SeaLion und IntelliJ, wobei

01:25:28.000 --> 01:25:34.640
das ist eh kostenlos. IntelliJ kostet ja nix. Was war das andere, PyCharm? PyCharm kostet

01:25:34.640 --> 01:25:41.120
auch nix. IntelliJ ist kostenlos und PyCharm ist kostenlos. Das Einzige, was du dir holen

01:25:41.120 --> 01:25:46.680
müsstest ist SeaLion. Zumindest, was ich dir zeigen wollte ist, die haben ein Package für...

01:25:46.680 --> 01:26:00.320
Die haben ein All Products Pack. Das kostet dich 250 Euro im Jahr und ich denke, wenn man

01:26:00.320 --> 01:26:07.760
das professionell oder semi-professionell verwendet, kann man das ausgeben, zumal es ab dem zweiten

01:26:07.760 --> 01:26:11.640
und dritten Jahr nochmal günstiger wird. Hab ich mir auch gekauft. Also das ist auch das,

01:26:11.640 --> 01:26:18.320
was ich am Start habe bei mir. Also ich verwende von denen auch drei Sachen. Ich verwende Rider,

01:26:18.320 --> 01:26:23.200
ich, wobei es stimmt gar nicht, ich verwende sogar mehr, aber nicht oft. Also hauptsächlich

01:26:23.200 --> 01:26:28.800
verwende ich von den Rider, weil ich.NET mittlerweile quasi fast exklusiv unter Linux

01:26:28.800 --> 01:26:38.840
programmiere. GoLand verwende ich für Go. SeaLion ab und zu mal für Arduino Platform

01:26:38.840 --> 01:26:44.120
my own Zeugs, wobei ich da mittlerweile zum größten an Whistle Studio Code verwende,

01:26:44.120 --> 01:26:52.600
weil das Setup einfacher ist. Ich habe PyCharm und RubyMine auch installiert, aber verwende

01:26:52.600 --> 01:27:02.560
ich beides relativ selten. Ja, also diese Dinger sind wirklich gut und gerade wenn du

01:27:02.560 --> 01:27:05.880
aus dem Java Umfeld kommst, solltest du die glaube ich vom Namen her zumindest schon kennen.

01:27:05.880 --> 01:27:17.720
NetBeans wusste ich gar nicht, dass es das noch gibt. Mit explaining Query, da müsste

01:27:17.720 --> 01:27:21.840
ich ja wissen, was der ausführt. Da muss ich ja von Hand irgendwelche SQL Queries ausführen.

01:27:21.840 --> 01:27:36.720
Ich bin dazu zu low IQ was Datenbank angeht. Keine Ahnung. Wir können uns das Query mal

01:27:36.720 --> 01:27:41.640
ausgeben lassen und ich mach das von Hand. Können wir probieren. Das machen wir jetzt,

01:27:41.640 --> 01:27:47.360
das machen wir jetzt, das Query von Hand. Ruby ist doch super. Ruby ist neben SeaSharp

01:27:47.360 --> 01:27:51.920
meine absolute Lieblingsprogrammiersprache schlechthin. Leider ist Ruby so ein bisschen

01:27:51.920 --> 01:27:59.000
in der Bedeutungslosigkeit verschwunden die letzten Jahre über. Vor allem weil Rails

01:27:59.000 --> 01:28:08.520
nicht mehr angesagt ist. Aber Ruby selbst ist das beste was es gibt. Wenn du brauchst

01:28:08.520 --> 01:28:13.280
das, dann würde ich halt sagen kannst du PyCharm verwenden, IntelliJ verwenden, da hast du

01:28:13.280 --> 01:28:17.440
Python und Java schon mal abgedeckt und für C gibt es ja jede Menge andere Möglichkeiten.

01:28:17.440 --> 01:28:29.880
Du installierst ja Vmware Workstation oder VirtualBox und installierst da drin über

01:28:29.880 --> 01:28:34.720
einen ISO das Lieblungs deiner Wahl. Also das kriegt eigentlich fast jeder der ein bisschen

01:28:34.720 --> 01:28:47.600
IT technisch interessiert ist hin. Ja das ist richtig gut. Also ich muss sagen die Preispolitik

01:28:47.600 --> 01:28:54.400
finde ich in Ordnung. Wenn man das und spätestens wenn man damit Geld verdient mit dem was man

01:28:54.400 --> 01:28:58.960
eben da drin macht. Also sag mal wenn du professionelles oder semi professionelles Zeug verwendest,

01:28:58.960 --> 01:29:06.680
sind 250 Euro im Jahr bzw. im dritten Jahr dann irgendwie keine Ahnung 200, ne 100, 170

01:29:06.680 --> 01:29:14.960
Euro oder so. Da kannst du dich eigentlich nicht beschweren. Rails finde ich cool. Also

01:29:14.960 --> 01:29:20.040
ich mag das Ruby Ökosystem und Rails eigentlich auch, aber das ist mittlerweile ziemlich in

01:29:20.040 --> 01:29:25.640
der Versenkung verschwunden. Stimmt das habe ich ganz vergessen. Wenn du einen E-Mail Account

01:29:25.640 --> 01:29:30.880
hast von deiner Uni, dann kannst du glaube ich dort dir eine Studentenlizenz ausstellen

01:29:30.880 --> 01:29:51.920
lassen. Ja ich habe es aber selbst noch nicht ausprobiert. Bin mal gespannt. Also ich denke

01:29:51.920 --> 01:29:56.520
nicht das sie schaffen werden w.h. Studio Code Konkurrenz zu machen was Frontend JavaScript

01:29:56.520 --> 01:30:05.160
Sachen angeht. Aber für andere Dinge wo es zum Beispiel keine offizielle JetBrains IDE

01:30:05.160 --> 01:30:11.320
gibt, sowas wie Rust oder sowas, da könnte ich mir das schon vorstellen, dass das sich

01:30:11.320 --> 01:30:27.160
durchsetzen könnte. Naja es kommt drauf an was man machen will. Also wenn du JavaScript

01:30:27.160 --> 01:30:33.640
Frontend Zeug machen willst, würde ich eindeutig Visual Studio Code nehmen. Die Ausmal an Plugins

01:30:33.640 --> 01:30:40.360
und dass der Krempel eben selbst in JavaScript programmiert ist, ist schon ganz gut. Für

01:30:40.360 --> 01:30:45.440
Frontend Sachen würde ich immer Visual Studio Code nehmen. Manche schwören auf WebStorm,

01:30:45.440 --> 01:30:51.480
ok, aber ich mag Visual Studio Code. Aber ganz ehrlich,.NET Entwicklung ist ein ziemlicher

01:30:51.480 --> 01:30:55.920
Painschamp in Visual Studio Code. Du kannst das machen, du kriegst auch die ganzen Plugins

01:30:55.920 --> 01:31:00.200
dabei, dass du Autovervollständigung hast und sonst was, aber schön ist es nicht. Es

01:31:00.200 --> 01:31:05.560
ist irgendwie haklich. Ich mag das nicht. Deswegen habe ich hier auch zwei Sachen auf.

01:31:05.560 --> 01:31:11.080
Ich habe hier eine IDE für.NET auf und ich habe hier Visual Studio Code für den Frontend

01:31:11.080 --> 01:31:19.640
Chat auf. Und die richtig hardcore Leute, die machen es über NeoWim, genau. Den macht

01:31:19.640 --> 01:31:24.800
dann hier, wie ist denn der Manke als Einsteiger hier, den macht dann Akira zum ersten Mal

01:31:24.800 --> 01:31:39.920
auf und weiß nicht mal, wie er rauskommt. Wenn ihr Leute NeoWim empfiehlt. Jaja, Fleet

01:31:39.920 --> 01:31:47.440
ist quasi der JetBrains IDE Core extrahiert und dann so gemacht, dass du es mit Plugins

01:31:47.440 --> 01:31:52.560
erweitern kannst. Was ja jetzt schon geht, ich habe ja jetzt schon einige Plugins, aber

01:31:52.560 --> 01:32:06.080
müssen wir mal gucken, was da rauskommt. So, aber gehen wir mal zurück zu unserem Datenbank

01:32:06.080 --> 01:32:10.360
Query. Ich habe keine Ahnung, warum das Lamas Fuck ist. Wir müssen uns jetzt mal irgendwie

01:32:10.360 --> 01:32:13.480
auch. Also, okay, wir gucken wir gucken uns jetzt mal an, was der für einen Query macht

01:32:13.480 --> 01:32:17.760
und dann machen wir das Query von Hand in der Datenbank. Jetzt wird es jetzt wird es

01:32:17.760 --> 01:32:32.000
waren, so HTTP. Ja, das Query macht er da. Select Text from Limit. Okay, auf auf. Bash.

01:32:32.000 --> 01:32:41.200
P SQL. Bäm. Gibt es da nicht, Leute, gibt es nicht, von wo wir gerade bei dieser JetBrains

01:32:41.200 --> 01:32:45.920
Geschichte sind, hatten die nicht auch ein Tool, wo man Datenbank Queries irgendwie schöner

01:32:45.920 --> 01:32:49.760
drin machen kann? Hatten die nicht sowas? Habe ich letztens bei denen auf der Webseite

01:32:49.760 --> 01:32:59.040
gesehen, habe ich noch nie verwendet. Datacrit. Wollen wir das mal ausprobieren? Ach nee,

01:32:59.040 --> 01:33:06.960
ich habe ja mein Account hier gar nicht eingeloggt. Ich mache das jetzt mal kurz mal gucken. Ist

01:33:06.960 --> 01:33:16.840
das kostenlos? Braucht man dann? Braucht man dann ein Account für? Ja, ich weiß nur mal

01:33:16.840 --> 01:33:21.520
so für die Leute, die immer sagen, ich hätte, ich hätte, ich würde das ja nur erzählen

01:33:21.520 --> 01:33:28.080
und in Wirklichkeit irgendwelche gecrackten Version zu verwenden. Ich habe das hier ganz

01:33:28.080 --> 01:33:38.040
offiziell aktiviert für mich. Und ich kann euch das zeigen. Das kommt ja jedes Mal. So

01:33:38.040 --> 01:33:47.360
nach dem Wort Jaja aktiviert. Lulul. About. Hier. License to MaxK. Ihr könnt jetzt natürlich

01:33:47.360 --> 01:33:54.160
nicht verifizieren, dass ich das bin, aber die. Das ist relativ unwahrscheinlich, dass

01:33:54.160 --> 01:34:01.000
ich den gecrackten Licens Key irgendwo habe, der dann auch auf MaxK und so Nachnamen, Nachnamen

01:34:01.000 --> 01:34:08.680
liegt. Warum habe ich IntelliJ Community Edition installiert? Warum? Das muss ich mal kurz

01:34:08.680 --> 01:34:18.320
aufmachen und gucken. Warum? Ich mache kein Java Kram? Oh, du nie warst drin gemacht.

01:34:18.320 --> 01:34:36.280
Okay. Alles klar. Bam. Data. Datalore, Dataspell, Datacrip. Jetzt wollen sie es einmal wissen

01:34:36.280 --> 01:34:49.640
hier. Warum ist die outdated? Was ist outdated? Das da. Burscht. Wir haben noch nie großartig

01:34:49.640 --> 01:34:55.640
Go gemacht im Stream. So, wenn ich mich, wenn ich mich registrieren muss, habe ich, habe

01:34:55.640 --> 01:35:12.520
ich gelitten. Ich habe das alles nicht hier. Activate. Okay. Easy. Da hat es mein Account

01:35:12.520 --> 01:35:16.040
gemerkt. Alles klar. Das immer. Also mein Fake Account für letzten Stream, den ich gemacht

01:35:16.040 --> 01:35:21.600
habe. Wie funktioniert der Kram jetzt? Habe ich noch nie verwendet. New Projekt. Lul. Was

01:35:21.600 --> 01:35:30.000
macht das jetzt? Database Explorer. Okay, das ist glaube ich abfuck für jemand, der von

01:35:30.000 --> 01:35:47.080
der man keine Ahnung hat. Datasource. Postgres. Postgres. Wow. Localhost. 5 4 3 2. Das ist

01:35:47.080 --> 01:35:59.240
richtig. User Postgres. Passwort gibt es nicht. Apply. Not found. Download. Ich habe keinen

01:35:59.240 --> 01:36:05.760
Plassen Schimmer, was ich hier überhaupt mache. Native Keychain is not available. Ja, soll

01:36:05.760 --> 01:36:12.680
mir recht sein. Das ist eh leeres Passwort. Und hat das jetzt funktioniert? Die Musik

01:36:12.680 --> 01:36:24.280
passt sehr gut. Und jetzt hat es jetzt funktioniert. Select. Sternchen. Ich muss doch erst noch,

01:36:24.280 --> 01:36:35.680
ich muss doch erst noch die Datenbank auswählen, oder? Wo mache ich das? Ah hier. Cute. Cute

01:36:35.680 --> 01:37:04.920
Chat Database. Ok. Select. Sternchen. From. Cute Chat Database. Ne. Ne. Ne. Ne. Ne. Ne.

01:37:04.920 --> 01:37:16.560
Ah, ich bin nicht connected. Ja, wie connecte ich mich denn? Ne, doch ich bin connected.

01:37:16.560 --> 01:37:35.360
Ah, hier Konsole. Jetzt. Select. Sternchen. From. Ah. Wow. Wie heißt denn der Krempel?

01:37:35.360 --> 01:37:59.440
Ich habe doch das Query hier. Select. Text values. Text values. Text. Ne. Kein Schimmer?

01:37:59.440 --> 01:38:07.880
Die Musik ist richtig spooky, passt gerade gut dazu, ja. Ähm, das erscheint mir unnötig

01:38:07.880 --> 01:38:19.200
komplex anstatt einfach. Ich meine meine Datenbank heißt offensichtlich Text values. Oder sehe

01:38:19.200 --> 01:38:35.400
ich das falsch? Text values. Heißt nicht so. Ja, woher weiß ich denn, wie der Krempel

01:38:35.400 --> 01:38:43.560
da drinne heißt überhaupt? Du musst das Schema selecten. Ich habe davon überhaupt

01:38:43.560 --> 01:38:55.800
keinen Platz zum Schema. Wo sehe ich denn, was es da überhaupt gibt drinne? Nach From

01:38:55.800 --> 01:38:59.840
kommt die Tabelle. Ja, ich weiß ja, die Tabelle müsste ja eigentlich, sag ich doch, Text

01:38:59.840 --> 01:39:10.560
values heißen. Macht es aber nicht. Ok, das ist mir eindeutig zu, das ist mir eindeutig

01:39:10.560 --> 01:39:36.040
zu high IQ dieses Ding hier. Schemas, no Schemas selected. Ok. All Schemas. Und nu? Ne. Ich

01:39:36.040 --> 01:39:42.720
hab keine Ahnung, was ich hier mache. Ich hab wirklich keinen, absolut keinen, blassen

01:39:42.720 --> 01:40:01.880
Schimmer. Tables. Also jetzt mal ernsthaft. Laut. EF Core heißt meine Table Text values.

01:40:01.880 --> 01:40:15.520
Warum gibt es das hier nicht? Das ist irgendwas internes, oder? Text values, da ist es doch.

01:40:15.520 --> 01:40:26.800
Da ist es doch. Ok, ok. Verstehe. Public. New Query Konsole. Jetzt aber. Ok. Next

01:40:26.800 --> 01:40:33.440
Sternchen, From Text. Ah, ja, ja, ja. Ok, jetzt kommen wir der Sache näher. So, wir

01:40:33.440 --> 01:40:41.480
führen das jetzt aus. So, Control, Enter. Exzellent, da haben wir es. Da ist unser,

01:40:41.480 --> 01:40:47.480
ist unser Kram. Ok, nice. Ok, jetzt kann man das machen, was ich vorher, was ich, was

01:40:47.480 --> 01:40:53.040
ich eigentlich vorher machen wollte. Also select. Das ist das, das ist das, was dort net ausführt

01:40:53.040 --> 01:41:00.400
hier. Select, das ist ST. So, like, so like muss ich ja das eintragen, was ich, was ich

01:41:00.400 --> 01:41:09.080
Query habe, HTTP. Limit sind 10. Stimmt doch, oder? Warum, warum macht der eigentlich ST?

01:41:09.080 --> 01:41:15.640
Ach so, dass er das where danach machen kann. So, und jetzt führen wir das mal aus. Ah,

01:41:15.640 --> 01:41:30.560
nein, es ist like, HTTP. Sternchen, genau. Ja, das ist einfach, das ist einfach lahm.

01:41:30.560 --> 01:41:42.360
Wo sieht man denn die Zeit, was es jetzt gebraucht hat? Ach hier, 931 Millisekunden. Limit 1.

01:41:42.360 --> 01:41:53.640
Warum ändert das Limit was an der Zeit? Das Limit soll doch überhaupt keinen Einfluss

01:41:53.640 --> 01:42:03.080
auf die Zeit haben in dem Fall, er findet ja nix. Explain, ja, explain, lass uns jetzt

01:42:03.080 --> 01:42:32.920
explainen. I've had time. Und jetzt? Was, was, was willst du mir sagen? Ah, jetzt. Ah,

01:42:32.920 --> 01:42:46.200
I've had informations. Excellent, excellent. Bitmap heap scan on text values. Check condition.

01:42:46.200 --> 01:43:03.280
Bitmap index scan. Mhm, mhm, alles klar. Ja. Und was sagt mir das jetzt? Was sagt mir

01:43:03.280 --> 01:43:09.720
das jetzt genau? Jetzt weißt du Bescheid, ja, aber richtig. Jetzt habe ich voll den

01:43:09.720 --> 01:43:27.960
Plan, warum es so lange dauert. Analyse, Analyse. Also jetzt ist es obvious, jetzt ist ein klarer

01:43:27.960 --> 01:43:40.840
Fall. Wie ging das? Postgres Analyse. Nimm mal das Pattern nach dem Raus nach Like. Nein,

01:43:40.840 --> 01:43:46.280
das ist ja genau das, was ich machen will. Ohne das findet er nix. Da findet er genauso

01:43:46.280 --> 01:43:49.520
wenig. Also wir können das, wir können das tatsächlich mal raus machen. Er findet genauso

01:43:49.520 --> 01:43:57.040
wenig. Aber wir können uns die Geschwindigkeit mal angucken. Die Geschwindigkeit macht keinen

01:43:57.040 --> 01:44:07.200
großen. Sag mal. Die Datenbank ist aber schon richtig erstellt, oder? Kann man sich irgendwie

01:44:07.200 --> 01:44:16.240
die Infos davon anzeigen lassen, wie die erstellt wurde? Nee, ich habe keinen Index im klassischen

01:44:16.240 --> 01:44:23.240
Sinne. Ich habe einen Tree Cram Index, der für Textsuche da ist. Und die Textsuche ist

01:44:23.240 --> 01:44:31.360
ja auch saumäßig schnell, wenn er was findet. Aber warum ist das so langsam, wenn er nix

01:44:31.360 --> 01:44:58.760
findet? So, wie ging das jetzt? Explain Analyse. Nee, Collect Statistics. Explain Statement.

01:44:58.760 --> 01:45:12.920
Was sagt mir denn diese Cost, Cost dahinter denn jetzt? Explain. Wir lernen Datenbankzeug,

01:45:12.920 --> 01:45:20.480
das ist wirklich nix, wovon ich keine Ahnung habe. Cost, Cost. Also was mich enorm stutzig

01:45:20.480 --> 01:45:29.840
macht ist, warum ändert das Limit überhaupt was an der Zeit? Weil, wenn er nix findet,

01:45:29.840 --> 01:45:40.200
muss er sowohl bei Limit 1 als auch bei Limit 10 die ganze Datenbank durchsuchen. Fehlt

01:45:40.200 --> 01:45:47.720
ja nicht ein Character. Doch. Für die abschließende Sache schon. Aber ich will ja explizit die

01:45:47.720 --> 01:45:55.680
Limit-HTTP anfangen und danach irgendwas enthalten. Die gibt es nicht, aber das ist ja ein Fall,

01:45:55.680 --> 01:46:01.040
der passieren kann, dass es das nicht gibt. So wird das denn noch größer, wenn ich sage

01:46:01.040 --> 01:46:17.480
Limit 100? Nee. Warum ist das so extrem? Weil dadurch, dass wir diesen Tree Cram Index

01:46:17.480 --> 01:46:22.000
haben, sollte er das ziemlich schnell erkennen können, dass man eben, also was mich äußerst

01:46:22.000 --> 01:46:31.840
verwirrt ist, warum Limit 1 einfach doppelt so schnell ist. Obwohl es beides in die komplette

01:46:31.840 --> 01:46:53.000
Datenbank durchkämmt werden muss. Ja, gut Leute, ich hab keine Ahnung. Leute, ich lasse

01:46:53.000 --> 01:47:05.880
die Datenbank nochmal neu erstellen. Irgendwie so. Weiß nicht. Vielleicht. Keine Ahnung.

01:47:05.880 --> 01:47:31.640
So und woran erkenne ich jetzt, was da lang dauert? Cost 0. Cost 195. Was VirtualBox

01:47:31.640 --> 01:47:39.000
denkt an Bildschirme 600 mal 400? Kann schon sein. Der Installer wird das wahrscheinlich

01:47:39.000 --> 01:47:44.680
denken. Kannst du es nochmal mit Prozent-HTTP ausführen? Ja, das ist viel schneller, aber

01:47:44.680 --> 01:47:48.760
das ist auch klar, warum das viel schneller ist. Weil, oh nee, ich hab mich detached.

01:47:48.760 --> 01:47:55.360
Wie attache ich mich denn jetzt wieder? Macht das automatisch? Ah, das macht der automatisch.

01:47:55.360 --> 01:48:00.520
Das ist viel schneller. Guck, das dauert 26 Millisekunden. Aber ist auch klar, weil der

01:48:00.520 --> 01:48:11.720
findet halt 10 Stück und hört dann auf. Achso, ja, sowohl bei VirtualBox als auch bei, genau,

01:48:11.720 --> 01:48:21.680
als auch bei Vmware brauchst du Guest-Vmware-Tools, also Guest-Edition-Tools, dass er das erkennt,

01:48:21.680 --> 01:48:27.240
dass dein Desktop-Bildschirm und sowas. So, aber ich suche hier explizit. So, wir suchen

01:48:27.240 --> 01:48:45.320
jetzt mal nach was anderem, was es nicht gibt. Ok, Leute, jetzt blick ich nicht durch. Wenn

01:48:45.320 --> 01:48:53.840
ich was suche... Achso, das ist, weil ich keinen Prozent dahinter hab. Das ist, weil

01:48:53.840 --> 01:49:03.640
ich keinen Prozent dahinter hab. Hä? Warum ist... Warum ist HTTP... Ist das irgendwas

01:49:03.640 --> 01:49:12.040
mit HTTP... Ist das jetzt einfach nur Pech, dass ich HTTP suche? Escapt der da irgendwas,

01:49:12.040 --> 01:49:15.840
weil er denkt, ich mach irgendwelche... Ist das irgendein Security-Feature, dass wenn

01:49:15.840 --> 01:49:27.640
ich HTTP, dass einer besonders escapen muss oder so? Drück mal rechtsklick auf das Select-Statement.

01:49:27.640 --> 01:49:46.240
Und jetzt? Explain Plan. Explain Analyze. Ok. Ah ja, jetzt ist alles klar. Natürlich,

01:49:46.240 --> 01:50:11.640
das weiß ich Bescheid. Ja, 4,5 Billionen Dinger, das passt schon. So, ähm, wie sieht's mit

01:50:11.640 --> 01:50:20.360
HTTPS aus? Auch langsam. Haben wir sonst noch irgendwas in der Mitte? In.NET haben

01:50:20.360 --> 01:50:28.160
wir manchmal am Ende stehen, ne? Aber auch viel zu langsam, für dass er es nicht findet.

01:50:28.160 --> 01:50:38.200
Nein, eine Sekunde ist kacke. Wir hatten es ja vorher schon. Vorher war das im Durchschnitt

01:50:38.200 --> 01:50:46.080
15, war das irgendwie 300 Millisekunden oder so das Langsamste? Moment. Vorher war das

01:50:46.080 --> 01:50:53.640
300 Millisekunden. Was hatten wir noch mal vorher? Moment, Moment, Moment, Moment. Aber

01:50:53.640 --> 01:51:01.160
ich muss noch kurz einen Comment machen, sonst check ich, blick ich nicht mehr durch. Ähm,

01:51:01.160 --> 01:51:15.040
sind wir hier richtig? Get in it. Get add. Oh ne, jetzt hab ich binaries gealtert. A minus

01:51:15.040 --> 01:51:23.000
M hack W. Wunderbares Comment. Exzellent. So, ähm, und jetzt machen wir das mal rückgängig.

01:51:23.000 --> 01:51:50.800
Moment. Kann ich mal weiter rückgängig machen? Äh, local history. History. What? History?

01:51:50.800 --> 01:52:00.680
Ist doch local history. So, wo, also wir machen das einfach mal rückgängig, was wir heute

01:52:00.680 --> 01:52:09.680
gemacht haben. So, hier haben wir angefangen. 13 Uhr, gib ihm. Revert. Bam. Yep. So. Ach

01:52:09.680 --> 01:52:21.680
so, da hab ich Wildcard-Dings komplett gemacht. Dann findet er, dann findet er ja was. Okay,

01:52:21.680 --> 01:52:36.480
dann mach ich das, dann mach ich das hier mal raus. So. Run. Und jetzt Http. Das ist

01:52:36.480 --> 01:52:55.720
immer noch langsam. Ich fass das nicht. Okay, keine Ahnung. Aber, okay, wir suchen mal

01:52:55.720 --> 01:53:01.040
was anderes. Hier, keine Ahnung, blub. So, blub. Tia.net. Tia wollte schon immer mal

01:53:01.040 --> 01:53:11.800
suchen. Ja, der findet welche. Punkt.net. Punkt.net. Wunderbar. Nee. Punkt. Name. Ach, jetzt funktioniert

01:53:11.800 --> 01:53:16.000
sie ja mit meiner Suche nicht mehr. Ja, so. Danach will ich suchen unbedingt. Das ist

01:53:16.000 --> 01:53:22.960
das, was ich schon immer mal suchen wollte. Das sind 1,5 Millisekunden. Ist das wirklich,

01:53:22.960 --> 01:53:27.760
ist das vielleicht echt ein Problem, weil es Http ist? War dumme Frage. Könnte das

01:53:27.760 --> 01:53:43.240
wirklich daran liegen, dass es Http ist? Dass die Zeichenfolge Http ist? Ich mein, nee,

01:53:43.240 --> 01:53:49.320
das wird's nicht sein. Hat keine Resultate. Ja, wie Http nicht. Aber genau, das Problem

01:53:49.320 --> 01:53:53.800
ist Http gibt es, na doch, Tia.net gibt es auch ein paar Mal, aber Http gibt es halt

01:53:53.800 --> 01:54:07.200
eben 4,5 Millionen Mal. Okay. Keine Ahnung. Bei Http findet er eine Menge Treffer und

01:54:07.200 --> 01:54:14.680
muss viele Wildcards verarbeiten. Naja. Das stimmt, das wird's. Ja, das ist es. Das ist

01:54:14.680 --> 01:54:24.280
wahrscheinlich echt so. Http ist in 4,5 Millionen Rows drinne. Und er muss gucken, ob es dort

01:54:24.280 --> 01:54:33.520
am Anfang ist. Aber gerade das sollte eigentlich durch den Index schnell sein. Dafür gibt's

01:54:33.520 --> 01:54:43.000
den ja. Dass der eben erkennt, dass es Http nicht am Anfang gibt. Ich lass die Datenbank

01:54:43.000 --> 01:54:48.680
jetzt noch mal neu erstellen. Wobei das dauert wieder ewig. Dauert wieder 5 Minuten oder

01:54:48.680 --> 01:54:56.640
10 Minuten. Ohne Limit. Ich kann das Limit mal komplett weglassen, ja. Sollte ja genauso

01:54:56.640 --> 01:55:07.280
schnell sein von der Idee her. Ja. Http hat nix. Also von der Idee her sollte es insofern

01:55:07.280 --> 01:55:13.080
schnell sein. Weil, Docker stellt es hier. Machen wir noch mal hier das, was wir das

01:55:13.080 --> 01:55:19.840
letzte Mal gemacht haben. Also, der speichert ja für jedes, für jeden Text, also für

01:55:19.840 --> 01:55:26.600
das, was man hier sieht. Also für jedes dieser Dinger. Nehmen wir mal zum Buster. Nehmen

01:55:26.600 --> 01:55:34.120
wir hier das da. Aus den humberto.net. Das übrigens Fake-Daten, das Zeug gibt's alles

01:55:34.120 --> 01:55:42.920
nicht. Wobei, soll ich mich trauen mal, who is humberto.net? Das sind zwar Fake-Daten,

01:55:42.920 --> 01:55:57.240
aber Moment, ist das wirklich registriert? Das ist anscheinend wirklich registriert.

01:55:57.240 --> 01:56:04.600
Huberto.net, alles klar. Meine Fake-Daten sind anscheinend echte Daten, sehr gut. Also,

01:56:04.600 --> 01:56:09.880
das macht die Datenbank beim Speichern dieses Textes da raus. Eben damit die Suche schneller

01:56:09.880 --> 01:56:20.120
geht. Der zerlegt Austin, Http, humberto.net in solche Dreierpaare. Und das speichert er

01:56:20.120 --> 01:56:23.160
sich dann wahrscheinlich in einem sortierten Index, dass er Binary Research machen kann

01:56:23.160 --> 01:56:28.480
oder was auch immer er dann macht. Keine Ahnung. Und deswegen sollte er ziemlich schnell

01:56:28.480 --> 01:56:40.480
feststellen, aha, der Typ sucht nach Http. Ah, ja, natürlich, das ist ja eigentlich ganz

01:56:40.480 --> 01:56:49.480
logisch, dass das langsam ist. Ja, ja, das funktioniert. Funktioniert, tut das. Die

01:56:49.480 --> 01:56:55.240
anderen Queries sind sonst richtig langsam. Aber guck mal, von der Idee her, der guckt

01:56:55.240 --> 01:57:01.480
da rein in seinen Index. Wahrscheinlich weiß der nicht so ohne weiteres, ob das am Anfang

01:57:01.480 --> 01:57:08.560
oder in der Mitte ist. Der weiß nur, dass irgendwie in dem Index Htt drin steht. Und

01:57:08.560 --> 01:57:15.440
dann muss der wahrscheinlich gucken, genau, und das findet er 4,5 Millionen Mal. Und dann

01:57:15.440 --> 01:57:21.400
muss der wahrscheinlich gucken, ist es am Anfang. Der muss wahrscheinlich wirklich jeden Eintrag

01:57:21.400 --> 01:57:33.760
durchgehen und gucken, ist es denn am Anfang. Da ist wahrscheinlich nicht direkt die, selbst

01:57:33.760 --> 01:57:38.120
wenn die Position direkt gespeichert ist, so quasi, mal angenommen, da würde Index

01:57:38.120 --> 01:57:45.600
off dahinter gespeichert sein, was ja nicht geht, weil das könnte ja mehrfach drinne,

01:57:45.600 --> 01:57:49.040
was auch immer. Aber selbst wenn da direkt die Position dahinter steht, der muss ja jeden

01:57:49.040 --> 01:57:58.040
Eintrag durchgehen und gucken, ob der nicht am Anfang steht. Das ist jetzt absolut der

01:57:58.040 --> 01:58:12.600
Worst Case eigentlich. Ich denke in dem Fall, also wie soll ich sagen, in den normalen Daten,

01:58:12.600 --> 01:58:18.600
die ich da habe, wäre das ja wahrscheinlich überhaupt nicht der Fall. Kann man den Index

01:58:18.600 --> 01:58:30.120
manuell zu Http oder Https ändern? Hä, wie? Aber das ist jetzt einfach bei Design verkackt.

01:58:30.120 --> 01:58:35.800
Meine Testdaten sind halt so ein bisschen doof, weil da Http überall drinne ist und ich suche

01:58:35.800 --> 01:58:44.720
halt zufälligerweise direkt nach Http. Dann ist es ein ziemlich doofes Beispiel, dass

01:58:44.720 --> 01:58:50.000
ich bereits Http rausgepickt habe. Das wird wahrscheinlich in der Art und Weise in echt

01:58:50.000 --> 01:58:54.440
nie der Fall sein. Mal davon abgesehen, das wird auf jeden Fall definitiv nicht der Fall

01:58:54.440 --> 01:58:59.480
sein, weil ich dort irgendwelche Prometheus Exporte reinpumpen würde und die haben zwar

01:58:59.480 --> 01:59:05.040
sicherlich ab und zu mal Http in der Domain, aber die meisten Label Value Pairs sind sonst

01:59:05.040 --> 01:59:14.080
was, bloß nicht Domains, die mit Http anfangen. Nice. Okay, ja, das ergibt aber Sinn, dass

01:59:14.080 --> 01:59:42.960
es so langsam ist. Das ergibt tatsächlich Sinn. Ja. Das ergibt tatsächlich Sinn. Dann

01:59:42.960 --> 01:59:53.640
fällt mir nichts ein, um es schneller zu machen zu dem, was ich das letzte Mal gebaut

01:59:53.640 --> 02:00:18.200
habe. MySQL? Hä? Ich bezweifle, dass das MySQL schneller kann. Ja. Und weiter? Also

02:00:18.200 --> 02:00:32.040
ich kenne die Hilfeseite dazu. Mit Fulltext Search sollte es schneller sein. Da habe ich

02:00:32.040 --> 02:00:40.000
so meine Zweifel, weil das sind ja keine Wörter. Fulltext Search ist bei Wörtern schnell, aber

02:00:40.000 --> 02:00:48.600
bei Substrings von Wörtern Elastic Search, ja, gut, so was könntest du da mit Sicherheit

02:00:48.600 --> 02:00:59.400
drauf schießen, ja. Also die Postgres, die Postgres Fulltext Search kann zum Beispiel

02:00:59.400 --> 02:01:10.200
keine Substrings von Wörtern, eben weil es keine Wörter sind. Und wenn MySQL das kann,

02:01:10.200 --> 02:01:14.640
dann ist es wahrscheinlich, weil MySQL Fulltext Search plus das, was Postgres hier in dem

02:01:14.640 --> 02:01:23.120
Fall mit diesen Drupeldingern Wörtern macht, auch macht, bloß automatisch. Die können

02:01:23.120 --> 02:01:30.840
ja alle nicht zaubern. Das Full in Fulltext Search bezieht sich auf ganze Wörter. Das

02:01:30.840 --> 02:01:35.200
ist kein ganzes Wort. Weil natürlich könnte man als Trainer irgendwie jetzt sagen, nicht

02:01:35.200 --> 02:01:40.080
Leerzeichen, sondern gleich, aber das weißt du ja vorher nicht. Fulltext Search ist in

02:01:40.080 --> 02:01:47.720
der Regel nichts für Substring, vor allem nicht für Substring mit Wildcard davor. Dafür

02:01:47.720 --> 02:01:53.520
ist Fulltext Search kacke. Weil Fulltext Search in der Regel so funktioniert, dass du deinen

02:01:53.520 --> 02:01:59.480
Text, ganz simpel gesagt, du nimmst deinen Text, splittest den in Wörter und dann machst

02:01:59.480 --> 02:02:09.040
du einen Index draus. Also du machst eine Liste draus, sagen wir mal alphabetisch sortiert,

02:02:09.040 --> 02:02:14.360
dass du in deine Liste dann per Binary Search relativ schnell finden kannst. Wo ist das?

02:02:14.360 --> 02:02:20.320
Dann hast du das Wort gefunden und zu dem Wort hast du dann dir noch zusätzlich gespeichert,

02:02:20.320 --> 02:02:24.640
in welchem Dokument das vorkommt, an welcher Position. Das ist so ganz grob kurz gesagt

02:02:24.640 --> 02:02:30.600
wie Fulltext Search funktioniert. Und das Full in Fulltext bezieht sich auf komplette

02:02:30.600 --> 02:02:36.280
Wörter. Und was Fulltext normalerweise überhaupt nicht gut kann, sind Wildcards am Anfang,

02:02:36.280 --> 02:02:42.840
weil er dann die Liste auch komplett durchscannen muss. Ja, da muss ich mir mal was überlegen.

02:02:42.840 --> 02:02:49.280
Ich hab gedacht, das könnte man jetzt besonders schlau machen, das so zu beschleunigen, aber

02:02:49.280 --> 02:02:54.520
der absolute Worst Case, wenn HTTP wirklich in jedem einen Tag vorkommt und es nicht

02:02:54.520 --> 02:03:19.080
matcht. Wobei könnte man das nicht einfach umdrehen? Nee, ich brauch ja beides, ich will

02:03:19.080 --> 02:03:25.080
es ja nicht. Ja, da fällt mir nichts ein zu. Dann fällt mir nichts ein zu, wie man das

02:03:25.080 --> 02:03:31.560
schneller machen kann, wobei es ja so schon saumäßig schnell ist. Der braucht ja nur

02:03:31.560 --> 02:03:42.240
bei der Diomalessuche nur 30-40 Millisekunden. Ich will es ja nicht, ich will es ja finden,

02:03:42.240 --> 02:03:48.080
ich will es ja finden. Wann kommt Battlefield Bad Company 3? Das musst du mal EA fragen,

02:03:48.080 --> 02:03:54.240
was soll ich das wissen? Wahrscheinlich gar nicht, weil DICE vor einer Weile gesagt hat,

02:03:54.240 --> 02:03:57.560
sie haben verlernt, sie haben das ein bisschen anders ausgedrückt, aber sinngemäß haben

02:03:57.560 --> 02:04:06.560
sie gesagt, sie haben verlernt oder sie wissen nicht mehr, was an Battlefield Bad Company

02:04:06.560 --> 02:04:12.760
den Leuten gefallen hat. Mach doch einen Präfix vor dem Wort. Ja und dann? Also das

02:04:12.760 --> 02:04:21.160
weiß ja derjenige, der danach sucht, nicht. Der hat ja keine Ahnung. Irgendeiner tippt

02:04:21.160 --> 02:04:28.120
im Webinterface HTTP ein, erwartet, dass er Antworten bekommt für HTTP. Das weiß man

02:04:28.120 --> 02:04:32.480
nicht, ob alle HTTP haben. Es ist in diesem Fall mit diesen Daten so, aber das weißt du

02:04:32.480 --> 02:04:41.040
ja nicht. Es wird in der Praxis auch nie relevant sein, gehe ich mal von aus, weil das, was

02:04:41.040 --> 02:04:47.960
ich davor hatte, reinzupumpen, hat das definitiv nicht. Aber ich überlege gerade, ob es irgendwie

02:04:47.960 --> 02:04:58.800
eine schlaure Variante als das gibt. Weil in dem Fall, hier macht es halt das Order

02:04:58.800 --> 02:05:13.280
bei langsam. Fällt mir jetzt gerade nichts ein. Bin ich gerade zu low IQ für? Reicht

02:05:13.280 --> 02:05:18.080
man eigentlich an Datenbank-Grempel jetzt schon mal? Sollen im Webinterface alle 4,5

02:05:18.080 --> 02:05:22.760
Millionen Treffer rauskommen? Nein, nein. Im Webinterface sollen 10 Ergebnisse rauskommen,

02:05:22.760 --> 02:05:32.360
aber der Trick ist ja, jedes Zeitproblem ist gelöst, insofern, dass ich jetzt nachvollziehen

02:05:32.360 --> 02:05:48.240
kann, warum es langsam ist. Also ich will bloß 10 Ergebnisse haben. Aber ich möchte,

02:05:48.240 --> 02:05:58.320
die die mit dem Query anfangen, die will ich oben haben. Wenn ich das hier rausnehme und

02:05:58.320 --> 02:06:08.240
die random sortiert lasse, dann ist es mega schnell, aber ich habe nicht die, die mit

02:06:08.240 --> 02:06:13.080
dem Query anfangen oben. Weil ich hätte gerne, wenn einer zum Beispiel einen gibt, dann

02:06:13.080 --> 02:06:18.800
hätte ich gerne, dass er zuerst 10 Stück nimmt, falls es die gibt, die Plup am Anfang

02:06:18.800 --> 02:06:23.680
haben und wenn es die halt nicht gibt, sondern sagen wir nur 3 Stück mit Plup am Anfang,

02:06:23.680 --> 02:06:30.280
dann eben noch 7 Stück mit Wildcard auffüllt. Das funktioniert auch, aber dabei sind wir

02:06:30.280 --> 02:06:37.800
drauf gestoßen, wenn man nicht nach Plup sucht, sondern nach HTTP, dann funktioniert es insofern

02:06:37.800 --> 02:06:43.160
nicht richtig, es funktioniert schon, aber es funktioniert langsam. Weil er eben HTTP

02:06:43.160 --> 02:06:50.560
potenziell findet in jedem Wort und dann 4,5 Millionenfach checken muss, ist HTTP denn

02:06:50.560 --> 02:06:59.120
am Anfang. Das ist eigentlich relativ logisch, dass das langsam ist. Ja, da muss ich mir

02:06:59.120 --> 02:07:01.880
irgendwas überlegen. Vielleicht fällt mir noch was ein oder ich lasse es einfach so.

02:07:01.880 --> 02:07:13.320
Nein, Timeout ist doch doof, ich will auch ein Ergebnis haben. Zur Not gegebenenfalls

02:07:13.320 --> 02:07:20.720
zwei Queries machen mit Wearfilter für das Startwith, dann kann der Präfix, äh, was?

02:07:20.720 --> 02:07:28.720
Nein, nein, nein, das ist ja das, was nicht funktioniert, guck mal. Das ist ja das, was

02:07:28.720 --> 02:07:32.680
nicht funktioniert. Das ist ja das, was ich schon gemacht habe. Guck mal, wenn du das

02:07:32.680 --> 02:07:38.040
hier machst, wenn du hier checken willst, ist es am Anfang. Das ist ja das, was du meinst,

02:07:38.040 --> 02:07:43.200
ne? Zwei Queries. Du machst dieses Query mit, äh, ist am Anfang und dann machst du dieses

02:07:43.200 --> 02:07:48.840
Query mit, ist irgendwo in der Mitte. So, aber das hier ist langsam. Das ist langsam

02:07:48.840 --> 02:07:58.920
erst fuck, wenn du das ausführst. Das braucht knapp ne Sekunde. Und warum? Weil er nachguckt,

02:07:58.920 --> 02:08:06.720
aha, das Wort startet mit HTT. In dem Fall zerlegt er auch HTTP, weder in HTT unter anderem

02:08:06.720 --> 02:08:11.520
und dann muss er bei jedem dieser 4,5 Millionen gefundenen Einträge gucken, ist das HTT am

02:08:11.520 --> 02:08:25.720
Anfang. Ich kanns, im Prinzip kann ichs auch so lassen. Im Prinzip kann ichs so lassen,

02:08:25.720 --> 02:08:29.320
wie ich die ganze Zeit schon gemacht hab, weil es ist immer noch schneller als im Worst

02:08:29.320 --> 02:08:43.120
Case mein anderes Ding. Da fällt man manchmal in Fallen rein, wo man gar nicht gedacht hat,

02:08:43.120 --> 02:08:47.760
dass es die gibt. Ja, das hat nen Index. Es hat zwar keinen klassischen Index, aber es

02:08:47.760 --> 02:09:11.200
hat so ne Art Index. Interessant. Tja, ne, da fällt mir jetzt wirklich nichts Gescheites

02:09:11.200 --> 02:09:18.920
zu ein, außer das einfach so zu lassen, wie wir es das letzte Mal schon gemacht haben.

02:09:18.920 --> 02:09:41.600
Ein klassischer Index sollte den Präfix-Check beschleunigen können. Geht in Postgres ein

02:09:41.600 --> 02:09:46.240
Substring-Index? Ja, das haben wir doch. Da gehts doch darum. Genau das haben wir. Wir

02:09:46.240 --> 02:09:51.120
haben für jeden Texteintrag, so speichert Postgres so ne Kombination aus allem möglichen,

02:09:51.120 --> 02:09:55.280
dass du Substring Search mark hast. Aber vielleicht muss man noch nen klassischen Index drauf

02:09:55.280 --> 02:10:04.360
machen, um zu gucken, ob das Starts, das könnten wir tatsächlich mal machen, ja. Das machen

02:10:04.360 --> 02:10:08.920
wir jetzt. Das machen wir jetzt. Wie bring ich dem dann bei, nen normalen Index zu machen

02:10:08.920 --> 02:10:13.120
noch zusätzlich? Dann müssen wir die Datenbank nochmal neu erstellen lassen wahrscheinlich.

02:10:13.120 --> 02:10:24.320
Also das ist der Index für Substring-Suche. Wie sag ich dem, dass er noch nen normalen

02:10:24.320 --> 02:10:47.680
Index drauf machen soll? Nochmal Has-Index? Ne, oder? Weiß ich gar nicht, wie mach ich

02:10:47.680 --> 02:10:54.520
das? Kein Schimmer. So hab ich das für diese Substring-Suche auf jeden Fall rausbekommen

02:10:54.520 --> 02:11:00.560
das letzte Mal. Muss man, muss man das nicht doppelt machen? Einfach nochmal so Sachen,

02:11:00.560 --> 02:11:12.880
Has-Index oder so? Okay. EF Core Postgres-Index. Wie geht das? Zeig her. Has-Index. Ja gut,

02:11:12.880 --> 02:11:40.040
auf der ID ist schon mal klar. Im normalen Fall, also was mich eigentlich interessiert

02:11:40.040 --> 02:12:03.720
ist Wildcard-Wort-Wildcard. Das ist Darkreader-Neighbor-Youblog. Aber halt eben dann die, die mit was anfangen

02:12:03.720 --> 02:12:15.240
als erstes. Naja meine Idee war jetzt ja ursprünglich, anstatt diese Abfrage hier mit dem Order-Buy

02:12:15.240 --> 02:12:23.000
zu machen, wir machen einfach zwei Queries. Einmal eins ohne Wildcard und wenn das schon

02:12:23.000 --> 02:12:27.840
zehn Stück zurückgibt, dann ist alles gut. Ansonsten führen wir einfach das Query nochmal

02:12:27.840 --> 02:12:34.120
so aus und nehmen halt noch sieben zusätzliche zum Beispiel dazu davon dann. Das Problem

02:12:34.120 --> 02:12:40.800
ist nur, dass dieses Query, wenn man HTTP eingibt, halt übelst langsam ist. Und dieses

02:12:40.800 --> 02:12:45.640
ist übrigens nicht langsam bei HTTP, weil er eben was findet. Und ich gehe mal davon

02:12:45.640 --> 02:12:49.280
aus, wenn ich was suche, was er gar nicht findet, was gar nicht in diesem Index drinne

02:12:49.280 --> 02:12:53.640
ist, dann ist es auch schnell, weil dann kann er direkt sagen, hier so nach dem Motto was

02:12:53.640 --> 02:13:11.160
wie blub, hier gibt es kein blub, kann nicht sein. S-Index. Wie kann ich dem denn jetzt

02:13:11.160 --> 02:13:15.680
sagen, dass ich anstatt hier in diesem Index noch einen normalen Index machen will? So

02:13:15.680 --> 02:13:24.120
jetzt? Funktioniert das so? Keine Ahnung. Ich bin Stocher da voll im Dunkeln. S-Index.

02:13:24.120 --> 02:13:37.720
Ah nee, der hat das schon. Nee, das passt schon. Der hat schon den Index erstellt dafür.

02:13:37.720 --> 02:13:43.200
Guckt mal, das ist schon richtig. Der macht hier einen wie auch immer gerne GIN-Index

02:13:43.200 --> 02:13:54.520
und dann macht er noch diese andere Geschichte obendrauf. Nee, dann habe ich wirklich keine

02:13:54.520 --> 02:14:21.720
Ahnung mehr. Wisst ihr was? Dann lassen wir das einfach so. Das denke ich auch, ja. Ja,

02:14:21.720 --> 02:14:27.680
ich glaube, das hat er. Ich glaube, das hat er hiermit schon. Zumindest wenn man den,

02:14:27.680 --> 02:14:42.160
wenn man das hier dieser, dieser Doku-Seite von denen glaubt. Oder muss ich nochmal, oder

02:14:42.160 --> 02:14:54.200
muss ich das einfach zweimal machen? Einmal so und einmal so? Kannst du irgendwie aussuchen,

02:14:54.200 --> 02:15:04.880
welchen Index da beim aktuellen Query benutzen willst? Bestimmt irgendwie? So, wir machen

02:15:04.880 --> 02:15:08.280
das, ich gucke mal, ob man so die Datenbank erstellen kann, ob das in irgendeiner Art

02:15:08.280 --> 02:15:12.120
und Weise schneller ist. Wisst ihr was? Wir lassen dieses ganze Krempel, wir lassen den

02:15:12.120 --> 02:15:18.240
mal weg. Wir lassen den mal weg und erstellen den neu und gucken, ob mit einem einfachen

02:15:18.240 --> 02:15:30.680
Index, der startet mit schneller ist. Probieren wir das mal aus. Ja, 900 Millisekunden ist,

02:15:30.680 --> 02:15:36.720
mir geht es nicht wirklich darum, dass das jetzt besser benutzbar wird oder so. Generell,

02:15:36.720 --> 02:15:41.840
wenn es darum geht, müsste ich das ja gar nicht machen. Hab ich das so gemacht, dass

02:15:41.840 --> 02:15:50.160
es funktioniert? Hoffe mal. Run. Mir geht es einfach, dass ich was lerne drum. Nicht,

02:15:50.160 --> 02:16:02.160
dass da irgendwie was so Sinnvolles bei rauskommt. So, jetzt wird eine Runde geinsertet in den

02:16:02.160 --> 02:16:15.200
Index bzw. nicht in die Datenbank. Das dauert jetzt 1-2 Minuten. Oder habe ich den Output

02:16:15.200 --> 02:16:24.280
abgeschaltet? Übrigens, random Seed 1337, ganz wichtig, immer bei eurem Randomizer Seed

02:16:24.280 --> 02:16:35.000
1337 verwenden. Ihr solltet prinzipiell nicht den Seed irgendwo reinschreiben, dann ist

02:16:35.000 --> 02:16:51.000
es nämlich ziemlich easy, eure Secrets zu erraten, das will man nicht. Du brauchst ziemlich

02:16:51.000 --> 02:17:01.720
sicher, wie gesagt, Guest Tools, dass es funktioniert. Du brauchst, wie heißt das mal, Virtual Box?

02:17:01.720 --> 02:17:10.340
Virtual Box Guest Tools, wie nennt man sich der Kram? Du hast zuerst ins CD, dann musst

02:17:10.340 --> 02:17:16.040
du starten oder zumindest die Kiste neu starten und dann musst du in der VM keine Auflösung

02:17:16.040 --> 02:17:21.880
einstellen. Sobald die Guest Tools, Guest Editions, genau, sobald die Guest Tools funktionieren,

02:17:21.880 --> 02:17:31.600
macht er automatisch das Ding auf die richtige Auflösung. Guck, jetzt ist es auf der richtigen

02:17:31.600 --> 02:17:41.160
Auflösung, er macht es automatisch, siehste? Ok, Datenbank Insert dauert ein bisschen.

02:17:41.160 --> 02:17:49.480
So, jetzt haben wir eine Datenbank gleich mit keinem Substring-Dingsgedöns-Durchsuch-Index,

02:17:49.480 --> 02:18:01.520
aber eine mit einem stinknormalen Index auf das Textfeld. Und dann gucken wir mal, ob

02:18:01.520 --> 02:18:14.840
das schneller ist. Open VM Tools? Nee, das bringt ja nichts, er hat Virtual Box. Und wenn

02:18:14.840 --> 02:18:20.960
er Virtual Box hat, bringen ihm Open VM Tools nichts. Ich würde eh, ganz ehrlich, ich würde

02:18:20.960 --> 02:18:25.640
nicht Virtual Box, ich würde Forever Workstation nehmen oder? Ach nee, Forever Player gibt's

02:18:25.640 --> 02:18:29.920
ja nicht mehr, oder? Forever Player war früher die kostenlose Variante, ich glaube, Forever

02:18:29.920 --> 02:18:37.520
Player kostet doch jetzt auch was. Was Open VM Tools geht auch mit Virtual Box? Echt?

02:18:37.520 --> 02:18:49.800
Das ist nice. Das ist mir neu, weil ich immer VM mehr verwende. Gehen die auch, das ist

02:18:49.800 --> 02:18:53.920
ja der Chat, die ganzen Prime-Subs haben sich gelohnt, der Chat ist mittlerweile absolut

02:18:53.920 --> 02:19:05.920
hier Next-Level-IQ-Werte. Der weiß Bescheid. Das heißt, Chat, wenn ihr auch Next-Level-IQ-Werte

02:19:05.920 --> 02:19:10.600
habt, müsst ihr mir auch einen Prime-Sub dalassen, weil das gilt für den kompletten Chat. Ist

02:19:10.600 --> 02:19:15.080
quasi geshared jetzt zwischen 230 Leuten, aber nur, wenn ihr gerade zuguckt. Sonst geht

02:19:15.080 --> 02:19:22.240
das nicht. So, Datenbank, inserte mal, please. Etwas schneller. Ich glaube, ich sollte mal

02:19:22.240 --> 02:19:28.760
mein Logging ausschalten, weil mein Arbeitsspeicher ist zu 94% voll und wahrscheinlich liegt es

02:19:28.760 --> 02:19:42.080
daran, weil mein Terminal den ganzen Text drinstehen hat. Weil ich bin ziemlich blöde

02:19:42.080 --> 02:19:56.920
gewesen. Mein Terminal hat unlimited scrollback-Buffer. Er ist fertig, Poggers. So, diesen Krämpel

02:19:56.920 --> 02:20:01.040
hier gleich mal wieder auskommentieren, dass er nicht jedes Mal neu die Datenbank erstellt.

02:20:01.040 --> 02:20:06.880
Passt mal auf, ich schließe jetzt mein Terminal, mal gucken wir, wie viel Arbeitsspeicher er

02:20:06.880 --> 02:20:23.720
gleich freigibt. Oh, Kinga, Kinga, Kinga. Wie habe ich es genannt? Search-Champ. Okay,

02:20:23.720 --> 02:20:30.880
dann gehen wir mal hier in dieses Data-Ding wieder und machen noch mal das Gleiche. Aha,

02:20:30.880 --> 02:20:45.920
aha, guck mal, es ist schneller, es ist schneller. Jetzt ist es bloß 317 Millisekunden, es ist

02:20:45.920 --> 02:20:56.320
schneller. Der best case, ja den best case, ich weiß nicht, ob ich den gescheit testen

02:20:56.320 --> 02:21:04.040
kann überhaupt. Hiermit. Ich meine, das müsste langsam, langsam sein jetzt mit dem nicht

02:21:04.040 --> 02:21:09.760
vorhandenen Textsearch-Index. Achso, der macht automatisch einen Limit. Dann ist es

02:21:09.760 --> 02:21:28.240
auch schneller. Aber ja, ich limite 10. Ja, das ist natürlich hier auch schnell, weil

02:21:28.240 --> 02:21:37.640
überall HTTP drin ist. Also, suchen wir mal irgendwie emerald.org oder so. Ja, das dürfte

02:21:37.640 --> 02:21:45.400
jetzt, das dürfte jetzt nicht so schnell sein. Ja, Mist, ja, der hat ja halt nur, das ist

02:21:45.400 --> 02:21:51.880
ja doof, der hat halt nur 5 Domains oder so, die den Test-Ding an einträgt. 5000 Limit,

02:21:51.880 --> 02:22:03.040
bam. Ja, jetzt braucht er schon ein bisschen länger. Ja. Also, normale Suche mit Wildcard

02:22:03.040 --> 02:22:10.480
dauert jetzt halt deutlich länger. Es dauert jetzt 500 Millisekunden, um alles zu finden.

02:22:10.480 --> 02:22:24.080
Und, äh, was machen wir denn mal? Was hab ich? Eleanor. Und das ist halt 300 noch was. Warum

02:22:24.080 --> 02:22:40.240
limitiert der immer auf 500? So, macht er gar nicht. All, bam. 1500, gib ihm. Er ist

02:22:40.240 --> 02:22:47.360
tatsächlich, wenn er am Anfang ist, ist er doch relativ, relativ geschwind. Kann er

02:22:47.360 --> 02:22:53.440
nicht Jeanette-mäßig mal bitte hier auf All bleiben? Okay, also ich denke schon, dass

02:22:53.440 --> 02:23:00.520
der normale Index tatsächlich was bringt. Und jetzt das andere mit einkommentieren, ja.

02:23:00.520 --> 02:23:05.760
Ja, ja, probieren wir das mal aus. Jetzt müsste man nur noch fragen können, ob man in dem

02:23:05.760 --> 02:23:17.320
Query irgendwie sagen kann, was er für einen Index verwenden soll. Wahrscheinlich meckert

02:23:17.320 --> 02:23:21.440
er jetzt rum, dass das nicht funktioniert, dass das schon ein Index existiert oder sowas.

02:23:21.440 --> 02:23:36.280
Wahrscheinlich meckert er, dass es schon ein Index gibt. Probieren wir mal aus. Ähm, ich

02:23:36.280 --> 02:23:48.080
werde mal kurz die Output umleiten, dass mein Terminal nicht wieder abkackt. Ach so,

02:23:48.080 --> 02:23:56.640
jetzt sehe ich die Fehlermeldung ja gar nicht. Okay, das ist ziemlich blöd. Zack. Ne, das

02:23:56.640 --> 02:24:05.160
funktioniert. Der meckert nicht rum dabei. Und wann heißt, und wann weiß, dass er fertig

02:24:05.160 --> 02:24:26.280
ist? Gute Frage. Gar nicht. Doch. Wartet mal. Ich stelle das Locklevel hoch. Ich stelle

02:24:26.280 --> 02:24:31.040
das Locklevel. Wo ist das denn hier nochmal? Locklevel? Das ist immer so versteckt bei

02:24:31.040 --> 02:24:49.560
dem Campbell. Wo waren das nochmal? App-Settings? Hier, die vollen Locklevel. Warning. Moment,

02:24:49.560 --> 02:24:57.920
Development ist es doch. Stimmt doch gar nicht. Info-Development-Warning. Ich mache einfach

02:24:57.920 --> 02:25:04.000
das Locklevel hoch, dann sehen wir es nicht mehr. Er erstellt nur einen GIN-Index, ist

02:25:04.000 --> 02:25:15.880
das so? Das müssen wir uns nochmal angucken. Run. Also, was macht er hier? Zeigt mal her.

02:25:15.880 --> 02:25:21.200
Die Datenbank Pfeiferts hier unter uns. Also, Create-Index. Tatsächlich, er macht nur einen

02:25:21.200 --> 02:25:34.200
GIN-Index. Dann weiß ich auch nicht. Muss ich die Sachen dann doppelt in die Datenbank

02:25:34.200 --> 02:25:57.840
schreiben oder was? Boah, keine Ahnung. Was passiert denn? Was passiert denn? Wie sieht

02:25:57.840 --> 02:26:09.040
das aus, wenn man das weglässt? Was macht er dann? Ja, dann sagt er Create-Index. So,

02:26:09.040 --> 02:26:13.560
das kommt jetzt auf die Reihenfolge an? Dann kann es ja nicht funktionieren, wenn es doppelt

02:26:13.560 --> 02:26:36.600
drin ist. Okay. Das juckt ihn überhaupt nicht. Es zählt immerhin nur, das muss man bestimmt,

02:26:36.600 --> 02:26:45.920
man muss irgendwie doppelt HESS-Index machen oder irgendwie sowas. Okay, das befragen

02:26:45.920 --> 02:27:09.560
wir den jetzt mal. Multiple-Index-On-Same-Column, richtig? Ja, ne? Ah, Stack Overflow, alles

02:27:09.560 --> 02:27:20.360
gut. Multi-Column, ne? Combine Multiple-Indexes. Ich will einfach nur zwei verschiedene Indextypen

02:27:20.360 --> 02:27:28.360
haben. Stimmt, das ist... Ich wollte auch gar nicht nach Postgres suchen. Ich wollte

02:27:28.360 --> 02:27:43.000
eigentlich auch nach Ding suchen, nach NPGSQL wollte ich eigentlich suchen, nach dem EF-Core-Ding,

02:27:43.000 --> 02:28:09.960
nach dem Postgres-Adapter. Oh, das sind jetzt schon die absolut High-IQ-Datenbank-Dingern.

02:28:09.960 --> 02:28:24.400
Das ist mir jetzt zu hoch, da mach ich nicht weiter. Ne, keine Ahnung, hab ich kein Bock

02:28:24.400 --> 02:28:30.400
mehr. Ich lass es jetzt einfach so. Ich lass es jetzt einfach so. Es funktioniert ja und

02:28:30.400 --> 02:28:34.920
es ist auch relativ schnell. Das ist halt ein dummer Worst-Case mit Hard-TDP, aber scheiß

02:28:34.920 --> 02:28:49.520
drauf. Oh, ne, reicht spätst. Keine High-IQ-Lösung heute, aber gut, wir haben was gelernt. Und

02:28:49.520 --> 02:28:53.800
ich hab jetzt auch mal Datacrypt verwendet. Kann ich gleich wieder zumachen, werd ich

02:28:53.800 --> 02:29:05.600
nie mehr verwenden. Reicht genug. Genug. So Leute, ich muss jetzt was trinken, sonst

02:29:05.600 --> 02:29:17.120
treuere Hals. Und jetzt geh ich off. Jetzt geh ich off und kreiselgrinde noch ein bisschen.

02:29:17.120 --> 02:29:24.000
Und jetzt noch eine andere Frage an die ganzen Frontend-Experten unter euch. Was ist denn

02:29:24.000 --> 02:29:40.400
euer Lieblings-Date-Time-Picker-Library? Auf mobile ist das einfach. Auf mobile nimmt

02:29:40.400 --> 02:29:47.280
man den Native vom Browser. Auf dem Desktop ist es ein bisschen doof, weil der Native vom

02:29:47.280 --> 02:29:59.080
Browser halt null in das Design der Seite passt. Light-Pi-Date-Time-Picker. Kengi, danke

02:29:59.080 --> 02:30:04.160
für den Sub. Ach Leute, ich muss mal kurz nachgucken nach den Subscriptions hier. Die

02:30:04.160 --> 02:30:20.000
Hälfte wieder übersehen. Ferdy Fuchs hat subscribt. Hab ich auch nicht gesehen. Dankeschön

02:30:20.000 --> 02:30:28.600
für den Sub. Hi IQ-Subscription hier Leute. Ich war zu beschäftigt mit meinem Datenbank-Krempel.

02:30:28.600 --> 02:30:45.080
Majorink auch. Vollkorn-Milchbrot hatte ich schon. Okay, Light-Picker. Warum ist das so

02:30:45.080 --> 02:30:56.240
schräg? Da tut dir der Nacken weh. Ah hier. Okay, der sieht sehr viewig aus mit dem Grün,

02:30:56.240 --> 02:31:03.320
wobei man das wahrscheinlich semen kann, wie man lustig ist. Und Date? Kann er auch time

02:31:03.320 --> 02:31:17.080
picken? Kann er auch time picken? Ja. Oh, transparent. Wie kann man den time picken

02:31:17.080 --> 02:31:30.760
lassen? Wo ist hier time? Ich sehe hier nichts für time. Oder ist das nur date? Der Darkreader

02:31:30.760 --> 02:31:37.800
macht es kaputt. Ja, das wird es wahrscheinlich sein. Single date, placeholder, separator,

02:31:37.800 --> 02:31:51.760
time. Ein Beispiel mit time? Hier ist time drin, aber ich kann keine time eintragen.

02:31:51.760 --> 02:32:13.040
Hier ist doch time. Hier kann ich keine time auswählen. Egal, ich geh jetzt auf Leute,

02:32:13.040 --> 02:32:29.720
wir sehen uns. Bis zum nächsten Mal. See you.

