WEBVTT

00:00.000 --> 00:26.760
So Leute, ich bin wieder am Start, exzellent, jetzt Refreshen, irgendwas stimmt hier nicht.

00:26.760 --> 00:51.520
Ah jetzt, ok wunderbar. Poggers, easy clap. Er spielt die Gifts ein bisschen schnell ab

00:51.520 --> 01:11.760
würde ich sagen. Aber dieser Windows Image Viewer ist installable. Der Stream war noch

01:11.760 --> 01:17.840
im Hintergrund auf. Ja das ist verwirrend, das habe ich auch manchmal. Ich hatte das mal,

01:17.840 --> 01:25.080
habe ich irgendwas auf dem Tablet laufen gehabt, bin eingepennt, dann ist der Typ off

01:25.080 --> 01:28.600
gegangen und ich habe es nicht mitgekriegt und irgendwann ist der Typ mitten in der Nacht

01:28.600 --> 01:33.320
on gekommen und das Tablet, obwohl sich das eigentlich gesperrt hat, dann ist Twitch

01:33.320 --> 01:38.720
auf einmal wieder angegangen. Das war glaube ich immerhin Bucketing, da war der Typ auf einmal

01:38.720 --> 01:47.120
am Start nachts um 4. Ach ja Tommy, das ist eine gute Idee. Das gucken wir uns jetzt mal

01:47.120 --> 01:56.320
schnell an, da hast du recht, für die richtigen Hacker-Mans. Mal gucken, wo man den Link dazu

01:56.320 --> 02:06.040
hat, ich finde den nicht mehr. Das da, hm? Ok, was ist das Richtige? Das da, das da,

02:06.040 --> 02:11.360
nimmt sich alles glaube ich nicht großartig, das ist vom 20. Mai, das ist vom 9. April.

02:11.360 --> 02:17.360
Hier, ich glaube hier sind Beispiele bei, da gucken wir uns mal das an, wobei das hat,

02:17.360 --> 02:24.400
das andere hat Dark Theme und Dark Theme ist ja bekanntlichermaßen wichtig. So, gucken

02:24.400 --> 02:32.200
wir mal. Also was gibt's, aber das ist schöner geschrieben hier. Also was gibt's für neue

02:32.200 --> 02:39.040
C Sharp 9 Features? Das ganze ist ja noch gar nicht draußen, ne? Das kommt auch glaube

02:39.040 --> 02:48.840
ich nach.NET 5. Also das kommt, das kommt, das dauert noch ein bisschen. Wo kommt das

02:48.840 --> 02:55.160
raus? C Sharp 8, C Sharp 9. Gibt glaube ich noch gar kein Release Date, kann das sein?

02:55.160 --> 03:02.440
Irgendwann ende das hier. Release at end of the year. Hier, hier kann man doch nachgucken.

03:02.440 --> 03:09.360
Das muss man Microsoft ja nur wirklich mal lassen, ne? Also, die haben wirklich so komplett

03:09.360 --> 03:15.600
sich um die, wie sagt man das, so 180 Grad Kehrtwende oder so gemacht. Also, früher

03:15.600 --> 03:24.000
hat Steve Ballmer Stühle nach Leuten geworfen, die was die Open Source gut fanden. Da gibt's

03:24.000 --> 03:27.560
doch, ob das stimmt weiß man natürlich nicht, ne? Da gibt's ja diese Story von dem einen

03:27.560 --> 03:31.360
der Typ, der zu Google gewechselt ist, dem er irgendwie den Stuhl hinterher geworfen

03:31.360 --> 03:35.680
hat und dann irgendwie den Stuhl aus dem Fenster oder so. Also, ob das stimmt, keine Ahnung,

03:35.680 --> 03:40.880
aber ich kann's mir bei dem Kerl gut vorstellen, dass das stimmt. Der hat doch jetzt auch irgendwie

03:40.880 --> 03:44.480
ein eigenes Baseball Team und, ne Basketball, Basketball ist, ne? Der hat doch jetzt irgendwie

03:44.480 --> 03:52.920
auch ein Basketball Team und eskaliert dabei voll rum. Die, genau die, die Velopos, die

03:52.920 --> 03:56.680
Velopos, die Velopos. Da haben die Zuschauer auch zwangsläufig mitmachen müssen, sonst

03:56.680 --> 04:01.280
hätte er nicht aufgehört. Ja, aber, ähm, also was ich sagen wollte, also Microsoft hat

04:01.280 --> 04:06.400
da wirklich 180 Grad Kehrtwende gemacht. Guckt euch das mal an. Früher hat der Ballmer sich

04:06.400 --> 04:10.680
hingestellt und hat gesagt, irgendwie Open Source ist ja wie Krebs und so was in der

04:10.680 --> 04:17.280
Richtung. Der ist da voll abgegangen und spätestens seit jetzt, ähm, dessen Namen ich mir nicht

04:17.280 --> 04:24.000
merken kann, Nadella, Satya Nadella oder so ähnlich, also der neue Microsoft-Ober, Microsoft-Mensch

04:24.000 --> 04:30.520
am Start ist, die haben 180 Grad Kehrtwende gemacht. Also die sind von, die sind von einem

04:30.520 --> 04:36.560
der meistgehasstesten Close Source Typen zu einem der mit beliebtesten Open Source Läden

04:36.560 --> 04:41.200
geworden. Das ist, das hätte ich, also ohne Scheiß, ne? Und man muss sich das auch mal

04:41.200 --> 04:46.320
angucken. Die Aktie ist durch die Decke gegangen in der Zeit. Ja, okay, das ist jetzt nur heute.

04:46.320 --> 04:50.040
Äh, wir müssen mal hier, keine Ahnung, bisschen Langzeit-Dings gucken. Guckt euch das mal

04:50.040 --> 04:57.920
an. Und das ist nur ein, ja? Guckt euch das mal an. Also, hier, der Ballmer hat irgendwo

04:57.920 --> 05:01.480
so hier aufgehört. Keine Ahnung, weiß nicht wann der Ballmer aufgehört hat, 2015 oder

05:01.480 --> 05:07.320
so. Irgendwo hier. Und seitdem ist die Microsoft-Aktie so extrem durch die Decke gegangen, auch

05:07.320 --> 05:12.120
dank Azure und dem ganzen Cloud-Scheiß. Es waren ein paar Cliffe ins Klo dabei, aber

05:12.120 --> 05:17.120
insgesamt muss man sagen, macht Microsoft nicht nur aus, äh, Programmierersicht, Anwendersicht,

05:17.120 --> 05:21.760
sonst wie macht er einige Sachen wirklich ganz gut. Auch hier aus Anleger-Sicht, ne? Ist

05:21.760 --> 05:42.720
das, ähm, kannst du dich nicht beschweren. 98 waren sie noch mal höher. Das war vor,

05:42.720 --> 05:48.040
das war vor der, äh,.NET-Blase, aber das kann ich mir eigentlich, gar nicht vorstellen,

05:48.040 --> 05:54.800
ob die Verhältnisse stimmen hier nicht ganz. Moin, Kengin, was, okay, oder was auch immer.

05:54.800 --> 05:59.600
Äh, ja, also ganz ehrlich, äh, wer Microsoft-Aktien hier gekauft hat, als der Ballmer aufgehört

05:59.600 --> 06:05.000
hat, hat das Beste, was du machen konntest. Die haben, die Leute haben jetzt irgendwie,

06:05.000 --> 06:31.680
das Doppelte. Das geht ab. Ach stimmt,.COM-Blase, wie komme ich auf.NET? Vielleicht weil wir

06:31.680 --> 06:35.360
uns vorher zu viel.NET-Zeug angeguckt haben. Ja, und man kann jetzt wirklich öffentlich

06:35.360 --> 06:40.880
auf GitHub sehen mittlerweile, äh, was noch offen ist für, für C-Sharp 9, also das ist

06:40.880 --> 06:44.640
echt nicht schlecht. Ich muss da Microsoft auch mal loben, weil ich hacke ja immer auf

06:44.640 --> 06:50.560
Windows rum, dass das sackt, und Windows sackt nach wie vor. Aber das ist echt gut. So, also

06:50.560 --> 06:55.360
was gibt es denn für neue C-Sharp 9-Features? Ja, gucken, wir gucken uns einfach beide Posts

06:55.360 --> 07:02.560
an. Der Metz, das ist der Ober-C-Sharp-Mensch jetzt. Der Heilsberg macht das ja nicht mehr,

07:02.560 --> 07:06.760
der hat ja am Anfang nur ein bisschen C-Sharpen, jetzt macht er TypeScript. Man darf auch nicht

07:06.760 --> 07:11.680
vergessen, bei Microsoft, ne, die haben sowohl mit C-Sharp als auch mit TypeScript, äh,

07:11.680 --> 07:15.760
zwei Sachen, die ganz vorne mitspielen. Also die haben wirklich viele ordentliche Sachen

07:15.760 --> 07:23.800
hinbekommen. So, ähm, und hier, das wie gesagt, das ist der Ober-C-Sharp-Architekt hier. Ich

07:23.800 --> 07:27.800
hab, weiß nicht, ich kann mir den Nachnamen von ihm nicht merken, das ist ein bisschen,

07:27.800 --> 07:35.720
das ist irgendwas norwegisches oder so. So, und zumindest, es gibt jetzt ein paar neue

07:35.720 --> 07:39.280
C-Sharp-Features und das Ganze kommt Ende des Jahres. Ich hab's mir noch nicht angeguckt.

07:39.280 --> 07:44.240
Schauen wir mal, was gibt es denn? Also, In-It-Only-Properties. Oh, das hab ich schon, das hab ich gesehen in

07:44.240 --> 07:50.160
dem Video. Das finde ich eigentlich ganz nice. Man kann jetzt, haben die ein Beispiel drinne?

07:50.160 --> 07:57.040
Genau. Also bisher ist es ja so, wenn man, äh, in C-Sharp, ich wollte jetzt sagen.NET,

07:57.040 --> 08:03.400
aber.NET trifft es nicht mehr so ganz, weil zu.NET gehört ja auch F-Sharp und, äh,

08:03.400 --> 08:23.000
Visual Basic.NET gibt es das eigentlich noch. Das haben die eingestellt, oder? Ist das dead?

08:23.000 --> 08:50.760
Ist VB.NET dead? Okay, nein, das ist nicht dead. Okay, ich hab nix gesagt. Es geht weiter

08:50.760 --> 08:59.160
mit Visual Basic. Ich, ich glaube, ich hab noch nie Dark Mode in Windows ausprobiert.

08:59.160 --> 09:17.400
Zeig mal, wo geht man, wie macht man hier Dark Mode an? Command, Dark Mode. Ich weiß

09:17.400 --> 09:29.840
nicht, was es ist. Ich starte das mal nicht. Was taskbar, Rechtklick und dann? Einstellungen.

09:29.840 --> 09:38.320
Was, Color? Ah, hier, hier. Ah, hier. Ah, doch, ich hab's doch auf, ich hab's doch auf

09:38.320 --> 09:52.080
Dark stehen. Okay, das muss auf Dark stehen bleiben, sonst geht das nicht. Bäh, ist ja

09:52.080 --> 10:12.600
einfach nur schwarz. Das ist kein ordentlicher Dark Mode, das sieht einfach noch kacke aus.

10:12.600 --> 10:29.560
Microsoft, Alter. Okay, warte mal, ich mach mal hier zu. Ah, okay, okay, ich hab nix gesagt.

10:29.560 --> 10:36.480
Ich hab nix gesagt. Ich hab nix, es funktioniert. Aber ganz ehrlich, schön integriert sieht

10:36.480 --> 10:39.840
das nicht aus. Muss ich jetzt, muss ich jetzt echt mal sagen. Ich glaube, ich lass das

10:39.840 --> 10:43.400
so stehen, wie ich das die ganze Zeit hatte. Das hier auf Hell und hier der Browser auf

10:43.400 --> 10:48.600
Dark. Das gefällt mir besser. Aber zurück zu den 90 Sharp Features. Also, das erste hab

10:48.600 --> 10:57.880
ich schon in der Webcast. Die Fensterrahmen sind halt für'n Arsch. Moment, das muss ich

10:57.880 --> 11:11.320
mir jetzt noch mal angucken. Colors, Dark. Wieso? Ich mein, man sieht kaum was. Aber

11:11.320 --> 11:22.840
was ist an den Fensterrahmen so schlimm? Seven-Zip-Help. Achso, ah, okay. Die alten

11:22.840 --> 11:28.680
Anwendungen gehen nicht. Lull. Ja, gut. Das ist auch wieder so ein Ding. Das ist komplett

11:28.680 --> 11:36.080
inkonsistent, was die da gebaut haben. Ah, komplett inkonsistent. Bei den neuen Sachen

11:36.080 --> 11:48.320
geht's, bei den alten geht's nicht. Äh, Müll. So, aber gucken wir uns mal die neuen,

11:48.320 --> 11:51.440
gucken wir uns mal die neuen Features an. Wie gesagt, das hab ich schon gesehen. Man

11:51.440 --> 11:57.120
kann ja schon seit einer Weile, ich glaub seit uralt, also schon lange her, kann man,

11:57.120 --> 12:01.640
wenn man in die Sharp eine Klasse anlegt, hier Person, kann man ja die so initialisieren

12:01.640 --> 12:07.320
ohne Constructor. Und jetzt, was auch schon eine Weile geht ist, man kann Properties so

12:07.320 --> 12:11.600
anlegen und die haben jetzt ein neues Schlüsselwort, hab ich gesehen. Das kenn ich schon. Man kann

12:11.600 --> 12:17.200
anstatt GetSet, was man übrigens auch machen kann ist, man kann sowas sagen wie GetPrivateSet,

12:17.200 --> 12:22.320
das funktioniert auch schon, dass man es von außen nicht setzen kann. Aber jetzt kann

12:22.320 --> 12:26.120
man da noch Init dabei schreiben, das hab ich schon mal in einem Video gesehen und das

12:26.120 --> 12:32.840
sorgt dafür, dass man nur beim ersten Mal was schreiben kann. Das heißt, das da kann

12:32.840 --> 12:40.040
ich machen, ich kann das einmalig initialisieren und danach ist es ReadOnly. Das ist ganz praktisch,

12:40.040 --> 12:46.560
es ist ähnlich wie wenn ich PrivateSet mache. Das ist ähnlich wie wenn ich PrivateSet mache,

12:46.560 --> 12:50.200
aber dass ich mit PrivateSet das hier nicht verwenden kann, dann muss ich über irgendeinen

12:50.200 --> 12:54.760
Constructor gehen. Also hier kann ich nur Public Sachen setzen, über diesen, weiß gar nicht

12:54.760 --> 13:00.440
wie das heißt, Object Initializer heißt es, genau. Das kann ich nur machen, wenn die Sachen

13:00.440 --> 13:04.080
Public sind und dementsprechend Set auch Public ist, sonst funktioniert das nicht. Es ist

13:04.080 --> 13:07.920
ein bisschen schönere Variante, was zu initialisieren als über den Constructor, je nachdem, hat

13:07.920 --> 13:12.320
alles seine Vornachteile. Und jetzt kann man sagen Init anstatt Set und dann kann man das

13:12.320 --> 13:18.240
nur einmal setzen. Das heißt, man kann nur einmal das hier machen und dann kann man nur

13:18.240 --> 13:22.800
noch, es ist ReadOnly, danach. Man kann es einmal setzen von außen und danach ist ReadOnly.

13:22.800 --> 13:27.220
Das, ich hab gelesen, das machen die aus dem Grund. Das ist auch ein bisschen für die

13:27.220 --> 13:35.280
funktionale Geschichte, weil in C Sharp kommt ja mittlerweile relativ viel, was weggeht vom

13:35.280 --> 13:39.720
reinen objektorientierten Ansatz. Also ich hab ja mit Pattern Matching und was auch immer

13:39.720 --> 13:44.800
noch alles. Die verfolgen ja ein bisschen mehr so diesen Functional Programming Ansatz mittlerweile.

13:44.800 --> 13:48.800
Also du kannst ja in C Sharp mittlerweile relativ viel Funktionales machen und objektorientiert.

13:48.800 --> 13:55.600
Und dafür wollen die das machen, dass man mehr Immutable Objects verwenden kann. Ist

13:55.600 --> 14:01.760
eigentlich eine nette Idee, ob ich das jetzt wirklich oft verwenden werde. Ich weiß nicht,

14:01.760 --> 14:05.800
wahrscheinlich nicht. Ich glaub, das ist sowas, das verwendet man, wenn man es halt mal, wenn

14:05.800 --> 14:13.600
es sich gerade anbietet und danach, danach nicht mehr. Oder nicht immer, sondern ab und zu mal.

14:13.600 --> 14:21.800
Wir schreiben ja auch hier, genau, man kann es nur einmal setzen, jedes weitere setzen gibt

14:21.800 --> 14:25.760
einen Error. Und was die ja wirklich gut machen bei der ganzen.NET Geschichte,

14:25.760 --> 14:38.200
und da kann sich C++ in Riesenscheibe abschneiden, die haben gute Tools. Also sprich,

14:38.200 --> 14:44.120
du kriegst in.NET oder in C Sharp, du kriegst gute Compilerwarnung. Du kriegst nicht irgendwie drei

14:44.120 --> 14:49.720
Seiten Error ausgekotzt, wie das bei C++ ist. Bei C++ machst du ein Zeichen an der falschen

14:49.720 --> 14:56.000
Stelle falsch und du kriegst 20 Seiten und du weißt überhaupt nicht, was der eigentlich von dir will,

14:56.000 --> 15:00.960
bis du dann irgendwann das Zeichen richtig setzt und auf einmal sind alle Sachen, die angeblich

15:00.960 --> 15:06.800
quer über das Dokument verteilt falsch sind, weg. Das ist halt ein bisschen für ein Arsch. Das kriegen

15:06.800 --> 15:12.840
die hier deutlich besser hin. Es gibt ja auch so Sachen, zum Beispiel, was die in C++ auch

15:12.840 --> 15:20.920
teilweise nicht richtig hinbekommen ist, wenn ich, wie machen wir das jetzt? Waren genommen,

15:20.920 --> 15:27.400
ich habe irgendeine Funktion in C++, die heißt jetzt plupp, und der kann ich irgendein Callback

15:27.400 --> 15:36.720
übergeben, und zwar ein Callback mit einem Int oder so. Machen wir das jetzt mal. Wenn ich

15:36.720 --> 15:40.760
das jetzt aufrufe, diese Funktion, pass auf, das ist jetzt der Vorführeffekt, jetzt geht's,

15:40.760 --> 15:44.560
aber ich kann auch sagen, in manchen Situationen funktioniert es nicht. So,

15:44.560 --> 15:51.760
jetzt kann ich da einen Lambda reinstecken, also anonyme Funktion, und in C++ gibt es ja

15:51.760 --> 15:59.680
sowas wie Auto. Und wenn ich jetzt hier gucke, welchen Variablen-Typ hat B, B hat Typ Auto. Das

15:59.680 --> 16:04.800
ist ja falsch. B hat Typ Int. Auto ist einfach nur, weil ich den Kram nicht schreiben muss,

16:04.800 --> 16:11.960
weil ich nicht jedes Mal nachgucken muss. C++ weiß, dass das ein Int ist, weil, wenn ich jetzt

16:11.960 --> 16:17.760
versuche da irgendwie einen String reinzustecken oder so, dann sagt er, nee, nee, nee, das geht

16:17.760 --> 16:22.560
nicht, das geht nicht. Also wenn ich da, wenn ich da, ah nee, Moment, rein machen kann ich da eh

16:22.560 --> 16:28.960
nichts. Das ist jetzt ein doofes Beispiel gewesen. Sagen wir mal, ich mache sowas hier, String C

16:28.960 --> 16:36.640
gleich B. Dann sagt er, ah nee, nee, nee, nee, geht nicht, weil, naja, also Int, Int zu C geht nicht.

16:36.640 --> 16:42.160
Was ich allerdings machen kann, ist Int D gleich B. Das, das funktioniert dann. Also, man sieht,

16:42.160 --> 16:49.160
der weiß prinzipiell, dass das ein Int ist, aber warum zeigen das die Tools nicht an? Na,

16:49.160 --> 16:54.760
das ist auch sowas, da kann sich C++, was Fehlermeldung und Tools angeht, von C-Sharpen

16:54.760 --> 16:59.160
auf eine Riesenscheibe abschneiden. Weil ich meine, es war intern, weil, muss es wissen, dass das ein

16:59.160 --> 17:03.600
Int ist, aber warum zeigt es mir das nicht an? Was Auto wieder komplett unsinnig macht, weil ich

17:03.600 --> 17:08.280
muss trotzdem jedes Mal nachgucken, was ist das für ein Typ. Und, und, ich habe noch nicht mal

17:08.280 --> 17:15.120
irgendwie hier Auto-Vervollständigung dadurch. Also, ist schon ganz schön kacke. Ich glaube,

17:15.120 --> 17:19.400
das ist aber auch der Komplexität von C++ geschuldet, weil wenn auch nicht mal mehr das

17:19.400 --> 17:25.280
Gremium durchblickt, was ihre eigene Sprache so macht, wie sollen denn dann die Tool-, beziehungsweise

17:25.280 --> 17:29.880
die IDE- und Tool-Implementierungsleute da noch durchblicken? Kein Wunder, das ist halt so.

17:29.880 --> 17:35.880
Ja. So, zumindest, das ist jetzt ein neues Feature in C-Sharp 9. So ein Finish ist eigentlich eine

17:35.880 --> 17:42.080
gute Sache. Was sind denn Immutable Objects? Ja, zum Beispiel sowas wie Daytime ist standardmäßig

17:42.080 --> 17:47.880
immutable. Ich mache mal kurz Visual Studio auf. Versuche ich das mal kurz zu demonstrieren,

17:47.880 --> 17:58.640
was ich meine. So, eh, Console-App 14 klingt gut. Weiß nicht, was da drin ist, ob man das

17:58.640 --> 18:07.880
löschen kann. Oh ja, das klingt unglaublich wichtig. Blob 1, Blob 2, Firefox. Oh nee,

18:07.880 --> 18:12.200
das ist das, wo ich versucht habe, Modern Warfare den Sound-Liser zu stellen, was die

18:12.200 --> 18:22.000
Sachen als Cheat erkannt haben. Das ist das, wo ich Modern Warfare versucht habe, den Sound anzupassen.

18:22.000 --> 18:26.040
Nee, das behalte ich mal. Das kann man bestimmt noch gebrauchen. Wo Modern Warfare sich dann

18:26.040 --> 18:31.240
geschlossen hat, weil Modern Warfare gesagt hat, oh nein, der Max ja cheatet. Anti-Cheat hat erkannt,

18:31.240 --> 18:38.680
dass ich cheate. Oh nee, Moment, VB.net. Und deswegen konnte ich das nie verwenden.

18:38.680 --> 18:45.760
Nachdem ich ja die Sachen immer so beknackt benenne. So, also was mit Immutable gemeint,

18:45.760 --> 18:54.640
es ist folgendes. Also, ich habe hier sowas wie, keine Ahnung, Date, Time, Now. Nee,

18:54.640 --> 18:59.960
Moment, Moment, War ist es ja hier, Time. Date, Time, Now. So, da steht jetzt die,

18:59.960 --> 19:06.200
das ist jetzt ein Date-Time-Objekt, wo die aktuelle Uhrzeit drin steht. Wenn ich da jetzt

19:06.200 --> 19:15.280
was dran ändere, zum Beispiel at Mini-Seconds, dann ändere ich nicht dieses Time-Objekt,

19:15.280 --> 19:25.440
sondern ich kriege ein neues Date-Time-Objekt mit. Also, zum Beispiel. So, wenn ich das hier jetzt

19:25.440 --> 19:36.440
ausgebe, an den beiden Stellen, oder wir machen mal add hours, oder so, add hours, fünf. So, da gibt

19:36.440 --> 19:43.520
jetzt an beiden Stellen das gleiche aus. Guck, exakt das gleiche, obwohl ich fünf Stunden

19:43.520 --> 19:48.680
hinzugerechnet habe. Das wird man ja eigentlich nicht erwarten. Man würde ja eigentlich erwarten,

19:48.680 --> 19:57.200
hier gibt er 15.32 Uhr aus, und hier gibt er 20.32 Uhr aus. Ist aber nicht so, weil das ist

19:57.200 --> 20:03.520
immutable. Insofern, wenn man das Objekt ändert, kriegt man ein neues Objekt zurück. Sowas hier

20:03.520 --> 20:11.480
wäre jetzt okay, sowas kann ich machen. Guck, und jetzt funktioniert das. Das ist das 15.32,

20:11.480 --> 20:18.080
20.32. Also sprich, die Methoden ändern nicht den internen State von diesem Objekt, sondern geben

20:18.080 --> 20:23.880
eine Kopie von dem ursprünglichen Objekt mit den Änderungen zurück. Jetzt fragt man sich natürlich,

20:23.880 --> 20:27.840
wozu braucht man diesen Blödsinn? Das ist ja komplett sinnlos und Ressourcenverschwendung. Klingt

20:27.840 --> 20:36.600
erstmal logisch, aber wenn es im Bereich Multithreading geht und du dir sicher sein möchtest,

20:36.600 --> 20:43.400
dass ein Aufruf von irgendeiner Methode oder irgendeiner Funktion wirklich nichts ändert drumherum,

20:43.400 --> 20:49.560
dann ist das natürlich eine praktische Geschichte. Weil, mal angenommen, ich würde dieses Time-Objekt

20:49.560 --> 20:55.720
jetzt Multithreaded in fünf Threads verwenden, und ich will mir sicher sein, das ist konsistent und

20:55.720 --> 21:04.120
funktioniert, und ich adde dann was, dann mache ich es ja kaputt in fünf anderen Threads, weil sich

21:04.120 --> 21:09.880
das ja auf einmal on the fly ändert. Und vielleicht hat es auch Probleme, wenn ich was adde und

21:09.880 --> 21:15.760
auslese gleichzeitig, dass es nicht funktioniert. Deswegen haben die sich gedacht, ok, gerade für

21:15.760 --> 21:21.240
solche Sachen sind Immutable-Objekte gut, weil ich kann mich darauf verlassen, dass das hier immer

21:21.240 --> 21:28.480
das Gleiche bleibt, auch wenn ich was ändere. Ich glaube, das hat man verstanden, oder? Und da wollen

21:28.480 --> 21:32.040
sie jetzt halt ein bisschen mehr Fokus darauf legen, dass es einfacher wird. Finde ich eigentlich eine

21:32.040 --> 21:48.960
ganz gute Idee. Genau. Notizblock ist raus. So, genau, also das geht jetzt hier mit Init,

21:48.960 --> 21:54.000
sprich, ich kann das einmalig füllen und danach nie wieder. Und wenn ich es ändere,

21:54.000 --> 22:01.000
wenn ich es ändere, dann muss ich es so ändern, wie hier, quasi neues Objekt anlegen. Ok, was

22:01.000 --> 22:08.160
haben wir sonst noch Neues? Init, Accessories and Read-Only-Fields. Monkey S, was ist das hier

22:08.160 --> 22:23.840
für eine Ausgeburt der Functional Programming-Hirn? Was ist mit der Uhrzeit? Wieso? Was soll mit der

22:23.840 --> 22:29.800
Uhrzeit? Ach so, oben rechts, die ist falsch. Übrigens, die Uhrzeit geht nicht. Warum ist die

22:29.800 --> 22:42.440
Uhrzeit kaputt? Hä? Moment, warum hat VLC gestoppt? Stimmt das denn jetzt wenigstens?

22:42.440 --> 22:48.160
Nee, das stimmt da hinten und vorne nicht. Moment, Moment. Open, Network Stream. Yes.

22:48.160 --> 22:56.040
Ah, yes. Also man, die Uhrzeit sind immer noch zwei Stunden falsch, aber jetzt stimmt

22:56.040 --> 23:05.400
wenigstens die Anzeige oben. Ok, was gibt es noch für neue Features? Init, you are allowed

23:05.400 --> 23:11.840
to mutate Read-Only-Fields with enclosing class chests, like you can in a constructor. Ok,

23:11.840 --> 23:25.760
jetzt wird es wir. Was machen die hier? Hä? Liegt der ESP neben dir? Ja, fast. Ok, also

23:25.760 --> 23:55.160
Finger League. Äh, Moment, Moment. Moment. Al. Ganz richtig. Exzellent sein, Schneider

23:55.160 --> 24:05.120
League. Wieso lädst du ein RTSP-Stream, wenn der ESP direkt neben dir ist? Ja, dreimal

24:05.120 --> 24:14.920
darfst du raten. Also ok, was die jetzt hier genau vorhaben, erschließt sich mir erstmal

24:14.920 --> 24:20.880
nicht. Das ist wahrscheinlich zum Initialisieren, also sprich, dass ich, ah, dass ich das setzen

24:20.880 --> 24:26.400
kann. Ich kann das, ach, jetzt verstehe ich, ich kann das quasi durchreichen. Ich kann

24:26.400 --> 24:31.800
quasi, wenn ich das setze, durchreichen zu einem privaten Feld. Ok, ja. Das ist übrigens

24:31.800 --> 24:37.240
hier auch BigBrain, neue C-Sharp-7-Schreibweise. Das ist richtig cool, ist auch was, wo sich

24:37.240 --> 24:45.800
C++ was abschneiden könnte. Und zwar, man guckt, ob, ähm, nicht Null übergeben wurde

24:45.800 --> 24:52.080
als Wert zum Setzen. Und wenn Null übergeben wurde, dann wirft man hier eine Exception,

24:52.080 --> 24:56.920
die auch einen ordentlichen Namen hat. Also sprich, ich krieg da eine Argument-Null-Exception,

24:56.920 --> 25:02.200
wo genau drinne steht, ok, Argument-Null for First Name. Das ist eigentlich auch ganz praktisch,

25:02.200 --> 25:09.240
wo man grad wieder bei schönen Fehlermeldungen sind. Also, nicht alle.NET C-Sharp-Fehlermeldungen

25:09.240 --> 25:13.760
sind gut, aber die meisten. So, was haben wir jetzt? So, Rackets. Das hab ich auch in

25:13.760 --> 25:30.560
dem Video gesehen. Die haben jetzt. Das ist doch anders jetzt. Das haben die doch geändert.

25:30.560 --> 25:41.200
Genau, man kann jetzt sagen, Rekord. Das stimmt nicht so genau. Das ist jetzt anders. Die

25:41.200 --> 25:47.000
Rackets. Stimmt nicht mehr. Oder das ist neu. Ehrlich gesagt, keine Ahnung, was davon stimmt.

25:47.000 --> 25:51.200
Ich hab ein Video gesehen, da konnte man das so machen. Public Record Person. Das ist eine

25:51.200 --> 25:55.680
Klasse, die ein bisschen mehr wie ein Instruct funktioniert. Wann man das braucht, müsste

25:55.680 --> 26:01.760
man mal wirklich genau schauen. Was haben wir noch für Features? With Expressions. Gut,

26:01.760 --> 26:07.880
das ist das Gleiche wie oben. Man kann es ja initial nicht mehr ändern. Und damit leg

26:07.880 --> 26:12.840
ich quasi ein neues Objekt an, was diesen Namen enthält und das alte kopiert. Wieso

26:12.840 --> 26:16.600
nicht einfach einen Struct nehmen? Weil es immer noch Klassen, also Structs, wenn du

26:16.600 --> 26:21.040
immer automatisch kopiert, wenn du die übergibst. Und das ist immer noch Reference, allerdings

26:21.040 --> 26:26.720
Immutable Reference. Mit ein paar anderen Sachen. Frag mich nicht genau. Da müsste

26:26.720 --> 26:30.720
ich mir jetzt eben die Teilen mal angucken. Also, das ist immer noch Reference, aber es

26:30.720 --> 26:41.520
ist. Equals beispielsweise geht auf die Properties anstatt auf die Reference. Man könnte auch

26:41.520 --> 26:45.080
einen RevStruct eigentlich nehmen. Ich weiß nicht genau, wie und wann. Das muss ich mir

26:45.080 --> 26:52.720
im Detail angucken, wenn das Final ist und wenn das rauskommt. Das ist im Prinzip gehört

26:52.720 --> 27:05.360
alles dabei. Das gehört auch alles dabei. Ach ja, das ist jetzt auch neu. Das wird verwirrend,

27:05.360 --> 27:10.600
Leute. Das wird übelst verwirrend. Normalerweise sieht ja ein Programm, ein Minimalprogramm

27:10.600 --> 27:18.680
in C Sharp so aus. Hier. Und es ist jetzt erlaubt, dass man im neuen, in C Sharp 9, darf

27:18.680 --> 27:32.720
man sowas hier machen. Das ist, das ist gültiges, das ist gültiges C Sharp 9. Rust habe ich

27:32.720 --> 27:36.880
mir vor einer ganzen Weile angeguckt, ja. Das ist jetzt gültiges C Sharp 9. Man darf

27:36.880 --> 27:42.240
jetzt Sachen Top Level schreiben. Okay, ich glaube, da haben die auch ein Beispiel für.

27:42.240 --> 27:47.160
Genau. Man darf Sachen jetzt Top Level schreiben. Man muss die Sachen nicht mehr einfach nur

27:47.160 --> 27:51.880
der Form halber in irgendwie den Namespace und Static Main verpacken. Das Problem, was

27:51.880 --> 27:56.600
ich dabei sehe, ist, dass es auf den ersten Blick mal total ungewohnt ist für C Sharp

27:56.600 --> 28:02.080
Programmierer. Das kann sein, dass es in C Sharp 8 auch teilweise schon geht, aber auf

28:02.080 --> 28:09.440
jeden Fall nicht so. Und das Beste ist, dass es auch nach wie vor nur syntaktisch, syntaktisch

28:09.440 --> 28:13.400
das Ganze besser macht. Unter der Haube kommt immer noch sowas hier raus, weil das kann

28:13.400 --> 28:19.440
man auch nur einmal machen, hat er zumindest in dem Video gesagt. Ah ja, ob ich das verwenden

28:19.440 --> 28:23.800
werde, sei mal dahingestellt. Aber man sieht, wo die Reise hingeht, die versuchen, die Sachen

28:23.800 --> 28:28.160
einfacher zu machen. Also, dass man weniger schreiben muss und das finde ich eigentlich

28:28.160 --> 28:31.680
eine sinnvolle Sache. So, Improved Pattern Matching, das gucken wir uns jetzt nicht im

28:31.680 --> 28:34.680
Detail an, weil das wirklich übels Brainfuck ist, wenn man das wirklich, also wenn man

28:34.680 --> 28:42.360
das mal übertreibt. Das verwende ich eh relativ selten. Das Einzige, was ich Pattern Matching

28:42.360 --> 28:49.800
verwende ist in Ifs. Das Einzige, was ich an Pattern Matching verwende ist in Ifs. Irgendwie

28:49.800 --> 28:57.200
keine Ahnung, If. Warte mal, hier irgendwie keine Ahnung. B, an dem Moment, war. Ja und

28:57.200 --> 29:05.440
test gleich true, irgendwas, mir fällt jetzt nichts ein. So kann, dass ich dann teste irgendwie,

29:05.440 --> 29:14.080
test ist sowas und test gleich gleich, keine Ahnung, test oder so. Also solche Sachen dafür

29:14.080 --> 29:21.600
verwende ich das manchmal, aber ansonsten verwende ich relativ wenig Pattern Matching.

29:21.600 --> 29:29.520
Aber das ist Gewöhnungssache, ich denke mal, dass da schon praktische Sachen dabei sind.

29:29.520 --> 29:39.040
Ja, aber Flo690, es geht nur einmal, es geht nur einmal. Also sprich, man kann nicht mehrere

29:39.040 --> 29:45.240
Top Level Methoden haben, dann meckert er. So, Simple Type Patterns, Relational Patterns.

29:45.240 --> 29:48.960
Okay, jetzt gibt es übels Brainfuck, das gucken wir uns jetzt nicht alles im Detail an.

29:48.960 --> 30:05.440
What the fuck? Oh, da wird es Big Brain. Das muss ich mir im Detail angucken, das kriege

30:05.440 --> 30:10.880
ich jetzt nicht so aus dem Ärmel geschüttelt. Genau, und das ist die neue Syntax für diese

30:10.880 --> 30:15.840
Struct Klassen quasi, die, die, die zwar in dem anderen Artikel irgendwie anders, keine

30:15.840 --> 30:25.760
Ahnung. Das hatten wir schon in the only Setter, Top Level Statements hatten wir auch schon,

30:25.760 --> 30:29.160
Pattern Matching Enhancement hatten wir auch schon, Performance und Interop immer gut.

30:29.160 --> 30:45.840
Bald ist er dort nicht C Interop besser als der C++ C Interop. Ach ja, das habe ich auch

30:45.840 --> 30:53.280
in dem Video gesehen, das ist jetzt neu. Man kann jetzt wohl Sachen anlegen, ohne dass man

30:53.280 --> 30:58.760
hier hinten nochmal den Typ nennen muss. Ist eigentlich auch ganz cool. Also sprich, ich

30:58.760 --> 31:01.640
gebe hier vorne den Typ und dann kann ich sagen New, ohne dass ich den hinten nochmal

31:01.640 --> 31:09.960
hinschreiben muss. Also sprich, der weiß, dass ich hier eine New Weather Station anlegen

31:09.960 --> 31:17.360
will, ohne dass ich hinschreibe New Weather Station. Das hat bestimmt ziemlich viel Gehirn

31:17.360 --> 31:23.480
gekostet bei denen, dass das so funktioniert. Auf der anderen Seite bin ich mir nicht so

31:23.480 --> 31:31.960
ganz sicher, ob ich das gut finde, weil normalerweise machst du ja hier vorne VAR anstatt den Namen

31:31.960 --> 31:39.080
hin. Es ist glaube ich ganz gut, wenn man das als Parameter verwendet in einem Funktionsaufruf.

31:39.080 --> 31:44.920
Also wenn man einfach nur kurz was anlegen will, was man in eine Funktion reinschiebt,

31:44.920 --> 31:48.320
dann ist das so halt ein bisschen kürzer. Man sieht, die haben sehr viel Wert darauf

31:48.320 --> 31:58.040
gelegt, dass die Sachen halt insgesamt kürzer werden. So. Die C Sharp 9 gucken wir uns dann

31:58.040 --> 32:05.760
im Detail an, wenn es draußen ist. So. Also, wo haben wir denn aufgehört gestern? Für

32:05.760 --> 32:11.240
alle die gestern nicht dabei waren. Also. Ich versuche das nochmal kurz zusammenzufassen.

32:11.240 --> 32:21.800
Ich uploade mal kurz den Kram hier. Vorgestern. Nee, gestern. Doch. Doch, gestern haben wir

32:21.800 --> 32:28.720
das gemacht, oder nicht? Oder haben wir das vorgestern gemacht? Nee, vorgestern haben

32:28.720 --> 32:35.400
wir das gemacht. Stimmt. Stimmt, vorgestern. Warte mal, zeige ich mal her. Oblors, vorgestern.

32:35.400 --> 32:43.560
Ich finde das so schlecht, dass man hier nicht so ewig rumklicken muss jetzt. So. Also, das

32:43.560 --> 32:58.480
haben wir gemacht. Tatsächlich, ja, das haben wir vorgestern gemacht. Ja, okay. Verstehe.

32:58.480 --> 33:07.360
Alles recht. So. Erst mal ein Serial Monitor an, dass man was sieht. So. Wunderbar. Heap

33:07.360 --> 33:13.880
size. Alles gut. Also, was wir gemacht haben ist, wir haben einen Mini-Web-Server programmiert,

33:13.880 --> 33:18.520
der Folgendes machen kann. Ich zeige den mal. Ich erkläre mal kurz, was das macht. Also,

33:18.520 --> 33:31.560
was der Sinn, der Sinn dahinter ist. Was hat der für Schmerzen? Ich meine, es geht ja

33:31.560 --> 33:38.160
schließlich. Ich habe es ja gerade hochgeladen. Ja, also, wir haben den Web-Server angelegt.

33:38.160 --> 33:43.120
Den kann man folgendermaßen starten. Gibt man einen Port und später, für Basic OS,

33:43.120 --> 33:47.920
übergibt man ihm den Passwort und den Username und Passwort. Und was wir im letzten Stream

33:47.920 --> 33:51.840
gemacht haben ist, wir haben den Web-Server so weit programmiert, dass man statisches

33:51.840 --> 33:56.680
HTML vom Flash aus liefern kann. Hier nehme ich diese Index-HTML-Seite. Da ist nicht allzu

33:56.680 --> 34:04.880
viel drauf. Und das Ganze halt über SSL, also sprich, dass das halt verschlüsselt ist,

34:04.880 --> 34:13.920
und multithreaded. Also, zum Beispiel, wenn man jetzt hier auf die Seite geht, habe ich

34:13.920 --> 34:18.640
das wieder, ich glaube, ich habe es wieder gelöscht. Na super, ich habe es gelöscht.

34:18.640 --> 34:23.440
Wir haben nämlich gestern noch was anderes ausprobieren. Ich kommentiere das mal, ich

34:23.440 --> 34:28.520
kommentiere das mal schnell wieder, schnell wieder ein, dass ich es euch im Browser zeigen

34:28.520 --> 34:39.080
kann, dass das überhaupt funktioniert. So. Ist das richtig? Keine Ahnung. Upload. Ne,

34:39.080 --> 34:57.720
das ist falsch. Moment. Ah. Stopp. Das ist falsch. So. So, abbrechen, nochmal uploaden.

34:57.720 --> 35:05.680
Also, der kann jetzt statische Webseiten ausliefern, und zwar über eine verschlüsselte Verbindung.

35:05.680 --> 35:09.520
Ich zeige euch das jetzt auch gleich mal im Browser, dass man sieht, dass es funktioniert.

35:09.520 --> 35:15.520
Was wir heute machen ist, ich versuche dem, also erstmal, dass wir einen ganz simplen

35:15.520 --> 35:21.680
Get- und Post-Request parsen können. Vielleicht noch für den Post die Content-Length rausholen

35:21.680 --> 35:29.240
oder so. Und, dass wir Basic Auth hinbekommen. Da bin ich ja mal gespannt, ob wir Basic Auth

35:29.240 --> 35:35.440
hinbekommen. So, wenn man jetzt den Browser aufmacht und geht jetzt auf die IP von der

35:35.440 --> 35:43.840
Kiste hier, also von dem Controller. Ups. So, man geht jetzt auf die IP. Das ist 125,

35:43.840 --> 35:49.920
glaube war das, oder? Was hat er für eine IP gekriegt? Wi-Fi Connected Max, super. Ah,

35:49.920 --> 36:03.840
hier. 1125. So, Moment. Moment, HTTPS 4433. Und jetzt bekommt man theoretisch eine Webseite,

36:03.840 --> 36:09.440
die ich übrigens falsch auslieferte. Text HTML wäre das Richtige gewesen. Dann würde

36:09.440 --> 36:13.600
es auch funktionieren. So, aber ihr seht schon, man bekommt eine Webseite ausgeliefert und

36:13.600 --> 36:20.400
die Webseite liegt auf dem Flash. Also, die absolute Basic Funktionalität, die wir brauchen,

36:20.400 --> 36:26.960
die haben wir schon. Man kann über den Webserver, TLS, SSL verschlüsselt, kleine Webseiten

36:26.960 --> 36:31.680
ausliefern. Das ist alles, was wir brauchen. So, erste Mal. Als nächstes basteln wir Basic

36:31.680 --> 36:36.240
Ords, also sprich, dass man sich anmelden muss. Gucken wir mal, ob es jetzt funktioniert.

36:36.240 --> 36:57.160
Exzellent. Da ist unsere Seite. Und by the way, LullW größer KeckW. Also. Den ganzen

36:57.160 --> 37:04.280
Mist schmeißen wir wieder raus, weil das brauchen wir eigentlich gar nicht. So, Basic Ords.

37:04.280 --> 37:12.080
Also, ich hab mir das folgendermaßen vorgestellt. Also, man übergibt dem Ding hier am Anfang

37:12.080 --> 37:16.880
ja eine Username und ein Passwort. So, und Basic Ords funktioniert folgendermaßen.

37:16.880 --> 37:27.200
Basic Ords-Example. Ich brauch mal irgendwie Wikipedia eintrauen oder so. Hier, die ist

37:27.200 --> 37:34.600
eigentlich ganz gut. Genau. Das ist ja ein absolut mieses Bild. Ist das abfotografiert

37:34.600 --> 37:44.800
mit einem uralten Siemens-Handy oder so? Okay, die Beispiele sind übelst kacke, dann zeige

37:44.800 --> 37:51.040
ich euch selbst. Also, wenn man eine Anfrage macht an einen Web-Server, da kann man einen

37:51.040 --> 37:57.000
Username und ein Passwort mit übergeben. Zum Beispiel hier, admin123456, add123456.

37:57.000 --> 38:07.880
Und wenn ich das jetzt abrufe, oder auch nicht. Also, wenn ich das jetzt, ah jetzt, okay,

38:07.880 --> 38:13.560
hängt, was auch immer. So, und dann sieht man, was der hier mitschickt ist, das hier

38:13.560 --> 38:18.640
ist das eigentlich Interessante. So, da schickt nämlich ein Authorization-Header mit. Da steht

38:18.640 --> 38:23.640
drinne Authorization Basic und dann steht so ein komisches Geschwubbel hier hinten. Und

38:23.640 --> 38:32.080
dieses Geschwubbel ist Username und Passwort als Base64 encoded. So, also was man jetzt

38:32.080 --> 38:36.920
gucken muss, dass Basic Ords funktioniert. Ach hier, hier haben sie glaube ich noch ganz

38:36.920 --> 38:46.840
gute Erklärungen. Oder auch nicht. So, genau, was man jetzt machen muss, dass Basic Ords

38:46.840 --> 38:51.560
funktioniert und das hier in den Passwort, also man möchte ja, dass hier, also wenn ich

38:51.560 --> 38:56.640
die Seite jetzt aufrufe, soll da ein Passwort-Popup kommen, wo drin steht, ey bitte, bitte authentifizieren.

38:56.640 --> 39:02.060
Genau, also so funktioniert das vorhin, das Client macht eine Anfrage an den Server. Server

39:02.060 --> 39:08.600
schickt, so wird unauthorized, allerdings mit dem Hinweis, ey guck mal, du musst dich

39:08.600 --> 39:14.160
anmelden. Dann gibt es ein Popup und, also man kann es auch gleich mitschicken, ist eigentlich

39:14.160 --> 39:18.960
egal. Und dann schickt der Browser nochmal eine Anfrage mit diesem Authorization-Header

39:18.960 --> 39:25.280
dahin. Und wenn das stimmt, ist okay und wenn nicht, ist es halt verboten. Das heißt, wir

39:25.280 --> 39:29.600
müssen jetzt einen Check einbauen, der bei jeder Anfrage, also sprich, ich mach's mal

39:29.600 --> 39:36.680
ein bisschen kleiner, der bei jedem, bei jeder Anfrage durchgeht, so. Das hier unten ist

39:36.680 --> 39:40.640
das, was wir das letzte Mal gebastelt haben zum Handle vom SSL, das ist erstmal wurscht.

39:40.640 --> 39:46.300
Das heißt, wir müssen jetzt bei jedem Handle-Connection, müssen wir quasi sowas hier machen, wie Check

39:46.300 --> 39:54.040
Basic Ords oder so. Nicht Handle-Connection, bei jedem, nachdem er die Verbindung angenommen

39:54.040 --> 39:58.080
hat, weil ansonsten, bevor ich die Verbindung nicht angenommen hab, kann ich ja die Verbindung

39:58.080 --> 40:04.640
auch nicht lesen. Das funktioniert ja nicht. So, dann lösche ich den ganzen Krams hier

40:04.640 --> 40:17.640
mal wieder, weil das brauchen wir jetzt gar nicht. SSL Read. Ja, okay. Das heißt, wir

40:17.640 --> 40:24.120
machen jetzt mal sowas wie Pass Request, so. Müssen wir gleich anlegen und da stecken

40:24.120 --> 40:30.760
wir das aktuelle Request-Objekt rein und das aktuelle Request-Objekt ist, ich bin grad

40:30.760 --> 40:45.160
verwirrt. Moment, wo steht der Request drin? Da, da, hier, da, das brauch ich. So, also,

40:45.160 --> 40:56.560
ich mach mal hier. Das muss übrigens, ah nee, das ist Private. Private kann, muss nicht

40:56.560 --> 41:10.840
inline sein. Also, Void. Dann brauchen wir ein Pass Request. So, und jetzt müssen wir

41:10.840 --> 41:15.120
aus dieser Anfrage das da oben irgendwie rausholen. Also, sprich, der Client macht diese Anfrage

41:15.120 --> 41:23.200
hier. Oder aber er macht eine Anfrage ohne hier. So, jetzt müssen wir zwei Fälle behandeln.

41:23.200 --> 41:29.160
Entweder, es gibt einen Authorization-Header, dann müssen wir gucken, ob das stimmt. Oder,

41:29.160 --> 41:37.560
es gibt keinen Authorization-Header, dann müssen wir sowas hier antworten. www, authenticate,

41:37.560 --> 41:45.560
realm, bla, blub. Wenn man das hier antwortet, HTTP-mäßig, dann macht der Browser einen

41:45.560 --> 41:48.720
Pop-Up, das werdet ihr gleich sehen, jetzt probieren wir aus, dann macht der Browser

41:48.720 --> 41:56.720
einen Pop-Up, wo drin steht, bitte anmelden. So, also, das heißt, wir antworten jetzt dem

41:56.720 --> 42:06.680
Browser, einfach mal ohne zu checken, ob der Header gesetzt ist, antworten wir mit, äh,

42:06.680 --> 42:25.720
was? War ich irgendwas verkehrt? Ach so, ja klar, ähm, das muss man als, als, äh, Referenz

42:25.720 --> 42:29.560
übergeben, alles klar. Wenn ich das als Zeug habe, ich mein, ich könnte es auch, egal,

42:29.560 --> 42:34.880
wir lassen es jetzt einfach erstmal so. So, jetzt muss ich gucken, jetzt muss ich, jetzt

42:34.880 --> 42:43.440
muss ich zurücksenden, ey, mach mal Ausentifizierung. So, und jetzt hätte ich das jetzt nicht gelöscht,

42:43.440 --> 42:48.440
dann hätte ich nur das kopieren können von unten, das war was, mbit, tls, write, hier,

42:48.440 --> 42:53.880
write. So, und jetzt müssen wir folgendermaßen antworten, wir müssen jetzt, wir müssen jetzt

42:53.880 --> 43:05.160
so antworten, http, 1.1, unauthorized, ok, das müssen wir antworten, wenn wir was anderes

43:05.160 --> 43:10.520
antworten, geht's nicht, das müssen wir antworten, so, das und nicht anders, also, wir müssen

43:10.520 --> 43:19.520
antworten, http, was, slash, 1.1, 401, an, ach du Scheiße, warum haben die das nicht

43:19.520 --> 43:29.320
copy paste bar gemacht, hier unauthorized muss man antworten, kontrol r, kontrol n,

43:29.320 --> 43:44.000
weil es http ist, geht nicht anders, so, und jetzt, jetzt was, www, authenticate, passt

43:44.000 --> 43:56.320
mal auf, dass ich mich nicht verschreibe, www, authenticate, was, basic, oder was, realm,

43:56.320 --> 44:03.000
gleich, das ist magic, ich hab keine Ahnung was das genau macht, das Bild ist gut, ja,

44:03.000 --> 44:10.320
das ist das beste, so, und jetzt irgendwie keine Ahnung, lulw, ich weiß nicht mal für

44:10.320 --> 44:21.600
was das gut ist, was hab ich verkehrt gemacht, Moment, ich, ich mach das, mach mal den String

44:21.600 --> 44:36.520
hier kurz raus, auto, response, ah, hab nicht richtig kopiert, jetzt hat er hier Lehrzeichen

44:36.520 --> 44:42.800
reingemacht, nein, du sollst keine Lehrzeichen reinmachen, www, unauthorized, geh fort, i,

44:42.800 --> 44:51.720
keine Lehrzeichen, stimmt das jetzt, basic, realm, gleich, keqwe, alles klar, so, und

44:51.720 --> 45:03.000
jetzt können wir das senden, ssl, response, und dann strlen, response, so, und jetzt müsste

45:03.000 --> 45:08.320
ich den popup im browser kriegen, wenn ich das richtig gemacht hab, was hab ich falsch

45:08.320 --> 45:13.600
gemacht, ok, ist es konst anscheinend, ja, mach nicht wegen, wenn du das so haben willst,

45:13.600 --> 45:18.920
dann ist es das, so, so, mal uploaden, jetzt müsste der browser mich eigentlich fragen,

45:18.920 --> 45:26.120
dass ich mich anmelden will, boah, das ist anstrengend, da muss man wirklich auf jedes,

45:26.120 --> 45:33.360
auf jedes Zeichen gucken, dass das funktioniert, oh, huge upload speed, massive, kurz was zu

45:33.360 --> 45:39.240
trinken einchecken, chat, wenn ihr irgendwas wissen wollt, haut rein, ich muss mich da

45:39.240 --> 45:42.400
nicht unbedingt die ganze Zeit drauf konzentrieren, weil dann muss ich nach einer Stunde ausmachen,

45:42.400 --> 45:48.080
so, also, jetzt gucken wir mal, ob das funktioniert, wenn ich jetzt die Seite lade, müsste er mich

45:48.080 --> 46:08.680
am Passport fragen, oder auch nicht, ah, ich weiß, was ich vergessen hab, ich weiß, was

46:08.680 --> 46:15.680
ich vergessen hab, ich hab das allerwichtigste vergessen, weil, das ist ja HTTP, ich hab

46:15.680 --> 46:19.600
was ganz wichtiges vergessen, pass mal auf, wer, wer, wer sieht's, vielleicht sieht's

46:19.600 --> 46:30.480
jemand, weil ich vergessen hab, wir müssen das abschließen, sonst geht das nicht, so

46:30.480 --> 46:37.080
muss ein HTTP-Request enden, wenn ein HTTP-Request so nicht endet, geht's nicht, eh, response,

46:37.080 --> 46:43.240
response, so, ich hoffe, jetzt funktioniert's, wir probieren das erstmal mit Curl aus, was

46:43.240 --> 46:54.280
Curl sagt, HTTPS, ja, HTTPS, oder was meinste, nee, nee, hab ich, das hab ich eingegeben,

46:54.280 --> 47:02.120
passt, oder, ja, ja, hab ich eingegeben, okay, der antwortet richtig, jetzt probieren wir

47:02.120 --> 47:18.480
das mal, jetzt probieren wir das mal mit dem Browser, ah, guck mal, und warum, weil ich

47:18.480 --> 47:26.840
das hier vergessen hab, ein HTTP-Response muss nicht, dom-pc, das ist eine exquisite,

47:26.840 --> 47:33.560
excellent, five-head-big-brain-frage, oh, ich hab den Chat nicht auf, er fragt, warum

47:33.560 --> 47:40.200
backslash r, backslash n und nicht backslash n, weil das im HTTP-Protokoll so definiert

47:40.200 --> 47:45.000
ist, also das ist nicht wie Zeilenendung und Linux Windows, wo man sich das mittlerweile

47:45.000 --> 47:54.120
ein bisschen aussuchen kann, das ist so definiert, so muss ein HTTP-Request aussehen, also das

47:54.120 --> 48:00.640
muss so sein, das haben die mal irgendwo in irgendeinem Standard-Dokument so reingeschrieben,

48:00.640 --> 48:08.080
dass ein HTTP-Request gefälligst mit character-turn-newline, character-turn-newline aufhören muss, geht

48:08.080 --> 48:18.400
nicht br, nee, br geht nicht, weil, warum geht br nicht, big-brain-Chat, fünf Sekunden

48:18.400 --> 48:32.280
Bedenkzeit, mitschreiben, morgen gibt's Klausur, weil es kein HTML ist, genau, korrekt, so sieht

48:32.280 --> 48:42.720
es aus, der Chat ist mal wie immer absolut richtig, richtig massive-brained, genau, weil

48:42.720 --> 48:51.920
es kein HTML ist, es ist in dem Fall noch ganz normales HTTP-Text, hier in diesem Response

48:51.920 --> 48:58.400
hier würde unten drunter, jetzt würde HTML kommen, hier würde jetzt das HTML kommen,

48:58.400 --> 49:05.800
aber das hier ist noch der ganz normale HTTP-Request, äh, Response und das muss so aufgebaut sein,

49:05.800 --> 49:11.840
weil irgendjemand sich vor 50 Jahren oder so mal, nee, ja, doch, keine Ahnung, vor 50

49:11.840 --> 49:17.800
Jahren jetzt einfach mal vor 50 Jahren auf die Idee gekommen ist, dass eben HTTP so aussieht

49:17.800 --> 49:21.640
und es muss so gemacht werden und wenn man das nicht so macht, dann funktioniert es nicht,

49:21.640 --> 49:25.440
das ist ja auch das Schöne an Standardisierungs-Sachen, wenn man sich nicht dran hält, dann geht's

49:25.440 --> 49:31.160
einfach nicht, und wenn man sich dran hält, sollte es nach Möglichkeit überall gleich

49:31.160 --> 49:41.320
funktionieren, genau, es muss immer eine Leerzeile sein, beziehungsweise es muss character-turn-newline

49:41.320 --> 49:42.320
sein.

49:42.320 --> 49:50.280
Ich hab noch nie ausgedacht, ob es einfach mit zwei Newlines geht, aber ich denke mal

49:50.280 --> 49:54.960
nicht, weil in jedem Beispiel siehst du, dass du das erfährst, warum benutzt du hauptsächlich

49:54.960 --> 49:55.960
Pointer-Referenzen?

49:55.960 --> 50:03.040
Ich benutze das, was funktioniert, ich bin jetzt nicht so, äh, der C++-Freund, dass

50:03.040 --> 50:14.520
ich sagen will, ich muss das alles 100 pro C++-Next-Level-Shit machen, was ist der Unterschied

50:14.520 --> 50:15.960
zwischen der Referenz und dem Pointer?

50:15.960 --> 50:27.440
Achso, das hier, das wäre jetzt eine Reference, wo ist denn da der Unterschied?

50:27.440 --> 50:44.280
Zum ernsthaft, ich hab keinen Plan, und jetzt, warum, warum gibt's da beides, warum gibt's

50:44.280 --> 50:50.680
da beides, hä, aber wo ist der Unterschied, ich mein, letztendlich ist eine Reference

50:50.680 --> 50:53.680
auch ein Pointer, oder?

50:53.680 --> 51:10.120
Okay, ich weiß nicht, weil C++-Freifer exquisite C++, ne, das verstehe ich nicht, keine Ahnung,

51:10.120 --> 51:16.760
der Unterschied, der ist mir nicht geläufig, keine Ahnung, woran das liegt, also was das

51:16.760 --> 51:17.760
ist.

51:17.760 --> 51:24.880
Vielleicht ist ja eigentlich mal BigBrain im Chat, weil du bei Referenzen direkt auf

51:24.880 --> 51:30.600
dem Object arbeitest, also im Prinzip, wenn ich das richtig verstehe, was Cheat95 sagt,

51:30.600 --> 51:36.680
heißt das, eine Reference ist ein Pointer, der für mich schon automatisch dereferenziert,

51:36.680 --> 51:42.800
und ein Pointer ist eine Adresse, die ich selbst dereferenzieren muss, ja, oder, also

51:42.800 --> 51:46.280
wenn ich eine Reference nehme, ist es ein Pointer, den C++ für mich schon wieder zum

51:46.280 --> 51:50.440
Objekt umwandelt, und ein Pointer muss ich das selbst machen.

51:50.440 --> 52:03.560
Also ist das quasi eine Abkürzung, also ist im Prinzip, ist das hier eine Abkürzung,

52:03.560 --> 52:17.920
wie wenn ich das von Hand mache, okay, aber damit kann ich leben, aber das ist gut zu

52:17.920 --> 52:23.200
wissen, deswegen mache ich so Streams auch, da lernt man unter anderem doch jeden Stream

52:23.200 --> 52:24.200
irgendwas.

52:24.200 --> 52:34.280
Also, so, jetzt können wir hier irgendwas eingeben, jetzt können wir zum Beispiel sagen,

52:34.280 --> 52:39.240
keqw, blub, ho, oh, ja gut, logisch, ich überprüfe das ja gar nicht.

52:39.240 --> 52:48.080
Ach, das muss auch nicht, das kann auch nicht Null sein, okay, dann ist es natürlich gar

52:48.080 --> 52:53.960
nicht mal verkehrt, das als Reference zu machen, das finde ich eigentlich ziemlich gut, okay,

52:53.960 --> 53:00.000
das mache ich, das finde ich nice, das machen wir, das gefällt mir, also sprich, ich nehme

53:00.000 --> 53:11.520
jetzt hier Reference, hier nehme ich auch eine Reference, und dann übergebe ich hier

53:11.520 --> 53:19.560
das Objekt selbst, und hier muss ich dann, weil der möchte ja explizit hier einen Pointer

53:19.560 --> 53:31.520
haben, das ist ja C, und, okay, so, jetzt muss ich auch gucken, dass FD funktioniert,

53:31.520 --> 53:38.000
und FD, mal gucken, ob das jetzt klappt, wo übergebe ich FD, kleinen FD, hier auch per

53:38.000 --> 53:46.840
und, per Reference, excellent, ne, oh je, ach, Moment, das ist jetzt ein Pointer, jetzt

53:46.840 --> 54:00.680
muss ich den Pointer vorher erstmal, das ist aber auch nicht schön, oder, auch nicht, ob

54:00.680 --> 54:10.560
mir das jetzt so viel besser gefällt, ehrlich gesagt, weil das hier muss ich ja als, das

54:10.560 --> 54:15.920
kann ich ja nicht als hier Stack-Allocated-Dings, weil das geht ja hier aus dem Scope, und dann

54:15.920 --> 54:22.720
ist es weg, oder merkt er sich das, der macht da keinen Reference-Count oder sowas, ne, macht

54:22.720 --> 54:30.320
der da irgendeinen Reference-Count, also sprich, wenn ich da jetzt, ja, mal angenommen, ich

54:30.320 --> 54:55.980
mach da jetzt sowas, merkt er sich das, kapiert er das, ne, ne, ne, oder, das kapiert er nicht,

54:55.980 --> 55:00.600
das kackt jetzt ab, das kackt ab, guck mal, ich kann das hier auch gar nicht übergeben,

55:00.600 --> 55:10.480
ah, ne, Free, doch, und, oder muss ich hier, muss ich hier dann auch per und Captchern,

55:10.480 --> 55:21.400
hä, also wenn das jetzt funktioniert, ne, Moment, das glaube ich nicht, das kackt ab,

55:21.400 --> 55:26.280
das muss er, also das, das wird dann, da würde ich die Welt nochmal verstehen, wenn das jetzt

55:26.280 --> 55:27.280
funktioniert.

55:27.280 --> 55:31.960
Macht das, das macht doch garantiert keine Reference-Count-Geschichten für mich.

55:31.960 --> 55:49.960
Da müsste ich ja irgendeinen Shared-Pointer draus machen, so, Moment, Curl, oh, ne, siehste,

55:49.960 --> 55:54.360
siehste geht nicht, das ist aber auch klar, dass das nicht geht, das kann nicht gehen,

55:54.360 --> 56:00.040
weil das hier ist, hier geht es aus dem Scope und wird aufgeräumt, das ist, das gibt es

56:00.040 --> 56:04.120
gar nicht mehr, das Objekt danach, ok, das muss, ok, dann, dann ist das prinzipiell schon

56:04.120 --> 56:09.560
mal richtig, was ich hier unten gemacht hab, dass man hier sagt, ok, aber dann gefällt

56:09.560 --> 56:16.400
es mir auch nicht wirklich besser, ehrlich zu sein, ey, vorbei, probieren wir mal aus,

56:16.400 --> 56:24.000
jetzt Upload, jetzt müsste es funktionieren wieder, weil jetzt wird das hier, äh, quasi

56:24.000 --> 56:31.080
nicht lokal in der Funktion angelegt, sondern so, dass es hier nicht gelöscht wird, wenn

56:31.080 --> 56:36.960
es aus dem Scope geht, deswegen muss ich jetzt ja auch von Hand löschen, so, mal gucken,

56:36.960 --> 56:41.400
ob das jetzt funktioniert, wenn nicht, mache ich einfach die Steuerung Z-Org hier, bis

56:41.400 --> 56:50.800
es wieder funktioniert, funktioniert, nice, gut, ähm, excellent, ich weiß zwar nicht

56:50.800 --> 56:59.960
genau, ob das jetzt besser ist, aber, ja, wir gehen einfach mal noch voraus, dass es

56:59.960 --> 57:07.520
jetzt besser ist, ich mein, was richtig, oh, wir machen jetzt, jetzt, Leute, big brain

57:07.520 --> 57:15.040
C++, wir machen jetzt was anderes, wir machen jetzt, so, standard, shared pointer, oh, oh,

57:15.040 --> 57:24.840
oh, ob das funktioniert, so, standard, shared pointer, new, das da, äh, und jetzt müssen

57:24.840 --> 57:28.800
wir das aufräumen, da können wir uns nämlich den ganzen Kram spannen, oh mein, C++ Lambda

57:28.800 --> 57:42.520
Syntax, ah, Hilfe, ne, so, so, so, oh je, äh, ah, so, also, was muss man da jetzt übergeben,

57:42.520 --> 57:51.440
ne, das müssen wir auch noch runter machen, dass es richtig eindrückt, excellent, so,

57:51.440 --> 57:59.160
auto, so, das ist das Object zum löschen, da sagen wir, delete o und, und free, free

57:59.160 --> 58:09.880
o, sehr gut, so, und jetzt sollte er das komplett automatisch handeln, das heißt, ich brauch

58:09.880 --> 58:17.440
kein Delete mehr, und ich brauch hier kein Delete mehr, was hat er jetzt für Schmerzen,

58:17.440 --> 58:26.800
ah, äh, hier brauch ich den raw pointer nochmal, oder, oder kann man da sowas hier machen,

58:26.800 --> 58:46.200
ne, ne, kann man da sowas machen, oh, ey, das geht, alter, was ist das, was zum, ok,

58:46.200 --> 58:51.480
ne, ne, das machen wir nicht, wenn ich das jetzt hier richtig erkenne, ist das dereferenzieren

58:51.480 --> 58:57.840
und dann die Adresse von, ach du große, so, dass sowas überhaupt erlaubt ist, dass sowas

58:57.840 --> 59:16.400
valid C++ ist, so, so, und hier übergeben wir jetzt den shared pointer direkt, bam,

59:16.400 --> 59:23.560
ob das jetzt funktioniert, so, handle connection, und da brauchen wir jetzt aber keine reference

59:23.560 --> 59:31.120
übergeben, ne, das kann man ja direkt, das kann man theoretisch direkt moveen sogar,

59:31.120 --> 59:40.080
das ist, oh, jetzt ist aber immer sowas von modern OP C++ hier am Start, so, und jetzt

59:40.080 --> 59:54.960
kann man das sogar moveen, ja, so, und, ne, ne, Moment, das geht aber doch hier, also,

59:54.960 --> 59:59.040
ich kann das doch, wenn ich das hier auf dem Stack erzeuge, dann ist es hier weg, weil

59:59.040 --> 01:00:04.160
hier ist das Scope zu Ende und hier starte ich einen neuen Thread, wo ich das drin verwende,

01:00:04.160 --> 01:00:09.320
also, das geht hier aus dem Scope und dann ist es hier ungültig, deswegen, deswegen,

01:00:09.320 --> 01:00:14.240
das habe ich ja im Zwischen durch probiert, das geht ja nicht, aber mit dem shared pointer

01:00:14.240 --> 01:00:22.960
müsste es gehen, weil der macht ja reference count, so, ok, ok, big brain, so, mal gucken,

01:00:22.960 --> 01:00:31.360
ob das jetzt funktioniert, das kann ich ja einfach so übergeben, ok, Moment, das funktioniert

01:00:31.360 --> 01:00:37.560
jetzt nicht so einfach, das glaube ich nicht, dass es einfach funktioniert, Moment, upload,

01:00:37.560 --> 01:00:44.320
upload, upload, muss bei dem oberen nicht auch noch O als Parameter rein, wo, ist doch hier,

01:00:44.320 --> 01:00:54.720
ah, ne, Moment, ist kaputt, es ist kaputt, ach ja, natürlich, lull, hast recht, jaja,

01:00:54.720 --> 01:01:07.080
so, habe ich, ja, natürlich, ist verkehrt, ob das jetzt funktioniert, jetzt bin ich ja

01:01:07.080 --> 01:01:17.960
mal gespannt, das wäre jetzt zumindest die deutlich C++igere Variante, das kackt jetzt

01:01:17.960 --> 01:01:27.920
ab, ah, geht nicht, irgendwas verkehrt, ja gut, ich übergebe jetzt ja hier auch, natürlich

01:01:27.920 --> 01:01:31.880
geht das nicht, ich übergebe hier auch die Referenz auf den shared pointer, das bringt

01:01:31.880 --> 01:01:39.880
mir nichts, ich brauche hier das da, so, das war es eigentlich, so, mal gucken, ob es jetzt

01:01:39.880 --> 01:01:47.920
funktioniert, ne, Spaß an C++ werde ich nie bekommen, aber es kann weniger nervig werden,

01:01:47.920 --> 01:02:06.200
das ist aber auch das einzige, was möglich ist, so, mal gucken, mal gucken, pp hands

01:02:06.200 --> 01:02:18.960
oder nicht, es geht, alles klar, doch, also das, jetzt ist ja schon mal hier, richtig,

01:02:18.960 --> 01:02:25.000
richtig, exzellent C++, was, diese paar Zeilen ab 102, da bekommt man ja Angst, echt, zeig

01:02:25.000 --> 01:02:31.160
mal her, das hier, ja, vor allem das hier sieht absolut grausam aus, kann man das nicht

01:02:31.160 --> 01:02:42.680
einfach in einer Zeile machen jetzt, das erlaubt, mach da mal ein Autoformat mit, vielleicht

01:02:42.680 --> 01:03:06.560
ein bisschen besser, okay, sehr gut, so, die Fisch, also wirklich schön aussehen tut

01:03:06.560 --> 01:03:21.400
das nett, aber was soll ich anders machen, ne, okay, exzellent, er sollte sich jetzt

01:03:21.400 --> 01:03:25.400
automatisch aufräumen, da müssen wir jetzt mal gucken, ob der sich auch wirklich automatisch

01:03:25.400 --> 01:03:32.480
aufräumt, wir geben jetzt mal hier, ach so, machen wir schon, Heapspace, wir geben ja

01:03:32.480 --> 01:03:37.240
schon Heapspace aus, alle 500 Millisekunden, gucken wir mal, ob der Heaps, ob das auch

01:03:37.240 --> 01:03:44.720
ordentlich freed wird, wir gucken mal, ob das ordentlich freed wird, äh, sieht nicht

01:03:44.720 --> 01:03:48.520
so aus, als dass das ordentlich freed wird, wir haben jetzt, wir haben jetzt Heapspace,

01:03:48.520 --> 01:03:55.120
ich mach mal ein bisschen größer, Leute, wisst ihr was, ähm, machen wir uns mal hier

01:03:55.120 --> 01:04:04.800
so ein Fenster auf, wo man besser was sieht, jetzt hier erkennst du ja gar nix, ähm, Device,

01:04:04.800 --> 01:04:20.120
Monitor, oh, äh, oh, ich hab das hier nicht verknüpft, ähm, hier, Plattform, IO, Bin,

01:04:20.120 --> 01:04:30.200
muss man mal in das, what, ach, ich bin im falschen Verzeichnis, vielleicht macht er

01:04:30.200 --> 01:04:36.680
deswegen nicht, ah gut, so, hier unten erkennt man jetzt nämlich ein bisschen besser was,

01:04:36.680 --> 01:04:40.440
hier unten erkennt, jetzt erkennt man ein bisschen besser was, also, das ist mein freier

01:04:40.440 --> 01:04:50.320
Heapspace in Byte, also so ungefähr 168, 168 Kilobyte, so, wir gucken jetzt mal, ob der,

01:04:50.320 --> 01:04:54.880
ob der, äh, alles ordentlich freigibt, nach dem, was ich hier gewusstet hab, also er sollte

01:04:54.880 --> 01:04:58.960
jetzt, nachdem ich das abgebaut hab, also, die Verbindung aufbauen, Verbindung abgebaut

01:04:58.960 --> 01:05:10.360
haben, sollte ich genauso viel Speicher haben, wie vorher, ja, oder, meine Damen und Herren,

01:05:10.360 --> 01:05:19.080
meiner schwankt ein bisschen eben, warum, aber, im Großen und Ganzen, ja, der gibt wieder

01:05:19.080 --> 01:05:26.200
alles frei, der gibt wieder alles frei, also, ich würd sagen, wir haben kein Memory Leak

01:05:26.200 --> 01:05:37.520
produziert, exzellent, ich hab zwar nur die Hälfte kapiert, von dem, was ich gemacht

01:05:37.520 --> 01:05:43.480
hab, aber, es funktioniert, sehr schön, warum, warum, checkt der hier eigentlich nicht,

01:05:43.480 --> 01:05:52.040
dass die, was zeigt der hier für komischen Blödsinn an, Y5, was auch immer, ok, also,

01:05:52.040 --> 01:05:56.960
kein Memory Leak, das ist doch schon mal gut, ja, das ist auch gut, ok, im Moment, wenn

01:05:56.960 --> 01:06:03.200
man die Verbindung abbricht, dann auch kein Memory Leak, ich bin begeistert, wir haben

01:06:03.200 --> 01:06:10.800
das geschafft, ok, jetzt waren wir die Hardcore Variante, 5 Sekunden lang connecten, maximal

01:06:10.800 --> 01:06:22.800
5 Sekunden lang connecten, und das machen wir jetzt 100 mal in einer Schleife, also, oh,

01:06:22.800 --> 01:06:29.320
wie machen wir das jetzt am besten, also, erstmal schalten wir den Output ab, Def Null,

01:06:29.320 --> 01:06:35.680
das heißt, wir kriegen kein Output, das ist ok, sonst bammt uns das ganze voll, ok, so,

01:06:35.680 --> 01:06:39.480
und jetzt sagen wir mal, wir machen, wir starten mal 6 Stück, jetzt kommen die, jetzt kommen

01:06:39.480 --> 01:06:43.160
die Bash Skills, wir starten jetzt mal 6 Stück, mehr geht nicht, mehr, da ist der Speicher

01:06:43.160 --> 01:06:52.760
voll, so, vor, in, was weiß ich, 1, 2, 3, 4, 5, 6, du, das da dann, und das jetzt im

01:06:52.760 --> 01:06:59.240
Hintergrund, so, da startet es jetzt 6 mal, und mal gucken, was passiert, bamm, ja, ja,

01:06:59.240 --> 01:07:08.640
ja, ok, es geht nicht alles, es geht nicht alles, aber, ich glaube, wir haben keine Memory

01:07:08.640 --> 01:07:09.640
Leaks, oder?

01:07:09.640 --> 01:07:16.080
Ich glaube, wir haben keine Memory Leaks, wir haben irgendwie so 860, 67, ach, da noch

01:07:16.080 --> 01:07:34.880
was, 1, 6, 7, ok, das ist wohl noch nicht so komplett spread safe, wie ich gedacht habe,

01:07:34.880 --> 01:07:37.560
was hat er denn, was hat er denn für ein Fehler, was, Moment, jetzt müssen wir mal den Fehler

01:07:37.560 --> 01:07:41.320
angucken, vielleicht hat er auch einfach, vielleicht hat er auch einfach zu wenig Speicher,

01:07:41.320 --> 01:07:51.000
vielleicht hat er auch zu wenig Speicher, das kann auch sein, also, der ist beim Display

01:07:51.000 --> 01:07:58.600
abgekackt, ich glaube, der hat zu wenig Speicher gehabt, kurzzeitig, ich glaube, der hatte

01:07:58.600 --> 01:08:09.880
kurzzeitig zu wenig Speicher, ich glaube, der hat zu wenig Speicher gehabt, und konnte,

01:08:09.880 --> 01:08:16.160
und konnte jetzt irgendwas nicht allocaten, und ist verreckt dabei, gut, vielleicht sind

01:08:16.160 --> 01:08:24.800
6 Verbindungen auch ein bisschen viel, 6 gleichzeitig Verbindungen, vielleicht, 6 gleichzeitig Verbindungsversuche

01:08:24.800 --> 01:08:38.600
sind vielleicht ein bisschen viel, probieren wir mal mit 3, 3 Stück gleichzeitig, so, was,

01:08:38.600 --> 01:08:46.920
warum hat er bei 3 Stück schon Memory Allocation failed, aber ich würde sagen, wir haben kein

01:08:46.920 --> 01:08:55.440
Memory Leak produziert, also, ich würde sagen, wir haben kein Memory Leak produziert, oder,

01:08:55.440 --> 01:09:03.200
da kommt am Ende, da kommt am Ende ungefähr das gleiche immer wieder raus, so, ungefähr,

01:09:03.200 --> 01:09:17.720
so 100, also 167 irgendwas, 167 irgendwas kommt da raus, wobei, jetzt sind wir, oh, jetzt

01:09:17.720 --> 01:09:21.720
sind es nur noch 166, vielleicht haben wir doch irgendeinen Memory Leak produziert, ich

01:09:21.720 --> 01:09:34.040
habe keine Ahnung, exzellent, ok, jetzt, jetzt, jetzt machen wir die Hardcore Variante, While,

01:09:34.040 --> 01:09:37.400
True, Do, Achtung, Sleep, 10, Done, so, wir lassen, wir lassen die 3 Verbindungen jetzt

01:09:37.400 --> 01:09:42.680
einfach mal am Stück laufen, so, mal gucken, was passiert, gucken, wie viel wir da übrig

01:09:42.680 --> 01:09:53.160
haben, ok, jetzt sind wir bei 166 KB, so, 10 Sekunden warten, Next, Bam, 100, 155, oh,

01:09:53.160 --> 01:10:00.240
so, alles geklärt wird da nicht, aber warum, wo soll ich denn da, bitte schön, da hab

01:10:00.240 --> 01:10:05.160
ich, ich kann da gar keinen Memory Leak, ich mach ja da nichts, außer an der einen Stelle,

01:10:05.160 --> 01:10:28.780
und eigentlich sollte das klärt werden, vielleicht da die Librarien in Leak, ja, tja, wo, wo

01:10:28.780 --> 01:10:36.800
leake ich hier irgendwas, man das einzige, wo ich irgendwie was heapmäßig anlege, ist

01:10:36.800 --> 01:10:44.800
das hier, sonst nirgendswo, warte auf die Garbage Collector, wobei, guck mal, jetzt

01:10:44.800 --> 01:11:12.600
hat er sich eingekriegt, oder, jetzt hat er sich eingekriegt, kann das sein, ich hab

01:11:12.600 --> 01:11:19.040
doch irgendwas, was Fehlermeldungen ausgibt, ich hab doch irgendwas, was Fehlermeldungen

01:11:19.040 --> 01:11:30.000
ausgibt, aber das sollte eigentlich automatisch aufgeräumt werden, na, hier dürfte eigentlich

01:11:30.000 --> 01:11:44.560
nichts überbleiben, vielleicht sollte ich hier mal, so machen, ich hab jetzt eigentlich

01:11:44.560 --> 01:12:01.320
kein Bob Memory Leaks zu suchen, 688, was, hä, jetzt ist wieder mehr geworden, jetzt

01:12:01.320 --> 01:12:20.400
ist wieder mehr geworden, und jetzt ist wieder ein, also, so ungefähr kommt da das gleiche

01:12:20.400 --> 01:12:30.880
raus, der ist jetzt bei 164,900, vielleicht braucht der mal ne Weile, bis er alle möglichen

01:12:30.880 --> 01:12:37.920
Sachen einmal durch ist, alle möglichen Codes, Ifs, und irgendwas, kein Schimmer, was der

01:12:37.920 --> 01:12:50.400
für Schmerzen hat, aber ich glaube, so ungefähr bleibt es jetzt gleich, immer so um die, ich

01:12:50.400 --> 01:12:59.680
blick nicht durch, jetzt hat er sogar 165 auf einmal wieder, äh, kurze Mal zu einem

01:12:59.680 --> 01:13:03.680
Juby Key und Krypto Hardware Wallets, ist ne super Sache, haben wir auf der Arbeit auch

01:13:03.680 --> 01:13:11.000
für SSH Keys, jetzt wirds wieder mehr, ok, wisst ihr was, ich ignorier das ganze jetzt

01:13:11.000 --> 01:13:18.640
einfach mal, exzellent, wunderbar, alles klar, lassen wir so, perfekt, absolut keine Memory

01:13:18.640 --> 01:13:29.280
Leaks zu erkennen, Mini Cup, so, ähm, so weiter, jetzt mal zum eigentlichen, oh wisst ihr was,

01:13:29.280 --> 01:13:35.440
was sein könnte, ich hab da ne Idee, guck mal, wir sind ja, also, wir sind, hier sind

01:13:35.440 --> 01:13:40.840
wir auf jeden Fall Threadsafe, weil hier gibts nur, nur immer, das ist eh nur ein Thread,

01:13:40.840 --> 01:13:45.480
der da drauf zugreift, so, hier sind wir auch Threadsafe, das hier ist auch immer nur ein

01:13:45.480 --> 01:13:52.280
Thread, nämlich der hier, aber ab hier wirds Multithreaded, das heißt, guck mal, hier

01:13:52.280 --> 01:14:01.600
greif ich zu auf, äh, wo hab ich, Moment, seh es grad nicht, bin zu blöd, hier, hier

01:14:01.600 --> 01:14:09.560
greif ich auf so ne globale Variable, wo die Config für den Server drin steht zu, vielleicht

01:14:09.560 --> 01:14:16.680
hat der Schmerzen damit, wenn ich Multithreaded auf diese CONF Zugreifer und SSL Contacts

01:14:16.680 --> 01:14:28.280
davon erzeuge, das könnte sein, dass der da mit rumspackt, vielleicht sollte ich da

01:14:28.280 --> 01:14:31.960
irgendwie den Mutext drum machen, wisst ihr was, ich ignoriere das jetzt einfach mal,

01:14:31.960 --> 01:14:41.440
ich schreibe hier was nicht, so, ich weiß noch nicht ob ich das mach, mal gucken, jetzt

01:14:41.440 --> 01:14:44.920
Basic Auth wollte ich eigentlich machen, eigentlich wollte ich das hier machen, so, der Browser

01:14:44.920 --> 01:14:50.680
fragt ja schon, der Browser fragt ja schon, also, irgendwann mal, fragt er, fragt der

01:14:50.680 --> 01:14:58.440
Browser, Connection Fail, achso ja, der hat ja die Verbindung schon gespeichert, so, das

01:14:58.440 --> 01:15:05.000
heißt, wenn ich jetzt hier nen Curl drauf mache, dann sagt er, ich soll mich, ich soll

01:15:05.000 --> 01:15:11.280
mich authentifizieren, guck hier, der sagt, ich soll mich authentifizieren und ich hab

01:15:11.280 --> 01:15:18.920
mich nicht authentifiziert, deswegen muss ich jetzt zwei Sachen handeln, entweder,

01:15:18.920 --> 01:15:26.640
entweder ich hab nen Authentifizierungsheader drin, dann gehts weiter und ich hab keinen

01:15:26.640 --> 01:15:37.800
Authentifizierungsheader drin, dann krieg ich das hier als Response, würd ich sagen,

01:15:37.800 --> 01:15:46.520
also, ok, dann machen wir jetzt hier sowas wie Void, Check, Check Auth, ne, bool Muster,

01:15:46.520 --> 01:15:54.520
weil wir wollen ja wissen, ob Authentifiziert ist oder nicht, dort machen wir den SSL Kontext

01:15:54.520 --> 01:16:03.120
rein und dann sag ich hier sowas wie Check, If, Check Auth, so und wenn es, wenn es nicht

01:16:03.120 --> 01:16:09.600
authentifiziert ist, also sprich, wenn er es nicht authentifizieren soll, dann schick

01:16:09.600 --> 01:16:18.160
ich das hier zurück, das hier erzeugt im Browser dieses Popup, bitte anmelden und

01:16:18.160 --> 01:16:22.320
sag Return, weil dann wird alles aufgeholt, mit dem Request kann ich eh nicht mehr anfangen,

01:16:22.320 --> 01:16:35.520
so und danach und hier liefer ich dann die normale HTML Seite aus, genau, also sprich,

01:16:35.520 --> 01:16:42.920
wenn er authentifiziert ist, dann antworte ich mit HTTP 200, was auch immer, dann antworte

01:16:42.920 --> 01:16:55.880
ich mit der Website, so, würd ich mal, ok, das machen wir jetzt, dann antworte ich HTTP

01:16:55.880 --> 01:17:06.520
200, ok, hab ich hier mit Plain Text, ne, Text, oh ne, ich hab's mir nicht gespeichert,

01:17:06.520 --> 01:17:25.440
ok, so, dann antworte ich mit HTTP, ok, Content, was ist das, Content Type, Content, Content

01:17:25.440 --> 01:17:41.040
Type, Type ist, ne, ich kann nicht schreiben, Content Type ist Text HTML, ok, so und da kommt

01:17:41.040 --> 01:17:49.640
jetzt mein HTML-Gedöns rein, also sowas hier, HTML, HTML, so, also sprich, wenn ich nicht

01:17:49.640 --> 01:18:05.720
authentifiziert bin, krieg ich das nicht, soweit so gut, so, lull, oh, lull, gut, ja,

01:18:05.720 --> 01:18:10.120
also von der Idee sollte der jetzt checken, wenn ich authentifiziert, wenn ich nicht

01:18:10.120 --> 01:18:14.780
authentifiziert bin, dann krieg ich die Fehlermeldung, krieg das Popup, mich zu authentifizieren

01:18:14.780 --> 01:18:19.240
und wenn ich mich richtig authentifiziert habe, dann krieg ich die Website als Antwort,

01:18:19.240 --> 01:18:22.040
ist ja eigentlich ganz gut, jetzt müssen wir nur noch und jetzt kommt der eigentliche

01:18:22.040 --> 01:18:33.360
Spaß da dran, jetzt müssen wir nur noch diesen Header hier rauswursten, also sprich, wenn

01:18:33.360 --> 01:18:38.800
ich hier, ich sende hier so ein Authorization Header mit, das muss ich jetzt irgendwie da

01:18:38.800 --> 01:18:46.640
raus parsen, also sprich, ich muss jetzt den Request einlesen und dann muss ich das da

01:18:46.640 --> 01:18:57.960
raus holen, ach, du kacke, ok, also, ember, TLS, ne, was war das, read, SSL, read, SSL,

01:18:57.960 --> 01:19:08.760
ok, alles gut, so, jetzt brauchen wir einen Buffer, Buffer von was, unsigned, unsigned

01:19:08.760 --> 01:19:16.480
char, alles klar, machen wir, Buffer, wie groß darf die Response maximal sein, 2048 oder

01:19:16.480 --> 01:19:34.360
so, emm, Buffer 2048, das jetzt funktioniert, so und das hier, hier kommt die Länge zurück,

01:19:34.360 --> 01:19:40.160
was mache ich denn, was tippe ich denn hier für komisches Zeug, so und hier kommen die

01:19:40.160 --> 01:19:48.960
Bites zurück, die ich eingelesen habe, gut, emm, das heißt, wenn ich das hier jetzt ausgebe

01:19:48.960 --> 01:19:54.720
an der Stelle, dann müsste ich erstmal den Request und die ganzen Header einlesen an

01:19:54.720 --> 01:20:08.440
der Stelle, ok, das machen wir jetzt mal, wie Buffer, Länge, so, achso, ne, das muss char

01:20:08.440 --> 01:20:15.400
sein, so, also jetzt sollte ich schonmal diesen Request hier kriegen, probieren wir jetzt

01:20:15.400 --> 01:20:27.080
mal aus, upload, also ich lese jetzt die ersten 2, achso, jaja, return false, alles nicht

01:20:27.080 --> 01:20:33.680
identifiziert, also ich lese jetzt die ersten 2048 Bites von diesem Request ein, kommt das

01:20:33.680 --> 01:20:39.520
denn hin, ja, das reicht, oder, hier, das sind doch, das sind doch, also ich lese, ich

01:20:39.520 --> 01:20:48.280
will einlesen, von hier bis hier, ne, doch, von hier bis hier, das reicht, das reichen

01:20:48.280 --> 01:20:54.600
2048, ja, ich zähle das jetzt nicht, aber das reicht, oh, was hat er für Schmerzen,

01:20:54.600 --> 01:21:21.080
gott, ah, big brain, immer noch nicht, wo ist denn jetzt, achso, SSL, meine Güte, auch

01:21:21.080 --> 01:21:41.320
nicht, jetzt aber, ne, hä, jaja, ist gut, ist gut, ist gut, oder doch, warum sagt er

01:21:41.320 --> 01:21:54.640
no matching Function, aber es geht, was, ach, das geht nur für die ganze Applikation,

01:21:54.640 --> 01:21:59.080
nicht für eins, was meinste, ok, jetzt machen wir einen Curl und gucken, ob das funktioniert,

01:21:59.080 --> 01:22:22.240
ah, ne, Moment, ah, mein Monitor muss an, mein Serial, oh, fuck, rip, oh je, ich hab's

01:22:22.240 --> 01:22:50.600
kaputt gemacht, äh, hab ich ihn verkehrt gemacht, was hab ich verkehrt gemacht, ok,

01:22:50.600 --> 01:23:19.160
an, an welcher Stelle mag er denn jetzt nicht, wo, wo mag er denn jetzt nicht, ok, geben

01:23:19.160 --> 01:23:25.920
wir nochmal die Länge mit aus, was er denn eingelesen hat, jaja, ist gut, upload, abbrechen,

01:23:25.920 --> 01:23:33.680
neunmal neu upload, was, was ist jetzt verkehrt, hä, also, da, also, abkacken dürfte er doch

01:23:33.680 --> 01:23:50.120
dabei jetzt nicht, Wonka Smoke, der macht doch gar nichts böses, der liest den Request

01:23:50.120 --> 01:24:17.640
ein, hm, ah, hä, what the fuck, ah ja, aber er liest es doch ein, guckt mal, der, der

01:24:17.640 --> 01:24:28.160
funktioniert, der liest alles ein, legt er denn einen Plan, was der jetzt für Schmerzen

01:24:28.160 --> 01:24:39.720
hat, liegt das hier am Umwandeln oder so, jetzt, jetzt bin ich echt planlos, Stack Overflow

01:24:39.720 --> 01:24:58.320
detected, ja, ähm, äh, pff, äh, ich hab keine Ahnung, chat, ich weiß nicht woran

01:24:58.320 --> 01:25:13.480
das liegt, ok, ok, nochmal einlesen, wow, WTF, kann das sein, dass mein Stack einfach,

01:25:13.480 --> 01:25:20.280
ach, meine Stack size von dem Task ist zu klein, ach, guckt mal hier, jetzt, ich weiß woran

01:25:20.280 --> 01:25:29.240
es liegt, guckt mal, meine default Stack size ist 4096 und ich hab garantiert nicht, was

01:25:29.240 --> 01:25:35.040
zum Teufel macht der mit dieser Datei gerade hier, also ich kann maximal 4 Kilo Byte RAM

01:25:35.040 --> 01:25:45.120
verwenden, so, und innerhalb von diesen 4 Kilo Byte RAM, äh, will ich, schau mal 2048

01:25:45.120 --> 01:25:49.960
für diesen Buffer anlegen, das kann ja nicht funktionen, das ist einfach zu wenig, ich

01:25:49.960 --> 01:25:55.280
probier's mal mit 512, ob dafür genug Platz ist, wenn nicht mach ich die Stack size hoch,

01:25:55.280 --> 01:26:05.720
ah, yes, Serious Max blickt durch, ich seh es, exellent, 512 müsste vielleicht auch

01:26:05.720 --> 01:26:09.740
gerade noch reichen, einfach mehr RAM, ich kann dem Task, ich kann dem Task wirklich

01:26:09.740 --> 01:26:15.680
mehr RAM geben, ey, müssen wir ja eigentlich nicht so geizig sein, ich mein, guck mal,

01:26:15.680 --> 01:26:23.360
wir haben so eine Verbindung schon, eh, was ich 30 Kilo Byte brauche, das reicht nicht,

01:26:23.360 --> 01:26:37.640
das wird, ok, wir machen, wir machen das jetzt so 512, wir machen, ich mach die, die Task

01:26:37.640 --> 01:26:46.000
size mach ich jetzt größer, die Stack size mach ich jetzt größer, irgendwo hier, ne,

01:26:46.000 --> 01:26:57.800
Stack size, was ist das doppelte von 4096, 8182, 92, was ist das für eine Einrückung

01:26:57.800 --> 01:27:14.640
hier, what the hell, ok, mal gucken, ob es jetzt funktioniert, ist, ich glaube, ich glaube,

01:27:14.640 --> 01:27:22.160
wir haben irgendwie RAM vom Display überschrieben, grad aus versehen, guck mal, ist jetzt blau,

01:27:22.160 --> 01:27:26.600
ich glaub, wir haben irgendwie ausversehen grad im Speicher vom Display rumgeschrieben,

01:27:26.600 --> 01:27:33.880
ja, kann ja mal vorkommen, so ist das halt mit Low-Level-Zeugs, ne, oh, guck mal, jetzt

01:27:33.880 --> 01:27:41.040
geht es gar nicht mehr an, ah, doch, jetzt wieder richtig, haha, guck mal, jetzt funktioniert

01:27:41.040 --> 01:27:53.480
es, Stack size hochgemacht, jetzt funktioniert es, excellent, kannst du nicht 4096 mal, doch,

01:27:53.480 --> 01:27:59.640
kann ich, kann ich, es funktioniert, ah, der durfte nicht so viel RAM verwenden, jetzt

01:27:59.640 --> 01:28:07.120
ergibt das Sinn, kein Wunder, dass der abgeschissen ist an der Stelle, ah, yes, excellent, wunderbar,

01:28:07.120 --> 01:28:16.240
gut, also wissen wir schon mal, wir brauchen ein bisschen mehr RAM, wie viel RAM hat der,

01:28:16.240 --> 01:28:23.000
insgesamt 520K, davon kannst du allerdings so random access mäßig für dein Sketch,

01:28:23.000 --> 01:28:30.960
ganze plus maximal, sagen wir mal, so 260 Maximal glaub verwenden und ich kann jetzt

01:28:30.960 --> 01:28:38.000
hier, nachdem ich das Display andert, das Display braucht ungefähr 70KB, also ich hab

01:28:38.000 --> 01:28:43.680
jetzt noch 170K frei, also, da können wir dem, da können wir dem Task ruhig noch ein

01:28:43.680 --> 01:28:51.560
paar Kilobyte geben, guck mal hier, jetzt funktioniert es, jetzt klappt das ganze, ich

01:28:51.560 --> 01:28:59.720
hab natürlich ein Problem, wenn der Request länger als 512 ist, dann, egal, wir bleiben

01:28:59.720 --> 01:29:05.680
mal, wir bleiben mal bei den Basics, ja, ok, jetzt muss ich das hier rauslesen irgendwie,

01:29:05.680 --> 01:29:11.400
jetzt muss ich irgendwie das hier rauspasen, aus diesem, also, Authorization Basic, das

01:29:11.400 --> 01:29:27.160
da muss ich jetzt rauspasen, die Basics, genau, ok, also, ok, wir machen da mal einen Strink

01:29:27.160 --> 01:29:36.240
raus, damit kann man nämlich einfach mehr machen als mit so einem Charbuffer, ok, ok,

01:29:36.240 --> 01:29:41.840
wie kriegen wir, also wir müssen das hier jetzt rauspasen, das da, das müssen wir irgendwie

01:29:41.840 --> 01:29:49.480
rauspasen, also, ich hab da doch was, ich hab mir doch mal da, ich hab mir doch jede

01:29:49.480 --> 01:29:59.760
Menge Stringhelpers gebaut, weil die C++ Stringklasse so lowbrain ist und fast nix kann, zeig mal

01:29:59.760 --> 01:30:07.520
her, ist da nicht irgendwas dabei, String from Buffer, Read from File, String contains,

01:30:07.520 --> 01:30:16.280
na gut, das kann man auch so noch relativ einfach machen, starts with, ends, bringt uns starts

01:30:16.280 --> 01:30:24.720
with was, nee, to upper bringt uns auch nix, to lower bringt uns auch nix, String between,

01:30:24.720 --> 01:30:31.840
oh, was hab ich mir denn dabei gedacht, was macht das denn, ich hätte mir mal einen Hilfetext

01:30:31.840 --> 01:30:39.800
schreiben sollen, was macht das, ok, String start end, ah, ich weiß es wieder, ey, das

01:30:39.800 --> 01:30:46.320
ist richtig gut dafür, das funktioniert, das holt einen Substring, das extrahiert den

01:30:46.320 --> 01:30:53.360
ersten Substring, den er gefunden hat, zwischen start und ende, hast du einen Split, ja, einen

01:30:53.360 --> 01:31:01.280
Split hab ich auch gebaut, einen Split hab ich auch irgendwo gebaut, partition, Split,

01:31:01.280 --> 01:31:05.360
Split hab ich mir auch gebaut, wahrscheinlich die ineffizienteste Split Implementierung

01:31:05.360 --> 01:31:11.320
aller Zeiten, aber die funktioniert, muss man ja machen, weil C++, das C++ Gremium hat

01:31:11.320 --> 01:31:18.840
sich gedacht, ne Split Methode in unserer Stringklasse, nee, sowas, sowas, das kommt

01:31:18.840 --> 01:31:23.920
erst mal gar nicht ins Haus, ne, so ne, das wär ja, würd man mir hier mal was ordentliches

01:31:23.920 --> 01:31:29.000
einbauen, mit dem man auch arbeiten könnte, das wäre ja bloated, das geht nicht, ok,

01:31:29.000 --> 01:31:32.600
das bauen wir jetzt mal, also das Helper, mal gucken, ob mein eigenes gestricktes Zeug

01:31:32.600 --> 01:31:42.600
funktioniert, da bin ich jetzt mal gespannt, between, so, start, ok, also, start is Authorization

01:31:42.600 --> 01:31:49.800
Basics, inklusive Leerzeichen, wenn das jetzt funktioniert, dann gifte ich 5 Subs, ich glaub

01:31:49.800 --> 01:31:54.040
nämlich nicht, dass es funktioniert, ich glaub, ich bin da relativ safe, dass es nicht funktioniert,

01:31:54.040 --> 01:31:59.840
ok, also, ihr müsst das klippen, ne, ihr müsst ja nicht, ich erinnere mich auch so

01:31:59.840 --> 01:32:10.760
dran, ok, und am Ende, machen wir einfach, machen wir einfach Newline, ne, a character

01:32:10.760 --> 01:32:19.960
newline, weil das hier ist ja ein character newline, so, also wie gesagt, wenn das klappt,

01:32:19.960 --> 01:32:25.000
gifte ich 5 Subs, ich kann mir nämlich vom besten Bild nicht vorstellen, also, wenn das

01:32:25.000 --> 01:32:31.120
funktioniert, was ich mir hier, was ich hier mal irgendwann zusammengewurstet hab, dann

01:32:31.120 --> 01:32:37.080
sollte der jetzt den String rausholen, der zwischen Authorization, also das erste Vorkommen,

01:32:37.080 --> 01:32:43.800
ich müsste mal einen Hilfetext dafür schreiben, das erste Vorkommen zwischen Authorization

01:32:43.800 --> 01:32:58.680
Basic und Newline, also quasi, das da, ok, auto, auto, was ist denn das hier jetzt, Base

01:32:58.680 --> 01:33:09.280
64, ist das ja, das ist Base 64 String, so, so, also, geben wir uns das mal aus, also,

01:33:09.280 --> 01:33:15.040
wenn das jetzt funktioniert, dann passt da sich das hier raus, und ich bin mal noch nicht,

01:33:15.040 --> 01:33:22.560
ne, Newline ist Ctrl R, Ctrl N in der HTTP, ganz sicher, weil, ich mach das hier unten

01:33:22.560 --> 01:33:35.680
selbst, so, jetzt ist die Frage, gelten die 5 Subs schon, wenn er einfach nur das Richtige

01:33:35.680 --> 01:33:47.920
rauspasst, oder wenn ich es noch schaffe, das Base 64 zu decoden in Admin 123456, weil decoden

01:33:47.920 --> 01:33:53.400
ist einfach, für decoden hab ich mir auch mal was gebastelt, decode Base 64, das Problem

01:33:53.400 --> 01:33:59.000
ist nur, jetzt müssen wir uns drauf verlassen, dass das, was ich hier programmiert hab, funktioniert,

01:33:59.000 --> 01:34:03.040
also eigentlich sind ja die 5 Gift Subs schon sicher, weil wir wissen ja, dass wenn ich

01:34:03.040 --> 01:34:10.280
das programmiere, dann ist das eigentlich, da geht das eigentlich immer, also können

01:34:10.280 --> 01:34:18.880
wir uns eigentlich schon, also die 5 Subs sind so gut wie gegiftet schon, ok, Base 64,

01:34:18.880 --> 01:34:32.520
Auto, was weiß ich, Credentials, wir gehen schon die Namen aus, oh, das ist falsch, irgendwas

01:34:32.520 --> 01:34:50.040
ist falsch, Base 64 Decode, ah, Optional, ok, oh, da hab ich ja, WTF, was hab ich denn

01:34:50.040 --> 01:34:55.920
hier gemacht, warum ist das Optional, ja gut, weil es Null sein kann, weil es Null, das

01:34:55.920 --> 01:35:03.080
ist eigentlich gar nicht so blöd, was ich da gebastelt hab, Base 64, Has Value und wir

01:35:03.080 --> 01:35:13.720
decoden das nur, wenn es auch was zurück gibt, ja, die haben jetzt ein Optional Data Type,

01:35:13.720 --> 01:35:27.280
so, so und jetzt, wir geben das Fett in Rot aus, ob es funktioniert, Fett in Rot, wenn

01:35:27.280 --> 01:35:34.560
es funktioniert, steht jetzt, also wenn es funktioniert, dann, ok, wenn es funktioniert,

01:35:34.560 --> 01:35:44.360
dann steht jetzt ganz Fett in Rot da, Admin, 1, 2, 3, 4, 5, 6, so und dann ist es Return,

01:35:44.360 --> 01:35:58.400
Return, Return True oder so, ne, ne, ne, wir geben es einfach nur mal aus, ok, mal gucken,

01:35:58.400 --> 01:36:18.800
also Chat, das ging jetzt ein bisschen, hat er jetzt geuploadet, ach ne, was, was, was,

01:36:18.800 --> 01:36:46.600
was, was willst du von mir, ah hier, das geht nicht, äh, ok, ok, ok, ok, ok, ok, ok,

01:36:46.600 --> 01:36:56.220
eh, ok, wie, wie, ah ja, ich kann ja nichts ausgeben, was, eh, kein Wert drin hat, ok,

01:36:56.220 --> 01:37:02.560
klingt logisch, so, ok, ok, gucken, ob das geht, also da müsste jetzt gleich Fett in

01:37:02.560 --> 01:37:08.440
Rot stehen, Admin Doppelpunkt 1, 2, 3, 4, 5, 6, wenn er alles richtig aus, aus, äh,

01:37:08.440 --> 01:37:20.800
diesen kann oh chat meint ihr es geht? ich glaube nicht

01:37:20.800 --> 01:37:44.440
dass es geht safe ok

01:37:50.800 --> 01:38:02.760
ich bin überrascht ok also ich hätte nicht gedacht dass das zeug funktioniert was ich da

01:38:02.760 --> 01:38:15.960
gebastelt habe ja jetzt gibt es fünf subs jetzt gibt es fünf subs ok stufe 1 5 abos verschenken

01:38:15.960 --> 01:38:23.640
24 95 excellent aber wisst ihr was das gute ist wenn ich subs verschenke für 25 euro kriege ich

01:38:23.640 --> 01:38:40.640
12 euro 50 wieder also im prinzip überweise ich grad 12 euro 50 an twitch excellent im prinzip

01:38:40.640 --> 01:38:48.000
habe ich gerade twitch 12 euro 50 überwiesen so also wir hatten glück gehabt das butter toast

01:38:48.000 --> 01:39:03.000
rot king wall 137 zaroche.de x a pase capinus 89 excellent ok ich bin wirklich ich bin ich bin

01:39:03.000 --> 01:39:09.840
äußerst äußerst erstaunt dass das jetzt einfach so geklappt hat ganz ehrlich ich hätte damit hätte

01:39:09.840 --> 01:39:15.280
ich wirklich nicht gerechnet das heißt wir sagen jetzt hier return wenn die credentials gleich

01:39:15.280 --> 01:39:34.160
wo haben wir das gespeichert gleich user und pw ah moment falsche falsche sprache

01:39:34.160 --> 01:40:00.440
ähm ähm ähm moment user pw dann ist true ansonsten ist falls excellent

01:40:04.800 --> 01:40:09.200
alles klar so das würde jetzt ja auch bedeuten

01:40:09.200 --> 01:40:20.120
im prinzip nur 650 ausgegeben big brain nachgerechnet chat ist halt wieder heute

01:40:20.120 --> 01:40:30.080
absolut too smart für diese welt ja so das ok jetzt das müsste jetzt klappen also was

01:40:30.080 --> 01:40:35.200
haben wir denn was übergeben wir dann hier für admin 1 2 3 4 5 6 so das heißt das probieren

01:40:35.200 --> 01:40:40.760
jetzt mal aus also wenn ich jetzt mist übergebe also admin 1 2 3 4 6 dann kriege ich nur die

01:40:40.760 --> 01:40:47.120
fehlermeldung zurück dann kriege ich nur die fehlermeldung zurück ok gebe ich admin 1 2 3

01:40:47.120 --> 01:40:54.120
4 5 zurück müsste ich die webseite zurück bekommen bekomme ich aber nicht warum nicht

01:40:54.120 --> 01:41:03.720
weil ich auskommentiert habe excellent macht sehr schlau sehr schlau und ich habe noch was

01:41:03.720 --> 01:41:09.840
vergessen kontrol r kontrol n ich weiß nicht ob was noch mal machen muss also abbrechen

01:41:09.840 --> 01:41:19.000
liegt ja was ich schon alles geliegt habe in letzter zeit den finger den seitenschneider

01:41:19.000 --> 01:41:28.720
mein auge in der suppe habe ich mich gespiegelt da alles was da alles geliegt wurde wieder

01:41:28.720 --> 01:41:39.360
sich auszudenken die zahnbürste ja so viel so viel sachen geliegt ok so jetzt jetzt müsste

01:41:39.360 --> 01:41:46.720
ich aber die webseite zurückbekommen ha ha guck mal ich bekomme die webseite zurück und wenn

01:41:46.720 --> 01:41:52.280
ich mich falsch authentifiziere bekomme ich nur die fehlermeldung zurück genauso muss das sein

01:41:52.280 --> 01:41:59.400
gutes problem jetzt im browser aus so also admin ein moment wir authentifizieren uns mal falsch

01:41:59.400 --> 01:42:20.120
keck weh 1 2 3 4 5 6 beim geht nicht fehlermeldung fehlermeldung ok und jetzt admin 1 2 3 4 5 6

01:42:20.120 --> 01:42:32.960
geht der chat keckt schon wieder anstatt einfach mal abzuwarten ob es funktioniert keck weht

01:42:32.960 --> 01:42:49.400
chat braucht halt ein bisschen bis die verbindung steht ja da kannst du von so einer kleine kiste

01:42:49.400 --> 01:42:54.320
kannst du da nicht so viel erwarten gerade mit tls verbindung aber nachdem es einmal aufgebaut

01:42:54.320 --> 01:43:03.640
ist es halbwegs geschwind ja funktioniert der bsp ist langsam also bis zum kecken warten so

01:43:03.640 --> 01:43:11.640
sieht es aus hat er schrieben gerade geruckelt hat er streben ich habe es gesehen ist es war

01:43:11.640 --> 01:43:25.600
davon wieder am start job frames job frames ich habe es gesehen ja königung ist raus aber

01:43:25.600 --> 01:43:36.080
solange das so bleibt ist alles gut ok exzellent ich bin begeistert so den graben hier brauchen

01:43:36.080 --> 01:43:45.520
wir natürlich nicht das ist ja nur um zu testen ob das funktioniert es ist das ist cool also

01:43:45.520 --> 01:43:50.880
das ist sehr schick so jetzt heißt ich kann jetzt hier schon mal checken ob alternatifizierung

01:43:50.880 --> 01:43:56.680
geklappt hat alles klar wenn alternatifizierung nicht geklappt hat dann schicke ich dem schicke

01:43:56.680 --> 01:44:00.280
ich den nachricht bitte alternatifizieren also sprich wenn man kein alternatifikation

01:44:00.280 --> 01:44:05.960
header hat kriege ich schickt er den nachricht später alternifizieren und ansonsten liefer

01:44:05.960 --> 01:44:15.560
ich die seite aus jetzt also basic aus funktioniert exzellent jetzt kommt die etwas kompliziertere

01:44:15.560 --> 01:44:25.720
variante jetzt muss ich ja den eigentlichen request noch pasen also das da vielleicht

01:44:25.720 --> 01:44:33.600
sollte ich mir mal eine read eine read funktion machen so was also quasi quasi das hier aber

01:44:33.600 --> 01:44:47.080
halt ein bisschen schöner und so dass ich es wieder verwenden kann die kündigungsbestätigung

01:44:47.080 --> 01:44:58.240
ja ich glaube kündigung ist raus ist keine keine kündigung also zumindest aber arbeitsverhältnismäßig

01:44:58.240 --> 01:45:07.560
muss die kündigung schriftlich sein da kommst du nicht drum herum ok also weiter im text

01:45:07.560 --> 01:45:13.320
ich bin echt begeistert dass das basic also einfach funktioniert gut bei der gelegenheit

01:45:13.320 --> 01:45:17.280
können wir jetzt eigentlich auch gleich die webseite ausliefern lassen anstatt hier so

01:45:17.280 --> 01:45:25.120
ein schrott anstatt hier so ein schrott zurück zu liefern liefern wir mal die webseite zurück

01:45:25.120 --> 01:45:44.680
nämlich das ist die response read file und zwar index html als immer als string so und

01:45:44.680 --> 01:45:58.120
hier ist das html drin html und jetzt kann ich sagen hier html kann auch einfach so was

01:45:58.120 --> 01:46:11.960
hier machen html gleich response plus html ok das ergibt jetzt wenig sinn und plus dass

01:46:11.960 --> 01:46:24.520
ganze abgeschlossen ist am ende c können wir nämlich gleich die richtige webseite

01:46:24.520 --> 01:46:32.160
ausliefern und hier länge und jetzt kriege ich wieder meine lull omega lull seite wenn

01:46:32.160 --> 01:46:37.640
ich mich authentifiziert habe nicht gzip ne ist doch nicht gzip aber gzip das ist ne richtig

01:46:37.640 --> 01:46:42.800
gute idee das machen wir gleich noch mit dem gzip allerdings ist das dem webserver egal

01:46:42.800 --> 01:46:48.120
weil da muss ich einfach den header schreiben content encoding gzip glaube ich wenn ich

01:46:48.120 --> 01:46:55.520
hier content gzip encoding weiß ich was man da den header schreiben muss header content

01:46:55.520 --> 01:47:02.040
encoding content encoding gzip muss ich da reinschreiben kann man auch noch machen

01:47:02.040 --> 01:47:09.560
dann ist ein bisschen kleiner ok mal gucken ob ich jetzt meine lull webseite bekomme ha

01:47:09.560 --> 01:47:17.800
da ist er wieder frisch vom flash ausgelesen omega lull sehr schön sehr gut gefällt mir

01:47:17.800 --> 01:47:27.040
das es nimmt es nimmt gestalt an es nimmt gestalt an so wir machen jetzt mal irgend so

01:47:27.040 --> 01:47:36.400
ne read methode sowas hier read bytes das ist immer so schön nichts sagen read bytes

01:47:36.400 --> 01:47:43.640
so und dem müssen wir jetzt übergeben was brauchen der der braucht also der braucht

01:47:43.640 --> 01:47:48.560
erstmal sowas hier ne ne ne ne warte mal ne ich void der kriegt als was kriegt der als

01:47:48.560 --> 01:47:53.600
return optional oder sowas ne würde ich mal sagen irgendein optional was ist denn sinnvoll

01:47:53.600 --> 01:47:59.440
für read bytes als return ok das muss ich mir jetzt gerade mal überlegen weil die sache

01:47:59.440 --> 01:48:05.480
ist ja die ich muss ja ich muss ja an dieser stelle noch total viel sachen einlesen das

01:48:05.480 --> 01:48:10.200
heißt wenn ich jedes mal von hand diesen ganzen read kram machen muss ist doof weil

01:48:10.200 --> 01:48:14.400
ich muss erstens erstens muss ich den fall abfackeln wenn mal nicht die sache alles in

01:48:14.400 --> 01:48:23.920
ein buffer passt und ich muss den fall abfackeln wenn es einen fehler gibt deswegen machen

01:48:23.920 --> 01:48:38.960
wir sowas read bytes hier ssl und das können wir uns das können wir uns das copy pasten

01:48:38.960 --> 01:48:45.600
wir uns mal da nuf das können wir da oben auch gebrauchen read bytes also immer 512

01:48:45.600 --> 01:48:53.280
512 buffer ist ok ich mein das geht ja schnell in der schleife da brauchen wir auch nicht

01:48:53.280 --> 01:49:06.160
so ein großes deck size nicht so viel ram also das heißt wir machen jetzt mal sowas

01:49:06.160 --> 01:49:11.720
mal gucken ob das klappt was ich mir jetzt hier gerade vorstelle also wir lesen jetzt

01:49:11.720 --> 01:49:30.800
ein wir lesen jetzt ein bis ich glaube der sound ist der sound ist vorbei irgendwas anderes

01:49:30.800 --> 01:49:40.680
noch an ja exzellent so also wir lesen jetzt ein solange das hier ähm was machen wir größer

01:49:40.680 --> 01:49:59.520
null kleiner null oder sowas ist weil moment weil größer null oder weil da muss ich mal

01:49:59.520 --> 01:50:09.440
in das example von denen gucken wie die das hier machen äh wo haben wir denn hier das

01:50:09.440 --> 01:50:21.440
example server genau read read read woa warum ist das schon wieder so lang ok also was machen

01:50:21.440 --> 01:50:37.880
die hier read return value return wenn der ok wenn das kleiner null ist wenn das kleiner

01:50:37.880 --> 01:50:55.600
gleich null ist dann ist das ein fehler und ach nee und hier machen wir continue ok man

01:50:55.600 --> 01:51:07.560
muss die zwei sachen checken man muss die zwei sachen checken ich versuchte es mal irgendwie

01:51:07.560 --> 01:51:16.640
nachzubauen result gleich oje und wie kriegen wir das hier rein das muss man jetzt irgendwie

01:51:16.640 --> 01:51:25.640
klammern nochmal so und jetzt irgendwie kleiner gleich null oder so was ja das ist auch ein

01:51:25.640 --> 01:51:36.360
minuswert minuswert ok also result wenn result das ist dann continue verstehe wenn result

01:51:36.360 --> 01:51:40.560
das ist dann continue äh continue habe ich jetzt schon öfters gesehen dass leute damit

01:51:40.560 --> 01:51:45.280
nichts anfangen können also was man in der schleife machen kann ist ja also ich muss

01:51:45.280 --> 01:51:51.960
irgendwie irgendwann mal die schleife beenden so es gibt break break macht folgendes das

01:51:51.960 --> 01:51:57.760
geht einfach hier hin also break ist macht direkt an der stelle springt er aus der schleife

01:51:57.760 --> 01:52:04.000
raus auf die stelle nach der schleife continue ist genau das gegenteil continue bricht den

01:52:04.000 --> 01:52:08.320
aktuellen durchlauf ab also das hier wird nicht ausgeführt und der nächste durchlauf

01:52:08.320 --> 01:52:13.400
geht los also quasi continue bleibt in der schleife hört aber an der stelle wo continue

01:52:13.400 --> 01:52:18.520
steht auf und macht mit dem nächsten durchlauf weiter was ja auch sinnvoll ist solange ich

01:52:18.520 --> 01:52:22.840
noch sachen lesen muss und solange ich noch sachen schreiben muss mache ich das einfach

01:52:22.840 --> 01:52:30.840
warum übrigens read ergibt doch eigentlich überhaupt keinen sinn oder also was gibt

01:52:30.840 --> 01:52:40.880
das zurück ssl want read ssl want write ok alles klar dann weiß gar nicht ob das sinn

01:52:40.880 --> 01:52:51.800
sinnvoll ist ja an der stelle ssl äh ne doch ssl want read ok warum kann es want warum

01:52:51.800 --> 01:53:09.040
kann warum kann eine read funktion als fehlermeldung want write zurück liefern verstehe ich nicht

01:53:09.040 --> 01:53:13.520
aber ok ich muss das ich muss das ja auch nicht verstehen es ist nicht nicht erforderlich

01:53:13.520 --> 01:53:21.000
zu verstehen so ok read bytes if das das das dann mal continue das steht ja auch bei denen

01:53:21.000 --> 01:53:31.240
in dem in dem beispiel so wenn jetzt der rest kleiner null ist dann gibt es eine fehlermeldung

01:53:31.240 --> 01:53:41.960
das ist ok wir wissen ja dass die schleife nur läuft wenn es kleiner gleich null ist

01:53:41.960 --> 01:53:48.900
so und kleiner gleich null bedeutet wenn ich hier bin nachdem ich die zwei sachen gecheckt

01:53:48.900 --> 01:53:56.120
habe dass es auf jeden fall nen fehler ist es ist auf jeden fall nen fehler weil wenn

01:53:56.120 --> 01:54:04.800
ich größer null bin größer null dann habe ich was gültiges gelesen und alles ist gut

01:54:04.800 --> 01:54:10.680
wenn ich kleiner gleich null bin dann habe ich den fehler ok das heißt an der stelle

01:54:10.680 --> 01:54:23.160
kann ich quasi irgendwie irgendeine fehlermeldung ausgeben also error error irgendwie war immer

01:54:23.160 --> 01:54:36.320
ssl error und da kommt jetzt irgendwie result rein und error result und und die error error

01:54:36.320 --> 01:54:47.360
message excellent und dann return ich so was was was ist ein sinnvoller return type für

01:54:47.360 --> 01:54:52.080
dieses ding im prinzip der buffer so also den buffer an sich kann ich nicht return das

01:54:52.080 --> 01:55:00.480
ist keine allzu gute idee deswegen return wir einfach mal nen vector auf ansa was auf

01:55:00.480 --> 01:55:12.680
ansaint ansaint char alles klar warum gibt es eigentlich 30.000 verschiedene byte typen

01:55:12.680 --> 01:55:24.600
in c und c++ char ansaint char uint 8 und was auch was auch immer letztendlich letztendlich

01:55:24.600 --> 01:55:30.560
ist das doch alles das gleiche letztendlich sind das 8 bit und wie ich die interpretiere

01:55:30.560 --> 01:55:38.840
ist doch mein bier also standard vector geben wir da jetzt zurück so das heißt wenn man

01:55:38.840 --> 01:55:55.280
hier durch den haben wir was gelesen und in result steht was sinnvolles drin das könnte

01:55:55.280 --> 01:56:06.080
natürlich nicht funktionieren weil wenn er jetzt hier dann überschreibt er sich ja dann

01:56:06.080 --> 01:56:20.960
überschreibt er sich ja also ich brauche okay ich brauche hier sonst der überschreibt

01:56:20.960 --> 01:56:30.440
sich ja aber gut ich gehe ne moment ich muss doch jetzt nicht dass ich das jetzt irgendwie

01:56:30.440 --> 01:56:35.520
wenn der sagt ne moment minus ne ne ne ne minus dann habe ich nix gelesen dann habe

01:56:35.520 --> 01:56:40.520
ich nix gelesen alles klar ne passt passt passt so also das heißt ich mache jetzt sowas

01:56:40.520 --> 01:56:48.720
wie vector add ne moment wie kriege ich jetzt mit der big brain wie kriege ich jetzt diesen

01:56:48.720 --> 01:57:14.280
buffer in mein vector rein er pennt und dann mit länge oder so pennt ne push ne kann man

01:57:14.280 --> 01:57:41.640
irgendwie den reiten range pushen push buffer push attach to vector ok ok was insert insert

01:57:41.640 --> 01:58:11.600
he insert what äh ich bin ich hab keine ahnung wie

01:58:11.600 --> 01:58:17.240
kriege ich das jetzt da rein ok ich bin immer wieder begeistert wie schwierig so dinge

01:58:17.240 --> 01:58:26.520
z++ sind ähm also ich will wobei moment mal moment mal ich eigentlich ist es doch bescheu...

01:58:26.520 --> 01:58:36.480
könnte ich nicht sowas hier machen muss das nicht auch gehen und jetzt einfach anstatt

01:58:36.480 --> 01:58:55.960
buffer data size so und jetzt muss ich am ende doch noch sagen vector resize resize

01:58:55.960 --> 01:59:20.160
auf länge wow äh auf result länge ob das geht ok äh wir probieren es einfach mal aus

01:59:20.160 --> 01:59:26.760
ob das funktioniert ich hab so meine ich hab so meine zweifel dass das klappt ähm ok

01:59:26.760 --> 01:59:35.760
wunderbar data size ok also das heißt anstatt dieser anstatt dieser geschichte hier äh

01:59:35.760 --> 01:59:46.600
anstatt dieser geschichte lesen wir jetzt äh das hier oben ein read bytes ssl vector

01:59:46.600 --> 02:00:00.720
so am moment jetzt muss ich aus dem vector noch ein strill machen so warum gibt es da

02:00:00.720 --> 02:00:12.200
nicht sowas wie länge ok size excellent ob das jetzt ok oder bin ich ja mal sehr gespannt

02:00:12.200 --> 02:00:21.680
oh nee jetzt hab ich was verkehrt gemacht was hat er für schmerzen wo ist das problem

02:00:21.680 --> 02:00:36.920
was no return statement wo ist no return statement ach hier ok return weg

02:00:36.920 --> 02:00:46.000
pass auf dass du dir keinen das könnte schon sein wobei dürfte eigentlich nicht sein weil

02:00:46.000 --> 02:00:53.200
das ist alles hier lokal für den thread und und hier auch also theoretisch nicht aber sowas

02:00:53.200 --> 02:00:59.480
ist immer sowas fängt man sich immer schnell ein und merkt sein als später so ok das müsste

02:00:59.480 --> 02:01:12.880
einfach weiter funktionieren ok es scheint es scheint es scheint zu klappen hey ok ich

02:01:12.880 --> 02:01:18.200
habe das richtig gemacht es geht also 100% nicht verstanden habe ich es nicht aber es

02:01:18.200 --> 02:01:23.400
funktioniert da bin ich ja schon mal froh dass es einfach klappt auch wenn ich irgendwie

02:01:23.400 --> 02:01:33.320
ein bisschen hässlich finde so wir ach so einen moment wir müssen jetzt ja noch den

02:01:33.320 --> 02:01:43.440
wir müssen ja noch den fall händeln dass es nichts zum lesen gibt moment was passiert

02:01:43.440 --> 02:01:53.120
wenn es nichts zum lesen gibt dann return dann den leeren vector das will ich ja will

02:01:53.120 --> 02:01:57.920
ich das denn den leeren vector returned bin ich mir ehrlich gesagt gar nicht so sicher

02:01:57.920 --> 02:02:04.680
ob ich das will vielleicht sollte ich vielleicht sollte ich sowas machen da wird es jetzt zwar

02:02:04.680 --> 02:02:09.840
ein bisschen ein bisschen abartig zu lesen aber die schönere variante wäre doch tatsächlich

02:02:09.840 --> 02:02:20.520
sowas oder also dass man jetzt sagt ok entweder kriege ich den vector zurück da sind die

02:02:20.520 --> 02:02:27.080
bites drinnen oder alternativ kann ich einfach gucken ob der vector null ist ob der ob der

02:02:27.080 --> 02:02:33.120
leer ist das geht auch nee das ist besser das heißt ich muss jetzt hier checken read

02:02:33.120 --> 02:02:47.520
bites und dann if empty oder so empty warum wo ist das problem ich kann auch den vector

02:02:47.520 --> 02:02:58.880
zurück geben warum nicht das funktioniert das geht also man würde normalerweise hier

02:02:58.880 --> 02:03:03.160
annehmen dass der hier aus dem scope geht aber wenn ich den return ist ok das darf ich

02:03:03.160 --> 02:03:12.680
das ist das ist erlaubt da weiß ich dass das geht das ist erlaubt der kopiert den dann

02:03:12.680 --> 02:03:19.640
also unter der haube kopiert er den also ich glaube der kopiert den der hat hier der hat

02:03:19.640 --> 02:03:27.280
hier quasi stack auf dem auf dem auf diesem function auf dem stack von dieser function

02:03:27.280 --> 02:03:34.480
hat der hat der den vector und beim return kopiert er den vector da rein und gibt mir

02:03:34.480 --> 02:03:39.760
den zurück also sprich ich kopiere den vector einmal also wenn ich das richtig verstehe

02:03:39.760 --> 02:03:46.440
was da unter der haube passiert kopiert er den vector einmal allerdings ganz ehrlich kann

02:03:46.440 --> 02:03:52.960
ich mit leben ja wenn er das für wenn er da 512 mal 512 bites kopiert ich glaube nicht

02:03:52.960 --> 02:04:00.200
dass das mich jetzt performance mäßig zerstört ok wenn er wenn er nicht leer ist dann mache

02:04:00.200 --> 02:04:12.360
ich den rest so alles klar so ok das ergibt jetzt schon ein bisschen mehr sinn read bites

02:04:12.360 --> 02:04:17.560
wenn ich bites gelesen wird vorbei wir nennen es nicht weg wenn es bites das gelesen habe

02:04:17.560 --> 02:04:34.520
ja gehen wir aus da unten was also ist er gut 10 plus plus alles klar so gut jetzt aber

02:04:34.520 --> 02:04:41.120
basic aus wunderbar und wir haben omega null von franker faces set kopiert das ist das

02:04:41.120 --> 02:04:49.360
allerwichtigste gut so jetzt lass mal in mich gehen wir haben jetzt ja noch gar nichts großartiges

02:04:49.360 --> 02:04:53.120
gemacht außer basic aus basic aus natürlich wichtig weil wenn man firmware updates macht

02:04:53.120 --> 02:04:58.200
wenn wir ja das firmware updates nur nicht von jedem depp gemacht werden dürfen free

02:04:58.200 --> 02:05:04.200
hunter x twitch prime dankeschön exzellent subscription der chat iq platzt ja heute schon

02:05:04.200 --> 02:05:11.600
fast aber mittags subscription ja noch viel mehr dankeschön also wissen dass es funktioniert

02:05:11.600 --> 02:05:18.680
so jetzt muss ich den eigentlichen request parsen read binds das kann ich jetzt nämlich

02:05:18.680 --> 02:05:29.160
gleich weiter verwenden das ist das ist sehr gut ist um nicht zu sagen exzellent basic

02:05:29.160 --> 02:05:36.400
off funktioniert so jetzt sind wir wieder hier also der hannes kann es stufe 1 abonnement

02:05:36.400 --> 02:05:50.480
huge sup big brain sup dankeschön ok jetzt ok das heißt ich mach das hier mal weg weil

02:05:50.480 --> 02:05:54.600
jetzt kommt der eigentliche knackpunkt jetzt muss ich da auch guck mal da streicht es

02:05:54.600 --> 02:06:01.280
jetzt doppel durch das ist nicht einfach nur aus kommentiert es ist quasi gelöscht so

02:06:01.280 --> 02:06:06.880
jetzt muss ich den htp request parsen das heißt ich muss mir jetzt diesen diesen schmodder

02:06:06.880 --> 02:06:16.880
hier rausholen get slash und anhand dessen den den fad irgendwie raus bekommen der den

02:06:16.880 --> 02:06:24.280
ich da ausgelesen habe das heißt wir lesen jetzt erstmal also wir machen jetzt folgendes

02:06:24.280 --> 02:06:30.680
wir checken jetzt if post wir checken if get das ist das einzige was wir unterstützen was

02:06:30.680 --> 02:06:46.320
haben wir sonst noch htp mäßig post get put post get put patch delete post get put patch

02:06:46.320 --> 02:06:56.240
delete habe ich was vergessen es gibt ja noch die die web darf dinger hett hett gab es noch

02:06:56.240 --> 02:07:06.880
oder nee doch nicht get post aber gut das unterstütze ich nicht also ich unterstütze

02:07:06.880 --> 02:07:20.800
nur post und get x fanatics drei monate ajaja aber massive ajaja huge sup also ich unterstütze

02:07:20.800 --> 02:07:25.520
nur if nur post und get das reicht wie gesagt ich will ja eh nicht dass das andere verwenden

02:07:25.520 --> 02:07:29.560
sondern einfach dass ich dass ich den kram verwenden kann so das heißt wir müssen jetzt

02:07:29.560 --> 02:07:41.480
gucken ob es in post request ist das heißt wir gucken jetzt ob das was ich hier eingelesen

02:07:41.480 --> 02:08:01.320
habe wo lese ich denn hier auf was ein ja ach nee das ist fail was ich hier mache das

02:08:01.320 --> 02:08:06.840
kreuz das ist doof wie mache ich das jetzt ich muss das hier einlesen ich muss das hier

02:08:06.840 --> 02:08:24.880
einlesen beides muss hier den request einlesen und dem muss ich die muss ich das das irgendwie

02:08:24.880 --> 02:08:48.520
übergeben das ok request da kann ich das hier nämlich rausschmeißen und if empty kann

02:08:48.520 --> 02:08:59.600
ich auch rausschmeißen und jetzt check ich nur noch das kann ich auch rausschmeißen

02:08:59.600 --> 02:09:09.640
und jetzt check ich nur noch ob der request passt ok gut ach nee das umwandel ins string

02:09:09.640 --> 02:09:22.440
muss ich jetzt ja hier machen ok request so ok alles klar so weil ich brauche den text

02:09:22.440 --> 02:09:25.920
da hier unten aktuell kann ich den kann ich ja auf den auf diesen text den ich hier nur

02:09:25.920 --> 02:09:33.960
hier drin zugreifen aber hier brauche ich den jetzt so also request contains includes

02:09:33.960 --> 02:09:42.840
ach so scheiße ah moment ich nehme einfach das was ich schon mal gebaut habe string starts

02:09:42.840 --> 02:09:49.560
with excellent tja hätten die mal ein bisschen mehr in ihre c++ standard string klasse eingebaut

02:09:49.560 --> 02:09:53.480
da müsste man nicht so viel selbst tricken und wisst ihr was noch cooler wäre hätten

02:09:53.480 --> 02:09:57.080
die schon sowas wie extension methods dann könnte ich das einfach extenden ohne hier

02:09:57.080 --> 02:10:10.800
zig helper gedöns basteln zu müssen also startet der mit einem get startet der mit

02:10:10.800 --> 02:10:18.560
einem get dann ist es ein get request und startet der mit irgendwas anderem eigentlich

02:10:18.560 --> 02:10:22.640
muss ich das jetzt gar nicht weil doch wir sind mal wir sind mal so nett wir überprüfen

02:10:22.640 --> 02:10:31.080
das noch mal und startet der mit einem post dann ist es logischerweise nen post request

02:10:31.080 --> 02:10:43.560
ok soweit so gut was hat er jetzt für schmerzen ah da fehlt ein klammer lull so und jetzt

02:10:43.560 --> 02:10:48.320
ok jetzt muss jetzt muss ich den den das hier muss ich jetzt rauskriegen das übrigens

02:10:48.320 --> 02:10:55.400
blöd was ich blödsinnig was ich hier mache starts with so muss ich checken weil ich will

02:10:55.400 --> 02:10:59.160
er den fahrt ich will mir den fahrt rausholen und wie es hier hinter weiter geht weiß ich

02:10:59.160 --> 02:11:03.320
nicht weil es könnte ja potenziell auch sowas sein es könnte nicht get slash es könnte

02:11:03.320 --> 02:11:13.200
auch get get slash index html get slash logs get post slash update oder sowas sein so das

02:11:13.200 --> 02:11:20.600
heißt ich muss mir jetzt an der stelle das irgendwie raus rausholen was es für eine

02:11:20.600 --> 02:11:27.480
was es für ein fahrt ist oder wir sagen korrekt der wort uri wie heißt wie heißt die portion

02:11:27.480 --> 02:11:34.240
hier hinten das hier vorne ist da das ist die domain das hier zusammen ist die uri wie

02:11:34.240 --> 02:11:41.360
heißt diese portion hier hinten dran also das was hinter dem slash kommt das ist das

02:11:41.360 --> 02:11:46.720
ist ein uri ich nenne es mal fahrt ja pass habe ich glaube aber ich glaube das heißt

02:11:46.720 --> 02:11:57.000
irgendwie anders top es ist nicht uniform es wird in der besteht aus zeichnungen so

02:11:57.000 --> 02:12:04.160
wo steht beispiel example guck mal hier sieht man das tatsächlich das ist der fahrt ich

02:12:04.160 --> 02:12:09.000
habe sogar richtig benannt ok das ist der fahrt doch tatsächlich das hier ist die domain

02:12:09.000 --> 02:12:15.200
das ist was für einen protokoll port und das ist der fahrt und das ist das query alles

02:12:15.200 --> 02:12:19.960
klar da haben wir sogar richtig benannt ohne ohne es zu wissen ich habe nämlich keine ahnung

02:12:19.960 --> 02:12:24.200
gehabt dass das wirklich so heißt ok pass so das müssen wir jetzt irgendwie aus diesem

02:12:24.200 --> 02:12:30.280
request rauskriegen also das da das kann ja potenziell alles sein normalerweise wisst

02:12:30.280 --> 02:12:36.920
ihr was ich jetzt normalerweise machen würde reg x match sonst was aber ich bin mir nicht

02:12:36.920 --> 02:12:41.880
so sicher ob das eine gute idee ist und ob das ding überhaupt eine reg x library dabei

02:12:41.880 --> 02:12:50.920
hat vielleicht machen wir es mal ohne reg x weiß ich ob reg x reg x auf msp 32 ob das

02:12:50.920 --> 02:13:00.880
so eine gute idee ist und dazu kommt ich glaube ich habe noch nie reg x in c++ verwendet wir

02:13:00.880 --> 02:13:06.720
machen das anders also wie kriegen wir das raus wir wollen nur das hier nur diesen fahrt

02:13:06.720 --> 02:13:20.640
wollen wir haben ich glaube ich glaube wir können das wieder damit machen big brain

02:13:20.640 --> 02:13:29.400
methode kopf wenn wir können sagen der fahrt ist quasi zwischen das erste was er findet

02:13:29.400 --> 02:13:36.960
zwischen get das das war eine gute idee da ich das mal gebastelt habe ich habe das ja

02:13:36.960 --> 02:13:40.160
schon ein paar mal gebraucht so was in der richtung aber hierfür für für so header

02:13:40.160 --> 02:13:52.560
gedönst ist das tatsächlich ganz praktisch zwischen get und hat ttp so also sprich zwischen

02:13:52.560 --> 02:13:58.760
get und hat ttp ist ja dann nur noch das hier wir machen sogar leerzeichen hat ttp das heißt

02:13:58.760 --> 02:14:03.160
er nimmt wirklich nur das hier raus so da müssen wir jetzt mal ausprobieren wenn ich jetzt

02:14:03.160 --> 02:14:12.320
was anderes aufrufe sagen wir mal slash logs dann macht er nämlich slags get auf slash

02:14:12.320 --> 02:14:23.680
logs so jetzt schauen wir mal ob das funktioniert der müsste jetzt an der stelle sich nur slash

02:14:23.680 --> 02:14:40.720
logs wo ist jetzt das problem wieder ich liebe diese fehlermeldung ach so weil es optional

02:14:40.720 --> 02:14:45.520
ist ich liebe diese fehlermeldung ok es ist ja optional es kann ja sein dass es nicht

02:14:45.520 --> 02:14:51.400
passt wisst ihr was im zweifelsfall schmieren wir ab wenn er nichts findet aber ich will

02:14:51.400 --> 02:15:02.680
jetzt nicht auf null checken weil das auf null checken eigentlich ziemlich ziemlich

02:15:02.680 --> 02:15:13.800
easy ist an der stelle nämlich einfach so gucken es wäre eigentlich alles was wir machen

02:15:13.800 --> 02:15:25.520
müssen so also jetzt würde ich erwarten dass ich slash logs raus bekomme ah yes komm mal

02:15:25.520 --> 02:15:31.120
hier funktioniert funktioniert slash logs das heißt jetzt kann ich das gleiche mit

02:15:31.120 --> 02:15:43.600
post noch machen aber das gleiche mit post post und das dazwischen ist der fad tatsächlich

02:15:43.600 --> 02:15:50.440
so gut das heißt wir haben jetzt die url vom post request vom get request das heißt wir

02:15:50.440 --> 02:15:58.600
können jetzt sowas hier einbauen so void handle get oder so und der kriegt jetzt übergeben

02:15:58.600 --> 02:16:08.800
das da und den fad und dann machen wir dann irgendwann mal weiter aber wir bauen jetzt

02:16:08.800 --> 02:16:13.800
erst mal den post request ein weil der post request ist ein bisschen komplizierter im

02:16:13.800 --> 02:16:19.840
post request muss ich mir die content length noch rausholen ich zeige euch gleich mal

02:16:19.840 --> 02:16:27.200
hier post post request example jetzt nehme ich ein bisschen komplizierter den get request

02:16:27.200 --> 02:16:32.440
ist einfach nur das hier so was anderes ist an einem get request nicht wirklich interessant

02:16:32.440 --> 02:16:41.480
erst mal so allerdings bei einem post request ist das hier noch ganz entscheidend content

02:16:41.480 --> 02:16:46.160
length weil wenn ich ein update hochladen will muss ich ja wissen wie groß das update

02:16:46.160 --> 02:16:52.880
ist bevor ich anfange zu schreiben das heißt ich brauche ein handle get ich brauche ein

02:16:52.880 --> 02:17:08.600
handle post und der kriegt noch länge dabei und wie kriegen wir den header raus wie kriegen

02:17:08.600 --> 02:17:22.880
wir den header raus für den post request also sowas wie länge länge ist das können wir

02:17:22.880 --> 02:17:26.280
wieder genauso machen ich zeige euch mal wie ein post request aussehen würde wenn wir

02:17:26.280 --> 02:17:38.640
x x post so und da steht dann sowas drinne wie ach so moment ich musste auch irgendwas

02:17:38.640 --> 02:17:46.840
uploaden mit sonst funktioniert das ganze ja nicht sieht man ja nix x post mal den ganzen

02:17:46.840 --> 02:18:00.240
ganzen shit hier hinten weg machen binary post 5 4 3 3 so jetzt können wir uns mal gucken

02:18:00.240 --> 02:18:13.000
wie ein post request aussieht content length 0 excellent warum ach so weil ich im falschen

02:18:13.000 --> 02:18:24.680
ordner bin alles klar unauthorized guck mal es funktioniert was ich gebastelt habe unauthorized

02:18:24.680 --> 02:18:31.320
ich muss erstmal passwort eingeben oder funktioniert ich bin ich bin ja immer begeistert wenn sachen

02:18:31.320 --> 02:18:45.440
funktionieren ha guckt content length ist ungefähr was ist in megabyte oder so so das

02:18:45.440 --> 02:18:50.680
heißt das muss ich mir jetzt erstmal rausholen content length also sprich wir machen einfach

02:18:50.680 --> 02:18:56.080
genau das gleiche wie hier oben das ist echt big brain funktion hätte ich nie gedacht

02:18:56.080 --> 02:19:05.720
dass die man nützlich wird also länge länge ist wo das natürlich voll fällt wenn wenn

02:19:05.720 --> 02:19:10.240
es header doppelt gibt ne allerdings sollten hätte nicht doppelt sein aber wenn es header

02:19:10.240 --> 02:19:17.440
doppelt gibt kack das ab was aber nicht schlimm ist das muss nicht robust sein bis ins letzte

02:19:17.440 --> 02:19:27.240
das muss für meine zwecke funktionieren also zwischen content length und und und und und

02:19:27.240 --> 02:19:40.240
zeilen ende zwischen content length und zeilen und das müsste die länge sein wie kriegt

02:19:40.240 --> 02:19:52.520
man das jetzt in int umgewandelt wie wie macht man c++ string to int ok was gibt es

02:19:52.520 --> 02:20:10.920
denn da stoi stoi was ist der unterschied zwischen stoi und attoi ah guck mal sehr

02:20:10.920 --> 02:20:31.160
overflow beste stoi ist a horrible function alles klar horrible also monka shake function

02:20:31.160 --> 02:20:57.940
gut dann nehmen wir standard stoi also stoi länge ok das funktioniert nicht warum funktioniert

02:20:57.940 --> 02:21:20.920
das nicht war ich was war ich falsch a value x klappt also jetzt krieg ich fahrt und die

02:21:20.920 --> 02:21:30.400
länge raus ok mal gucken ob das funktioniert das müssen wir jetzt mal gucken ob das jetzt

02:21:30.400 --> 02:21:44.760
geht monka giga omg 2 sagt das als schlecht zu bezeichnen ist fragwürdig bloß weil das

02:21:44.760 --> 02:21:51.920
altes c herra endling das ist der kaufa flow die müssen recht haben der kaufa hat immer

02:21:51.920 --> 02:22:02.560
recht vor allem schon skit schon skit hat instant recht immer so ja das hat das hat

02:22:02.560 --> 02:22:09.760
funktioniert slash ist der fahrt und die länge ist die länge ist ungefähr ein mb die firmware

02:22:09.760 --> 02:22:22.320
na guck mal mal wie groß ist die firmware erst ne bild netz firmware ne nicht bootloader

02:22:22.320 --> 02:22:30.400
firmware bin 1,1 mb das ist ziemlich das ist ziemlich genau also das das das auch auch

02:22:30.400 --> 02:22:37.640
richtig ja aber mo ist das schon recht also der kaufa flow ist da auch nicht immer unfehlbar

02:22:37.640 --> 02:22:41.680
das problem ist nur dass man sich oftmals davon auch so so leiten lässt also liest

02:22:41.680 --> 02:22:48.080
ans deck auf afro und das erste was du liest ist ist trash oder sags ist trash easy da

02:22:48.080 --> 02:23:00.040
next dabei ist es vielleicht gar nicht so trash ok das heißt wir können jetzt hier

02:23:00.040 --> 02:23:07.760
sowas machen händel post dann brauchen wir ssl wir brauchen den fahrt und wir brauchen

02:23:07.760 --> 02:23:21.280
die länge ich habe in den klammer zu viel jaja value ist gut jetzt habe ich mit der

02:23:21.280 --> 02:23:27.880
klammer zu wenig also jetzt dachte mal dieses addon für diese rainbow rainbow klammern

02:23:27.880 --> 02:23:34.800
ist doch wirklich praktisch seht ihr jetzt ich sehe hier vorne ist gelb aber hier hinten

02:23:34.800 --> 02:23:37.920
habe ich keine gelbe klammer jetzt mache ich so noch ein bisschen gelbe klammer hab und

02:23:37.920 --> 02:23:58.680
dann ist zu das ist echt ein poggers extension gibt es nix so händel post ja elevenko aber

02:23:58.680 --> 02:24:14.680
ist das händel post ich lese jetzt einfach mal das firmen update plinth ein ich lese

02:24:14.680 --> 02:24:21.480
jetzt ich lese jetzt einfach mal das firmen update da irgendwie plinth ein so also sagen

02:24:21.480 --> 02:24:38.880
wir wire read bytes was brauchen wir ssl context ok weil read bytes not empty ach nee moment

02:24:38.880 --> 02:24:54.280
ich brauche die bytes ja äh wie machen wir das jetzt am besten wir sagen einfach wire

02:24:54.280 --> 02:25:12.520
ja oops auto bytes read bytes ssl so und sobald wir sehen es war einfach ganz hart true

02:25:12.520 --> 02:25:26.560
bamm endlosschleife so sobald bytes empty ist a break so ich glaube das ist ganz ok

02:25:26.560 --> 02:25:33.840
also sprich der liest jetzt so lange ein bis es nichts mehr zu lesen gibt und dann geht

02:25:33.840 --> 02:25:44.640
er raus das klingt doch eigentlich ganz sinnvoll so und jetzt lesen jetzt gucken wir mal jetzt

02:25:44.640 --> 02:25:51.120
lesen wir mal ein wie viel wie viel er einliest also int count wir zählen jetzt mal die bytes

02:25:51.120 --> 02:25:55.200
ob das stimmt was der liest und was da also wir geben jetzt mal die content wir geben

02:25:55.200 --> 02:25:59.840
jetzt mal die content lengths aus also von der idee her müsste jetzt so sein der sendet

02:25:59.840 --> 02:26:05.000
hier eine content length mit und zwar irgendwie ein bisschen knapp 1,1 mb und am ende müsste

02:26:05.000 --> 02:26:11.960
ich exakt so viele bytes eingelesen haben wie ich content lengths habe ansonsten fehlt

02:26:11.960 --> 02:26:23.520
was oder es ist mehr was sehr merkwürdig wäre wenn es mehr ist also gucken wir mal

02:26:23.520 --> 02:26:37.160
bytes bytes length size also count plus gleich bytes size so und jetzt gehen wir mal aus

02:26:37.160 --> 02:27:00.160
content length oder content is length und current is count so da sollte mir jetzt ausgeben

02:27:00.160 --> 02:27:05.320
jetzt für schmerzen überhaupt geht doch da sollte mir jetzt ausgeben wie viel in content

02:27:05.320 --> 02:27:11.600
lengths steht und wie viel davon wir schon eingelesen haben und am ende sollte es immer

02:27:11.600 --> 02:27:23.760
gleich sein so und das break ist empty das passt davor ok mal gucken ob das klappt ich

02:27:23.760 --> 02:27:30.840
lese jetzt einfach das firmware update ein ohne das firmware update zu schreiben konvertiert

02:27:30.840 --> 02:27:39.600
der dateityp auto einfach in den sinnvollsten dateityp ne auto guckt was hinterm return steht

02:27:39.600 --> 02:27:47.200
und trägt das ein also sprich wenn du wenn du sagst wenn du einmal sagst return eins

02:27:47.200 --> 02:27:51.560
und sagst dann später noch mal return string dann sagt er geht nicht du kannst nicht zwei

02:27:51.560 --> 02:27:59.280
unterschiedliche typen return achso ja und hier ist es auch so also sprich der weiß ja

02:27:59.280 --> 02:28:04.800
dass das hier den standard vector uint 8t returned das ist das gleiche wie war in zip

02:28:04.800 --> 02:28:10.120
in c sharp nur leider in den tools nicht so gut weil manchmal einfach typ auto da steht

02:28:10.120 --> 02:28:16.600
obwohl obwohl er es weiß ok also mal gucken der sollte jetzt ein der sollte jetzt einlesen

02:28:16.600 --> 02:28:44.680
postchamp postchamp postchamp der müsste dann aufhören einzulesen bei 1,1 mb ok auf

02:28:44.680 --> 02:29:09.000
das byte genau guckt mal hier auf das byte genau auf das byte genau ok operation timed

02:29:09.000 --> 02:29:22.680
auto ich muss die connection noch schließen ich ich habe irgendwo kein break drinne zeile

02:29:22.680 --> 02:29:38.560
43 wenn aber endlosschleife ok das ist dumm return erst mal schön endlosschleife fabriziert

02:29:38.560 --> 02:29:43.840
das wird hier wieder getrieben wir basteln am webserver auf dem esp 32 weiter und du

02:29:43.840 --> 02:29:46.800
wirst ich weiß nicht ob du im letzten stream dabei war ich glaube nämlich nicht du wirst

02:29:46.800 --> 02:29:52.620
nicht glauben wir haben es schon geschafft basic ors einzubauen und wir können get und

02:29:52.620 --> 02:29:58.440
post request handeln also das wichtigste ist sogar schon drinne und das ganze natürlich

02:29:58.440 --> 02:30:08.400
über tls postchamp so jetzt machen wir das gleiche nochmal und gucken ob es jetzt nicht

02:30:08.400 --> 02:30:19.400
hängen bleibt so upload post request wisst ihr was ich bin geneigt hier mal ein bisschen

02:30:19.400 --> 02:30:28.040
mehr als 512 zu probieren richtige big brain aktion wieder ja 6 hat schon fast übrigens

02:30:28.040 --> 02:30:36.160
leute chat chat ich muss ich muss euch mal ich muss euch mal loben und zwar 150 leute

02:30:36.160 --> 02:30:44.400
im durchschnitt hier am start bei doch recht nischen thema also man sieht hier eindeutig

02:30:44.400 --> 02:30:51.880
bester chat auf twitch operation timeout mal gucken ob er jetzt wieder abkackt moment

02:30:51.880 --> 02:31:03.760
warum warum hat er eine endlos schleife da jetzt das verstehe ich nicht 43 ich return

02:31:03.760 --> 02:31:29.680
doch ich return doch wo ist das problem moment das hier funktioniert nicht das ist nie empty

02:31:29.680 --> 02:31:46.160
das ist nie empty warum nicht das müsste aber empty sein if empty break hä warum ist das

02:31:46.160 --> 02:31:57.960
ach kann das sein dass der ist nicht empty weil der 512 elemente am start hat und deswegen

02:31:57.960 --> 02:32:03.000
512 nullen enthält kann das sein der ist nie empty kann das sein wenn ich den vector so

02:32:03.000 --> 02:32:14.560
initiiert dass er nicht aha ja dann funktioniert das so nicht wie ich mir das gedacht habe

02:32:14.560 --> 02:32:28.960
ich meine ich könnte den vector hier re seisen wieder auf null ist er jetzt empty ist er jetzt

02:32:28.960 --> 02:32:36.560
empty ich habe hunger leute wie lang bin ich hier schon am start progas zweieinhalb stunden

02:32:36.560 --> 02:32:44.980
und heute morgen zweieinhalb stunden ob ist ist er empty wenn man den jetzt auf null wer

02:32:44.980 --> 02:32:47.680
wir gleich sehen wer wir gleich sehen achja moment abbrechen abbrechen abbrechen wir machen

02:32:47.680 --> 02:32:52.720
noch eine sache ich lasse mich mal dazu hin reißen den buffer ein wenig zu vergrößern

02:32:52.720 --> 02:33:00.240
und ich hoffe es kackt nicht gleich ab das rösti gegessen excellent mit was dabei rösti

02:33:00.240 --> 02:33:06.640
ist glaube ich so fast schon schweizer national essen oder hast du eigentlich vor das projekt

02:33:06.640 --> 02:33:10.560
im anschluss zu veröffentlichen ich kann es auf github laden aber ich habe nicht vor

02:33:10.560 --> 02:33:15.440
da irgendwie eine großartige reusable library rauszumachen also ich werde das so machen

02:33:15.440 --> 02:33:19.880
ich werde das immer erweitern so wie ich es halt bei mir brauche weil wenn ich da irgendwie

02:33:19.880 --> 02:33:24.360
eine library draus machen würde dann müsste ich ja gucken dass man auch den den server

02:33:24.360 --> 02:33:29.000
ordentlich ordentlich ansprechen kann ohne dass man die internen sachen ändern muss ich

02:33:29.000 --> 02:33:34.640
will eigentlich bloß irgendwie so keine mini webserver basteln der statisches html vom

02:33:34.640 --> 02:33:39.160
flash aus liefern kann logs aus liefern kann und ein firmware update machen kann aber was

02:33:39.160 --> 02:33:42.600
man natürlich machen kann ist ich kann den kran auf github hochladen und jeder kann sich

02:33:42.600 --> 02:33:47.880
das kopieren und seine eigenen sachen hinzufügen die er braucht oder einfach nur abgucken ja

02:33:47.880 --> 02:34:02.840
das können wir machen ok so mal schauen ob es jetzt funktioniert

02:34:02.840 --> 02:34:07.120
ist er jetzt schneller oder ist eine ganze ecke schneller leute der ist dreimal so schnell

02:34:07.120 --> 02:34:14.120
wie vorher mit dem größeren buffer der ist viel schneller habt das gesehen dass der größere

02:34:14.120 --> 02:34:25.480
buffer macht richtig was aus ja guck mal keine endlosschleife mehr excellent keine endlosschleife

02:34:25.480 --> 02:34:29.680
mehr und es bricht ab sehr gut was wir jetzt noch machen müssen ist weil normalerweise

02:34:29.680 --> 02:34:36.800
reboot man ja nach einem firmware update wir simulieren das ganze mal esp restart also

02:34:36.800 --> 02:34:43.320
das hier ist quasi fake firmware update funktion gerade wir machen den restart das problem

02:34:43.320 --> 02:34:48.000
ist wenn man ein restart machen da muss ich dem zeit geben die verbindung zu klausen wenn

02:34:48.000 --> 02:34:51.920
ich nämlich ich kann sie nämlich mal zeigen was passiert wenn ich einfach restart wenn

02:34:51.920 --> 02:34:57.920
ich einfach restart dann bleibt die verbindung hier hängen das ist unschön muss jetzt mal

02:34:57.920 --> 02:35:13.480
abgucken wie ich die verbindung klaus klaus klaus ich habe es gesehen rückwärts ja habe

02:35:13.480 --> 02:35:18.240
ich das nicht schon alles habe ich sogar schon drinne stehen ausgezeichnet wenn ich so excellent

02:35:18.240 --> 02:35:26.160
ist das hier ist alles excellent wenn es funktioniert das ist so schlimm ich habe mir das wort mittlerweile

02:35:26.160 --> 02:35:30.400
angewöhnt ich sage das auch auf der arbeit wenn irgendwas ist aber es ist also das ist

02:35:30.400 --> 02:35:33.560
das ist ja noch ein normales wort das fällt nicht so sehr auf dass ich sie nicht mehr

02:35:33.560 --> 02:35:39.440
alle habe wenn ich dann irgendwelche anderen gaming sachen von mir gebe dann fällt das

02:35:39.440 --> 02:35:45.400
mehr auf allerdings mittlerweile muss ich sagen finde ich das auch nicht mal schlimm aber

02:35:45.400 --> 02:35:52.320
wenn man sagt excellent oder gar exquisite dann ist das dann denken die leute auch jetzt

02:35:52.320 --> 02:36:03.000
spinnt da wieder rum wenn ich zum beispiel keck weh sage ja das wenn ich keck weh sage

02:36:03.000 --> 02:36:08.800
verwirrt das die leute das stimmt so schauen wir mal jetzt müsste hängen bleiben jetzt

02:36:08.800 --> 02:36:18.960
müsste rebooten und hängen bleiben jetzt flutscht aber wird hier geupdatet also wir

02:36:18.960 --> 02:36:25.320
schreiben ja gar nichts auf flasch guck jetzt bleibt er hängen und das warum hat er nicht

02:36:25.320 --> 02:36:37.520
restarted achso ja genau der restarted und kann die verbindung nicht closen das heißt

02:36:37.520 --> 02:36:44.800
ich muss jetzt hier eine sache machen und zwar kann ich immer versagen delay delay für

02:36:44.800 --> 02:36:53.520
eine sekunde und dann klaus ups jetzt fahrt geste weg und dann klaus ssl und dann restarten

02:36:53.520 --> 02:37:19.640
klaus ich diese hackers hacker mans heute sind wir sind wir heute wieder so und jetzt

02:37:19.640 --> 02:37:27.080
sollte der eigentlich die verbindung ach nee moment fail falsche rum falsche rum erst

02:37:27.080 --> 02:37:34.840
mal klausen und dann warten und es kann ja nicht funktionieren sonst warte eine sekunde

02:37:34.840 --> 02:37:49.600
und klaus danach und restart direkt das kann er nicht kann er nicht klappen so jetzt laden

02:37:49.600 --> 02:37:53.480
wir es nochmal hoch und jetzt sollte er klausen eine sekunde warten und restarten nach dem

02:37:53.480 --> 02:37:59.160
firm nach dem fake firmware update also wir schreiben also dass das upload funktioniert

02:37:59.160 --> 02:38:03.440
was wir halt nicht machen ist auf auf den flash schreiben das würde das ganze auch ordentlich

02:38:03.440 --> 02:38:13.080
viel langsamer machen der flash speichert er schreibt nicht so so so schnell so sekunde

02:38:13.080 --> 02:38:24.600
warten und er wartet hier noch auf timeout ok ja warte timeout bäm beendet zack exzellent

02:38:24.600 --> 02:38:39.840
so so mag ich das also sprich sogar post upload funktioniert schon

02:38:39.840 --> 02:38:45.880
wisst ihr was ich weiß warum das 10 sekunden hängt hier das hängt 10 sekunden weil der

02:38:45.880 --> 02:38:52.960
nur empty diesen empty vector zurück gibt wenn der 10 sekunden timeout abgewartet hat

02:38:52.960 --> 02:38:57.240
und dann gibt es einen fehler das heißt ich könnte mit zählen ich könnte mit zählen

02:38:57.240 --> 02:39:07.280
also sprich wenn hier mein wenn ich so viel empfangen habe wie ich content length habe

02:39:07.280 --> 02:39:11.640
dann mache ich break und dann müsste ich diese 10 sekunden nicht mehr warten das ist natürlich

02:39:11.640 --> 02:39:21.200
noch besser probiere ich noch mal kurz aus und dann müsste das ziemlich gut funktionieren

02:39:21.200 --> 02:39:26.160
eigentlich so dann kann man hier drinnen das firmware update machen hier kann man dann

02:39:26.160 --> 02:39:34.880
was auch immer index machen wir irgendwie keine ahnung if pass so slash dann machen

02:39:34.880 --> 02:39:46.200
wir index html wenn fahrt gleich logs dann machen wir logs und so weiter und sofort

02:39:46.200 --> 02:39:56.720
ob das jetzt funktioniert ob ich keine 10 sekunden auf timeout warten muss flutsch flutsch flutsch

02:39:56.720 --> 02:40:11.840
hat funktioniert guckt hier zack update fertig reboot exzellent ja das ist das ist äußerst

02:40:11.840 --> 02:40:16.960
nice also es nimmt wirklich langsam gestalt an das einzige was wir jetzt noch mal nachschauen

02:40:16.960 --> 02:40:20.240
müssen ob der jetzt wirklich ob ich nicht irgendwelche memory leaks fabriziert habe

02:40:20.240 --> 02:40:30.240
in der ganzen in der zwischenzeit das ist ein titi go t display falls du das board haben

02:40:30.240 --> 02:40:35.600
willst kann ich dir empfehlen aktuell bei bengo zu gucken die haben das nämlich im angebot

02:40:35.600 --> 02:40:44.880
für 699 aus china das ist zwar damit nicht unbedingt das allergünstigste esp 32 baut

02:40:44.880 --> 02:40:51.280
aber es hat ein display bei und auch schön schön drauf gemacht ja du kriegst du kriegst

02:40:51.280 --> 02:40:57.760
für die hälfte normales esp 32 baut im angebot aber mit display ist natürlich richtig gut

02:40:57.760 --> 02:41:02.400
und ich finde 699 ist eigentlich ziemlich ziemlich ok wenn man sich an wenn man sich

02:41:02.400 --> 02:41:10.800
überlegt dass das auf amazon dass wir auf amazon 14 euro dafür haben wollen das ist

02:41:10.800 --> 02:41:19.680
viel zu teuer ich habe mir als 10 stück von bestellt und den auf bengut man kann es auch

02:41:19.680 --> 02:41:30.200
aus uk bestellen aber kostet mehr das lohnt sich da nicht was sonst ja klar was übrigens

02:41:30.200 --> 02:41:41.160
witzig ist dass es aus den usa ganze 58 cent kostet nach germany aus china ganze 83 29 also

02:41:41.160 --> 02:41:45.520
das ist wirklich billig der kram deswegen lohnt sich auch nicht eins zu kaufen da bist

02:41:45.520 --> 02:41:54.440
du nicht so viel billiger wenn du 10 stück kaufst brauchst du nur 3,29 versand genau richtig

02:41:54.440 --> 02:42:00.560
bengut bei aliexpress gibt es die auch manchmal wir können mal kurz gucken was die bei aliexpress

02:42:00.560 --> 02:42:07.480
kosten aber bei aliexpress sind die meistens ein klein klein grob papier tt go t display

02:42:07.480 --> 02:42:24.320
nein nein ja aber wat ah ok ist es doch guck mal die haben es auch gerade im angebot bei

02:42:24.320 --> 02:42:38.040
aliexpress da stimmt was nicht dass mit 16 mb flash ist irgendein anderes modell ich

02:42:38.040 --> 02:42:45.560
glaube die zeigen mist an guck mal es ist ähnlich günstig dafür kostet also bei bengut

02:42:45.560 --> 02:42:56.840
ist es ein tick günstiger dass mit 16 mb ist irgendwas anders aber ist das irgendwas

02:42:56.840 --> 02:43:16.840
anders dran ich glaube dass mit 16 mb ist das mit dem mit dem sd kartenslotter da wirst

02:43:16.840 --> 02:43:27.040
du mal genau gucken allerdings 4 mb ist reicht reicht auch dicke 16 mb ist schon übertrieben

02:43:27.040 --> 02:43:34.360
16 mb flash da flasht da flasht sie eine halbe stunde wenn du das 16 mb voll flasht

02:43:34.360 --> 02:43:43.240
willst so das gefällt mir das nimmt echt gestalt an hier chat ich bin begeistert wie

02:43:43.240 --> 02:43:50.560
gut das klappt so eine sache bauen wir jetzt noch ein dann gehe ich was essen und zwar

02:43:50.560 --> 02:44:00.680
wir gucken wenn ein get request auf slash kommt bzw oder oder slash index html jetzt

02:44:00.680 --> 02:44:09.040
habe ich irgendwie was zu viel kaputt gemacht dann machen wir nämlich das hier unten dann

02:44:09.040 --> 02:44:21.560
machen wir das hier unten dazu post also wir müssen jetzt händel get der kriegt ssl und

02:44:21.560 --> 02:44:34.400
den fad übergeben gut und wenn es index html ist dann liefern wir die index html aus ich

02:44:34.400 --> 02:44:41.040
sollte vielleicht noch eine methode machen für void sowas wie send string oder sowas da muss

02:44:41.040 --> 02:44:46.840
ich nicht jedes mal diesen diesen dieses anhängen von dem von dem character turn new line zeugs

02:44:46.840 --> 02:44:54.640
machen also dass ich sowas mit send string und dann hier ssl das brauchen wir zum verschicken

02:44:54.640 --> 02:45:06.080
und irgendwie einen standard string und dann machen wir nämlich den kram hier drinnen

02:45:06.080 --> 02:45:22.240
moment moment nee nee nee nee send string macht eigentlich sollte nichts anderes machen

02:45:22.240 --> 02:45:28.720
außer ok das das liefert schon mal zurück ob es funktioniert hat das ist auf jeden fall

02:45:28.720 --> 02:45:41.920
sinnvoll und dann macht er sowas hier ja dann macht er sowas hier und wir hängen vorher noch

02:45:41.920 --> 02:45:49.440
mal strepend wir hängen wir hängen am ende noch mal den character turn new line an weil

02:45:49.440 --> 02:45:54.640
auch woops weil ansonsten muss ich das jedes mal tippen und das habe ich echt kein bock drauf

02:45:54.640 --> 02:46:11.440
so und dann gucken wir irgendwie result wenn result größer null ist dann ist gab es dann

02:46:11.440 --> 02:46:17.680
hat es funktioniert dann gab es keinen fehler moment größer gleich null dann gab es keinen

02:46:17.680 --> 02:46:23.320
fehler weil das gibt zurück wie viel bytes geschrieben wurden sprich null bytes ist auch

02:46:23.320 --> 02:46:29.560
ok dann hat es schreiben funktioniert alles andere ist ein fehler so das heißt wir können

02:46:29.560 --> 02:46:38.560
den ganzen schmodder hier unten mal weg machen response brauche ich htp 1.1 ok off topic frage

02:46:38.560 --> 02:46:48.400
empfehlung für eine rate karte kann ich dir keine geben macht zfs sucht ihr einen guten adapter und

02:46:48.400 --> 02:46:55.760
macht irgendwie mini saas nimm im mini saas zu sata und macht zfs oder aber mach einfach sata

02:46:55.760 --> 02:47:01.160
ans mainboard und zfs drauf dass die budget variante die würde ich heute machen wenn ich

02:47:01.160 --> 02:47:07.080
mehr als eine festplatte hätte würde ich heute auch zfs rate 1 machen nimmst einfach zwei nimmste

02:47:07.080 --> 02:47:13.840
zwei zehn terabyte platten oder zwei zwei 14 terabyte platten wie mit deinem beispiel macht

02:47:13.840 --> 02:47:25.400
ein zfs rate 1 drüber das beste was du machen kannst wenn es rate sein soll was man sich auch

02:47:25.400 --> 02:47:30.000
mal überlegen muss ob du wirklich ein rate haben willst du könntest ja auch einfach einmal nachts

02:47:30.000 --> 02:47:37.200
den erst machen von platte 1 auf platte 2 das wäre dann zwar kein kein würde dir in puncto

02:47:37.200 --> 02:47:43.840
ausfallfähigkeit nicht bringen weil wenn die platte kaputt geht dann ist trotzdem kaputt aber es

02:47:43.840 --> 02:47:49.960
hat auch seine vorteile weil du hast ein paar stunden zeit zwischen den syngs also sprich wenn

02:47:49.960 --> 02:47:56.080
du aus versehen was löscht dann hast du weniger lesegeschwindigkeit das ist richtig wobei das für

02:47:56.080 --> 02:48:02.480
normales gigabit netzwerk vollkommen unerheblich ist bei einem rate wenn du daten auf der platte

02:48:02.480 --> 02:48:08.320
kaputt macht sind die halt generell kaputt weil das direkt züngt deswegen muss man auch immer sagen

02:48:08.320 --> 02:48:14.520
als backup eignet sich das halt nicht also wenn du jetzt daten gespeichert hast auf deinem rate 1

02:48:14.520 --> 02:48:20.080
und du löscht aus versehener datei dann ist es halt instant weg auf beiden platten wenn du das

02:48:20.080 --> 02:48:26.880
einmal in der nacht erst züngst ist die datei noch da weil du halt noch nicht direkt gesüngt

02:48:26.880 --> 02:48:32.280
hast es hat alles seine vornachteile mehr geschwindigkeit hast auf jeden fall mit einem

02:48:32.280 --> 02:48:37.440
rate 1 lesegeschwindigkeit schreibgeschwindigkeit ist quasi kein unterschied theoretischen ticken

02:48:37.440 --> 02:48:41.200
langsamer praktisch gesehen macht es keinen unterschied schreibgeschwindigkeit ist normal

02:48:41.200 --> 02:48:49.640
lesegeschwindigkeit ist eine ganze ecke schneller und wenn du mehr als gigabit hast wenn du mehr

02:48:49.640 --> 02:48:55.560
als gigabit drinne hast ist dann würde ich in rate 1 machen weil rate 1 bringt ja lesegeschwindigkeit

02:48:55.560 --> 02:49:05.480
also automatisch mit dabei hast du irgendwie 2,5 5 g 10 g dann ist es gar nicht so verkehrt mit

02:49:05.480 --> 02:49:11.920
modernen festplatten du kannst du kriegst du kriegst schon deine 300 300 mb die sekunde oder vielleicht

02:49:11.920 --> 02:49:24.320
sogar 400 mb weiß ich eher 300 mb die sekunde lesend von einem rate 1 so http response das machen

02:49:24.320 --> 02:49:29.760
wir jetzt nämlich noch schnell ich bin jetzt gerade voll side tracked worden wir liefern das aus wenn

02:49:29.760 --> 02:49:37.000
far slash ist beziehungsweise index html dann sagen wir response ist das read file und dann sagen wir

02:49:37.000 --> 02:49:46.600
hier send string ssl und dann kann ich nämlich den ganzen miss dahinten weg machen braucht das

02:49:46.600 --> 02:50:01.320
nicht mehr response plus htm was hat er für schmerzen was achso ich muss als standard string

02:50:01.320 --> 02:50:20.280
lesen und nicht als arduino string gut irgendwo habe ich was vergessen anzupassen da was ist

02:50:20.280 --> 02:50:38.760
kaputt also wenn dein mainboard nicht genügend sata anschlüsse hat echt du hast mainboard was

02:50:38.760 --> 02:50:47.600
nicht zwei sata an was keine zwei sata anschlüsse hat ja dann nehmen hba du kannst relativ günstig

02:50:47.600 --> 02:50:58.760
bekommst du welche mini saas mini saas kannst du pro mini saas anschluss 4 sata oder 5 4 oder 5 ich

02:50:58.760 --> 02:51:20.120
glaube mini saas mini saas in sogar fünf sata ne vier vier ja also ich habe ein glaub so ein

02:51:20.120 --> 02:51:27.840
die kosten nicht viel ich kann dir den aber nicht empfehlen weil ich verwende den schon ewig nicht

02:51:27.840 --> 02:51:34.560
mehr so eine kiste habe ich in meiner fetten server box drinnen die ich aber gerade nicht

02:51:34.560 --> 02:51:40.440
verwende weil total auf was heißt musste einfach mal ein bisschen rumgucken muss einfach ein bisschen

02:51:40.440 --> 02:51:45.000
rumgucken ja und wie gesagt du kannst ja den hba verwenden trotzdem zfs rate machen also so

02:51:45.000 --> 02:51:50.320
so würde ich es machen also ich würde den hba den würde ich nur verwenden zum anschließen von

02:51:50.320 --> 02:51:59.640
den sata platten und dann würde ich software rate zfs rate machen so schauen wir mal also

02:51:59.640 --> 02:52:14.480
slash funktioniert index html funktioniert auch und post update funktioniert hoffentlich auch

02:52:14.480 --> 02:52:21.240
noch oh oh was ist hier mit meinen kommt mal hier mein ram geht ganz schön runter gerade

02:52:26.960 --> 02:52:31.920
ok reboot excellent geht mir mein ram so krass runter also wegen der seite

02:52:31.920 --> 02:52:53.240
oh das ist der firefox der versucht zu refreshen der firefox baut mehrere versucht

02:52:53.240 --> 02:53:03.240
gerade mehrere verbindungen aufzubauen deswegen schwankt der ram so es geht box life sagt wir

02:53:03.240 --> 02:53:11.840
fahren gut mit den p420 von ap sind das mini saz connector mit also quasi zweimal mini saz auf

02:53:11.840 --> 02:53:23.640
sata oder was was ist das für dinger nee das sind keine mini saz das sind normale saz

02:53:26.640 --> 02:53:28.160
was aber kein großer unterschied machen

02:53:28.160 --> 02:53:41.640
ist sogar eine batterie dabei vermute mal dass es eine batterie ist richtig advanced

02:53:43.400 --> 02:53:45.000
heute zeigt doch mal die anschlüsse

02:53:45.000 --> 02:54:01.640
das ist ein cash alles schlüsse erst mal erst mal noctua lüfter so muss das sein

02:54:01.640 --> 02:54:10.600
wird das wort zu diesen mini webs ja es werden alle meine sachen hier hochgeladen

02:54:10.600 --> 02:54:22.320
alle streams gibt es hier im archiv und hier sind die streamtitel drinnen

02:54:22.320 --> 02:54:49.040
excellent so passt max fps liegt jetzt ist es raus das ist da das ist da der firefox

02:54:49.040 --> 02:55:01.080
der hier den ganzen ram verbraucht im hintergrund ja wunderbar funktioniert richtig gut ich bin

02:55:01.080 --> 02:55:08.000
wirklich begeistert und was man was man daran sieht ist wie schön so plaintext protokolle

02:55:08.000 --> 02:55:16.160
sind du kannst dir ein paar beispiele angucken und einfach nachbauen es funktioniert dennny

02:55:16.160 --> 02:55:30.760
die vier monate excellent subscription big brain so chat ich esse jetzt eine runde pizza

02:55:30.760 --> 02:55:37.440
ich war heute lang genug und wir machen die tage weiter vielleicht morgen morgen habe ich auch

02:55:37.440 --> 02:55:44.240
noch frei ich hoffe euch hat es gefallen ich hoffe alles verstanden ich habe ja viele selbst

02:55:44.240 --> 02:55:58.520
nicht kapiert weil c++ und jetzt mache ich erstmal pepo fett massive pepo fett mache ich

02:55:58.520 --> 02:56:17.760
jetzt möchte möchtest du nicht einfach ausgehen vm vm ausgehen ah yes

02:56:17.760 --> 02:56:28.680
so und wenn wir den webserver dann fertig haben vielleicht können wir dann auch

02:56:28.680 --> 02:56:33.920
weitermachen mit dem eigentlichen projekt hier weil das soll ja immer noch was geben

02:56:33.920 --> 02:56:39.160
um eine klimaanlage zu steuern ich habe ja schon was fertig was mit einem anderen board

02:56:39.160 --> 02:56:44.920
funktioniert aber hier mit dem board ist es viel viel viel viel besser weil da kann ich dann auch

02:56:44.920 --> 02:56:48.600
sogar den status anzeigen ob es zu heiß oder zu kalt oder zu sonst was ich habe mehr platz

02:56:48.600 --> 02:57:15.560
alles klar chat wir sehen uns beim nächsten stream macht es gut bis denn zu

