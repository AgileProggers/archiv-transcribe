WEBVTT

00:00.000 --> 00:04.160
So, jetzt schauen wir mal, ob wir jetzt Quality Options haben.

00:04.160 --> 00:15.000
Haben wir jetzt Quality Options?

00:15.000 --> 00:28.480
Tja Leute, dann stremen wohl zu viele Leute und ich krieg sie gerade auf Twitch nicht.

00:28.480 --> 00:39.400
Da kann ich leider jetzt nichts machen, außer ich werde Twitch-Partner endlich mal irgendwann.

00:39.400 --> 00:45.360
Dann krieg ich auch immer Quality Options.

00:45.360 --> 00:54.800
Aber solange ich kein Twitch-Partner bin, bin ich halt quasi extrem so dritter Klasse,

00:54.800 --> 00:59.200
was Quality Options angeht.

00:59.200 --> 01:08.120
Oh, ich pause nochmal kurz auf Twitch.

01:08.120 --> 01:14.480
Ey Leute, ich sage euch, ich hab quasi gestern den ganzen Tag rum probiert, hier den Gift-Player

01:14.480 --> 01:23.720
zum Laufen zu kriegen, also nicht den da, sondern den High-Speed, DirectX, FFmpeg, sonst

01:23.720 --> 01:24.720
als Gift-Player.

01:24.720 --> 01:35.600
Und was unglaublich schwierig war, also das Gegenteil von, warum geht Easy nicht, ah,

01:35.600 --> 01:36.600
das Fenster noch kleines.

01:36.600 --> 01:49.240
Also das Gegenteil von Easy, das ist ey Windows, es ist so undurchsichtiger Kack ey teilweise.

01:49.240 --> 01:54.040
Ich weiß gar nicht, wie man dafür überhaupt irgendwas ernstzunehmendes entwickeln kann

01:54.040 --> 01:55.040
manchmal.

01:55.040 --> 02:18.000
So, auf Twitch gepostet, äh, auf Twitter.

02:18.000 --> 02:29.120
Ich bin schon komplett, wie er im Kopf, äh, so machen wir mal hier unsere Chill-Steps,

02:29.120 --> 02:30.760
Chill-Steps-Sohle-Geschichte an.

02:30.760 --> 02:37.760
Mal gucken, wie lautstärk ist.

02:37.760 --> 02:58.320
Joa, joa, hoff mal den an, ach, das ist der, hoff an, der andere Icon, ey, ich mein Thumbnail.

02:58.320 --> 03:01.960
Leute, das Windows-Teuch hat mich so kaputt gemacht im Kopf, ey, ich kann überhaupt keine

03:01.960 --> 03:02.960
Wörter mehr aussprechen.

03:02.960 --> 03:11.080
Ich bin wirklich komplett, komplett hinüber, was das angeht.

03:11.080 --> 03:20.080
Also, ich hab hier das, das, das ekligste überhaupt produziert, ne, also man kann das,

03:20.080 --> 03:22.800
man kann das nicht mal mal lesen, was ich hier gebastelt hab letztendlich, das müssen

03:22.800 --> 03:23.800
wir jetzt aufräumen.

03:23.800 --> 03:29.240
Ich hab hier quasi 365 Zeilen, irgendeinen Schritt zusammen gebastelt, dass es schnell

03:29.240 --> 03:30.240
ist.

03:30.240 --> 03:33.840
Auf den ersten Akt, ich zeige euch jetzt gleich mal, was da alles dahinter steckt, ey, es

03:33.840 --> 03:34.840
ist der Wahnsinn.

03:34.840 --> 03:39.840
Und es macht aktuell nicht mehr, außer ne noch nicht animierten Papagei anzeigen.

03:39.840 --> 03:48.320
Mit 6000, na gut, das ist weil OBS im Hintergrund jetzt auch noch ein bisschen CPU braucht.

03:48.320 --> 03:55.360
Mit 6500 FPS, ne nicht animierten Papagei, aber, man, man merke, der Papagei ist transparent.

03:55.360 --> 04:00.880
Was meint ihr, was es für ein Akt war, diesen Scheiß transparent zu kriegen, das könnt

04:00.880 --> 04:01.880
ihr euch gar nicht vorstellen.

04:01.880 --> 04:09.840
Das ist wirklich, also was die sich bei Microsoft dabei gedacht haben, es ist mir vollkommen

04:09.840 --> 04:10.840
schleierhaft.

04:10.840 --> 04:16.680
Und es ist mir teilweise echt ein Rätsel, wie man, warum man dafür entwickelt.

04:16.680 --> 04:18.680
Ey, das ist, also ich zeig euch das jetzt mal.

04:18.680 --> 04:21.680
So, wir gehen da chat.

04:21.680 --> 04:23.280
Wart mal, ich glaub meinen.

04:23.280 --> 04:26.920
Ich muss mal kurz meinen Vorschau refreshen.

04:26.920 --> 04:31.160
Letzte, was ich sehe, ist der Kühne in der Heimachs geschrieben hat, ich glaube nicht,

04:31.160 --> 04:34.320
dass das das letzte war, dass er schon wieder irgendwie 6 Minuten her.

04:34.320 --> 04:42.240
So, sagt mal was.

04:42.240 --> 04:45.720
Ich weiß, dass mein Vorschaufenster geht.

04:45.720 --> 05:00.360
So, ah ja, genau, jetzt, jetzt, jetzt geht der Chat wieder, der Boy next door, ja genau.

05:00.360 --> 05:04.760
Jetzt haben, haben Gatschi besten.

05:04.760 --> 05:13.640
Okay, also ich zeig euch das mal, ey, das, das, das haltet ihr im Kopf nicht aus, also

05:13.640 --> 05:19.200
das ist so ungefähr, also wir räumen das jetzt auf, das ist wirklich ganz abartig,

05:19.200 --> 05:20.200
ne.

05:20.200 --> 05:25.520
Also das hier ist so ungefähr, was wir das letzte Mal auch hatten, bloß, dass es nicht

05:25.520 --> 05:28.720
skaliert war, aber das hab ich jetzt auch mittlerweile eingebaut, dass es, dass es hier

05:28.720 --> 05:32.120
schön skaliert und dass es nicht transparent war.

05:32.120 --> 05:38.800
Und ich sag euch Leute, Transparenz unter Windows, ey, sowas undurchsichtiges ist der

05:38.800 --> 05:39.800
Wahnsinn.

05:39.800 --> 05:46.320
Erstmal, wenn man danach sucht, findet man nichts Gescheites.

05:46.320 --> 05:56.360
Was man findet ist, sind in irgendwelchen Cheaterstellungsforen, ist kein Witz, ja,

05:56.360 --> 06:01.160
also wenn man hier irgendwie danach sucht, wenn man jetzt hier zum Beispiel sucht, keine

06:01.160 --> 06:12.640
Ahnung, Direct2D transparent overlay, wenn man irgendwie solche Dinge sucht, das erste,

06:12.640 --> 06:19.720
was man findet sind irgendwelche Cheatforen, ja, weil das natürlich auch für viele Cheats

06:19.720 --> 06:25.080
unerlässlich ist und das Schlimme ist, dass Microsoft dazu nichts Gescheites geschrieben

06:25.080 --> 06:30.600
hat, es gibt 20 Millionen Optionen, die du setzen kannst, hier beim Erstellen vom Fenster

06:30.600 --> 06:34.520
zum Beispiel, wo du nicht genau weißt, was der ganze Kram überhaupt macht.

06:34.520 --> 06:42.640
Es ist, es ist, es ist komplett hier, achso ja, das Ziel heute, das Ziel heute kann ich

06:42.640 --> 06:47.760
dir zeigen, also das Ziel generell ist, einen schnellen Giftplayer zu machen für mein Meme

06:47.760 --> 06:51.160
Tool, weil ich zeig dir das mal, also wenn man hier jetzt zum Beispiel draufklickt,

06:51.160 --> 07:00.920
hör mal, hör mal, klicken, zack, das braucht 2, 3 Sekunden oder vielleicht, na, so 1, 2

07:00.920 --> 07:06.000
Sekunden hier, bis das geladen ist und angezeigt wird, aber kleinere Gifts gehen schneller,

07:06.000 --> 07:11.200
aber man merkt, man merkt die Verzögerung, bei kleinen Gifts geht, hier hängt es schon

07:11.200 --> 07:19.520
wieder, weil ich den jetzt erstmal wieder groß machen muss, so, aber hier hängt es

07:19.520 --> 07:36.800
schon wieder, klick, so, und was wir machen, äh, Moment, was wollte ich jetzt sagen, ja

07:36.800 --> 07:42.360
genau, was wir machen, wir basteln einen eigenen Giftplayer, den ich anstatt hier meinem WPF

07:42.360 --> 07:43.360
Fenster verwenden kann.

07:43.360 --> 07:50.240
Alles in Ram laden macht er ja, wenn du hier nämlich im Hintergrund guckst, das Ding braucht,

07:50.240 --> 07:55.640
sobald du einen Gift aufmachst, 830 MB, weil er jeglichen Frame irgendwie in voller Auflösung,

07:55.640 --> 08:00.400
in voller Farbe, mit allem in Ram lädt, für jedes Bild, und so ein Gift ist dann unglaublich

08:00.400 --> 08:04.200
groß, vor allem in diesem komischen WPF Plugin, was ich verwende, und diese komischen WPF

08:04.200 --> 08:09.360
Library, die ich verwende, fürs Anzeigen von Gifts, und das ist Müll, und erstens will

08:09.360 --> 08:13.640
ich schneller haben, ja, und das darf auch gerne ein bisschen weniger Ram verbrauchen,

08:13.640 --> 08:22.280
deswegen haben wir das letzte Mal angefangen, was eigenes zu basteln, mit FFmpeg und Direct2D,

08:22.280 --> 08:27.680
man sieht schon, das braucht jetzt 85 MB, wir haben so ein bisschen, so ein paar kleinere

08:27.680 --> 08:34.520
Memory Leaks haben wir hier, ja, ein paar kleinere Memory Leaks haben wir, aber sagen

08:34.520 --> 08:40.480
wir mal so, das braucht halt 80 MB, und es ist gut, ja, und es geht halt mega schnell,

08:40.480 --> 08:44.520
guck, sobald man sie zack, Gift ist da, und der muss jetzt die ganze Anwendung noch starten,

08:44.520 --> 08:50.880
also das geht schon schneller, und die große Herausforderung, die es jetzt gab, das letzte

08:50.880 --> 08:55.960
Mal haben wir das eigentlich ganz gut hingekriegt, das Gift zu animieren, das Gift zu animieren

08:55.960 --> 09:00.640
ist auch kein Akt, das könnte ich jetzt auch wieder einfügen, da muss ich einfach hier,

09:00.640 --> 09:09.040
wie gesagt, wir müssen das alles aufräumen, das ist Überbleibsel von meinem Rumprobierer,

09:09.040 --> 09:14.360
ja, so, und hier lesen wir das Gift, irgendwo lesen wir das Gift, wo lesen wir das Gift?

09:14.360 --> 09:25.400
Back it, Moment, wo lesen wir das Gift, da lesen wir das Gift, hier lesen wir das Gift

09:25.400 --> 09:28.600
ein, also sprich, eigentlich um jetzt das Gift zu animieren, müsste ich jetzt bloß

09:28.600 --> 09:33.360
noch den Kram, ich kann es ja mal kurz zeigen, dass wir jetzt einen Stand haben, wo das Gift

09:33.360 --> 09:41.040
auch animiert läuft, machen wir mal hier unten hin, irgendwie so, zack, und jetzt machen

09:41.040 --> 09:46.000
wir einen Sleep von, keine Ahnung, machen wir 100 Millisekunden, dass es nicht zu schnell

09:46.000 --> 09:54.720
läuft, so, jetzt sollte das Gift, oder auch nicht, was auch immer, zumindest ist es kein

09:54.720 --> 09:59.680
großartiges Akt, das Gift zu animieren, ähm, ich weiß gar nicht warum, was hat er jetzt

09:59.680 --> 10:05.160
für Schmerzen, eh, egal, es ist total wirr, was ich hier gebaut habe, und das Schwierige

10:05.160 --> 10:09.360
war wirklich, die Transparenz hinzukriegen, also das jetzt zu animieren, das kriegen wir

10:09.360 --> 10:14.640
heute auch hin, also das Ziel ist heute, dass wir einen ordentlichen Giftplayer haben, nicht

10:14.640 --> 10:21.320
hier mein hingerotztes Zeug, der schnell funktioniert und animierte Gifts abspielt, wie gesagt,

10:21.320 --> 10:24.160
das Animieren ist nicht das Problem, das haben wir das letzte Mal schon gemacht, da kann

10:24.160 --> 10:27.840
man sich einfach den nächsten Frame aus FFmpeg ziehen und gut ist, das haben wir ja auch

10:27.840 --> 10:31.400
schon hin gebastelt, was wirklich schwierig war, und jetzt kommen wir mal wieder zurück

10:31.400 --> 10:37.840
zu dem, was ich eigentlich sagen wollte, es ist wirklich schwierig, ein transparentes

10:37.840 --> 10:44.920
Windows zu machen, unter Windows, ein transparentes Windows, auf dem man malen kann, und ich

10:44.920 --> 10:50.720
habe nur einen offiziellen Weg von Microsoft gefunden, alle anderen waren aus irgendwelchen

10:50.720 --> 10:58.640
Cheatforen, die irgendwelche Dinge abusen, die man nicht machen sollte, zum Beispiel,

10:58.640 --> 11:03.880
was ich ganz witzig fand, was ich rausgekriegt habe ist, ihr kennt doch dieses Nvidia Overlay,

11:03.880 --> 11:07.880
was ich jetzt aus irgendwelchen Gründen nicht einblenden darf, warum darf ich das denn nicht

11:07.880 --> 11:14.640
einblenden, all diese GeForce Experience, das Ding ist so kaputt, so, Moment, ich mach

11:14.640 --> 11:22.200
es mal an, Overlay, Overlay, zack, ja, besser hier, will kein Account, so, seht ihr das,

11:22.200 --> 11:28.200
seht ihr das Nvidia Overlay, wie benutzt ihr FFmpeg mit C-Sharp, mit einem automatisch

11:28.200 --> 11:33.760
generierten Binding, was es auf GitHub gibt, such mal nach, ich zeige es dir gleich, seht

11:33.760 --> 11:39.840
ihr das Nvidia Overlay, oder seht ihr das im Stream nicht, muss man auf meinem Vorschau

11:39.840 --> 11:47.160
Bildschirm gucken, ja, also man sieht das, man sieht das Nvidia Overlay, und da hab ich

11:47.160 --> 11:51.040
rausgefunden, ich zeig dir mal kurz die FFmpeg Bindings, die du brauchst, das hier brauchst

11:51.040 --> 12:02.680
du für FFmpeg von C-Sharp aus, den hier, FFmpeg autogen von Ruslan B, und dann musst du

12:02.680 --> 12:10.840
quasi im Prinzip C-Style FFmpeg machen halt, plus aus die Sharp raus, so, und ich hab rausgekriegt

12:10.840 --> 12:17.720
in diesen Cheat-Forum, die ich geguckt habe, was da teilweise für komische Hacks am Werke

12:17.720 --> 12:22.320
sind, um nicht erkannt zu werden, das ist teilweise ganz witzig, und zwar sie verwenden dieses

12:22.320 --> 12:30.320
Nvidia Overlay, was quasi kein Cheat, keine Cheat-Engine der Welt flaggen wird, weil es

12:30.320 --> 12:35.840
ja das Nvidia Overlay ist, und das ist ja was Legitimes, die hijacken das so ein bisschen,

12:35.840 --> 12:41.600
ja, also die crampen sich quasi das Nvidia Overlay und malen dann dort in das Nvidia

12:41.600 --> 12:50.120
Overlay ihr eigenes Zeug rein, das ist eigentlich eine richtig geile Idee, ich mein, so Dinger

12:50.120 --> 12:54.440
kann man alles machen, aber wir wollen ja gar nicht wie ein Cheat aussehen, weil wir

12:54.440 --> 13:01.560
sind ja kein Cheat, und, das heißt alles, was ich hier so gefunden habe in diesen komischen

13:01.560 --> 13:07.000
Hacks, hier also, die meisten, ohne Scheiß, die meisten Treffer zu wie man transparente

13:07.000 --> 13:11.760
Overlays macht, sind in diesem Cheat-Forum, nach irgendwie 500 Stück oder so, ja, das ist

13:11.760 --> 13:17.360
gar nicht wahr, danach kommt Stack-Overflow, aber es ist alles nicht sonderlich intuitiv,

13:17.360 --> 13:22.760
das heißt, ich denke mal, und der Sebaro, der nimmt ja die Videos auch wieder auf, das

13:22.760 --> 13:28.920
ist wahrscheinlich eine der wenigen Anleitungen, was wir heute im Stream machen, wenn nicht

13:28.920 --> 13:35.720
die einzige weltweit, die quasi nicht auf irgendeinem Cheat-Scheiß basiert, auf offiziellen

13:35.720 --> 13:41.400
Lösungen von Microsoft basiert und ein funktionierendes Beispiel hier im Stream hat, transparente

13:41.400 --> 13:49.600
Fenster, ja, und ja, gibt es Punktabzug, wenn der Player als Cheat erkannt wird, dann geht

13:49.600 --> 13:56.920
die Anzeige raus an den Anti-Cheat-Entwickler, also mehr als den offiziellen Microsoft-Weg

13:56.920 --> 14:02.200
befolgen, können wir nicht tun, können wir wirklich nicht machen, und der offizielle

14:02.200 --> 14:08.920
Microsoft-Weg ist, also, dass man hier so ein transparentes Fenster kriegt, der Witz

14:08.920 --> 14:13.040
ist ja, das Fenster muss nicht nur von der Farbe transparent sein, sondern man muss auch

14:13.040 --> 14:18.600
durchklicken können, das Ding wird safe detected, ey, ohne Scheiß, ich kann halt nichts dagegen

14:18.600 --> 14:27.480
machen, ähm, was soll ich tun jetzt endlich, ja, wenn die Funktionen, die in Windows eingebaut

14:27.480 --> 14:31.600
sind, vollkommen legitim sind, sogar Microsoft in Anleitungen verwendet, von irgendwelchen

14:31.600 --> 14:36.760
Anti-Cheat-Tools erkannt werden, weiß ich auch nicht, ja, aber gut, was willst du machen,

14:36.760 --> 14:47.000
ich meine, die Cheat-Entwickler können den ganzen gleich, können den gleichen Kram verwenden,

14:47.000 --> 14:52.360
und ich hoffe ja mal, dass das Anti-Cheat-Zeug nicht wild flaggt, sondern quasi schon mal

14:52.360 --> 14:56.000
gucken, zu welchen Programmen gehört das und sonst was, weil, ich meine, das Video-Overlay

14:56.000 --> 15:06.000
wird ja auch nicht geflaggt, lol, alter, so, und, ja, der einzige Weg, den ich gefunden

15:06.000 --> 15:10.440
habe, wie man das offiziell macht, ist ein Artikel von Microsoft, den muss ich jetzt

15:10.440 --> 15:19.080
mal finden, das war irgendwie, ähm, wofür machst du das, zum GIFs anzeigen als Overlay,

15:19.080 --> 15:23.640
zum Beispiel, guck mal, ähm, hier kann ich GIFs als Overlay anzeigen lassen, das funktioniert

15:23.640 --> 15:30.600
auch gut, das ist auf, das ist auf WPF-Basis, das klappt ganz gut, das Problem ist nur,

15:30.600 --> 15:36.160
dass, ähm, diese Library für WPF ziemlich lahm ist, bei großen GIFs wie dem hier zum

15:36.160 --> 15:41.360
Beispiel, guck mal, klickste, und jetzt ist es erst da, so, deswegen wollte ich selbst

15:41.360 --> 15:52.360
einen Overlay basteln, was, ähm, GIFs anzeigen kann, und das geht auch schon, guck mal da,

15:52.360 --> 15:57.200
zack, GIF da, und rendert so ungefähr mit 7000 FPS, wenn man es mal, wenn man es sich

15:57.200 --> 16:02.400
ein bisschen ein, einlaufen lässt, ja, so irgendwas, pfff, wenn man es sich ein bisschen einlaufen

16:02.400 --> 16:06.360
lässt, ja, wenn man es ein bisschen ein, wenn es ein bisschen gelaufen ist, dann hast du

16:06.360 --> 16:09.680
eben 7000 FPS, aber, ähm, es ist schon, es ist schon deutlich schneller, aber auch viel,

16:09.680 --> 16:13.520
viel weniger RAM, das andere brauch ich wie 800 MB RAM für so ein publisches GIF, und

16:13.520 --> 16:19.240
das hier ist mit komplettem Fenster und allem irgendwie bei 80.

16:19.240 --> 16:28.400
Dann soll sie mich halt als suspicious flaggen, wenn das Leute, wenn das, wenn das, äh, ganz

16:28.400 --> 16:34.360
viele verwenden, also viele, ich weiß nicht, was für die viele ist, 30, 40 Leute, ja,

16:34.360 --> 16:37.840
und irgendwann, wenn sie mal nachgucken, um was es da eigentlich geht, ansonsten sind

16:37.840 --> 16:42.720
sie auch, ansonsten sind die Anti-Cheat Hersteller auch nicht besser als irgendwelche Virenprogrammierer,

16:42.720 --> 16:47.120
wenn sie einfach blind da irgendwelche Sachen machen, vor allem, wenn sie halt viele Leute

16:47.120 --> 16:53.000
haben, und dann muss man halt auch mal einfach gucken, was dahinter steckt, ich mein, der

16:53.000 --> 16:59.600
ist ausgeholt, er ist offen auf GitHub, kann sich hier da angucken, so, und der einzige

16:59.600 --> 17:03.600
Weg, und jetzt, jetzt pass auf, jetzt Leute, jetzt wird's übelst abenteuerlich, den einzigen

17:03.600 --> 17:10.600
Weg, den ich gefunden habe, bei Microsoft, wie man das macht, ist, ha, ich, wie hießen

17:10.600 --> 17:22.600
diese Artikel, ähm, da war irgendwas von 2014, ich muss euch den mal zeigen, weil der Artikel

17:22.600 --> 17:41.080
selbst ist schon wieder übelst abgedreht, ey, ähm, kann man das irgendwie nicht, das

17:41.080 --> 17:46.040
kann man doch auf Seiten einstellen, Side, so, und ich hab, das ist ein Artikel, der ist

17:46.040 --> 17:53.080
von C++, ich hab den so ein bisschen, quasi, für, äh, sharpdx übersetzt, dass der damit

17:53.080 --> 18:11.880
funktioniert, ha, ok, allerdings in dieser komischen Artikel, ah, da kommen da Sachen

18:11.880 --> 18:22.600
doch schon näher, kann man nicht noch irgendwie nach Datum 2014 oder suchen, ok, dann suchen

18:22.600 --> 18:32.680
wir mal nach Microsoft, das da, das ist es glaube ich, ja, das ist es, das ist der einzige

18:32.680 --> 18:35.680
Artikel von Microsoft, den ich zu dem Thema gefunden habe, aber auch nicht auf Deutsch,

18:35.680 --> 18:43.200
ich hab das schon auf, wo stellt man hier die Sprache um, Sprache, Sprache, ich will

18:43.200 --> 18:56.720
das nicht auf Deutsch, wo stellt man hier, ah, da unten, English and all that, ok, so,

18:56.720 --> 19:01.880
das ist der einzige Artikel, den ich gefunden hab, und das ist schon, und das ist wohlgemerkt

19:01.880 --> 19:08.360
von 2014, und so macht es auch keine Cheat, kein Cheat, den ich bisher irgendwie da in

19:08.360 --> 19:12.280
diesem anderen Forum gesehen hab, macht es nach dem offiziellen Microsoft Weg, die machen

19:12.280 --> 19:18.800
alle so krumme Dinge, also irgendwie, NVIDIA Overlay hijacken, irgendwelche, irgendwelche

19:18.800 --> 19:26.080
Window, ähm, Window Manager Geschichten abgreifen und so, aber das ist der einzige

19:26.080 --> 19:33.880
Weg von Microsoft, den ich gefunden habe, transparentes Window auszumachen, wo man schnell

19:33.880 --> 19:34.880
reinzeichnen kann.

19:34.880 --> 19:42.680
Ja, stimmt, Lesezeit ist keine schlechte Idee, so, und jetzt nur so zu erklären, der Typ

19:42.680 --> 19:50.560
labert halt hier ein bisschen rum, so, und der Artikel ist halt in C, C++, was ist das,

19:50.560 --> 19:57.840
ich würde sagen, das ist eher C, da ist noch nicht mal was mit C++, ähm, also, die Beispiele,

19:57.840 --> 20:02.000
die sie da haben, sind in C, und ich hab das versucht, so ungefähr nachzubauen, was der

20:02.000 --> 20:10.320
Duta treibt, ja, und, ey, es ist wir, es ist, es ist mega wir, also die Essenz aus dem ganzen,

20:10.320 --> 20:14.520
ich zeig's euch mal, gleich bei mir im Code, ähm, stimmt, das sind Lambdas, das müssen

20:14.520 --> 20:20.640
C++ sein, ähm, so, und da zeigt der hier, blablabla, Window erstellen, blablabla, transparentes

20:20.640 --> 20:24.880
Window erstellen, ja, also, Bricht, das ist, Microsoft sagt selbst, so funktioniert's,

20:24.880 --> 20:30.320
also, ja, gut, kann sich nicht davor schützen, dass es irgendeinen Anti-Cheat-Typ fleckt,

20:30.320 --> 20:36.000
so, hier, guck, transparentes Window, blablabla, DirectX, blablabla, blablabla, ganz viel

20:36.000 --> 20:40.280
Blah, den ganzen Scheiß hab ich ausprobiert und in C Sharp, äh, Sharp DX zu übersetzen,

20:40.280 --> 20:46.480
ja, also, so, blablabla, dann steht hier zwischendrin irgendwas von der Direct Composition API, wenn

20:46.480 --> 20:51.840
du nach Direct Composition suchst, findest du ein Video von Microsoft im Jahr 2013, also,

20:51.840 --> 20:56.720
das ist wirklich der Abgrund, der Abgrund, wirklich, der komplette Abgrund, den ich, in

20:56.720 --> 21:02.200
den du hier schaust, Bob, von Windows, wieder, ähm, so, und am Ende zeigt der dir dann halt,

21:02.200 --> 21:05.560
wie geil er ist, er hat ein Fenster am Start mit einem grünen Kreis drauf, und letztendlich

21:05.560 --> 21:09.080
ist es ja das, was wir auch wollen, das Einzige, was wir danach noch machen müssen, ist, den

21:09.080 --> 21:16.480
Fensterrahmen weg, war es aber kein Ding, wichtig ist erstmal, dass man ein transparentes Fenster

21:16.480 --> 21:20.360
bekommt und dass man reinmalen kann, so, und jetzt zeige ich euch mal, wie das geht, weil

21:20.360 --> 21:23.480
wir wollen uns ja nicht diesen komischen Artikel von dem Typ angucken, sondern wie ich das gemacht

21:23.480 --> 21:30.000
hab, und Leute, es ist Magic pur, es ist wirklich Magic pur, ähm, ich kann, wie gesagt, ich

21:30.000 --> 21:32.160
kann euch gar nicht erklären, ich kann euch erklären, was ich gemacht hab, aber nicht

21:32.160 --> 21:40.320
warum das an manchen Stellen so aussieht, ähm, fangen wir erstmal oben an, ne, wir fangen,

21:40.320 --> 21:44.440
wir fangen beim interessanten Teil an, also das erste, was ich mach, wir räumen das jetzt

21:44.440 --> 21:48.240
gleich auf, das ist auch Ziel dieses Streams, ne ordentliche Giftplayer-Klasse zu machen

21:48.240 --> 21:52.040
und meine ganzen, ganzen Scheiße hier rauszuschmeißen, das Ding hat jetzt irgendwie 400 Zeilen

21:52.040 --> 21:56.800
gekocht, danach hat es wahrscheinlich noch 150, wenn wir fertig sind, ja, und das hier,

21:56.800 --> 22:01.680
diese Funktion ist das auch, was die ganzen Cheat-Tools immer verwenden, ich hab auch

22:01.680 --> 22:06.320
als probiert, das damit hinzukriegen, funktioniert, aber, und jetzt kommt der Hit, es ist langsamer

22:06.320 --> 22:12.520
als meine Lösung, Layered-Window mit, ähm, diesem, dieser Geschichte ist langsamer als

22:12.520 --> 22:15.840
das, was ich gebastelt hab, also ist die offizielle Microsoft-Lösung wahrscheinlich gar nicht

22:15.840 --> 22:21.160
mal so schlecht, aber wahrscheinlich nicht so flexibel, was, äh, natürlich wieder für,

22:21.160 --> 22:26.600
äh, Cheat-Geschichten schlecht ist, ja, also hier kannst du halt auch wirklich nur dein

22:26.600 --> 22:31.920
eigenes Fenster malen, alles andere kannst du vergessen, was halt bei den Cheat-Dingern

22:31.920 --> 22:35.360
nicht so ist, ne, aber wir wollen ja auch nicht cheaten, das ist wie gesagt die einzige

22:35.360 --> 22:43.960
offizielle Microsoft-Lösung, so, ähm, also wo gehts denn los, also als erstes müssen

22:43.960 --> 22:49.000
wir irgendwie DirectX-Gedöns erstellen, äh, das ist für mich zum größten Teil Magic,

22:49.000 --> 22:52.440
was diese Optionen hier machen, allerdings braucht man diese Option, sonst funktioniert

22:52.440 --> 22:59.480
es nicht, und, ganz wichtig, auch, auch wirklich sehr praktischer Tipp, wenn ihr mal DirectX-Zeug

22:59.480 --> 23:06.240
macht, wusste ich bis vor kurzem auch nicht, das Ding schmeißt laufend, wenn es sich an

23:06.240 --> 23:10.320
irgendwas stört, Fehler, und die Fehler sind halt überhaupt nicht aussagekräftig, da steht

23:10.320 --> 23:18.200
dann einfach nur ein DirectX-Error oder sowas, da, da kann man, ähm, da kann man, oh alter,

23:18.200 --> 23:21.920
wo war das denn jetzt versteckt, ich glaub hier irgendwo, da kann man hier in den Projekt-Settings

23:21.920 --> 23:31.760
unter Debug, kann man einstellen Enable Native Code Debugging, wenn man das eingestellt hat

23:31.760 --> 23:41.480
und an sein DirectX-Device hier die Option Debug dran steckt, dann, da wirds zwar ein

23:41.480 --> 23:49.080
bisschen langsamer bis man Debug wieder rausnimmt, aber dann wirft DirectX sinnvolle, und überraschend

23:49.080 --> 23:53.680
sinnvolle hab ich mich selbst gewundert, Fehlermeldungen, allerdings nicht auf die Konsole, sondern

23:53.680 --> 23:58.480
hier in dieses Output-Window, also wenn ihr mal irgendwas mit DirectX oder irgendwelche

23:58.480 --> 24:02.960
Windows-AP-Geschäfts macht, macht Native Code Debugging an und schaltet die Debuggeschichten

24:02.960 --> 24:09.720
hier für euer DirectX-Device ein, dann bekommt ihr zum größten Teil recht sinnvolle Fehlermeldungen,

24:09.720 --> 24:12.920
und so hab ich mich auch hier so ein bisschen ran getastet, zum Beispiel, ich hatte keine

24:12.920 --> 24:18.760
Ahnung, dass ich Flip-Discard verwenden muss für meine Swap-Chain anstatt Discard, weil

24:18.760 --> 24:24.400
ich weiß es nicht, weil nur das das supportete ist für dieses Szenario, weil man, ich weiß

24:24.400 --> 24:34.360
es nicht, aber Microsoft sagt das in der Fehlermeldung, so, ähm, ähm, achso, den Link, den Link kann

24:34.360 --> 24:42.640
ich dir geben, ja, du willst bestimmt jetzt deinen Cheat updaten, gibs zu, so, wo lernt

24:42.640 --> 24:49.840
man die Grundlagen von C, Youtube-Videos oder irgendwelche Bücher oder sonst was, wobei

24:49.840 --> 24:54.040
ich sagen würde, ich würde, also wenn du schon was programmieren kannst und was Low-Level-mäßiges

24:54.040 --> 25:00.320
machen willst, ist nicht verkehrt, mit, äh, sich das mal anzugucken, allerdings muss man

25:00.320 --> 25:10.120
sagen, einsteigen würde ich mit C auf keinen Fall, äh, Sebaru, ich hab probiert Quality-Settings

25:10.120 --> 25:20.000
zu kriegen, gar nicht funktioniert, so, ok, also, fangen wir mal an, die Magic kommt später,

25:20.000 --> 25:24.360
erst mal zur Erklärung, was am Anfang passiert, das ist relativ standard, DiamondX gedürzt,

25:24.360 --> 25:29.120
man erst, man erstellt eine Swap-Chain, eine Swap-Chain, das ist, DiamondX hat, also ich

25:29.120 --> 25:34.520
muss ja sagen, ich persönlich finde die OpenGL Sachen ein bisschen angenehmer benannt,

25:34.520 --> 25:39.320
vor allem wenn man sowas wie SDL oder irgendwie, äh, OpenTK oder sowas verwendet, das ist

25:39.320 --> 25:43.560
irgendwie ein bisschen griffiger, finde ich, als vieles DiamondX Zeug, wobei, das eigentlich

25:43.560 --> 25:47.680
nimmt sich nichts, dafür ist OpenGL viel, ähm, nerviger, weil man viel mehr selbst

25:47.680 --> 25:56.880
machen muss, ähm, naja, zumindest, als erstes muss man eine Swap-Chain-Description erstellen,

25:56.880 --> 26:02.760
damit man eine Swap-Chain erstellen kann, ähm, eine Swap-Chain ist im Prinzip eine,

26:02.760 --> 26:09.680
im Prinzip mehrere Buffer, die du, die du, die du austauschen kannst, das ist eigentlich

26:09.680 --> 26:14.640
alles was eine Swap-Chain ist, im Großen und Ganzen, du hast, du hast einen Buffer, da

26:14.640 --> 26:18.520
wird gerade, also das was da drinne ist wird angezeigt, und du hast in der Regel noch einen

26:18.520 --> 26:23.120
zweiten Buffer, da schreibst du dein Zeug rein, und wenn du fertig bist, dein, dein

26:23.120 --> 26:27.200
neues Bild reinzuschreiben, dann swapst du das Ganze, also sprich, den Buffer, den du

26:27.200 --> 26:32.560
gerade anzeigst, den schmeißt du weg, und zeigst deinen Buffer an, den du gerade reingeschrieben

26:32.560 --> 26:37.000
hast und swapst halt, ne, deswegen musst du auch hier einstellen, das Swap-Effekt, und

26:37.000 --> 26:43.200
in dem Fall muss, muss man, warum auch immer, weil Microsoft, muss man Flip-Discard verwenden,

26:43.200 --> 26:47.880
natürlich auch kein Hilfedext, warum, es gibt noch zig andere Varianten, das ist der

26:47.880 --> 26:53.800
Effekt, wenn man diese beiden Buffers switcht, also sprich, von dem Buffer, wo das angezeigte

26:53.800 --> 26:58.400
Bild ist, wenn ich dann switche zu dem Buffer, wo ich gerade reingerendert hab, ne, dann,

26:58.400 --> 27:02.480
aber in dem Fall muss ich Flip-Discard oder Flip-Sequential nehmen, weil das Microsoft

27:02.480 --> 27:08.480
gerne hätte, unterstützt wird aktuell generell wohl, so wie es aussieht, fast nur noch, Alpha-Mode

27:08.480 --> 27:12.840
pre-multiplied, da hab ich, ey, ohne Scheiß, da hab ich Stunden gebraucht für, bis ich

27:12.840 --> 27:16.440
gecheckt hab, aber das zeig ich euch gleich noch, zeig ich euch gleich noch, wie ich

27:16.440 --> 27:23.920
mein Gift transparent bekomme, also es gibt prinzipiell zwei verschiedene, Alpha-Modi,

27:23.920 --> 27:30.440
die DirectX, Direct2D und DirectX unterstützt, das ist einmal pre-multiplied und straight,

27:30.440 --> 27:37.280
der Unterschied ist im Prinzip relativ subtil auf den ersten Blick, weil die Anzahl der

27:37.280 --> 27:42.960
Bites sind die gleichen, also ein Pixel, ja, ein Pixel ist, besteht zum Beispiel, also

27:42.960 --> 27:51.840
man, ein, ein, genau, rot, ein roter Pixel, ja, ein roter Pixel sind erstmal drei Bites,

27:51.840 --> 27:59.640
erstmal drei Bites, und zwar die Bites 2, 5, 5, 0, 0, also hier, ne, erstes Bite 255,

27:59.640 --> 28:04.200
zweites Bite 0, drittes Bite 0, so, das ist erstmal ein roter Pixel, jetzt gibt's da

28:04.200 --> 28:12.480
zusätzlich noch ein viertes Bite, der sagt, ähm, wie transparent dieser Pixel ist, deswegen

28:12.480 --> 28:18.120
ist das normale, ist das sowas wie RGB, das hatte jeder schonmal gehört, und, ähm, RGB,

28:18.120 --> 28:22.120
das ist da quasi zwei, zwei Dinger, bringt's, falls ich irgendwelche Host Donations oder

28:22.120 --> 28:30.120
sonst was vergesse, spammt mich mal voll, weil ich hab wieder vergessen meine Alert-Dinger

28:30.120 --> 28:39.480
anzumachen, so, und, wenn man jetzt, das sind Alpha, äh, also, Alpha-Channel-Information,

28:39.480 --> 28:45.520
sprich, wie transparent der Pixel ist, 0 ist transparent, 255 ist komplett nicht transparent,

28:45.520 --> 28:49.840
also wenn ich sowas mache wie 100, dann ist das so halbtransparent, das muss natürlich

28:49.840 --> 28:55.200
das jeweilige Backend unterstützen, aber das ist eigentlich Standard heute, deswegen nennt

28:55.200 --> 29:03.920
sich das nicht mehr RGB, sondern RGBA, also sprich, rot, grün, blau, Transparenz, so,

29:03.920 --> 29:08.560
und intern, um die ganze Sache noch ein bisschen komplizierter zu machen, intern arbeitet DirectX

29:08.560 --> 29:19.720
bzw. Direct3D, äh, Direct2D, in dem Fall nicht mit RGBA, sondern mit BGRA, weil, wahrscheinlich

29:19.720 --> 29:24.160
weil's besser für das Speicherlayout von Grafikkarten ist oder so, ich weiß es nicht

29:24.160 --> 29:30.680
genau, ähm, zumindest intern verwenden sie das da, aber das macht im Prinzip keinen

29:30.680 --> 29:34.080
großen Unterschied, das ist im Prinzip einfach nur ein paar Sachen vertauscht, Alpha-Byte

29:34.080 --> 29:40.520
ist immer das letzte, so, und jetzt wollte ich ja erklären, was der Unterschied ist zwischen

29:40.520 --> 29:44.600
Pre-Multiplied und das braucht ihr immer, wenn ihr irgendwelche Grafikgeschichten macht,

29:44.600 --> 29:53.000
müsst ihr euch das merken, ähm, wie ist die Lage, sehr verwirrend ist die Lage, Windows

29:53.000 --> 29:58.600
Zeugs wieder am Start, also der Unterschied ist, den Hilfetext hier könnt ihr erstmal

29:58.600 --> 30:07.680
vergessen, also Pre-Multiplied, also fangen wir mal an, Straight, ja, jetzt, jetzt, äh,

30:07.680 --> 30:13.800
keine Feminism-Chokes oder sowas, also Straight bedeutet in dem Fall, die Pixel hier vorne

30:13.800 --> 30:24.520
stellen ganz klassisch Rot, Grün, Blau da, und nur der letzte, steht für die Transparenz

30:24.520 --> 30:32.120
von dem kompletten Pixel, so, Pre-Multiplied bedeutet, die Transparenz ist quasi hier

30:32.120 --> 30:37.120
vorne schon mit eingerechnet, ganz ehrlich, Vor- und Nachteile habe ich nicht so wirklich

30:37.120 --> 30:44.040
gecheckt, also ich weiß, im Hinterkopf ist mir schon lange klar, dass es das gibt, aber

30:44.040 --> 30:48.400
ich hatte damit noch nie Probleme, ähm, deswegen musste ich mir das heute erstmal angucken,

30:48.400 --> 30:53.160
was eigentlich auch der Unterschied ist, zumindest Pre-Multiplied bedeutet genau das, was da

30:53.160 --> 31:00.440
steht, nämlich, dass der Alpha-Wert schon eingerechnet ist in das normale RGB, das bedeutet

31:00.440 --> 31:04.440
Pre-Multiplied, so, und nachdem, und ich muss jetzt ein bisschen ausholen, sonst versteht

31:04.440 --> 31:09.600
man nämlich das eigentliche Problem bei der ganzen Sache gar nicht, nachdem jetzt quasi

31:09.600 --> 31:16.360
meine komplette Geschichte, die ich hier initialisiere am Anfang, zwingend dieses Format braucht

31:16.360 --> 31:24.240
für Pixel, also sprich, blau, grün, rot und Alpha-Channel und sein Alpha-Channel Pre-Multiplied

31:24.240 --> 31:28.400
haben will, also das geht einfach davon aus, das macht da keine Magic mehr oder so, also

31:28.400 --> 31:33.160
sprich, wenn der Pixel Pre-Multiplied nicht transparent ist, dann wird er einfach nicht

31:33.160 --> 31:38.760
transparent angezeigt, da kann mein Alpha-Channel noch so sehr auf Null stehen, das juckt ihn

31:38.760 --> 31:45.440
dann überhaupt nicht, ist dem vollkommen egal, und das heißt, ich kann meine normalen Bilder,

31:45.440 --> 31:51.280
sprich die einzelnen Frames vom GIF, nicht so einfach rendern, weil die sind nicht durchsichtig,

31:51.280 --> 31:55.840
und ihr seht ja, wenn man es hier anzeigt, hier sind sie durchsichtig, normalerweise

31:55.840 --> 32:05.400
hatte das immer weiß gerendert hier im Hintergrund, weil es nicht Pre-Multiplied war, so, aber

32:05.400 --> 32:09.520
noch mal ein Schritt zurück, wir müssen ja irgendwie diesen Inhalt, bevor wir Probleme

32:09.520 --> 32:13.920
überhaupt mit Transparenz oder sonstigen Dingern haben, wir müssen ja erstmal den ganzen Kram

32:13.920 --> 32:19.560
überhaupt in unser transparentes Fenster rein kriegen, und jetzt beginnt die Magic,

32:19.560 --> 32:22.760
also wir erstellen hier mal unsere Swap-Chain-Description, habe ich ja gerade erklärt, was die einzelnen

32:22.760 --> 32:29.160
Optionen machen, der Rest ist nicht so wichtig, Höhe, Breite noch, wie das Fenster halt ist,

32:29.160 --> 32:34.560
dann erstelle ich das DirectX-Device, muss ich sagen, ich nehme ja auch nochmal BGH-Support,

32:34.560 --> 32:40.400
das braucht man für Direct2D, wir wollen plus das neueste DirectX haben, weil wir halt krasse

32:40.400 --> 32:44.040
Checker sind und nur das neueste verwenden, geht wahrscheinlich mit älteren Sachen ganz

32:44.040 --> 32:51.880
genauso gut, so, dann speichern wir uns das hier in unserer Klasse, das DirectX-Device,

32:51.880 --> 32:56.200
dann kommt, jetzt kommt Magic, jetzt kommt übelste Magic, ich habe keine Ahnung, warum

32:56.200 --> 33:01.960
man das genau machen muss, jetzt braucht man irgendwie so ein DXGI-Device, danach muss man

33:01.960 --> 33:12.600
sich eine Factory erstellen von diesem DXGI-Device, danach kann ich mal eine Swap-Chain erstellen,

33:12.600 --> 33:16.120
das ist das, was ich vorhin erklärt habe, wo du deine Buffer switchen kannst mit, der

33:16.120 --> 33:20.800
braucht die Factory, die braucht das DXGI-Device und die Description, dass ihr weiß, was ihr

33:20.800 --> 33:25.520
für Settings haben soll, so, und jetzt, ich habe schon die Warnung hier reingeschrieben,

33:25.520 --> 33:31.000
jetzt kommt komplette Magic, weil, aktuell ist es so, ich habe ein Fenster erstellt, das

33:31.000 --> 33:38.040
ist transparent und hat keinen Hintergrund, das habe ich genauso gemacht, wie der Dude

33:38.040 --> 33:43.880
hier im Artikel, ich habe ein Fenster erstellt, was keinen Hintergrund hat, also kein, nein,

33:43.880 --> 33:52.200
was keine, was kein Bitmap quasi reserviert hat im Speicher von Windows, wo man überhaupt

33:52.200 --> 33:57.080
Content reinmalen könnte, also sprich, mit Windows-Bordmittel kann man in dieses Fenster

33:57.080 --> 34:03.440
nicht zeichnen, weil es keinen Buffer hat, gibt's nicht, ja, also, irgendwelche GDI-Dinger

34:03.440 --> 34:18.560
oder so von früher, das geht da nicht, das geht schreckt, nice, ähm, warum entwickelst

34:18.560 --> 34:23.560
du eigentlich nicht auf Linux, weil das, ähm, ziemlich Windows-Only hier ist, was ich gerade

34:23.560 --> 34:27.560
mache, deswegen mache ich es nicht unter Linux, weil das ist halt, gibt's halt unter

34:27.560 --> 34:38.520
Linux nicht, naja, zumindest, wo bin ich denn jetzt stehen geblieben, genau, absolute Magic,

34:38.520 --> 34:43.400
wie gesagt, das Fenster, das, auf das kann man nicht malen, auf dieses Fenster, mit,

34:43.400 --> 34:45.840
das ist genau das gleiche, wie der Typ hier im Artikel macht, plus, dass ich bei mir

34:45.840 --> 34:55.360
auch den Rahmen ausgeblendet hab, ähm, so, ja, mit Qt kannst du's machen, aber ich bringe

34:55.360 --> 35:00.880
mir in dem Fall auch nix, weil, ähm, das andere ist auch Windows-Only, das ist voll

35:00.880 --> 35:05.040
komisch, ja, ähm, und also mit Qt ist gar nicht so einfach, Qt ist ja erstmal standardmäßig,

35:05.040 --> 35:09.840
äh, also, du machst mit QML, ist es ja auch nicht großartig beschleunigt, das heißt,

35:09.840 --> 35:13.680
da müsste es mit OpenGL irgendwas passen, kein Nerv, wir sind eh relativ abhängig

35:13.680 --> 35:18.720
von Windows und dementsprechend, machen wir das jetzt mit DiamondX, dann ist es halt noch

35:18.720 --> 35:22.800
mehr Windows, na, also im Prinzip ist das das gleiche Fenster, wie der Typ im Artikel,

35:22.800 --> 35:40.800
ähm, so, und plus, dass ich den Rahmen ausgeblendet hab, ok, und jetzt kommt absolute Magic,

35:40.800 --> 35:44.960
ähm, nachdem wir ja, wie ich grad erklärt hab, hier nix reinmalen können auf klassische

35:44.960 --> 35:54.480
Art und Weise in dieses Fenster, müssen wir dem, was, wie heißt das eigentlich, korrekt,

35:54.480 --> 35:59.760
DWM, Desktop Window Manager wahrscheinlich, Dynamik Window Manager, ne, das ist das Linux-Ding,

35:59.760 --> 36:05.160
Windows, für was steht denn das hier überhaupt, der Desktop Window Manager, also sprich, das

36:05.160 --> 36:11.880
ist der Part von Windows, der dafür zuständig ist, ähm, so Sachen wie überlappende Fenster

36:11.880 --> 36:15.160
zu machen, halbtransparente, was ist denn ein halbtransparentes Fenster, gibt's sowas

36:15.160 --> 36:18.920
unter Windows 10, noch standardmäßig, kann man auf jeden Fall, auf jeden Fall machen,

36:18.920 --> 36:23.320
ja, also sprich, dass dieses Fenster über diesem Fenster ist, oder das, was haben wir

36:23.320 --> 36:27.880
denn hier, halbtransparentes, gibt's hier nichts, noch was halbtransparentes zum zeigen,

36:27.880 --> 36:31.680
zumindest ich, ich starte einfach jetzt mal mein Programm, ja, dass hier dieses Fenster

36:31.680 --> 36:36.080
da drüber ist, und dieses Fenster dafür, dafür ist dieser, dieser Desktop Window Manager

36:36.080 --> 36:44.080
zuständig, das heißt, nachdem unser Fenster jetzt kein Buffer hat, in dem wir malen können,

36:44.080 --> 36:50.560
müssen wir das Ganze quasi mit dem Desktop Window Manager in das Fenster malen, das ist

36:50.560 --> 36:55.560
das, was der Typ hier in seiner Anleitung beschreibt, wie das Ganze funktioniert, ach stimmt, der,

36:55.560 --> 37:04.120
der Calculator ist transparent, ja, richtig, oder auch, der, ich, ich gebe dir aber recht,

37:04.120 --> 37:07.400
der sollte eigentlich transparent sein, ich bilde mir auch an, dass der transparent ist,

37:07.400 --> 37:13.000
ich, ach, nee, weißt du was, warum das nicht transparent ist, weil ich Transparenz abgeschaltet

37:13.000 --> 37:17.360
hab, lull, ich hab Transparenz abgeschaltet, weil mir Transparenz auf den Keks gegangen

37:17.360 --> 37:29.280
ist, stimmt, ähm, der ist minimal transparent, ich glaube nicht, dass der transparent ist,

37:29.280 --> 37:35.480
hier ist nichts transparent, ich hab das abgeschaltet, aber guckt mal, hier unten die Taskleiste

37:35.480 --> 37:40.440
ist ein bisschen transparent, seht ihr's, da, ne, das macht alles der Desktop Window

37:40.440 --> 37:49.080
Manager, so, und mit dem müssen wir jetzt, mit, mit, mit Direct Composition, müssen wir

37:49.080 --> 37:55.800
in unser Fenster malen, wohlgemerkt, das hier ist immer noch ein transparentes Fenster,

37:55.800 --> 38:00.520
so, und ich hab keine Ahnung, was diese nächsten paar Dinger machen, aber sie funktionieren,

38:00.520 --> 38:04.600
die hab ich mir mehr oder weniger eins zu eins hier aus diesem C++ geschwuppelt, äh,

38:04.600 --> 38:12.080
ja, doch aus diesem C++ geschwuppelt, aus dem Artikel übersetzt nach Sharp DX, so, und

38:12.080 --> 38:16.920
was da jetzt passiert, ist folgendes, ähm, als erstes muss ich ein Direct Composition

38:16.920 --> 38:21.880
Device erstellen, aus meinem DXGI Device, warum, weiß nur Microsoft, ich hab keine

38:21.880 --> 38:26.240
Ahnung, muss man aber machen, als nächstes, und, ey, das ist, das ist die übelste Magic,

38:26.240 --> 38:32.880
also wirklich, ich weiß nicht, was da passiert, als nächstes muss ich, ähm, ein Target erstellen,

38:32.880 --> 38:40.760
ein, ein Direct Composition Target erstellen, ähm, was denn jetzt mit dem, irgendwie hör

38:40.760 --> 38:46.960
ich mich anders an, oder, äh, ich glaub, wartet mal, hatt ich grad einen Wackelkontakt

38:46.960 --> 38:53.040
oder so, ja, jetzt geht's wieder, vielleicht ist mein, vielleicht ist mein Gehirn auch

38:53.040 --> 39:00.040
einfach nur kaputt langsam, zumindest muss ich jetzt ein Direct Composition Target erstellen,

39:00.040 --> 39:07.360
von meinem Fenster, also von dem transparenten Fenster, den ihr nicht, das ist das, was man

39:07.360 --> 39:16.400
hier an der Stelle nicht sieht, ähm, ja, davon muss ich ein, ein, ein Direct Composition

39:16.400 --> 39:21.480
Target erstellen, mit Handle von meinem Windows Form, und dem muss ich das Direct Composition

39:21.480 --> 39:25.640
Device übergeben, danach muss ich, es wird, es wird immer abgedreht, ohne Scheiß, ich

39:25.640 --> 39:28.800
weiß, ich weiß wirklich nicht, was hier passiert, aber es funktioniert, danach muss

39:28.800 --> 39:35.000
ich ein Direct Composition Visual erstellen, wo ich dann das Composition Device reinstecke,

39:35.000 --> 39:40.200
weil das es wohl irgendwie braucht, und danach muss ich sagen, dieses Visual kriegt den Content

39:40.200 --> 39:45.440
von meiner Swap Chain, dann muss ich sagen, das Root Element ist dann das neue Visual,

39:45.440 --> 39:50.440
und dann muss ich das Ganze committen auf meinem Composition Device, und dann wird alles

39:50.440 --> 39:55.960
über den Desktop Window Manager, was ich hier in meiner normalen Direct X Swap Chain rendere,

39:55.960 --> 40:05.480
in meinen Fenster, beim Compositionen reingerendert, so, alter, ja, was auch immer, es ist komplett,

40:05.480 --> 40:19.440
hier, also es ist absolut für den Arsch, ja, dass das überhaupt so ein Riesenakt ist,

40:19.440 --> 40:21.960
aber zumindest ist es der einzige Artikel von Microsoft, den ich gefunden habe, der sich

40:21.960 --> 40:30.320
mit diesem Thema beschäftigt, und die sagen, so geht's, und es geht tatsächlich, und es

40:30.320 --> 40:39.840
ist schnell, es ist wirklich schnell, es ist schneller als dieses ganze Zeug, was man da

40:39.840 --> 40:44.040
zum Beispiel in irgendwelchen Cheat Foren findet, die auch Overlays machen wollen,

40:44.040 --> 40:49.480
das ist so um den Faktor 20% ungefähr schneller, also es ist schneller als Layered Windows

40:49.480 --> 41:00.880
mit Client-Area-Gedöns, also es ist wirklich schnell, das sieht man ja auch, Windows ist

41:00.880 --> 41:05.120
oft schwarze Magie, es ist wirklich komplett schwarze Magie, aber es funktioniert an der

41:05.120 --> 41:08.720
Stelle, und ich bin wirklich vordach, dass das Ganze funktioniert, weil es ist schnell,

41:08.720 --> 41:12.120
es ist transparent, und es funktioniert, man sieht hier, guck, ich kann hier durchklicken,

41:12.120 --> 41:16.240
eigentlich ist hier das Fenster, es ist Fenster drum herum, ich kann hier durchklicken, ohne

41:16.240 --> 41:24.440
Probleme hier, das einzige was verdeckt sind die Visual Studio Menüs, warum auch immer,

41:24.440 --> 41:32.040
aber damit kann ich leben, immerhin gibt es einen Artikel von Microsoft, das ist richtig,

41:32.040 --> 41:38.960
immerhin, immerhin, so, ja, und als nächstes zeige ich euch, was man machen muss, um das

41:38.960 --> 41:43.920
Bild transparent zu kriegen, weil wer gedacht hätte, damit ist die größte Hürde genommen,

41:43.920 --> 41:50.560
der hat sich wirklich getäuscht, aber vorher Leute, muss ich mal kurz aufs Klo, ich brauche

41:50.560 --> 42:12.760
mal einen Text hier, auf Klo, so, ich bin gleich wieder da, so, ich bin gleich wieder

42:12.760 --> 42:14.480
da.

42:42.760 --> 43:11.280
So, ich bin wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da, so,

43:11.280 --> 43:39.800
ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

43:39.800 --> 44:08.320
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

44:08.320 --> 44:36.840
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

44:36.840 --> 45:05.360
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

45:05.360 --> 45:33.880
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

45:33.880 --> 46:02.400
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

46:02.400 --> 46:30.920
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

46:30.920 --> 46:59.440
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

46:59.440 --> 47:27.960
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder da,

47:27.960 --> 47:46.040
so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder

47:46.040 --> 48:02.280
da, so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder

48:02.280 --> 48:20.040
da, so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder

48:20.040 --> 48:29.920
da, so, ich bin gleich wieder da, so, ich bin gleich wieder da, so, ich bin gleich wieder

48:29.920 --> 48:40.680
Gut, jetzt habe ich euch erklärt, wie man es schafft, quasi sein diode x Zeug in seinen

48:40.680 --> 48:45.720
Vendor zu rendern, das ist ja quasi das, was hier beschrieben ist, dazu gibt es immerhin

48:45.720 --> 48:50.400
noch einen Artikel, zu dem anderen, was ich euch jetzt zeige, wie ich das Bild überhaupt

48:50.400 --> 48:53.960
transparent gekriegt habe, gibt es keinen Artikel, aber ich vermute mal jeder, der sowas

48:53.960 --> 48:57.840
öfters macht, dem wird es wahrscheinlich halbwegs klar sein, wo das Problem gewesen

48:57.840 --> 49:06.920
ist. In der Pause, das 3DS, anvoxen mit dem Friseur, oh, das war noch Zeit, nein, das

49:06.920 --> 49:19.200
war noch, das ist schon ewig her, das war 2011 oder so. Poggers. Ok, weiter gehts. So,

49:19.200 --> 49:24.920
und jetzt kommt der nächste Knackpunkt, das Bild, was wir von unserem animierten GIF

49:24.920 --> 49:29.120
auslesen, also aktuell ist es nur das erste Bild, aber trifft für alle weiteren Bild

49:29.120 --> 49:36.680
natürlich auch zu, das hat einen Alpha Channel, also sprich, das hat eine Anzeige, das hat

49:36.680 --> 49:42.400
transparente Farbe, hier, außen drum, sieht man ja, weil das Bild ist transparent, aber

49:42.400 --> 49:49.080
das Ding wurde die ganze Zeit nicht transparent gerendert. Bis ich dann auf die glorreiche

49:49.080 --> 49:56.240
Idee gekommen bin, mir mal zu überlegen, warum das Ganze nicht funktioniert. Erstmal

49:56.240 --> 50:02.320
habe ich wild gesucht, Google und sonst was, so wie malt man ordentlich Bilder in Direct2D,

50:02.320 --> 50:07.640
aber ergibt zwar Anleitungen, aber so wirklich eine Beschreibung, wie ich transparente Bilder

50:07.640 --> 50:12.760
male, gibt es irgendwie nicht. Und das liegt einfach daran, dass Bilder, die den korrekten

50:12.760 --> 50:17.680
Alpha Channel haben, einfach standardmäßig transparent sind. Problem ist bloß, und deswegen,

50:17.680 --> 50:22.520
sonst nochmal zurückzukommen auf diese Geschichte hier, Problem ist nur, dass natürlich mein

50:22.520 --> 50:31.480
GIF, also der frame, der erste frame von diesem GIF, also das erste Bild von der GIF-Animation,

50:31.480 --> 50:35.320
das ist zwar im richtigen Farbformat, das sieht man ja auch, weil die Farben sind richtig,

50:35.320 --> 50:45.040
also sprich, das ist zwar im Format BGRA, allerdings, es ist Alpha Mode quasi straight

50:45.040 --> 50:50.080
und nicht pre-multiplied und deswegen hat ich die ganze Zeit hier, wo ich, ich hab mich

50:50.080 --> 50:54.760
kaputt gesucht, war der Hintergrund weiß und nicht transparent. Bis ich dann auf die

50:54.760 --> 50:59.720
glorreiche Idee gekommen bin, ich muss das Ganze einfach multiplied und dann gehts. Und

50:59.720 --> 51:04.800
wie man das macht, zeige ich euch jetzt mal schnell. Und danach fangen wir an, neue Sachen

51:04.800 --> 51:11.080
zu basteln bzw. das hier aufzuräumen und unser FFmpeg Zeug thread-sicher in eine eigene

51:11.080 --> 51:15.400
Klasse zu verpacken. So, also jetzt zeige ich euch, wie man das Ganze macht. Hier ist

51:15.400 --> 51:18.000
ganz viel Geschiss drin, was man eigentlich gar nicht mehr braucht. Ich hab übrigens

51:18.000 --> 51:21.840
meinen komischen FPS-Counter, hab ich weggeschmissen, wir machen das FPS hier in der Render-Loop

51:21.840 --> 51:27.280
drinne. Das ist im Prinzip noch das gleiche hässliche Kram vom letzten Mal, nix Neues

51:27.280 --> 51:37.640
dazu gekommen. FFmpeg, bla, GIF einlesen, weiteres Rennen hab ich übersprungen, wir

51:37.640 --> 51:45.600
lesen bloß den ersten, wir lesen bloß das erste Bild ein. Dann hab ich hier noch irgendwas,

51:45.600 --> 51:51.360
das brauchen wir gar nicht mehr, oder? Lol. Also, wie gesagt, der Code ist jetzt nicht

51:51.360 --> 51:56.160
wie 400 Zeilen lang, der ist danach wahrscheinlich noch 150 oder so. Den Scheiß können wir

51:56.160 --> 51:59.920
auch rausmachen, da wollte ich gucken, ob das auch im richtigen Farbformat ist. Prender,

51:59.920 --> 52:03.800
gibt es da noch? Der Prender, da bitt man Prender Tage, brauchen wir auch alles gar

52:03.800 --> 52:11.000
nicht mehr eigentlich. Ist eigentlich komplett overrated, den können wir schonmal löschen,

52:11.000 --> 52:19.160
der Prender. Der Name ist so geil, der ist mir nix eingefallen, der Prender, der Prender-Renderer.

52:19.160 --> 52:33.160
Ok, und jetzt kommt der Knackpunkt, wie kriegt man das Bild? Von straight zu pre-multiplied,

52:33.160 --> 52:38.440
und da gibt es was schönes, also entweder macht man das von Hand, das ist auch kein

52:38.440 --> 52:44.960
Ding, da muss man halt jeden Pixel mal dem Alpha-Value nehmen durch 255, dann hat man

52:44.960 --> 52:50.160
das ganze pre-multiplied. Aber, da gibt es schon was fertiges in DirectX, und zwar gibt

52:50.160 --> 53:00.160
es Effects. Und ein Effekt ist pre-multiply. Und pre-multiply funktioniert relativ einfach,

53:00.160 --> 53:06.160
kriegt man alles Effekt an, und als Input sagt man einfach hier dieses Bitmap. Und dann

53:06.160 --> 53:14.120
macht er das für ein, da wandelt er quasi den straight Alpha-Channel in pre-multiplied

53:14.120 --> 53:20.680
über alle Beis von jeweils den Pixel um. Und danach habe ich noch was gemacht, danach

53:20.680 --> 53:28.360
skaliere ich das Bild noch hoch auf die jeweilige Fensterbreite, mit dem richtigen Seitenverhältnis.

53:28.360 --> 53:35.280
Das ist gar nicht so kompliziert, das ist, hier kriege ich raus, Scale 1, Scale 2, warum

53:35.280 --> 53:44.080
heißt das so? Weil man weiß das nicht genau. Die Dinger können wir dann auch mal ordentlich

53:44.080 --> 53:56.240
nennen. Das ist der Effekt für die Transparenz, und das hier ist der Scale-Effekt. So, und

53:56.240 --> 54:00.200
ich gehe mal davon aus, dass er das halt ziemlich effizient in Hardware auf der Grafikkarte

54:00.200 --> 54:06.000
macht. Unten habe ich noch mal Scales. Die brauche ich aber wahrscheinlich nicht mehr.

54:06.000 --> 54:18.600
So. Und hier passiert jetzt das, was ich euch eben erklärt habe mit dem Bild. Der schreibt

54:18.600 --> 54:23.080
das Alpha, den Alpha-Channel um von straight zu pre-multiplied und skaliert das Ganze auf

54:23.080 --> 54:29.880
die, also in der passenden Seitenverhältnis auf das Fenster hoch. Das hat auch ewig gedauert,

54:29.880 --> 54:33.640
bis ich das raus gekriegt habe letztendlich. Das steht in keinem Guide und in sonst nichts

54:33.640 --> 54:39.960
drinne. Irgendwo. Kannste knicken. Aber es ist im Prinzip ganz logisch, wenn man sich

54:39.960 --> 54:44.040
das überlegt. Ich habe nämlich die ganze Zeit versucht, sowas hier zu machen. Ich wollte

54:44.040 --> 54:49.800
ihm nämlich sagen, alter mein Bitmap ist nicht pre-multiplied. Und wenn man das probiert,

54:49.800 --> 54:55.680
dann crash das Ganze, wie man hier sieht. Er macht nichts im Endeffekt. Weil eben in

54:55.680 --> 55:00.240
meiner Swap-Chain gar kein straight erlaubt ist. Und ich habe wirklich ewig rum probiert,

55:00.240 --> 55:05.000
bis ich dann mal so den Geistesblitz irgendwo hatte, ey wandel doch einfach mal dein straight

55:05.000 --> 55:09.760
in pre-multiplied um. Und seitdem funktioniert das Ganze und wird auch noch schön skaliert

55:09.760 --> 55:17.240
und ist dementsprechend, weil es wahrscheinlich auf der GPU läuft, auch relativ zackig. So.

55:17.240 --> 55:24.480
Und dann kommt im Prinzip das, was wir das letzte Mal auch gemacht haben. Das ist übrigens

55:24.480 --> 55:30.360
ganz wichtig, wenn man transparente Fenster malen will. Dann muss man hier sagen, man

55:30.360 --> 55:35.360
cleart den Background mit Null. Wenn man das nämlich nicht macht, wenn man zum Beispiel

55:35.360 --> 55:43.480
irgendwie sagt, keine Ahnung, color so blue oder so, dann ist der Hintergrund halt blau

55:43.480 --> 55:51.680
oder halt hellblau oder keine Ahnung. Indian Red oder sowas. Das will man ja nicht. Das

55:51.680 --> 55:57.920
heißt, man muss hier sagen, clear Null. Und dann ist es nämlich, dann ist das quasi

55:57.920 --> 56:02.640
halt durchsichtig, der Hintergrund. So. Und da ist ganz viel geschwummelt drin, was ich

56:02.640 --> 56:07.840
nicht brauche. Und das hier ist der eigentliche Kniff, wie man dann den ganzen Krempel rendert,

56:07.840 --> 56:14.120
wie man hier oben zusammengebastelt hat. Wir haben ja hier das Bild mit dem RGB-Werten

56:14.120 --> 56:18.840
vom GIF drinne. Dann haben wir hier die Effekte, die quasi das Premultiply und danach skalieren.

56:18.840 --> 56:23.680
Und hier kann man dann quasi sagen, mal das Bild, als Output nimmst du das Bild von den

56:23.680 --> 56:27.760
Effekten und dann kann man es auch ein bisschen verschieben. Das müssen wir übrigens gleich

56:27.760 --> 56:32.400
machen, weil das Bild ist, werden wir gleich sehen, wenn wir das Bild animieren, das Bild

56:32.400 --> 56:38.040
ist dann zwischenzeitlich ein bisschen abgeschnitten. Das ist da, das ist ein bisschen, nicht so

56:38.040 --> 56:41.320
praktisch. Das ist dann hier oben abgeschnitten und links und rechts ein bisschen abgeschnitten.

56:41.320 --> 56:46.280
Deswegen müssen wir hier sagen, dass wir das Ganze ein bisschen tiefer, tiefer setzen.

56:46.280 --> 56:50.320
Aber das machen wir dann, wenn es soweit ist. Guck, ich zeig's euch mal mit den FPS zum

56:50.320 --> 56:53.280
Beispiel. Wenn ich die direkt oben in der linken Ecke male, dann ist ein bisschen was

56:53.280 --> 57:01.520
abgeschnitten. Warum, bin ich mir noch nicht so ganz sicher. So. Und das war's im Prinzip

57:01.520 --> 57:09.040
schon. Und da hab ich gestern quasi fast den ganzen Tag noch dran rum probiert, bis ich

57:09.040 --> 57:13.200
das auf die Reihe gekriegt hab. Es ist wirklich, es sieht jetzt relativ simpel aus, aber es

57:13.200 --> 57:16.480
war wirklich übelst kompliziert. So, und jetzt werden wir den ganzen Scheiß ein bisschen

57:16.480 --> 57:23.720
aufräumen und einen ordentlichen GIF-Decoder-Buzzle mit FFM-Pack, der nicht hier quasi alles

57:23.720 --> 57:27.160
versorgt. Wir löschen erstmal alle möglichen Dinge, die wir nicht mehr brauchen, weil ich

57:27.160 --> 57:34.480
mein, offensichtlich, es läuft ja gerade. Es läuft ja gerade, also sprich, warum, also

57:34.480 --> 57:41.800
brauchen wir ja anscheinend von dem ganzen Kram nichts, der hier drinne steht. Ganzes

57:41.800 --> 57:58.400
Kommentar soll ich rauslöschen. So, meinen Magic-Hinweis kann ich auch löschen. Debug-Mode

57:58.400 --> 58:11.000
hab ich weg. Der ganze Mist hier oben kann auch weg. Das kann auch weg. Das brauchen

58:11.000 --> 58:20.240
wir aber auch alles nicht mehr. Das hier brauchen wir noch, sonst gehts nämlich nicht. So, siehste,

58:20.240 --> 58:24.640
allein durch das löschen sind wir jetzt schon mal 100 Zeilen Code weniger. Jetzt werden

58:24.640 --> 58:31.040
wir noch dieses ganze FFM-Pack Zeug auslagern und ich überleg grad, wo wir da am besten

58:31.040 --> 58:37.840
mit anfangen. Also erstmal sollten wir gucken, ob das hier unten schon halbwegs sinnig ist.

58:37.840 --> 58:47.640
Wir zählen am Anfang unsere FPS, ok. Wir skalieren. Copy-for-memory für das Bitmap,

58:47.640 --> 58:52.800
das müssen wir dann später in der Schleife machen. Also sprich, das müssen wir später

58:52.800 --> 59:08.640
müssen wir das hier machen, weil wir updaten ja pro Durchgang unser Bild. Ey, jetzt ist

59:08.640 --> 59:16.640
es nicht mal skaliert. Hab ich irgendwas zu viel gelöscht? Monkeys. Ach nee, ich mach

59:16.640 --> 59:23.560
das andere auch noch außerhalb von der Schleife. Ja, das ist kein Wunder, dass das jetzt noch

59:23.560 --> 59:43.200
nicht... Moment, was hab ich jetzt gemacht? Was hab ich jetzt gemacht? Ich hab doch gar

59:43.200 --> 59:51.640
nichts geändert. Warum ist das Bild jetzt kleiner? Ah, ich weiß warum. Weil ich die

59:51.640 --> 59:58.960
Größe gelöscht hab, was natürlich Blödsinn ist. Die sollte ich mal lieber da lassen.

59:58.960 --> 01:00:06.760
So. Jetzt wird er ordentlich gross. Ja gut, manchmal muss man sich auch nicht wundern,

01:00:06.760 --> 01:00:15.280
oder? Höhe, Breite. Alles gut. So, und ich würd sagen, wir fangen jetzt mal damit an,

01:00:15.280 --> 01:00:21.600
das ganze FFMPEG Zeug auszulagern in eine eigene Klasse. So, den Max-FPS-Counter können

01:00:21.600 --> 01:00:25.160
wir löschen, den brauchen wir nicht mehr. Wir counten das jetzt in der Schleife drin.

01:00:25.160 --> 01:00:38.320
Es ist relativ einfach, ja. Wir gucken, wann wir angefangen haben von der Zeit her. Dann

01:00:38.320 --> 01:00:45.800
gucken wir, was für eine Zeit jetzt ist, und dann gucken wir quasi, wenn jetzt größer

01:00:45.800 --> 01:00:56.360
ist als Startzeit plus eine Sekunde. Dann ist halt eine Sekunde rum. Dann gucken wir,

01:00:56.360 --> 01:01:00.200
wieviel FPS wir gezählt haben, schreiben sie in FPS und setzen die Frameset auf Null.

01:01:00.200 --> 01:01:14.360
Also, eigentlich recht einfach. Ja, TheraFox sagt hier nicht, dass es hier nicht nur Optimierungspotenzial

01:01:14.360 --> 01:01:35.360
gibt. Genau, so. Jetzt weiter im Text. Also, wir machen jetzt eine Klasse für den FFMPEG,

01:01:35.360 --> 01:01:40.480
für den GIF-Decoder, dass es hier ein bisschen aufgeräumt ist. So, das Ding nennen wir auch

01:01:40.480 --> 01:01:57.240
ganz billig. GIF-Decoder. Das ist noch übrig. What the fuck? Wir schreiben das jetzt einfach.

01:01:57.240 --> 01:02:13.840
GIF-Decoder. Do you want to check the file and replace it? Yes. Schreckt. Okay, also,

01:02:13.840 --> 01:02:23.040
wir machen jetzt einen GIF-Decoder, und was das Ding auf jeden Fall braucht, ist den Dateiname

01:02:23.040 --> 01:02:29.000
von der Datei, die wir wiedergeben wollen. Ich meine, wie soll das Ding was decoden können

01:02:29.000 --> 01:02:36.280
aus der Datei, wenn es nicht weiß, ob es decoden soll? Also, irgendwie logisch, wenn er nicht

01:02:36.280 --> 01:02:41.920
weiß, wo das GIF ist, kann er ja auch schlecht. Das seht ihr ja auch hier. Also, ich muss

01:02:41.920 --> 01:02:46.320
ja irgendwo das GIF angeben, wo es liegt. So, also, wir brauchen auf jeden Fall für

01:02:46.320 --> 01:02:53.400
unseren GIF-Decoder, brauchen wir den Pfad, wo das GIF liegt, und wir machen mal so eine

01:02:53.400 --> 01:02:58.920
Variable, die nennen wir irgendwie Loop, und die ist standardmäßig, keine Ahnung, was

01:02:58.920 --> 01:03:04.640
standardmäßig ist, also sprich, der soll das GIF in Endlosschleife basteln. Und wir

01:03:04.640 --> 01:03:08.880
werden es jetzt ganz am Anfang, wir werden am Anfang keines Leaps oder sonst was einbauen.

01:03:08.880 --> 01:03:15.520
Wir gucken einfach mal, wie schnell man das GIF, wie gesagt, mein Hirn ist schon komplett

01:03:15.520 --> 01:03:19.800
matsch heute, wie schnell man das GIF quasi rendern kann, wie oft wir das in der Sekunde

01:03:19.800 --> 01:03:27.120
hinkriegen in Endlosschleife, also in Animationsschleife, von Anfang bis Ende, von Ende bis Anfang,

01:03:27.120 --> 01:03:30.880
von Anfang bis Ende, also wie oft wir einfach das GIF loopen können pro Sekunde. Mal schauen.

01:03:30.880 --> 01:03:42.280
Genau, so, jetzt gruppieren wir uns mal den ganzen Krempel, den wir hier quasi in unserer

01:03:42.280 --> 01:03:46.840
Renderfunktion trennten, gruppieren wir uns jetzt erstmal in unseren GIF-Decoder, weil

01:03:46.840 --> 01:03:55.720
es sollte später so sein, dass die ganze Winno-Klasse, diese ganze Formklasse überhaupt nichts mehr

01:03:55.720 --> 01:04:00.680
von FFmpeg weiß und wissen muss. Das ist eigentlich Sinn und Zweck der Sache. Alles

01:04:00.680 --> 01:04:20.360
mit FFmpeg machen wir hier drin. Achso, unsave, das ganze muss unsave sein und das unsave

01:04:20.360 --> 01:04:24.960
können wir dann hier wieder raus machen, wenn wir fertig sind, weil unsave, weil Pointer

01:04:24.960 --> 01:04:32.960
und Gedöns, ne. So, dann brauchen wir jetzt den Initialisierungscode von hier, also Format-Context,

01:04:32.960 --> 01:04:37.280
wir kopieren uns das jetzt einfach mal rüber. Es kommt in Constructor von unserem GIF-Decoder

01:04:37.280 --> 01:04:41.280
rein, weil es ist ja im Prinzip ganz logisch, wenn das Ding angelegt wird, wenn irgendein

01:04:41.280 --> 01:04:46.400
GIF-Decoder anlegt, dann lese ich die Datei ein und lege so die Sachen an, die ich brauche,

01:04:46.400 --> 01:04:50.600
damit ich, wenn man play drückt oder wenn man abspielen will das GIF, dass schon alles

01:04:50.600 --> 01:04:57.400
geladen ist. So, dann nehmen wir das hier, das müssen wir ein bisschen anpassen, weil

01:04:57.400 --> 01:05:03.360
das ist jetzt kein hardcoded Fahrt mehr, sondern der Fahrt den ich übergebe. So viel Setup

01:05:03.360 --> 01:05:12.480
für eine von außen einfache Sache. Richtig. Richtig. Es sieht super simpel aus, ne, ein

01:05:12.480 --> 01:05:17.480
paar GIFs abzuspielen quasi als Overlay über allen anderen Fenstern. Wenn irgendeiner

01:05:17.480 --> 01:05:22.920
sagt, ey, zeig mal ein GIF an quasi als Overlay, dann denkt man doch, ey, das ist kein Akt.

01:05:22.920 --> 01:05:25.480
Wahrscheinlich gibt es auch ein paar Programme für, wie man das machen kann. Es gibt ja

01:05:25.480 --> 01:05:29.400
viele Programme, die quasi Top-Moused-Windows setzen können und auch noch manche Fenster

01:05:29.400 --> 01:05:33.800
transparent machen können und so. Aber das wirklich richtig zu machen, ordentlich und

01:05:33.800 --> 01:05:38.800
schnell zu machen, es ist tatsächlich gar nicht so ohne. Würde man gar nicht denken.

01:05:38.800 --> 01:05:46.160
So, wir kopieren uns unseren ganzen FFM-Pack-Code rüber, den wir schon das letzte Mal gebastelt

01:05:46.160 --> 01:05:52.000
haben, von dem wir wissen, dass er funktioniert. Hier lesen wir ein Dateiformat, also sprich,

01:05:52.000 --> 01:05:55.800
was es ist, wie viele Frames es hat, also wie viele FPS es hat, wie lang es ist und so

01:05:55.800 --> 01:06:02.120
was. Dann brauchen wir den Krempel hier noch. Mal gucken, bis wann wir alles in Constructor

01:06:02.120 --> 01:06:07.440
packen. Oder wann in die Play-Methode. Oder wie nennen wir sie? Decode nennen wir sie.

01:06:07.440 --> 01:06:24.360
Play. Play wäre für den Decoder ziemlich blöd. Find-Decoder, Decoder, Blah, Package. So,

01:06:24.360 --> 01:06:34.360
mehr brauchen wir erstmal nicht. Jetzt ist der Kram hier alles initialisiert. Packages

01:06:34.360 --> 01:06:40.160
und Stream werfe ich weg. Das machen wir später. Legen wir das neu an, weil das brauchen wir

01:06:40.160 --> 01:06:45.880
bloß in der Methode, wo wir dann auch unser GIF-Decode, die brauchen wir nicht global.

01:06:45.880 --> 01:06:53.960
So, und jetzt können wir eigentlich schon anfangen, das Ganze zu rendern. Stream. Äh,

01:06:53.960 --> 01:07:05.080
ups, hab ich den aus Versehen gelöscht. Hab ich aus Versehen gelöscht. Wollte ich

01:07:05.080 --> 01:07:12.920
gar nicht. Ich wollte Package löschen, Package und Frame löschen und nicht Stream. So, ok.

01:07:12.920 --> 01:07:30.880
Können wir das hier irgendwie ein bisschen schöner schreiben? So. So. So, ha, das sieht

01:07:30.880 --> 01:07:36.440
ganz gut aus. Ok, ich versuche immer so, die Sachen immer so, dass die logisch zusammengehören,

01:07:36.440 --> 01:07:39.160
so einen Block stehen zu lassen, eine Leerzeit dazwischen zu machen. Das ist ein bisschen

01:07:39.160 --> 01:07:44.280
persönliche Ansicht, wie es einem am besten gefällt. So, und jetzt braucht man als nächstes,

01:07:44.280 --> 01:07:47.240
also wir machen uns jetzt eine, ich zeige euch jetzt mal, wie man das Ganze thread-sicher

01:07:47.240 --> 01:07:51.120
macht. Ich hab dann nämlich schon so eine Idee, wie wir das machen. Das heißt, an der

01:07:51.120 --> 01:07:58.040
Stelle legen wir jetzt einen neuen GIF-Decoder an und übergeben dem mal einen hardcoded-Fart

01:07:58.040 --> 01:08:09.920
wieder. Und zwar, was nehmen wir denn mal? Komm, wir nehmen, wir nehmen, wir nehmen wieder

01:08:09.920 --> 01:08:22.000
den Papagei, der Papagei ist schon ok. Mit dem, mit dem Dateipfad im Constructor musst

01:08:22.000 --> 01:08:34.440
du für jede Datei einen eigenen Instanz erstellen. Ja, das will ich aber auch so. So, Decoder,

01:08:34.440 --> 01:08:41.880
so jetzt brauchen wir sowas wie, wir brauchen einen Task, damit wir das Ganze quasi in einem

01:08:41.880 --> 01:08:45.960
eigenen Thread laufen lassen können, das decoden. Müssen wir ja letztendlich, wir wollen ja

01:08:45.960 --> 01:08:51.600
unser, unser GUI Zeug nicht blocken, was nicht unbedingt sein muss. So, dann machen wir eine

01:08:51.600 --> 01:08:58.960
Methode, ich kann nicht rein, irgendwie decode, ne, ne, ne, wir nennen das alles, wir nennen

01:08:58.960 --> 01:09:03.040
das Start, aber wir machen, oh, ich hab eine Idee. Wir machen das jetzt richtig pro, wir

01:09:03.040 --> 01:09:06.720
machen das jetzt richtig pro, pass mal auf. Jetzt, jetzt zeig ich euch mal was, jetzt

01:09:06.720 --> 01:09:13.640
kommt hier wirklich high IQ Proggerskills an, Schatz. Also wir machen, wir machen eine Start-Methode,

01:09:13.640 --> 01:09:19.320
vorher sagen wir uns im Constructor auch Task, irgendwie New Task und dann brauchen wir noch

01:09:19.320 --> 01:09:26.040
eine Methode, die der Task ausführt und das wird die Methode decode, decode decode, werden

01:09:26.040 --> 01:09:32.280
wir jetzt gleich nochmal einfügen lassen. So, wunderbar und in Start machen wir nix

01:09:32.280 --> 01:09:39.200
anderes als das Task, äh, Start. Soweit, so gut, erstmal relativ einfach. So, und jetzt

01:09:39.200 --> 01:09:46.920
waren wir in Trick 17, jetzt waren wir in Trick 17. Ähm, ich, wir müssen, wir müssen

01:09:46.920 --> 01:09:52.000
danach nochmal gucken, ich hab nämlich im Hinterkopf, dass es irgendwie mit C-Sharp bzw. mit irgendwie

01:09:52.000 --> 01:09:56.400
einem der letzten.NET Updates was gab, um das noch schöner zu machen. Vielleicht weiß

01:09:56.400 --> 01:10:00.920
da ja einer was von euch und zwar, von der Idee her machen wir das jetzt so, wir haben

01:10:00.920 --> 01:10:06.640
ja hier einmal unseren, nennen wir es mal GUI Thread, also sprich das Ding, wo Diode

01:10:06.640 --> 01:10:13.920
X drinne läuft, haben wir hier unser Diode X Zeug und das hier, das Decode von dem GIF

01:10:13.920 --> 01:10:19.640
läuft in einem separaten Thread ab. Und jetzt ist es ja so, ich muss ja irgendwie, dieses

01:10:19.640 --> 01:10:24.840
Dis, ja ich mach das gerne. Es gibt Leute, die machen dann so Dinger hier wie, äh, Private,

01:10:24.840 --> 01:10:34.200
blub, gleich eins, so, so Dinger, ja. Also, so Dinger machen viele gerne. Aber ich mag

01:10:34.200 --> 01:10:40.640
ehrlich gesagt, äh, das lieber, wenn meine Klassen-Dinger quasi meine Instanzvariablen

01:10:40.640 --> 01:10:45.200
halt nicht Unterstrich haben und ich jedes Mal ein This davor schreibe. Das ist komplett

01:10:45.200 --> 01:10:52.240
Geschmackssache, kann jeder machen wie er will. Und, ähm, ein Task ist nicht zwangsläufig

01:10:52.240 --> 01:10:56.240
ein neuer Thread, das stimmt, aber in der Regel ist das ein neuer Thread und zwar im

01:10:56.240 --> 01:11:02.040
Standard Threadpool, den es halt so gibt. Und es sei denn, man macht den Task mit Long

01:11:02.040 --> 01:11:08.000
Running, dann ist es ein eigenständiger Thread. Ansonsten ist ein Task in der Regel aber ein

01:11:08.000 --> 01:11:14.480
anderer neuer Thread. Miint, ja, okay, man kann es natürlich immer noch weiter, weiter

01:11:14.480 --> 01:11:28.360
versauen, ja. Es ist aber Geschmackssache. In welchem Fall ist denn ein neuer Task, in

01:11:28.360 --> 01:11:35.720
welchem Fall ist denn ein Task kein neuer Thread? Mir fällt jetzt da gar nicht so viel

01:11:35.720 --> 01:11:44.520
ein, ehrlich gesagt. Ich muss jetzt mal Backup mit ein paar Beispielen. Der sagt ja auch

01:11:44.520 --> 01:11:50.200
sogar hier irgendwo, dass, ähm, das standardmäßig halt im Threadpool läuft, dass es Default

01:11:50.200 --> 01:12:14.760
ist. Guck. Was, wenn der Main Thread nicht blockiert ist, dann ist es... Achso, ja. Ist

01:12:14.760 --> 01:12:26.280
das so. Also ich dachte eigentlich, dass standardmäßig, wenn du einen Task anwirfst, dass das immer

01:12:26.280 --> 01:12:31.120
in den Standard Threadpool geworfen wird. Steht doch sogar da. Use Specific Work to Run

01:12:31.120 --> 01:12:38.760
on Threadpool and Return Task Object. Oder ist es ein Unterschied zwischen Task Run und

01:12:38.760 --> 01:12:52.280
New Task? Zumindest läuft es parallel. Wir blockieren nichts, das ist ja das Wichtige

01:12:52.280 --> 01:13:22.200
an der Stelle.

01:13:22.200 --> 01:13:33.320
Das stimmt natürlich, der nimmt irgendwas, was frei ist. Es geht aber hauptsächlich

01:13:33.320 --> 01:13:38.280
darum, quasi den Kram nicht zu blockieren und das erreichen wir auf jeden Fall. So,

01:13:38.280 --> 01:13:44.120
ähm, genau. Decode, bla, bla, start. So, und jetzt in unserer Decode Methode werden wir

01:13:44.120 --> 01:13:48.560
uns die einzelnen Bilder aus dem GIF rausholen. Jetzt war er Trick 17. Ich hatte nämlich

01:13:48.560 --> 01:13:53.000
gerade eine gute Idee. Und das kann sein, dass es, wie gesagt, in C-Sharp 7 oder in

01:13:53.000 --> 01:13:58.040
ein oder neuen.NET Versionen noch was Besseres gibt. Ich bild mir ein, dass ich irgendeinen

01:13:58.040 --> 01:14:01.920
Vortrag von der letzten Bild oder der vorletzten Bild gesehen hab, wo sie genau was zu diesem

01:14:01.920 --> 01:14:06.480
Thema erzählt haben. Ist das hier noch immer das Meme Board? Ja, es wird weiter verbessert.

01:14:06.480 --> 01:14:11.280
Und zwar aktuell hast du das Problem, wenn du auf GIFs drückst, hast du ja gerade das

01:14:11.280 --> 01:14:15.800
Klicken gehört, das dauert ewig. Wir basteln jetzt unser eigenes GIF Overlay, dass das

01:14:15.800 --> 01:14:19.760
schneller geht. Und das, das, das wird auch deutlich schneller gehen. Geht ja jetzt schon

01:14:19.760 --> 01:14:26.200
schneller. Viel, viel schneller. Braucht anstatt 58 MB nur 80 MB. Ähm, genau, wir machen

01:14:26.200 --> 01:14:35.400
jetzt, pass mal auf, jetzt kommt's hier, jetzt, äh, wir nehmen jetzt eine Blocking Collection

01:14:35.400 --> 01:14:44.280
und zwar von AV Frame. Wir nennen das Ganze Frames. So, Default Value. Das ist, das ist

01:14:44.280 --> 01:14:48.840
auch ein schönes neues, ich glaube, Sie schreiben sieben Feature. Du kannst jetzt sagen, ey,

01:14:48.840 --> 01:14:53.640
ähm, dieses Property hat nur einen Getter, also sprich, du kannst da nichts Neues reinschreiben.

01:14:53.640 --> 01:14:59.800
Ähm, also keine, keine neue Collection zuweisen, aber du kannst einmal zum Initialisieren hier

01:14:59.800 --> 01:15:08.240
was reinschreiben. Sonst müsstest du das halt hier im Constructor machen. So, ähm,

01:15:08.240 --> 01:15:12.400
und Blocking Collection hat eine ganz schöne Eigenschaft. Erstens, das Ding ist Red Sicher.

01:15:12.400 --> 01:15:19.800
Und das Zweite ist, es hält quasi, es blockiert die andere Seite, wenn nicht, wenn nicht genug

01:15:19.800 --> 01:15:23.920
Bilder da sind. Wir probieren das jetzt mal aus, mal gucken, ob das das ist, was wir haben

01:15:23.920 --> 01:15:28.720
wollen. Und ich denke aber mal, dass wir ziemlich schnell in der Lage sind, neue Giftbilder

01:15:28.720 --> 01:15:32.920
zu decoden und dass wir auch ziemlich schnell in der Lage sind, Sachen zu rendern. Und eine

01:15:32.920 --> 01:15:37.440
Sache müssen wir noch machen, man kann nämlich der Collection angeben, dass wir maximal

01:15:37.440 --> 01:15:43.400
100 Items queuen wollen. Weil, sonst hätten wir den Fall, ähm, mal genommen, wir hätten

01:15:43.400 --> 01:15:52.760
einen riesen GIF und unser GIF decoded viel, viel schneller als wir es rendern können,

01:15:52.760 --> 01:15:58.480
würde das hier quasi voll laufen mit neuen, neuen Bildern. Deswegen sagen wir, ey, 100

01:15:58.480 --> 01:16:03.560
Bilder im Voraus berechnen ist erstmal genug, es ist kaum ein GIF mit 100 Bildern finden,

01:16:03.560 --> 01:16:07.720
äh, mehr als 100 Bilder im Voraus berechnen ist genug, im Zweifelsfall dann block halt

01:16:07.720 --> 01:16:14.680
hier dein Decoding so lange, bis eins abgearbeitet ist. Und auf der anderen Seite sollte das hier

01:16:14.680 --> 01:16:24.920
leer sein, dann blockt das Rendern, was wir auch in einem separaten Task laufen lassen,

01:16:24.920 --> 01:16:31.600
blockt das Rendern vom DirectX. Sollte hier nichts drin sein. Und da müssen wir uns nicht

01:16:31.600 --> 01:16:36.400
um irgendwelche Fälle kümmern mit, es ist nichts da, es ist null drinne, es kackt ab

01:16:36.400 --> 01:16:40.920
oder sonst was in der Richtung. Es hängt dann einfach bis auf beiden Seiten irgendwie

01:16:40.920 --> 01:16:46.040
was drinne ist. So, und das heißt in unserem Decode lesen wir jetzt die einzelnen Bilder

01:16:46.040 --> 01:16:53.400
vom GIF aus und schreiben dann die Bilder in diese Collection rein. Soweit, soweit zu

01:16:53.400 --> 01:17:01.640
gut. Ähm, also von der Idee her haben wir dann sowas hier wie, an der Stelle brauchen

01:17:01.640 --> 01:17:14.720
wir hier Frame, so haben wir den Decoder, Decoder, Decoder, Frames, Take, so. Und an

01:17:14.720 --> 01:17:19.080
der Stelle ist es jetzt so, wenn hier nichts drinne ist in Frames, weil unser GIF Decoder

01:17:19.080 --> 01:17:24.040
angenommen zu lahm ist, dann würde es an der Stelle blockieren und nicht weiter rendern,

01:17:24.040 --> 01:17:29.640
bis das, ähm, bis was drinne ist. Das heißt, ohne es ist thread-sicher, das ist natürlich

01:17:29.640 --> 01:17:35.080
ultra praktisch, das heißt ich muss mich hier um nichts kümmern. Moin, du hast doch immer

01:17:35.080 --> 01:17:39.120
noch deinen Server zuhause, wie hast du den gegen Angriffe von außen abgesichert mit

01:17:39.120 --> 01:17:45.120
einer Firewall und TLS oder, ähm, es gibt keine Zugriffe von außen. Deswegen muss

01:17:45.120 --> 01:17:57.600
ich da auch nichts absichern. Das einzige, was es gibt, ist, ähm, ein OpenVPN. Das ist

01:17:57.600 --> 01:18:01.400
das einzige, was es gibt. Aber ansonsten, es gibt keine wirklichen Zugriffe von außen,

01:18:01.400 --> 01:18:05.400
deswegen muss ich ja auch nichts großartig absichern. Und mein Nextcloud und das ganze

01:18:05.400 --> 01:18:12.040
Zeug, das ist quasi nur intern verfügbar oder wenn man per VPN angemeldet ist. Also

01:18:12.040 --> 01:18:15.160
sprich, das funktioniert dann auch nur von meinen Geräten aus, wo ich auch ein VPN

01:18:15.160 --> 01:18:25.320
drauf installieren kann. Ansonsten, äh, fragst du, weil du selbst was absichern willst, also

01:18:25.320 --> 01:18:29.880
ich kann dir erzählen, wie ich das machen würde, wenn ich es von außen erreichbar

01:18:29.880 --> 01:18:43.600
würde. So, ähm, DecoderFramesTake, TakeFrame, das ist ein AV-Frame. So, und jetzt können

01:18:43.600 --> 01:18:48.840
wir den ganzen Krampel hier löschen. Den brauchen wir drüben in unserer Decode-Methode

01:18:48.840 --> 01:19:01.120
drin. Ähm, so, Frame, Frame, das muss den ganzen Krampel ersetzen. Die ganzen Pointers

01:19:01.120 --> 01:19:09.880
ersetzen durch Punkte. Und wir dürfen nicht vergessen, den Frame wieder aufzuräumen.

01:19:09.880 --> 01:19:21.720
Dann ist MemoryLeak des Todes angesagt. Okay, so weit so gut. Gucken wir mal, ob das jetzt

01:19:21.720 --> 01:19:27.200
prinzipiell funktioniert. Also, wir decoden den ganzen Krampel, blablabla, Frame, Packet.

01:19:27.200 --> 01:19:32.920
Also, müssen wir hier ein neues Packet pro Durchlauf anlegen. Sagen wir hier, Packet

01:19:32.920 --> 01:19:45.800
gleich new AV-Packet. Und sagen Frame gleich new AV-Frame. So, blablabla, Add. Achso, ja,

01:19:45.800 --> 01:19:53.760
genau, dann müssen wir Referenz übergeben. Und sagen Add Frame. So, und jetzt gucken

01:19:53.760 --> 01:20:00.120
wir mal, ob es funktioniert. Es sollte eigentlich jetzt immer noch der Vogel rauskommen. Macht

01:20:00.120 --> 01:20:06.160
er aber nicht. Okay, da habe ich einen, achso, ich muss das Ganze noch starten. Haha, haben

01:20:06.160 --> 01:20:17.680
wir noch nicht gestartet. Decoder, Start. Kann ja nicht funktionieren. Bam! Es nimmt,

01:20:17.680 --> 01:20:29.320
es nimmt Formen an, Leute. Es nimmt Formen an. Was wird denn das, wenn es fertig ist?

01:20:29.320 --> 01:20:34.400
Das wird ein Gift-Player, der schneller ist als der normale WPF-Gift-Player. Guck hier,

01:20:34.400 --> 01:20:40.000
klick, wie lang das braucht. Und meiner ist dann der High-Speed-Gift-Player mit 6000 FPS

01:20:40.000 --> 01:20:50.520
die Sekunde. Wie im Titel steht, der schnellste Gift-Player der Welt wird das. Also, Woosa,

01:20:50.520 --> 01:20:55.200
wäre cool, wenn du uns mal erzählen willst. Also, wenn ich von außen was verfügbar machen

01:20:55.200 --> 01:21:01.040
würde, das Beste, was du machst, ist natürlich erstmal VPN, da gibt es relativ wenig Probleme.

01:21:01.040 --> 01:21:05.200
Das nächste sind Client-Zertifikate, auch immer wunderbar. Allerdings möchtest du

01:21:05.200 --> 01:21:08.680
das oftmals von außen zugänglich machen, ohne dass der andere eine Zeremonie abziehen

01:21:08.680 --> 01:21:17.280
muss, dass er darauf zugreifen kann. Und da ist das einfachste, also erstmal brauchst

01:21:17.280 --> 01:21:21.000
du ein paar Zertifikate. Wenn du das Ganze verschlüsselt machen willst, da empfiehlt

01:21:21.000 --> 01:21:26.600
sich Let's Encrypt und ich würde nie meine Anwendung direkt Port weiterleiten oder direkt

01:21:26.600 --> 01:21:31.960
freigeben in der Firewall. Ich würde das Ganze immer über, wenn es HTTP ist, aber das meiste

01:21:31.960 --> 01:21:38.640
ist ja HTTP, würde ich das über den Reverse-Proxy laufen lassen, dann nehme ich meistens EngineX

01:21:38.640 --> 01:21:43.160
für, aber es gibt auch zig andere Sachen, die du da verwenden kannst. Ich verwende

01:21:43.160 --> 01:21:47.600
meistens EngineX für, EngineX und Let's Encrypt mit Zertport funktioniert auch wunderbar

01:21:47.600 --> 01:21:53.200
zusammen, dann hast du quasi einen EngineX zwischen deinem Dienst und zwischen außen.

01:21:53.200 --> 01:22:05.760
Das heißt, da kannst du auch wunderbar quasi hinter einer Domain auf mehreren Ports quasi

01:22:05.760 --> 01:22:11.600
Dinger laufen lassen oder quasi mehrere Subdomains intern auf unterschiedliche Dinger mappen

01:22:11.600 --> 01:22:18.040
oder sowas. Dann kannst du dir überlegen, ob du noch eine Authentifizierung machst über

01:22:18.040 --> 01:22:22.520
EngineX. Du könntest beispielsweise, wenn du sagst, ok, ich will es möglichst einfach

01:22:22.520 --> 01:22:27.880
haben, dann machst du halt einen EngineX als Reverse-Proxy dazwischen und holst dir Let's

01:22:27.880 --> 01:22:32.560
Encrypt-Zertifikate und dann machst du halt, wenn du willst, dass es simpel ist und du

01:22:32.560 --> 01:22:36.240
noch ein bisschen Authentifizierung hast, dann machst du dem EngineX einfach Basic Auth

01:22:36.240 --> 01:22:42.040
und dann musst du halt Passwort und Username irgendwie mit deinen Leuten austauschen, aber

01:22:42.040 --> 01:22:46.080
das ist das Einfachste, was du machen kannst und das ist dann aber schon relativ gut. Natürlich

01:22:46.080 --> 01:22:49.720
gibt es dann noch unendlich viele weitere advancede Varianten, du kannst hier sogar

01:22:49.720 --> 01:22:53.840
einen To-Fack der Authentifizierung basteln mit, gibt es auch so Keycloak oder irgendwie

01:22:53.840 --> 01:22:58.040
sowas, wo dann der EngineX einen Request dagegen macht, so nach dem Autodata-Typ und

01:22:58.040 --> 01:23:02.840
sowas. Aber die einfachste Variante dürfte wirklich sein, Let's Encrypt-EngineX oder

01:23:02.840 --> 01:23:12.920
irgendeiner anderen Reverse-Proxy und Basic Auth davor und gut ist. Läuft schon, es läuft

01:23:12.920 --> 01:23:16.800
mit einem Bild und ist transparent, Patrick. Also es ist schon deutlich besser als das

01:23:16.800 --> 01:23:23.000
letzte Mal und du hast das ganze Intro verpasst, wie sehr es mich genervt hat, ein transparentes

01:23:23.000 --> 01:23:29.160
Fenster und ein transparentes GIF selbst zu ändern. Riesenakt. Okay, Decoder-Start, zack,

01:23:29.160 --> 01:23:35.760
da ist er. Und sogar schön gescaled. Okay, jetzt müssen wir natürlich nur einstellen,

01:23:35.760 --> 01:23:49.720
dass mehr Frames abgerufen werden. Okay, kann ich noch ein bisschen was löschen von dem

01:23:49.720 --> 01:24:04.840
ganzen Krämpel hier, den ich da hab? Bla, bla, bla. Bla, bla, bla, kann ich davor noch

01:24:04.840 --> 01:24:25.280
irgendwas wegschmeißen? Nee, glaub ich nicht. Okay, Copy from Memory, Frame, Decoder-Start,

01:24:25.280 --> 01:24:33.320
Decoder-Start. Gut, das hier muss ich in der Schleife machen. Das Bitmap kann ich ja vorher

01:24:33.320 --> 01:24:46.080
schon anlegen, das ist kein Problem. Das muss ich in der Schleife machen und ich muss einmal

01:24:46.080 --> 01:24:53.960
pro Schleifendurchgang einen neuen Frame holen, also am Ende vom Durchgang. So, jetzt sollte

01:24:53.960 --> 01:25:05.000
eigentlich das GIF animiert sein und ist es auch, plus es ist viel zu schnell. Ich vermute

01:25:05.000 --> 01:25:11.440
mal, dass das ist. Wollen wir mal ein Sleep irgendwie dazwischen, 100 Millisekunden, da

01:25:11.440 --> 01:25:18.040
ist es. Bam, danach kackt es ab. Logischerweise kackt es danach ab, weil es gibt keinen Frame

01:25:18.040 --> 01:25:42.040
mehr, richtig so. Aber, Animation in Form an. Warum genau kackt das ab, Frame? Na eigentlich

01:25:42.040 --> 01:26:05.240
abkacken sollte es doch nicht. Der letzte Frame ist doch immer noch drin, oder? Jetzt

01:26:05.240 --> 01:26:14.600
muss ich mal überlegen, warum kackt das an der Stelle ab. Also, wir müssen den Frame

01:26:14.600 --> 01:26:22.520
eh auf jeden Fall wieder löschen, weil das haben wir in Memory Leak. Das wollen wir nicht.

01:26:22.520 --> 01:26:29.640
Also im Prinzip funktioniert es, aber wenn die Animation fertig ist, kackt er ab, weil

01:26:29.640 --> 01:26:41.160
wahrscheinlich hier der Kram nicht... wo kackt... was war? Paint kackt er ab? Das ist wahrscheinlich

01:26:41.160 --> 01:26:48.960
ein Bug, dass er bei Paint abkackt. Also wahrscheinlich hat er hier irgendwie Probleme mit dem Speicherbereich,

01:26:48.960 --> 01:26:55.040
wobei ist den Frame doch eigentlich... ach nee, ha, nee, Moment. Das sollte doch eigentlich

01:26:55.040 --> 01:27:03.680
hängen, wenn nichts mal drinnen ist. Also warum der abkackt ist mir jetzt nicht so ganz

01:27:03.680 --> 01:27:26.120
klar ehrlich gesagt.

01:27:26.120 --> 01:27:55.640
Hm. Warum kackt er ab? Kannst du mal erklären, was das Endpoint der Fernandam-Struktur ist?

01:27:55.640 --> 01:28:06.280
Das ist quasi die Managed-Variante von einem Pointer. Ja, alles gut. Sharks Development.

01:28:06.280 --> 01:28:10.320
Warum kackt er denn ab an der Stelle? Ich meine, es ist nicht schlimm, wir laden ja

01:28:10.320 --> 01:28:19.160
eh die Bilder dann nochmal neu, aber er sollte definitiv nicht abkacken, wenn keine Bilder...

01:28:19.160 --> 01:28:27.160
also von der Idee her sollte es folgendermaßen sein. Ah, ich weiß woran das liegt. Das Ding

01:28:27.160 --> 01:28:37.920
hier kackt ab. Wartet mal, ich hab ne Idee. Wir machen mal... die Coden mal wieder nur

01:28:37.920 --> 01:28:48.680
ein Frame. Siehste, jetzt kackts nämlich nicht ab. Das kackt gar nicht ab, das ist Fail.

01:28:48.680 --> 01:28:57.440
Das kackt in Wirklichkeit nämlich der Gift-Decoder ab, was ganz klar ist, weil er nicht weiter

01:28:57.440 --> 01:29:04.400
lesen kann. Ich muss hier nämlich gucken. If Error F of Mpeg. Ok, das muss ich mir

01:29:04.400 --> 01:29:11.760
jetzt mal abgucken von dem, was wir das letzte Mal gemacht haben. Das war an das EOF oder

01:29:11.760 --> 01:29:18.600
sowas, ne? Ja, genau. Sprich, wenn das File fertig gelesen ist, dann darf er nicht weitermachen.

01:29:18.600 --> 01:29:24.680
Da muss er machen Break. Ha, guckt, und jetzt kackt das Ganze auch nicht mehr ab. Das lag

01:29:24.680 --> 01:29:29.000
nämlich gar nicht an unserem Render, das lag am Decoder, der abgekackt ist und die Exception

01:29:29.000 --> 01:29:39.200
war nur an einer komplett Fail-Stelle. Memory Leaks werden wir gleich ordentlich produzieren,

01:29:39.200 --> 01:29:47.000
ich hab's im Gefühl. So, und jetzt müssen wir eine Möglichkeit finden, wie wir das

01:29:47.000 --> 01:29:51.600
Ganze resetten. Also der Witz ist jetzt ja, wir können, also wir haben jetzt ein relativ

01:29:51.600 --> 01:29:54.680
langes Leap drin, dass wir sehen, dass die Animation funktioniert, wir machen das Leap

01:29:54.680 --> 01:30:01.240
dann ein kleines Mal raus, wenn wir es geschafft haben, quasi eine endlos Gift-Schleife zu

01:30:01.240 --> 01:30:06.120
decoden. Also von der Idee her würde ich mal sagen, was übrigens auch toll fällt,

01:30:06.120 --> 01:30:21.560
wir haben 0 FPS. Wir müssen jetzt mal gucken, wie man mit FFmpeg quasi zurückspringt hier,

01:30:21.560 --> 01:30:25.000
weil wir lesen ja immer noch, wir haben ja hier irgendwo einen neuen, wir haben ja hier

01:30:25.000 --> 01:30:36.120
irgendwo einen Stream und wir lesen Frames, Frames, Frames, Frames, sondern irgendwann

01:30:36.120 --> 01:30:43.320
sind wir am Ende, End of File und jetzt müssen wir irgendwie FFmpeg ja wieder sagen, geh

01:30:43.320 --> 01:30:49.560
an den Anfang des Files zurück. Ich hab keine Ahnung, wie man das macht, da müssen wir

01:30:49.560 --> 01:31:05.960
mal versuchen. FFmpeg Reset File. Ja, das kann man auch machen, wir könnten auch einfach

01:31:05.960 --> 01:31:09.640
alle Frames zwischenspeichern, das geht auch. Aber ich will mal gucken, wie man resettet.

01:31:09.640 --> 01:31:27.560
How to Reset AV Format Context so it could be reused. Das ist schonmal gut. Ok, da hat

01:31:27.560 --> 01:31:41.240
keiner Antwort gekriegt. Wisst ihr was, wir sollen jetzt mal Stack Overflow dabei. FFmpeg

01:31:41.240 --> 01:32:07.400
Reset Start Time of File. AV Frame. Position. Man muss einfach nur gut suchen können. FFmpeg

01:32:07.400 --> 01:32:29.240
Position File Context. Reset. Seeking. Seek. Seek.

01:32:29.240 --> 01:32:59.160
Text. Have you come?

01:32:59.160 --> 01:33:07.640
Ihr seht jetzt gerade Stack Overflow Driven Programming in Aktion. Seeking with AV Seek

01:33:07.640 --> 01:33:36.920
Frame. I.O. Stream. Set. Wir kommen da Sache langsam näher.

01:33:36.920 --> 01:34:01.480
AV Seek Frame hatten wir das schon oder hast du gewusst? Ist doch. AV Seek Frame.

01:34:01.480 --> 01:34:14.280
Seek. Set.

01:34:14.280 --> 01:34:41.160
Das muss ja irgendwie funktionieren.

01:34:41.160 --> 01:35:04.160
Also, wenn wir hier EOF haben, dann müssen wir sagen, was AV Seek, AV Seek Frame, Kontext,

01:35:04.160 --> 01:35:21.320
was für einen Kontext brauchen wir denn an der Stelle, ahja, Format, ok, Format, Kontext,

01:35:21.320 --> 01:35:31.240
Stream Index, Stream Index ist 0, GIF hat nur 1 Stream, Timestamp, wo wir hin wollen,

01:35:31.240 --> 01:35:47.440
die Tote, Keyframe, Timestamp, 0, Inflax, 0, ob das jetzt funktioniert, ob das jetzt

01:35:47.440 --> 01:36:02.560
funktioniert, nee, ich glaube nicht, dass es funktioniert.

01:36:02.560 --> 01:36:31.040
Äh, Scheiße, das funktioniert, krass, übrigens, wir haben ein paar Memory Dex, aber, ich

01:36:31.040 --> 01:36:53.320
glaube, es funktioniert, ich bin echt überrascht jetzt, ne, guck mal, wir leaken ein bisschen

01:36:53.320 --> 01:36:58.800
Memory, so ein bisschen, ein bisschen, ein bisschen Memory liegen wir, das liegt aber

01:36:58.800 --> 01:37:05.720
daran, dass ich auch nichts frei gebe, ok, gucken wir mal, also, wir sagen, ok, das Packet

01:37:05.720 --> 01:37:11.800
brauchen wir nicht, Package freen können wir, Frame freen können wir nicht, also, FFMPack,

01:37:11.800 --> 01:37:36.240
Free Packet, Deprecated, drauf geschissen, jetzt leaken wir schon eine ganze Ecke weniger,

01:37:36.240 --> 01:37:48.640
Free Packet ist obsolete, Use Packet Unwraff, machen wir, Dust Dust 1717, äh, kennst du

01:37:48.640 --> 01:37:53.720
dich mit FFMPack aus, oder woher weißt du das alles, ok, wir liegen, wir liegen noch

01:37:53.720 --> 01:37:58.320
ein bisschen an anderen Stellen, wie es aussieht, wahrscheinlich in unserem DirectX, DirectX

01:37:58.320 --> 01:38:06.560
Krämpel, müssen wir mal gucken, ja, garantiert, garantiert, wir müssen hier noch aufräumen,

01:38:06.560 --> 01:38:23.120
wir müssen mal gucken, an welcher Stelle, so, und jetzt müssen wir hier am Ende, müssen

01:38:23.120 --> 01:38:31.120
wir noch sagen, FFMPack, wahrscheinlich auch Unwraff, Unwraff Frame, sondern jetzt sollten

01:38:31.120 --> 01:38:44.840
wir weniger leaken, achso, auch bin ich blöd, vielleicht sollten wir das davor machen, bevor

01:38:44.840 --> 01:38:56.960
wir uns den neuen holen, guck mal, wir liegen nicht mehr, weil das, äh, wir machen das

01:38:56.960 --> 01:39:10.640
mit Open, mit DirectX, weil es Windows Only ist, also, so, und jetzt nehmen wir mal das

01:39:10.640 --> 01:39:24.160
Lieb raus, mal gucken, was passiert, alter, ich sag doch, der schnellste Giftplayer der

01:39:24.160 --> 01:39:44.720
Welt, wisst ihr, dazu passt jetzt richtig gut,

01:39:44.720 --> 01:40:13.160
ich bin begeistert

01:40:13.160 --> 01:40:41.120
Nice, gut, mal in den normalen Modus wieder wechseln,

01:40:41.120 --> 01:40:54.960
warum ist die Musik gar nicht so leise, ich mein, guck mal, wir schaffen es jetzt,

01:40:54.960 --> 01:40:59.600
meine Platte ist wahrscheinlich auch voll am, oh ja, mein SSD ist ein bisschen am blinken,

01:40:59.600 --> 01:41:08.240
ich mein, guck mal, wir haben ja die Frames noch nicht mal gecached oder so, wir lesen

01:41:08.240 --> 01:41:11.520
das quasi immer neu ein, erstellen immer neue AP-Acte und wir rendern das quasi mit

01:41:11.520 --> 01:41:19.600
maximal 1200 FPS oder so, das ist doch schonmal sehr ordentlich, allerdings soll das Ganze

01:41:19.600 --> 01:41:30.200
natürlich nicht ganz so hektisch sein, aber nice, das funktioniert schonmal, und wir brauchen

01:41:30.200 --> 01:41:39.640
auch nur 90, 90, 90 MB RAM, warum steht denn so überhaupt auf Release, soll ich auf Release

01:41:39.640 --> 01:41:58.760
stehen, wow, es ist kaputt, warum geht das kaputt,

01:41:58.760 --> 01:42:06.760
warum geht das kaputt, wenn es auf Debug steht, aber auf Release geht es nicht kaputt, wie

01:42:06.760 --> 01:42:12.720
dem auch sei, wir wollen das ja eh nicht so schnell haben, aber kaputt gehen sollte es

01:42:12.720 --> 01:42:23.240
eigentlich nicht, das sollte eigentlich volle Pulle, wir unreffen bestimmt irgendwas, was

01:42:23.240 --> 01:42:39.720
schon kaputt ist oder so, Triggered a Breakpoint, ja welcher Breakpoint auch immer, jetzt ich

01:42:39.720 --> 01:42:53.320
meine es ist ja geil, wenn es eine Exception wirft, aber warum, Unref, ja Breakpoint, habe

01:42:53.320 --> 01:43:16.640
ich halt keine Ahnung, ok, wahrscheinlich machen wir hier irgendwie irgendwas blödes,

01:43:16.640 --> 01:43:42.200
beim Unref kackt er ab, kackt er beim Unref ab, das ergibt ja überhaupt keinen Sinn, habe

01:43:42.200 --> 01:43:57.360
ich das vielleicht in der falschen Reihenfolge irgendwie, ah V-Frame 3, ne ich dachte das

01:43:57.360 --> 01:44:26.680
ist das neue 3, Moment, das sind unterschiedliche Dinger,

01:44:26.680 --> 01:44:49.680
wartet mal kurz, so wieder da,

01:44:49.680 --> 01:45:13.400
ich brauche gar nicht Unref, liegt es denn, wir gucken mal ob es überhaupt am Unref liegt,

01:45:13.400 --> 01:45:28.800
ja ohne Unref geht es, allerdings ist mein Ram gleich voll, wenn es so weiter geht, Moment

01:45:28.800 --> 01:45:37.120
wie mache ich das denn jetzt, jetzt stoßen meine krassen C-Pointer Skills an die Grenzen,

01:45:37.120 --> 01:45:47.840
der möchte einen Pointer haben, also ein Pointer zu einem Pointer auf Frame, ich habe allerdings

01:45:47.840 --> 01:45:57.680
nur einen Pointer auf Frame zu bieten, was mache ich denn jetzt, Leute haben wir nicht

01:45:57.680 --> 01:46:19.120
irgendeinen der hier, der Patrick, der so eine krasse C-Owner, was mache ich denn jetzt,

01:46:19.120 --> 01:46:24.840
also das geht, ok mal probieren wir aus, und, und, ey das wäre lustig wenn das geht, aber

01:46:24.840 --> 01:46:43.320
das glaube ich nicht, ne, was a V-Frame, jetzt ist es richtig getippt, aber das ist dann

01:46:43.320 --> 01:47:13.080
immer noch kein Pointer zum Pointer oder, ha, ha, nein, nein, nein, nein, nein, nein,

01:47:13.080 --> 01:47:42.720
nein, nein, nein, nein, nein, nein, nein, nein, nein, nein, nein, nein, nein, nein,

01:47:42.720 --> 01:47:45.960
Ja, an der stelle

01:47:57.480 --> 01:48:02.240
Ich habe keine ahnung was ja interessant finde dass er das im release modus nicht macht

01:48:02.240 --> 01:48:09.640
also mit anruf hat sie im release modus funktioniert

01:48:09.640 --> 01:48:21.560
was ich interessant finde anruf ist doch eigentlich das richtige im release modus

01:48:21.560 --> 01:48:36.040
funktioniert er doch auch was hat er im debug mod für schmerzen damit er

01:48:36.040 --> 01:48:48.800
gut wisst ihr was wir machen wir native code debugging an aber schon

01:48:48.800 --> 01:49:04.360
doch

01:49:04.360 --> 01:49:28.480
ja das ist halt die frage ob der constructor das hier auch so macht

01:49:28.480 --> 01:49:45.120
kann man jetzt nicht reingucken aber wahrscheinlich ja aber hier

01:49:45.120 --> 01:49:50.800
irgendeine logik drinne die fail ist wisst ihr was wartet mal wir machen jetzt was anders

01:49:50.800 --> 01:50:00.720
wir rennen dann jetzt mal nichts wir rennen dann jetzt mal nichts

01:50:00.720 --> 01:50:11.560
gucken ob der ob der ob der decoder jetzt läuft

01:50:11.560 --> 01:50:27.480
ne guck mal der decoder kackt schon ab warum ach so ja weil 100 elemente voll sind

01:50:27.480 --> 01:50:38.320
ich fühle das ding mal hier drin

01:50:57.480 --> 01:51:03.120
kann ich mir nicht vorstellen dass man das hier irgendwie

01:51:03.120 --> 01:51:13.880
siehst du das richtig komplett startet in dem fall schon das ist einfach ein rapper

01:51:13.880 --> 01:51:35.560
um diese um halt die zähle library von ffm pack

01:51:43.880 --> 01:51:51.840
ja einfach ein pack ist zäge schwimmel

01:51:51.840 --> 01:52:14.320
you can use frame anwärm oder to clear der donation sound poggers

01:52:14.320 --> 01:52:23.680
1 euro 23 vom huru boss seine konungstiere sind immer interessant

01:52:23.680 --> 01:52:26.960
das ist wenn es dir gefällt sehr sehr nice

01:52:26.960 --> 01:52:35.600
da musst du das objekt auch pinnen weiß ich nicht ob ich das pinnen muss

01:52:35.600 --> 01:52:48.760
ich dachte pinnen muss ich nur wenn ich quasi irgendwelche managed zu native

01:52:48.760 --> 01:52:53.080
geschichten mache was ich jetzt an der stelle gar nicht mache ich mache unter

01:52:53.080 --> 01:53:13.600
haum im prinzip alles unsafe native

01:53:13.600 --> 01:53:37.800
natürlich ein beispiel wie das verwenden

01:53:37.800 --> 01:53:45.760
da machen wir das jetzt doch mal so also wir waren jetzt in frame

01:54:07.800 --> 01:54:29.800
das funktioniert

01:54:29.800 --> 01:54:44.320
interessant

01:54:44.320 --> 01:54:50.040
warum funktioniert das so und anders nicht ich meine das ist ok was machen

01:54:50.040 --> 01:54:55.080
die denn in dem konstrukt davon muss das muss man auch github autogrenen

01:54:55.080 --> 01:55:02.600
ffm pack und a v frame da muss man nachgucken die da unter hau unter der

01:55:02.600 --> 01:55:10.200
hau bing was anderes machen ja ich mache auch acht ach so ich mache

01:55:10.200 --> 01:55:19.000
ich das ist das package obendrüber ich mache nur ich mache nur 3 gerade das

01:55:19.000 --> 01:55:28.840
funktioniert und wir liegen auch nichts und no leaks probieren das jetzt noch

01:55:28.840 --> 01:55:33.320
mal anders rum

01:55:35.680 --> 01:55:40.640
warum hat er hier irgendwelche schmerzen mit ich meine das müsste die lokal von

01:55:40.640 --> 01:56:04.360
der funktion sein ok sind wir ja auch weiterhin

01:56:04.360 --> 01:56:13.800
ok das problem ist anscheinend nur wenn ich das andere das funktioniert auch

01:56:13.800 --> 01:56:18.720
ok das ist prinzipiell prinzipiell ist alles gut das problem tritt nur auf wenn

01:56:18.720 --> 01:56:25.520
ich das von der anderen seite aus mache das denn

01:56:25.520 --> 01:56:32.280
das ist entweder

01:56:32.280 --> 01:56:50.120
das ist irgendwie in der threading geschichte was ich mir eigentlich

01:56:50.120 --> 01:57:03.360
vorstellen kann oder die adressen stimmen einfach nicht

01:57:03.360 --> 01:57:06.600
allerdings merkwürdig

01:57:06.600 --> 01:57:14.600
ok warte mal ich brauche den frame hier brauche ich den danach brauche ich

01:57:14.600 --> 01:57:16.920
nicht mehr

01:57:23.840 --> 01:57:27.600
ich meine wir geben einfach den wir speichern uns einfach den pointer

01:57:27.600 --> 01:57:32.840
da drin das geht natürlich auch aber eigentlich will ich kein anzelf zeug

01:57:32.840 --> 01:57:45.840
rausgeben ok ich habe da alle die idee leute wir machen weil ich will

01:57:45.840 --> 01:57:49.480
eigentlich hier in meiner form kann anzelf zeug verwenden ich will das

01:57:49.480 --> 01:57:52.960
ganze anzelf zeug hier drin machen ich habe die idee wir machen jetzt noch

01:57:52.960 --> 01:58:05.120
public-class-frame der kriegt ein av-frame av-frame

01:58:05.120 --> 01:58:22.160
was hat er für schmerzen achso

01:58:22.160 --> 01:58:37.760
wir können es auch noch anders machen wir können dann in point of

01:58:37.760 --> 01:58:53.120
also ja wir reppen den camp noch mal in der eigenen frame klasse da müssen wir

01:58:53.120 --> 01:58:58.840
da keine anzelf zeug rausgehen irgendwie so probieren aus gerade das so von von

01:58:58.840 --> 01:59:08.840
der idee funktioniert was programmiert eigentlich programmieren in gif in gif

01:59:08.840 --> 01:59:16.520
viewer also der tut ganz schön schnell das gif das ist als ergänzung zu meinem

01:59:16.520 --> 01:59:21.000
overlay hier weil das wpf giftzeug so langsam ist guck wenn du hier drauf

01:59:21.000 --> 01:59:26.480
klickst hast den klick gehört wie lange das dauert das ist der schnellste gift

01:59:26.480 --> 01:59:32.000
player der welt hier da funktioniert er nur im release modus im debug modus nicht

01:59:32.000 --> 01:59:37.160
es macht mich echt fertig jetzt was das vielleicht liegt am debugger das liegt

01:59:37.160 --> 01:59:43.760
am debugger wenn er die bagger attached ist dann spackts rum wenn er die bagger

01:59:43.760 --> 01:59:58.120
nicht attached ist dann spackts nicht rum liegt es am native code die baggen

01:59:58.120 --> 02:00:05.720
ne also mit attach dem debugger spinns ok dann ist das ich glaube gar nicht dass

02:00:05.720 --> 02:00:22.640
mein coder irgendwie probleme hat aber aber wir machen das trotzdem mit der

02:00:22.640 --> 02:00:25.320
eigenen klasse

02:00:25.320 --> 02:00:34.440
so und dann kriegen wir jetzt hier in den av frame so überlegen wir mal das

02:00:34.440 --> 02:00:55.400
haben wir es machen also einen av frame probier das jetzt mal so frame

02:01:04.440 --> 02:01:15.080
suppose weil das ist eigentlich das was was ich ursprünglich ursprünglich

02:01:15.080 --> 02:01:23.040
vorhatte also ich wollte eh eine eine klasse dafür machen dass ich kein

02:01:23.040 --> 02:01:38.360
anzeif zeug rausgeben muss weil fix fix wie ging da kram noch mal so na fix da

02:01:38.360 --> 02:01:42.120
musste man quasi sagen es wird doch da dran liegen

02:01:42.120 --> 02:01:58.280
av frame steinchen pointer geschiss jetzt für schmerzen

02:01:58.280 --> 02:02:20.240
also anzeif nehmen aber nicht anzeif machen anzeif anzeif ja ja ich habe

02:02:20.240 --> 02:02:24.480
kein if kein kein kein debug ifs irgendwo drin also nicht dass ich nicht

02:02:24.480 --> 02:02:38.120
dass ich wüsste anzeif fix so das also was was was können wir in unserer frame

02:02:38.120 --> 02:02:41.440
klasse sinnvolles geben das ist eh was was ich noch machen wollte sondern

02:02:41.440 --> 02:02:51.600
properties brauchen wir wir brauchen in pointer data hier wird er mir

02:02:51.600 --> 02:02:59.280
wahrscheinlich wird er meck wieder meckern wenn ich sage frame data null

02:02:59.280 --> 02:03:02.720
das mag er wahrscheinlich nicht

02:03:02.720 --> 02:03:16.280
ne das muss anzeif sein also sprich brauchen wir hier nun jetzt

02:03:16.280 --> 02:03:39.120
get return das da brauchen wir was jetzt also anzeif moment ein rückung ein

02:03:39.120 --> 02:03:57.680
rückung anzeif anzeif so gut wenn ich mag wird gekastet klar easy cast easy

02:03:57.680 --> 02:04:10.240
life so dann brauchen wir noch in pitch brauchen wir noch frame line size war

02:04:10.240 --> 02:04:16.080
das so ok das müsste doch eigentlich jetzt schon reichen so und die blogging

02:04:16.080 --> 02:04:20.840
collection ist kein av frame mehr sondern nur dann frame

02:04:20.840 --> 02:04:36.040
und hier ist es ein new frame falls das jetzt klappt hat der freund was von fix

02:04:36.040 --> 02:04:55.760
geschrieben hat doch recht gehabt das package kann weiter anreffen ach so ja

02:04:55.760 --> 02:04:59.800
klar das gibt es ja nicht so weil frame ist jetzt ja einen ab breite breite

02:04:59.800 --> 02:05:06.080
dings da breite höhe brauchen wir noch ganz natürlich funktionieren

02:05:10.000 --> 02:05:25.320
witz und heights wisst ihr wo ich übels bock drauf hätte leute also nicht jetzt

02:05:25.320 --> 02:05:30.920
aber wo ich gerade gerade so bauchgefühl gerade so unbewusst dran

02:05:30.920 --> 02:05:35.680
gedacht hat wo ich übels bock drauf hätte das ist ich würde jetzt gerne mit

02:05:35.680 --> 02:05:39.920
dem fall mit mw2 spielen auf der 360 so ohne scheiß das ist mir grad so

02:05:39.920 --> 02:05:43.800
eingefallen aber liebsten würde ich mich jetzt einloggen xbox party chat alter

02:05:43.800 --> 02:05:49.200
war xbox party chat geil nicht diese verkackte scheiße da ja

02:05:49.200 --> 02:05:55.960
stunden aber den krams gespielt außerdem waren wir da noch jünger

02:05:55.960 --> 02:06:00.440
wobei es ist nicht so dass ich mir großartig alt vorkomme in der richtung

02:06:00.440 --> 02:06:01.840
aber das wäre also

02:06:01.840 --> 02:06:23.680
so witz viele witz und so viele heights noch mehr das ist jetzt einfach nur auf

02:06:23.680 --> 02:06:33.000
frame data das haben wir schon gewerbt ich bin mal gespannt ob der shit

02:06:33.000 --> 02:06:37.240
funktioniert er so jetzt muss es erst mal funktionieren und für memory liegen

02:06:37.240 --> 02:06:42.000
jetzt wie verrückt die memory liegen ordentlich 2 gigabyte ram schon weg

02:06:42.000 --> 02:06:54.760
bärm in your face noch mal gucken ob das jetzt funktioniert frame despose scheiße

02:06:54.760 --> 02:06:58.160
alter was ist das für eine kacke

02:07:01.640 --> 02:07:04.640
voll auf den sack

02:07:04.640 --> 02:07:08.280
mega auf den sack dass es nicht funktioniert

02:07:08.280 --> 02:07:27.840
aber wie ging das free kann ich mal tippen er free

02:07:27.840 --> 02:07:44.680
frem frem frem frem ich kann jetzt schreiben av frem frem

02:07:44.680 --> 02:08:04.000
ne ne das mag nicht ich weiß woran das liegt ich habe eine idee ich habe nie

02:08:04.000 --> 02:08:08.200
das liegt überhaupt nicht an den referenzen das liegt hier dran

02:08:08.200 --> 02:08:18.720
das liegt 100 pro hier irgendwo dran ich sag es euch der das rumgesiege ist

02:08:18.720 --> 02:08:26.480
nicht richtig was ich hier mache weil ich guck mal das kackt ab genau ziemlich

02:08:26.480 --> 02:08:28.480
genau nachdem es einmal durch ist

02:08:28.480 --> 02:08:43.200
mein gesiege ist falsch alles kackt wischel studio noch ab oder was

02:08:43.200 --> 02:08:52.600
guck das kackt mehr oder weniger direkt mein ich ich sieke falsch das das wird

02:08:52.600 --> 02:08:58.400
sein dass es fehlt noch was oder sowas

02:08:58.400 --> 02:09:15.880
so ist es anders an der stelle

02:09:15.880 --> 02:09:25.400
fast das ist einfach nur verzögert haben

02:09:25.400 --> 02:09:31.560
ich werde mit euch ich sieke falsch

02:09:31.560 --> 02:09:41.160
ich habe das so irgendwie mach einfach try catch drauf wahrscheinlich wird das

02:09:41.160 --> 02:09:44.320
sogar funktionieren aber dann auf jeden fall in den memory

02:09:44.320 --> 02:09:46.840
liegt drinnen

02:10:02.800 --> 02:10:06.880
ich muss mal suchen ich habe bestimmt irgendwo was wo ich mal ein stream

02:10:06.880 --> 02:10:24.960
resettet habe ich ich suche noch mal ich suche noch mal danach siegfeil position

02:10:36.880 --> 02:10:55.960
ffmpeg format kontext sieg

02:10:55.960 --> 02:11:04.040
stream resett

02:11:25.960 --> 02:11:45.440
einfach nicht sieg nur die datei selbst storm ja das ist es muss gehen man muss

02:11:45.440 --> 02:11:57.400
mit immer muss doch an anfangen kommen

02:11:57.400 --> 02:12:03.200
mehr flo so was mache ich nicht also sagen wir so dass mit dem mit dem selbst

02:12:03.200 --> 02:12:06.160
mit dem mit dem storm das ist eine sache die ich vielleicht noch

02:12:06.160 --> 02:12:29.280
mache aber ich will wissen wie ich ordentlich siege

02:12:29.280 --> 02:12:40.320
position

02:12:40.320 --> 02:13:03.680
afv kodak flasch buffers kann man gleich ausprobieren

02:13:10.320 --> 02:13:22.800
was als letzten parametern vier

02:13:22.800 --> 02:13:32.960
wenn sie mal lustig wie interaktiv die ganzen streben dann werden wenn ich mir

02:13:32.960 --> 02:13:41.120
irgendwann hat weiter weiß das schon klar am anfang abgekackt

02:13:41.120 --> 02:13:44.480
stimmt doch irgendwas net

02:13:52.400 --> 02:13:55.520
ich spare mir jetzt mal kurz das disposender kackte auf jeden fall nicht

02:13:55.520 --> 02:14:15.920
mehr ab aber mein ram ist halt relativ schnell voll

02:14:25.920 --> 02:14:55.360
ok also nach was

02:14:55.360 --> 02:15:01.280
könnte man dann noch mal suchen interessantes so was der overflow also

02:15:01.280 --> 02:15:06.080
was was ist eigentlich was wir machen ffmpeg

02:15:06.080 --> 02:15:27.640
besetzt dream auf leicht pizream

02:15:27.640 --> 02:15:29.640
Speed Stream

02:15:29.640 --> 02:15:31.640
Gibt es da irgendwas?

02:15:41.640 --> 02:15:43.640
FFF Video Stream

02:15:43.640 --> 02:15:47.640
Gibt es da irgendwas?

02:15:55.640 --> 02:15:57.640
Gibt es da irgendwas?

02:15:57.640 --> 02:15:59.640
Gibt es da irgendwas?

02:16:05.640 --> 02:16:07.640
Gibt es da irgendwas?

02:16:07.640 --> 02:16:23.640
Gibt es da irgendwas?

02:16:37.640 --> 02:16:39.640
Gibt es da irgendwas?

02:16:39.640 --> 02:17:03.640
Gibt es da irgendwas?

02:17:09.640 --> 02:17:11.640
Gibt es da irgendwas?

02:17:11.640 --> 02:17:31.640
Gibt es da irgendwas?

02:17:41.640 --> 02:17:43.640
Gibt es da irgendwas?

02:18:11.640 --> 02:18:13.640
Gibt es da irgendwas?

02:18:19.640 --> 02:18:21.640
Gibt es da irgendwas?

02:18:21.640 --> 02:18:45.640
Gibt es da irgendwas?

02:18:51.640 --> 02:18:53.640
Gibt es da irgendwas?

02:19:01.640 --> 02:19:03.640
Gibt es da irgendwas?

02:19:03.640 --> 02:19:05.640
Sieg feil

02:19:07.320 --> 02:19:10.200
So und da muss rein der komische kontext hier wieder

02:19:17.800 --> 02:19:19.800
Kontext

02:19:22.040 --> 02:19:24.600
Index auf stream null

02:19:26.400 --> 02:19:28.400
Smalls timestamp null

02:19:28.400 --> 02:19:35.400
Lange tage timestamp macht der da stream stream

02:19:38.520 --> 02:19:42.800
Duration null bin ich ja mal gespannt ob der scheiß funktioniert

02:19:44.800 --> 02:19:48.880
Ups was vergessen

02:19:48.880 --> 02:19:56.160
Moment ich habe was vergessen was habe ich vergessen

02:20:02.960 --> 02:20:05.480
Null min null

02:20:11.560 --> 02:20:13.560
Tage timestamp null

02:20:13.560 --> 02:20:16.840
Null max timestamp. Der jetzt aber na

02:20:18.840 --> 02:20:20.840
Da war es jetzt ein akte

02:20:22.680 --> 02:20:25.880
Gehen wir memory liegen immer noch das tolles aber das ist ja klar

02:20:28.680 --> 02:20:30.680
Okay jetzt gucken wir auf wird es pausen dürfen

02:20:34.600 --> 02:20:39.880
Aha ich sag's euch hab's euch doch gesagt wir haben falsch gesiegt

02:20:39.880 --> 02:20:45.400
Das ist zwar kein richtiges deutsch ich weiß zwar nicht was wir falsch gesiegt haben, aber wir haben falsch gesiegt

02:20:50.120 --> 02:20:55.400
Das ist halt einfach so wir wieder komplett wir alter komplett durch

02:20:59.320 --> 02:21:03.960
Und wir memory liegen auch nicht wirklich oder vielleicht ein paar kilobyte, aber das

02:21:03.960 --> 02:21:06.680
Nee wir memory liegen nicht

02:21:09.800 --> 02:21:15.080
Guck mal hier 1200 fps gif animation

02:21:15.880 --> 02:21:19.640
Was gesiegt bedeutet das ist ganz schlecht eingeläut gesucht

02:21:21.240 --> 02:21:23.240
Ich meine damit hier das hier guck

02:21:23.880 --> 02:21:25.880
Sieg also suchen

02:21:26.520 --> 02:21:28.360
Und so gesiegt

02:21:28.360 --> 02:21:37.320
Ich meine damit hier das hier guck sieg also suchen und zwar also so wie ich das jetzt verstehe macht er an der stelle folgendes

02:21:38.440 --> 02:21:41.000
Hier ich öffne ja hier die datei warte mal

02:21:44.200 --> 02:21:48.200
Hier guck mal hier öffne ich ja die datei also meine meine bilddatei öffne ich ja hier

02:21:49.000 --> 02:21:55.200
Open input im fad steht die bilddatei drin und dann habe ich hier eine schleife wo ich quasi

02:21:55.200 --> 02:22:00.400
Inhalte aus der datei auslese irgendwann bin ich am ende end of file

02:22:01.600 --> 02:22:07.600
Und dann muss ich dass ich weiter lesen kann wieder an den anfang sieken also wieder an den anfang springen

02:22:07.720 --> 02:22:09.720
Also ich muss quasi den anfang suchen

02:22:10.160 --> 02:22:17.080
Also ich gebe quasi wieder auf position 0 zurück das ist ja natürlich sehr umständlich bei in dem c sharp stream würde ich sagen bei dem c sharp memory stream

02:22:17.280 --> 02:22:19.160
würde ich sagen

02:22:19.160 --> 02:22:21.160
position gleich 0 und er wäre am anfang

02:22:21.160 --> 02:22:24.440
Aber so einfach ist das jetzt natürlich nicht

02:22:25.720 --> 02:22:27.920
AV format sieg feil

02:22:31.560 --> 02:22:33.560
Warum ich doppelt machen muss weiß ich nicht

02:22:36.120 --> 02:22:38.440
Weil stack overflow das gesagt hat

02:22:38.440 --> 02:22:44.760
Kannst du ein video von mir kurz anschauen und sagen wie es ist und ob ich das video schneller machen soll oder oder nicht

02:22:45.640 --> 02:22:48.040
Es ist ein tutorial video für einen bot

02:22:48.360 --> 02:22:55.080
Einer hat mich gefragt ob ich ein anleitungsvideo machen möchte für den bot was ich auch gemacht habe was für mich war eher zu langsam die

02:22:55.080 --> 02:22:57.080
Aktionen und was für ein bot geht es denn

02:22:57.920 --> 02:22:59.920
gibt er viele bots

02:23:00.760 --> 02:23:02.320
Aktuelle ssd temp

02:23:02.320 --> 02:23:10.200
wie liest man das aus naja das geht das das das hittet ja gar nicht immer die ssd das hängt ja schon in einem fall ist im cash oder so

02:23:16.560 --> 02:23:21.920
Kommt mir trotzdem nicht ganz richtig was du probiert ob man beides machen muss nö ich habe das stack overflow kopiert

02:23:25.200 --> 02:23:27.200
Nö muss man nicht

02:23:27.200 --> 02:23:35.080
Man muss nicht beides machen jetzt gucken wir mal ob das andere auch gehen würde

02:23:39.000 --> 02:23:41.000
Okay, man braucht nur das erste

02:23:44.440 --> 02:23:46.440
Man braucht nur das erste

02:23:48.560 --> 02:23:50.560
Man braucht nur das erste

02:23:50.560 --> 02:23:58.440
Ne, okay, man braucht nur das erste man braucht nur das erste wie es aussieht

02:24:06.960 --> 02:24:11.160
Oder auch nicht vielleicht braucht man doch beides

02:24:11.160 --> 02:24:17.000
Man braucht auch beides zwar eben nur glück oder

02:24:21.080 --> 02:24:24.120
Oder nicht was war fuck

02:24:32.000 --> 02:24:34.000
Man braucht doch nur das erste

02:24:34.000 --> 02:24:40.320
Man braucht doch nur das erste spektrum aber wir müssen mal ein kleines wir müssen mal neu bilden so und jetzt noch mal

02:24:42.080 --> 02:24:44.080
Ne es reicht es reicht nicht

02:24:47.840 --> 02:24:49.840
Man muss beides machen

02:24:56.440 --> 02:24:58.440
Kackt ab wenn man nur eins davon hat

02:24:58.440 --> 02:25:03.720
Kackt ab wenn man nur eins davon macht ab und zu mal so kackt es nicht ab

02:25:08.880 --> 02:25:10.880
Sehr interessant

02:25:10.880 --> 02:25:20.120
Sehr interessant 1200 fps die sekunde wohl gewerkt

02:25:27.360 --> 02:25:29.760
Ja aber richtig cool dass es

02:25:30.960 --> 02:25:35.200
So schnell ist ich mein mit gecashten bildern ist es mit sicherheit noch eine ganze ecke schneller

02:25:35.200 --> 02:25:41.640
So schnell ist ich meine mit gecashten bildern ist es mit sicherheit noch eine ganze ecke schneller keine frage

02:25:43.720 --> 02:25:45.800
Gehe ich mal gehe ich mal von aus dass es

02:25:47.640 --> 02:25:50.600
Mit gecashten bilder noch eine ganze ecke schneller ist

02:25:55.320 --> 02:25:57.320
Ich meine wir könnten es mal ausprobieren

02:25:57.320 --> 02:26:11.560
Da müssten wir quasi wir könnten uns quasi die bilder hier in der zwischenspeichern

02:26:14.400 --> 02:26:21.440
Das können wir mal probieren gucken mal einfach nur mal testen was es für einen unterschied macht wenn man die bilder zwischenspeichern

02:26:21.440 --> 02:26:28.080
Eine möglichkeit um die frame rate zu setten warum soll ich denn die frame rate setten das auch die frame rate messen

02:26:30.400 --> 02:26:37.080
Du siehst ein memory leak wo ist es zeige ja private list frame

02:26:37.080 --> 02:26:59.240
Frames sagen wir zwei einmal frames klein einmal frames groß

02:26:59.240 --> 02:27:01.080
Mal gucken ob das ob das so funktioniert

02:27:01.080 --> 02:27:09.920
Das jetzt noch mal zu checken was es für ein performance unterschied macht zu cashen

02:27:09.920 --> 02:27:15.160
Wenn du das programm jetzt startest geht es nach oben

02:27:15.160 --> 02:27:23.240
Jetzt warum sollte ich hab da gar nichts gemacht

02:27:23.240 --> 02:27:44.880
Das pendelt sich ein bei irgendwie um die 100 da liegt nix

02:27:44.880 --> 02:27:54.440
Da liegt nix warum ist ein stirr die schild der playlist geht hier nicht mehr

02:27:54.440 --> 02:28:19.280
Da liegt nix guck was als fehler hätte durchaus sein können

02:28:19.280 --> 02:28:25.440
Und jetzt bitte das gift noch mit multis werden wir multis werden ja im prinzip schon

02:28:25.440 --> 02:28:31.920
Wir werden das gift in dem einen und die grafik in dem anderen also mit die kone das gift in einem

02:28:31.920 --> 02:28:33.640
Und trennen die grafik in dem anderen

02:28:33.640 --> 02:28:38.760
So mal gucken wie viel das jetzt bringt mit gecashten frames

02:28:38.760 --> 02:28:45.560
Okay so das heißt wir machen das wir breaken also wir gehen raus

02:28:45.560 --> 02:28:53.960
Nachdem wir einmal durch den end of file und danach machen wir endlos zum testen

02:28:53.960 --> 02:29:03.160
Endlos add frames von von dem ding

02:29:03.160 --> 02:29:09.480
Oder wie machen wir das jetzt am besten

02:29:09.480 --> 02:29:19.200
Oder wie machen wir das jetzt am besten

02:29:19.200 --> 02:29:24.840
Wir gehen wir breaken wenn wir end of file sind wir haben uns alle files zwischen gespeichert

02:29:24.840 --> 02:29:46.600
Doch wir machen das mit einer weile schlafen wir machen zwar frame wir machen c style cnt

02:29:46.600 --> 02:29:58.880
So und dann sagen wir add frames add

02:29:58.880 --> 02:30:01.360
Ich bin mal gespannt wie viel schneller das ist das lassen wir aber nicht so ich finde

02:30:01.360 --> 02:30:02.360
das andere schon schöner

02:30:02.360 --> 02:30:06.040
Wenn es direkt weil ich will ja gar nicht so viel ramp verbrauchen das ja eigentlich

02:30:06.040 --> 02:30:19.560
sind ins weg der sache so add frame dann müssen wir quasi gucken

02:30:19.560 --> 02:30:38.240
So und wenn das frame counter größer this frames count ist dann resetten wir frame counter

02:30:38.240 --> 02:30:39.240
wieder auf null

02:30:39.240 --> 02:30:41.960
Das jetzt so funktioniert bin ich mal gespannt

02:30:41.960 --> 02:30:45.720
Nein das habe ich falsch gemacht

02:30:45.720 --> 02:30:49.840
Irgendwo irgendwo ist meine meine logik fail

02:30:49.840 --> 02:30:54.560
größer gleich doch es müsste wahrscheinlich größer gleich sein

02:30:54.560 --> 02:30:58.520
Auch nicht

02:30:58.520 --> 02:31:00.600
Wo ist das problem

02:31:00.600 --> 02:31:07.960
Wo ist das Problem

02:31:07.960 --> 02:31:19.200
Achso ich sollte die frames nicht das pausen das wäre vielleicht ganz praktisch

02:31:19.200 --> 02:31:39.280
Moment was stimmt jetzt an meiner logik nicht ich meine das kackt schon mal nicht mehr

02:31:39.280 --> 02:31:40.280
ab das ist schon mal gut

02:31:40.280 --> 02:31:49.240
Irgendwo ist es null immer null

02:31:49.240 --> 02:31:54.000
Ach ich mache es pro durche auf alter bin ich dumm guck mal

02:31:54.000 --> 02:31:59.360
Richtig dumm

02:31:59.360 --> 02:32:02.000
Nicht der kack noob

02:32:02.000 --> 02:32:04.840
Guck mal hier bam gleich mal

02:32:04.840 --> 02:32:11.280
Doppelte bis dreifache anzahlen auch wieder schwankt es liegt es liegt da da heftig liegt

02:32:11.280 --> 02:32:12.280
es

02:32:12.280 --> 02:32:13.760
Warum liegt das denn

02:32:13.760 --> 02:32:18.920
Das sollte jetzt aber eigentlich nicht liegen

02:32:18.920 --> 02:32:32.840
Das soll hä wo kommt das memory leak jetzt bitte schon her ich höre hier doch auf einzulesen

02:32:32.840 --> 02:32:48.840
Wo kommt denn das her

02:32:48.840 --> 02:32:56.080
Das muss jetzt mal einer erklären wo das herkommt

02:32:56.080 --> 02:33:04.840
Musst du nicht alten frames aus der liste remove

02:33:04.840 --> 02:33:06.080
Ja das mache ich ja hier

02:33:06.080 --> 02:33:18.680
Das ist immer wieder in cache eingelesen

02:33:18.680 --> 02:33:29.600
Warum liegt das denn jetzt

02:33:29.600 --> 02:33:32.040
Es können ja auch gar nicht mehr als 100 rein

02:33:32.040 --> 02:33:34.560
Oder Moment ich habe das limit raus genommen

02:33:34.560 --> 02:33:40.160
Ich habe das limit raus genommen für die blocking collection

02:33:40.160 --> 02:33:42.320
Der schreibt wirklich jetzt unendlich viel da rein

02:33:42.320 --> 02:33:49.280
Krass äh hau verkackt

02:33:49.280 --> 02:34:00.840
Hallo andi unter aller sau

02:34:00.840 --> 02:34:01.840
Was ist ein memory leak

02:34:01.840 --> 02:34:02.840
Ja warte mal

02:34:02.840 --> 02:34:11.640
Boah poggers gecachede bilder macht was aus

02:34:11.640 --> 02:34:12.640
Schauts euch an

02:34:12.640 --> 02:34:15.640
Gecachede bilder ist das nochmal

02:34:15.640 --> 02:34:20.160
Da ist der schnellste gif player quasi noch schneller geworden

02:34:20.160 --> 02:34:29.400
Sind wir schon bei fast 5000 fps

02:34:29.400 --> 02:34:31.400
Oh mein gott

02:34:31.400 --> 02:34:32.400
Also ähm

02:34:32.400 --> 02:34:35.520
A memory leak ist eigentlich relativ einfach erklärt

02:34:35.520 --> 02:34:39.680
Das was der flow96 sagt ist so schon gar nicht verkehrt

02:34:39.680 --> 02:34:41.600
Wobei das nicht den kern trifft

02:34:41.600 --> 02:34:43.000
Wenn der ram verbrauch permanent steigt

02:34:43.000 --> 02:34:47.480
Die frage ist natürlich warum steigt der ram verbrauch immer weiter an

02:34:47.480 --> 02:34:50.480
Und

02:34:50.480 --> 02:34:52.280
In sprachen wie sagen wir mal c

02:34:52.280 --> 02:34:55.040
Dort wo du dich um die speicherverwaltung selbst kümmern musst

02:34:55.040 --> 02:34:57.320
Ist eigentlich auch das einzige wo memory leaks auftreten können

02:34:57.320 --> 02:34:59.720
Und warum ich in c sharp memory leaks habe

02:34:59.720 --> 02:35:02.000
Ist ähm weil ich eben die c library verwende

02:35:02.000 --> 02:35:05.600
Im prinzip ist eine memory leak ganz einfach damit erklärt

02:35:05.600 --> 02:35:07.760
Wenn du speicher anforderst

02:35:07.760 --> 02:35:10.200
Aber den speicher nicht wieder zurück gibst

02:35:10.200 --> 02:35:12.120
Das ist in memory leak

02:35:12.120 --> 02:35:14.240
Wenn ich jetzt sage betriebssystem gibt mir speicher

02:35:14.240 --> 02:35:15.760
Ich möchte was damit machen

02:35:15.760 --> 02:35:16.760
Kriege ich keine ahnung

02:35:16.760 --> 02:35:19.760
Ein mb speicher

02:35:19.760 --> 02:35:21.760
Und ähm

02:35:21.760 --> 02:35:23.640
Nächstes mal wenn ich was sage

02:35:23.640 --> 02:35:24.640
Wenn ich was brauche

02:35:24.640 --> 02:35:26.800
Betriebssystem ich brauche wieder ein mb speicher

02:35:26.800 --> 02:35:28.680
Ohne dass ich den speicher jemals wieder

02:35:28.680 --> 02:35:31.480
Äh sage hier kannst du wieder verwenden

02:35:31.480 --> 02:35:32.480
Das ist in memory leak

02:35:32.480 --> 02:35:35.480
Ja also sprich ich gebe einfach nicht den speicher wieder frei

02:35:35.480 --> 02:35:37.840
Den ich mal angefordert habe ganz ganz simpel gesagt

02:35:37.840 --> 02:35:40.560
Und was heißt ganz simpel gesagt

02:35:40.560 --> 02:35:41.560
Genau das ist es

02:35:41.560 --> 02:35:44.800
Du forderst speicher an und gibst die nicht wieder

02:35:44.800 --> 02:35:46.160
Oder vergisst die wieder zurück zu geben

02:35:46.160 --> 02:35:47.160
Und forderst weiteren an

02:35:47.160 --> 02:35:49.960
Und dann leaks du halt quasi memory

02:35:49.960 --> 02:35:53.600
Weil ja du hast es angefordert gibst das aber nie wieder zurück

02:35:53.600 --> 02:35:58.720
Letztendlich führt eine memory leak aber nie dazu

02:35:58.720 --> 02:35:59.720
Das was kaputt geht

02:35:59.720 --> 02:36:02.160
Das schlimmste was passieren kann ist

02:36:02.160 --> 02:36:03.160
Äh

02:36:03.160 --> 02:36:05.840
Dass irgendwann mal out of memory gibt

02:36:05.840 --> 02:36:07.400
Und du halt kein rammer kriegst

02:36:07.400 --> 02:36:10.640
Oder dein programm abgeschossen wird

02:36:10.640 --> 02:36:12.520
Das wahrscheinlich eher dein programm abgeschossen

02:36:12.520 --> 02:36:13.760
Also eigentlich passiert nichts

02:36:13.760 --> 02:36:19.760
Weil spätestens wenn dein programm beendet wird

02:36:19.760 --> 02:36:22.120
Wird auch jeglicher speicher wieder eingesammelt

02:36:22.120 --> 02:36:24.000
Den es jemals bekommen hat

02:36:24.000 --> 02:36:25.320
Also sprich du kannst nur

02:36:25.320 --> 02:36:26.760
Und das ist eine ganz wichtige geschichte

02:36:26.760 --> 02:36:27.760
Die man sich merken muss

02:36:27.760 --> 02:36:32.600
Du kannst nur memory leaken solange dein programm noch läuft

02:36:32.600 --> 02:36:34.800
Das ist ja auch gerade der

02:36:34.800 --> 02:36:36.600
Der effekt den man hat bei zeug

02:36:36.600 --> 02:36:38.200
Was ein bisschen merkwürdig programmiert ist

02:36:38.200 --> 02:36:39.200
Und z.B.

02:36:39.200 --> 02:36:41.200
Am Anfang Battlefield 4

02:36:41.200 --> 02:36:42.200
Dass man das

02:36:42.200 --> 02:36:45.040
Teilweise nach 2-3 stunden neu starten musste

02:36:45.040 --> 02:36:47.080
Weil das dann irgendwann 5GB gefressen hat

02:36:47.080 --> 02:36:48.080
Oder so ram

02:36:48.080 --> 02:36:52.560
Und durch den neustart vom game beendet sich der prozess

02:36:52.560 --> 02:36:55.200
Das betriebssystem sammelt alle arbeitsspeicher wieder ein

02:36:55.200 --> 02:36:57.320
Den es jemals diesen prozess gegeben hat

02:36:57.320 --> 02:36:58.320
Das weiß es ja

02:36:58.320 --> 02:37:00.840
Es wurde ja von ihm angefordert

02:37:00.840 --> 02:37:03.080
Und sagt jawoll kann es wieder verwendet werden

02:37:03.080 --> 02:37:12.200
Saito bar 3 man sieht es natürlich anders aus

02:37:12.200 --> 02:37:14.600
Ja wir reden jetzt hier rein von user mode geschichten

02:37:14.600 --> 02:37:26.160
Aber ich muss sagen hier dieser

02:37:26.160 --> 02:37:28.040
Der player der ist richtig hübsch jetzt oder

02:37:28.040 --> 02:37:33.240
Wir können es hier nochmal einrücken ein bisschen anders

02:37:33.240 --> 02:37:34.240
Ich glaube wir machen das mal alles

02:37:34.240 --> 02:37:39.120
Gucken ob das so besser aussieht wenn wir das alles auf eine ebene machen

02:37:39.120 --> 02:37:49.640
Sieht es jetzt besser aus ich weiß nicht

02:37:49.640 --> 02:38:03.960
Es sieht kürzer aus

02:38:03.960 --> 02:38:07.520
Ich muss sagen ich finde den gift player eigentlich ganz hübsch jetzt

02:38:07.520 --> 02:38:10.880
So wie er ist vor allem jetzt nachdem wir den frame nochmal

02:38:10.880 --> 02:38:20.680
Quasi gekapselt haben

02:38:20.680 --> 02:38:22.400
Finde ich den echt ganz ganz nett

02:38:22.400 --> 02:38:34.400
Achso ja gut jetzt müssen wir noch ein sleep einbauen

02:38:34.400 --> 02:38:40.800
Ok dann machen wir hier noch einen public

02:38:40.800 --> 02:38:46.960
Wo ist man zwar nicht aber finde ich schöner

02:38:46.960 --> 02:38:51.600
Stream index brauchen wir auch nicht

02:38:51.600 --> 02:38:52.600
Ist immer 0

02:38:52.600 --> 02:39:09.120
Können wir tatsächlich read only machen

02:39:09.120 --> 02:39:10.120
Wir machen jetzt noch hier was

02:39:10.120 --> 02:39:31.320
Und das setzen wir

02:39:31.320 --> 02:39:47.480
Jetzt kriegen wir noch die fps

02:39:47.480 --> 02:39:50.120
So jetzt werden wir das ganze nämlich ein bisschen begrenzen noch

02:39:50.120 --> 02:39:52.360
Weil aktuell ist es ein bisschen viel

02:39:52.360 --> 02:39:55.160
Gucken wir mal was der ganze spaß für cpu verursacht

02:39:55.160 --> 02:40:09.160
Also wir brauchen gerade mal leppische 33% cpu last

02:40:09.160 --> 02:40:13.160
Also quasi von einem 6 kerne lasten wir 2 kerne quasi komplett aus

02:40:13.160 --> 02:40:18.400
Was auch irgendwie sinn ergibt dass wir 2 kerne komplett auslasten

02:40:18.400 --> 02:40:21.040
Wir haben hier unseren thread der gifs decoded

02:40:21.040 --> 02:40:26.960
Und wir haben hier unseren thread der wie verrückt rendert

02:40:26.960 --> 02:40:29.640
Also das passt schon dass wir 2 kerne ziemlich gut auslasten

02:40:29.640 --> 02:40:34.640
Und das ist ein beispiel halt für ein problem was sich super multithreaden lässt

02:40:34.640 --> 02:40:37.560
So und wir werden jetzt mal sleepen

02:40:37.560 --> 02:40:44.080
Wir sleepen jetzt allerdings nicht einfach random irgendwie

02:40:44.080 --> 02:40:53.280
Sondern wir sleepen jetzt anhand der

02:40:53.280 --> 02:40:55.280
Das ist hier decoder

02:40:55.280 --> 02:40:57.280
Fps

02:40:57.280 --> 02:41:00.280
Tausend

02:41:00.280 --> 02:41:02.480
Tausend

02:41:02.480 --> 02:41:03.480
Durch fps

02:41:03.480 --> 02:41:06.080
Dann müssten wir eigentlich die zeit oder

02:41:06.080 --> 02:41:08.880
Die zeit in millisekunden haben die wir sleepen müssten

02:41:08.880 --> 02:41:18.280
Er ist ein double

02:41:18.280 --> 02:41:19.280
Ich will es ja in millisekunden

02:41:19.280 --> 02:41:22.880
1 durch framerate ist ja 0, irgendwas

02:41:22.880 --> 02:41:25.400
Ich will es ja in millisekunden es müsste so doch eigentlich passen

02:41:25.400 --> 02:41:30.520
Oder ist jetzt genau falsch rum

02:41:30.520 --> 02:41:37.680
Ne passt doch guck mal genau 25 fps so soll es sein

02:41:37.680 --> 02:41:51.280
Das ist der alte gif player also man sieht 25 fps sind 25 fps

02:41:51.280 --> 02:41:56.480
Wenn man sich das anguckt wird man verrückt

02:41:56.480 --> 02:42:00.480
Mit der zeit das wird da jetzt voll schwindelig

02:42:00.480 --> 02:42:06.440
Man sieht es ist nicht ganz synchron guck mal es läuft auseinander

02:42:06.440 --> 02:42:11.480
Jetzt weiß man nicht was richtiger ist meins oder der wpf timer

02:42:11.480 --> 02:42:14.080
Es läuft immer weiter auseinander

02:42:14.080 --> 02:42:21.720
Mit dem timer könnte man das auch machen aber wir brauchen halt also wir bräuchten

02:42:21.720 --> 02:42:51.400
halt einen sehr sehr präzisen timer

02:42:51.400 --> 02:42:56.440
Also das wäre schon also mit mit einem timer den man auf

02:42:56.440 --> 02:42:58.000
Da reicht noch nicht mal millisekunden

02:42:58.000 --> 02:43:04.200
Also mal angenommen wir wollen was mit 60 fps haben

02:43:04.200 --> 02:43:14.360
Dann bräuchten wir quasi 16,66 also irgendwie soweit wie es geht millisekunden

02:43:14.360 --> 02:43:19.800
Die differenz der zyklen ja das muss man auch mal machen

02:43:19.800 --> 02:43:24.840
Also und sprich wenn man es quasi nur mit 16 macht wird man ja irgendwie dann

02:43:24.840 --> 02:43:30.640
Läuft man damit knapp unter 25 fps also müsste man

02:43:30.640 --> 02:43:36.000
Ne mit knapp über 25 umso kürzer die zeit umso schneller

02:43:36.000 --> 02:43:39.760
Knapp über 25 fps also bräuchte man irgendwie einen timer

02:43:39.760 --> 02:43:44.080
Der halt auch wirklich hoch auflöst gibt es gibt es dort nicht mäßig so was

02:43:44.080 --> 02:43:50.760
Timer intervall kann man kann man die intervall das muss man mal gucken

02:43:50.760 --> 02:43:57.200
Wie sieht es mit sleep nanosekunden aus mikrosekunden aus

02:43:57.200 --> 02:44:03.720
Es gibt es gibt das hier es gibt thread aber das ist nicht schön es gibt spin

02:44:03.720 --> 02:44:14.400
Da kannst du irgendwie ich weiß nicht ob es sind nanosekunden ne das ist glaube

02:44:14.400 --> 02:44:19.600
Ich irgendwie schleif ins intern schleifendurchgänge oder sowas

02:44:19.600 --> 02:44:37.440
Wir können ja mal stackoverflow bemühen die scharp sleep nanosekunden

02:44:37.440 --> 02:44:40.000
Wir können mal gucken was was task delay hat

02:44:40.000 --> 02:44:53.320
Millisekunden millisekunden timespan wenn es den timespan frisst

02:44:53.320 --> 02:44:56.200
Prokramierst du auch beruflich ja aber was anderes als hier

02:44:56.200 --> 02:44:59.640
Allerdings verdiene ich nicht meine hauptsächliches kohler damit ich

02:44:59.640 --> 02:45:10.520
Prokramiere auch sachen ich mache so das was man neudeutsch def obs nennt

02:45:10.520 --> 02:45:17.680
Kann man hier nicht sagen new timespan also erst mal gucken ob das generell mit

02:45:17.680 --> 02:45:35.600
dem delay wie macht man das jetzt wait nicht wirklich oder was hat man 40

02:45:35.600 --> 02:45:42.400
Millisekunden verwirrungswunsch fps ne okay der task der task delay ist fail

02:45:42.400 --> 02:45:52.800
der funktioniert nicht richtig also hier 60 fps funktionieren hier

02:45:52.800 --> 02:46:02.840
60 fps ja und hier sieht man jetzt das halt der das nicht so ganz stimmt

02:46:02.840 --> 02:46:14.960
hat es immer ein bisschen schwankt wie können wir denn das jetzt wie

02:46:14.960 --> 02:46:22.600
sleept man dann hier ordentlich unter oder besser gesagt moment wie auf wie

02:46:22.600 --> 02:46:41.680
gut auflösen sind dann die timer intervall system threading timer system

02:46:41.680 --> 02:46:54.080
timer system windows ok was ist der unterschied dazwischen timer callback object state ok

02:46:54.080 --> 02:47:10.120
der sieht kompliziert aus der kann bestimmt was period in millisekunden alles in millisekunden

02:47:10.120 --> 02:47:25.560
es haben wir hier zu bieten intervall milliseconds als letztes haben die windows timer der kann

02:47:25.560 --> 02:47:36.440
man hier gar nicht setzen intervall in millisekunden performance count das gibt es bestimmt schon

02:47:36.440 --> 02:47:44.840
managt das ist da muss irgendwas ich wein ich hätte eine ganz blöde ideen

02:47:44.840 --> 02:48:07.600
ah flow das hast du gut beobachtet das kann man mal ausprobieren timer timer er akzeptiert

02:48:07.600 --> 02:48:22.840
aber double das können wir echt mal ausprobieren also sprich dass man da jetzt 16,777 oder

02:48:22.840 --> 02:48:52.680
ne was war es

02:48:52.680 --> 02:48:58.680
noch mal gucken wie wir das jetzt machen also von der idee her müssen wir uns jetzt ja

02:48:58.680 --> 02:49:17.000
die schleife hier schenken

02:49:17.000 --> 02:49:26.120
und der render krempel müsste eigentlich da rein jetzt ne wenn ich das jetzt richtig

02:49:26.120 --> 02:49:51.800
sehe es kann aber auch sein dass es voll verkacken ach so vielleicht sollte man mal starten start

02:49:51.800 --> 02:50:01.140
da

02:50:01.140 --> 02:50:01.640
30?

02:50:06.140 --> 02:50:07.140
Warum 33?

02:50:10.140 --> 02:50:11.140
Check ichs jetzt nicht?

02:50:14.140 --> 02:50:15.140
Das Ding sollte doch...

02:50:16.140 --> 02:50:17.140
33?

02:50:18.140 --> 02:50:19.140
Warum 33?

02:50:22.140 --> 02:50:24.140
Ich glaub der timet einfach nicht so genau.

02:50:24.140 --> 02:50:28.140
Nee, der ist einfach nicht so genau der Timer, der ist schlecht.

02:50:30.140 --> 02:50:34.140
Ich mein wir wollen jetzt hier alle 40 Millisekunden einen Tick haben und...

02:50:37.140 --> 02:50:38.140
Hast du noch ein Sleep drin?

02:50:38.140 --> 02:50:39.140
Nee.

02:50:44.140 --> 02:50:48.140
Ja, aber wenns mit 40 schon halt geht, Clocks HD...

02:50:48.140 --> 02:50:52.140
Ja, aber wenns mit 40 schon halt geht, Clocks HD...

02:51:01.140 --> 02:51:02.140
Also...

02:51:06.140 --> 02:51:10.140
Der Timer ist irgendwie nicht sonderlich precision-mäßig.

02:51:10.140 --> 02:51:16.140
Das Drawn geht schnell, das Drawn braucht doch keine so viel, das Drawn braucht nix.

02:51:19.140 --> 02:51:21.140
Ja, aber mein Code braucht keine...

02:51:21.140 --> 02:51:22.140
Nee, nee, nee, nee.

02:51:25.140 --> 02:51:28.140
Wenn man weiß, dass es ja ohne Timer gehts ja auch schnell.

02:51:28.140 --> 02:51:29.140
Also, ne?

02:51:29.140 --> 02:51:30.140
Das ist ja nicht so...

02:51:30.140 --> 02:51:33.140
Also mit nem Sleep, mit nem normalen Sleep funktionierts ja.

02:51:33.140 --> 02:51:35.140
Also daran kann es schonmal nicht liegen.

02:51:35.140 --> 02:51:40.140
Nee, also mit dem Timer klappt das nicht.

02:51:40.140 --> 02:51:43.140
Ich hab aber ne ganz blöde andere Idee.

02:51:44.140 --> 02:51:45.140
Pass mal auf.

02:51:49.140 --> 02:51:53.140
Ist bei GIFs nicht die Zeit zwischen den einzelnen Bildern in der GIF selbst hinterlegt?

02:51:54.140 --> 02:51:56.140
Das kann durchaus sein.

02:51:56.140 --> 02:52:01.140
Das kann durchaus sein.

02:52:03.140 --> 02:52:05.140
Hast du einen Grund warum du auf Englisch schreibst?

02:52:05.140 --> 02:52:07.140
W-w-w-w-wo schreib ich auf Englisch?

02:52:07.140 --> 02:52:09.140
Meinst du hier drinnen?

02:52:10.140 --> 02:52:13.140
Ja, Sounds Code schreibt man dann immer auf Englisch.

02:52:19.140 --> 02:52:22.140
Ja, aber Leute, das macht doch überhaupt keinen Sinn.

02:52:22.140 --> 02:52:26.140
Lass es mal ne Millisekunde dauern, wie das hier Ding.

02:52:26.140 --> 02:52:29.140
Das kann aber trotzdem nicht sein, dass der Timer auf einmal anstatt 60,

02:52:29.140 --> 02:52:32.140
obwohl ich die Zeit für 60 FPS angegeben auf einmal 33 hat.

02:52:38.140 --> 02:52:42.140
Achso, Tastaturlayout. Hab ich nicht, ich hab das Tastaturlayout auf Deutsch.

02:52:42.140 --> 02:52:47.140
So, also wir machen jetzt mal sowas hier.

02:52:51.140 --> 02:52:55.140
Das ist natürlich der Hardcore-Ansatz, sowas zu machen.

02:53:01.140 --> 02:53:05.140
Also, wir machen jetzt irgendwie sowas wie...

02:53:05.140 --> 02:53:08.140
Wir machen jetzt irgendwie sowas wie,

02:53:08.140 --> 02:53:10.540
Also Wir Machen Jetzt IrGendwie so was wie

02:53:14.580 --> 02:53:18.420
Weil True und dann dann dann Slippen wir IrGendwie Zwischen Zwischendurch

02:53:21.580 --> 02:53:26.300
IrGendwie sowas das funktioniert das wird Auf Jeden fall Funktionieren

02:53:28.180 --> 02:53:30.380
Kann man das Kann man das IrGendwie mit Detail Machen oder so

02:53:30.380 --> 02:53:39.140
Obwohl wir haben hier oben doch wir haben hier oben doch schon in daytime gesetzt start start time

02:53:46.460 --> 02:53:48.460
Aber ich probiere das Jetzt Mal Aus

02:53:48.460 --> 02:53:52.460
Start

02:53:56.660 --> 02:53:59.380
Obbei Ne mit daytime Komme ich da Wahrscheinlich nicht weiter

02:54:02.940 --> 02:54:06.860
Mit stopwatch mit stopwatch Können wir da IrGendwas Machen

02:54:06.860 --> 02:54:13.020
Mit stopwatch

02:54:13.020 --> 02:54:33.500
Was war eine Image Instanz dort den aktuellen frame index und last update Millisekunden

02:54:33.500 --> 02:54:44.300
Im image update Leuchten wir gerade nicht ein

02:54:44.300 --> 02:54:50.980
Ach so du checkst vorher ob es zeit zum updaten ist

02:54:50.980 --> 02:54:57.980
Du machst das Du machst das nicht alles hier in so einem riesen durchlauf sondern du checkst

02:54:57.980 --> 02:55:02.300
quasi so nach dem motto gibt es ein update ist es zeit zu updaten und wenn es Zeit zu updaten ist

02:55:02.300 --> 02:55:03.940
Damit Gemalt und gestoort

02:55:13.140 --> 02:55:15.140
Ticks

02:55:19.140 --> 02:55:21.140
Ticks

02:55:21.140 --> 02:55:28.140
Ticks brauchen wir

02:55:28.140 --> 02:55:40.660
Okay die meinen das Ernst Ticks

02:55:40.660 --> 02:55:53.780
Wie lang ist denn ein Tick ein paar nanosekunden oder so

02:55:53.780 --> 02:56:01.820
Ticks sind nicht Millisekunden Ticks ist irgendwas mit nanosekunden oder so

02:56:01.820 --> 02:56:26.940
Ticks mal 100 sind nanosekunden oder sehe ich das hier richtig

02:56:26.940 --> 02:56:37.420
Ticks mal 100 sind nanosekunden okay

02:56:37.420 --> 02:57:00.500
Microseconds würden wir schon reichen

02:57:00.500 --> 02:57:15.060
Aha das ist ja nice Ticks per Millisekund

02:57:15.060 --> 02:57:25.100
Aha das ist das ist gut stack overflow heute sind wir richtig stack overflow driven

02:57:25.100 --> 02:57:43.380
Ich will es jetzt einfach mal rauskriegen ob das so so funktioniert würde

02:57:43.380 --> 02:57:59.220
So wie jetzt gucken wir gerade wieder 140 leute zu wie ich keine ahnung

02:57:59.220 --> 02:58:05.580
Habt wie wir es hier ordentlich warten können gibt es gibt es nicht vielleicht einen sie schabt

02:58:05.580 --> 02:58:14.100
Gibt es das wäre mir natürlich am allerliebsten muss ich den ganzen wait schiess nicht selber

02:58:14.100 --> 02:58:15.100
machen

02:58:15.100 --> 02:58:29.460
Das hat doch bestimmt schon irgendeiner programmiert

02:58:29.460 --> 02:58:46.780
Github sie schabt timer high high precision timer in dotnet zack

02:58:46.780 --> 02:59:03.380
easy wie macht der das

02:59:03.380 --> 02:59:17.260
ja mit dem windows timer das können wir auch machen was sind das für eine für eine win

02:59:17.260 --> 02:59:22.260
mdl

02:59:22.260 --> 02:59:23.780
media timer muss ja genau sein

02:59:23.780 --> 02:59:37.420
Dann machen wir das doch damit

02:59:37.420 --> 02:59:39.460
Obbei mich ja doch interessieren würde wie man sowas hier hinkriegen

02:59:39.460 --> 02:59:44.300
Probieren wir das mal mit dem windows timer ich glaube das ist die bessere variante

02:59:44.300 --> 02:59:58.140
Warum ist es hier schwarz weil man weiß nicht

02:59:58.140 --> 03:00:25.540
gibt es aber schon fertige projekte

03:00:25.540 --> 03:00:30.860
da gibt es ein paar

03:00:30.860 --> 03:00:33.940
Ok wir machen das mal wie hier also ich finde das hier klingt gut

03:00:33.940 --> 03:00:36.140
Time set event

03:00:36.140 --> 03:00:44.340
Wir klauen uns jetzt mal hier den aufruf von ihm wie er das wie er das gemacht hat

03:00:44.340 --> 03:01:02.260
Also wir klauen uns das nicht wir holen uns die api definition raus

03:01:02.260 --> 03:01:03.260
Ja das nämlich

03:01:03.260 --> 03:01:15.700
Gucken wir mal ob das funktioniert wir rennen wir rennen dann mal gerade nichts

03:01:15.700 --> 03:01:17.100
Wir gucken einfach nur mal ob das geht

03:01:17.100 --> 03:01:33.580
Das sieht von der von der von der auflöser von von der methode relativ simpel aus von

03:01:33.580 --> 03:01:34.580
der signatur her

03:01:34.580 --> 03:01:50.940
Also set time ne wie hieß der kram set time set event

03:01:50.940 --> 03:01:55.540
So und dann sagen wir kleine stars diese promi frauen sind unter ein meter sechzig

03:01:55.540 --> 03:02:08.140
Oh ja das wollte ich schon immer mal wissen von gofeminin.de

03:02:08.140 --> 03:02:09.140
Milliseconds

03:02:09.140 --> 03:02:10.140
Moment

03:02:10.140 --> 03:02:16.300
Ich will keine Milliseconds

03:02:16.300 --> 03:02:25.540
Obwohl doch Milliseconds mit Komma ist ok

03:02:25.540 --> 03:02:27.460
Was sagt die Microsoft hilfe seite dazu

03:02:27.460 --> 03:02:47.140
So was sagt denn die Microsoft hilfe seite dazu

03:02:47.140 --> 03:02:57.740
In Milliseconds ich will es doch nicht in Milliseconds haben

03:02:57.740 --> 03:03:04.060
Warum ist das scheiß auch wieder in Milliseconds

03:03:04.060 --> 03:03:17.660
Alter geht mir das auf den keks jetzt

03:03:17.660 --> 03:03:19.620
Was query performance

03:03:19.620 --> 03:03:35.500
Oh ja das ist schön das wollen wir haben

03:03:35.500 --> 03:03:43.220
Da machen wir einfach jetzt eine wildschleife und gucken einfach

03:03:43.220 --> 03:03:44.340
Warum nennt man das

03:03:44.340 --> 03:03:50.220
New delay wenn es Milliseconds sind weil das Microsoft ist wahrscheinlich für unsigned

03:03:50.220 --> 03:04:09.060
Weil es ein unsigned ist

03:04:09.060 --> 03:04:23.940
Ich weiß dass du es gleich schon gesagt hast

03:04:23.940 --> 03:04:24.940
qpc und qpf

03:04:24.940 --> 03:04:47.700
Query performance

03:04:47.700 --> 03:05:00.660
Die Frequenz in der sich der performance counter update oder was also dass man sieht

03:05:00.660 --> 03:05:07.620
wie groß die sprünge sind zwischen den countern oder wie darf man das verstehen

03:05:07.620 --> 03:05:28.580
Query performance counter

03:05:28.580 --> 03:05:37.460
Jetzt Achtung schön das neue C sharp 7 feature

03:05:37.460 --> 03:05:41.620
Out bar counter

03:05:41.620 --> 03:05:45.300
Nächster mit extra variabler anlegen und jetzt counter ausgehen

03:05:45.300 --> 03:06:02.380
Aha jetzt bin ich mal gespannt

03:06:02.380 --> 03:06:15.200
Butschend

03:06:15.200 --> 03:06:38.960
Achso und das heißt, hiermit sehe ich quasi den Counter, der sich erhöht. Nur mal so,

03:06:38.960 --> 03:06:41.680
dass ich das jetzt richtig verstehe. Ich habe hier einen Counter, ich weiß allerdings nicht

03:06:41.680 --> 03:06:46.980
wie genau wie lang eine einheit ist wenn ich wissen will wie lange eine einheit ist dann muss ich hierhin gucken

03:06:54.860 --> 03:06:59.080
Oder ist es ein timestamp in in was

03:07:02.920 --> 03:07:04.920
Mikrosekunden okay

03:07:04.920 --> 03:07:10.440
Kann, wir können, wir ausprobieren

03:07:19.720 --> 03:07:21.720
Beruf, beruflich mache ich das in vielen sprachen

03:07:24.000 --> 03:07:26.000
Also was natürlich

03:07:26.080 --> 03:07:28.820
Wenn, man, ein, bisschen mit inox zu tun hat immer der fall ist es

03:07:28.820 --> 03:07:34.020
Irgendwelche shells, ich mache ganz gerne in ruby was wenn es nicht schnell sein muss

03:07:35.620 --> 03:07:42.460
In groovy habe ich auch ein paar sachen gebastelt schon wenn es geht dort net mit dort net core geht ja auf linux mittlerweile auch

03:07:43.460 --> 03:07:47.700
Mal auch die eine oder andere java script frontend geschichte wenn es sich nicht vermeiden lässt

03:07:49.460 --> 03:07:55.700
paar sachen also am liebsten mache ich eigentlich was in ruby wenn es nicht auf performance ankommt ruby und dort net ist für

03:07:55.700 --> 03:07:59.420
Mich so auf einer also die scharp und ruby ist für mich so auf einer einer ebene

03:08:12.300 --> 03:08:14.300
okay

03:08:16.420 --> 03:08:23.260
Also das heißt nur also wie wir machen jetzt jetzt mal ganz billig wir machen jetzt einen schleif und prägen die schleife sobald wir

03:08:23.260 --> 03:08:25.260
quasi

03:08:27.580 --> 03:08:33.380
40 millisekunden oder sag, man, mal 16 16, irgendwas

03:08:34.660 --> 03:08:36.820
millisekunden gewartet haben irgendwie

03:08:38.860 --> 03:08:40.860
oder besser gesagt

03:08:41.940 --> 03:08:43.940
16000 mikrosekunden

03:08:43.940 --> 03:08:51.940
Aber was noch sie also gucken, wir machen

03:08:54.340 --> 03:08:56.340
die performance counter

03:08:58.340 --> 03:09:03.860
Ich habe irgendwas im hals so und dann brauchen wir jetzt noch das andere das heißt dann brauchen wir jetzt noch

03:09:03.860 --> 03:09:11.380
die gleiche signatur hat

03:09:11.380 --> 03:09:23.980
Okay, das müssen wir nur einmal querien ich auch gerade sehen

03:09:23.980 --> 03:09:43.220
Ich weiß es gar nicht wie was nennen sollen query performance frequency

03:09:43.220 --> 03:09:47.420
Und war

03:09:51.540 --> 03:09:53.540
Timespan

03:09:56.980 --> 03:10:02.060
Was machst du dort gerade ich bastel ein transparentes gif overlay

03:10:04.820 --> 03:10:06.820
Für meinen

03:10:06.820 --> 03:10:13.060
Neen bort weil das standard wpf overlay wie du hier siehst wenn ich drauf klicke

03:10:14.500 --> 03:10:17.380
Viel zu langsam ist jetzt ja du klickst

03:10:18.860 --> 03:10:19.980
zack

03:10:19.980 --> 03:10:21.140
klick

03:10:21.140 --> 03:10:22.820
zack klick

03:10:22.820 --> 03:10:31.020
zack viel zu langsam bei kleinen bei kleinen gifs geht es ganz schnell aber ich habe jetzt was eigenes gebastelt was viel schneller ist

03:10:32.100 --> 03:10:34.100
das spielt gifs mit

03:10:34.100 --> 03:10:37.060
4273 fps ab

03:10:37.620 --> 03:10:43.180
Was kein mensch braucht so jetzt gucken wir gerade wie wir am besten warten auf das nächste nächste mal wo wir rennen mussten

03:10:52.860 --> 03:10:56.380
Ganz wichtig nicht einfach fps sondern fps in der sekunde

03:10:56.380 --> 03:11:01.820
So performance counter

03:11:05.020 --> 03:11:07.420
Sonst hängt er nach einmal rennen dann hängt er jetzt hier

03:11:11.900 --> 03:11:13.900
So

03:11:14.060 --> 03:11:19.060
Das bedeutet doch jetzt nur mal so von der idee also wenn ich jetzt hier einmal ausgebe

03:11:19.060 --> 03:11:27.420
Quasi den den den den die timespan also das da

03:11:30.260 --> 03:11:32.460
Ist quasi die zeit

03:11:36.420 --> 03:11:41.940
Zwischen zwei tix von diesen performance counter oder

03:11:41.940 --> 03:11:48.100
Oder habe ich das denn jetzt

03:11:48.100 --> 03:12:05.340
Frequenzie oder ne moment moment moment das ist das nee das ist wie wie wie schnell der updated oder

03:12:18.100 --> 03:12:20.100
Gibt es natürlich noch 2000

03:12:31.620 --> 03:12:35.140
Genau counter durch frequency ok was kommt dann da am ende raus

03:12:40.540 --> 03:12:42.540
Nennen wir es nicht timespan

03:12:42.540 --> 03:12:50.300
Frequenzie das ist ist das eine sekunde

03:12:56.860 --> 03:12:58.860
Das ist pro sekunde

03:13:03.980 --> 03:13:05.980
Das ist pro sekunde ne

03:13:05.980 --> 03:13:12.580
Aha okay das oh das ist aber echt interessant

03:13:15.500 --> 03:13:17.500
Das ist sehr interessant

03:13:24.740 --> 03:13:26.740
Lange mikrosekunden ja

03:13:26.740 --> 03:13:45.460
Also ganz, so ganz habe ich es jetzt aber noch nicht gecheckt, wie wir das machen.

03:13:45.460 --> 03:13:59.540
Warte mal, also sprich, was sehe ich denn jetzt überhaupt?

03:13:59.540 --> 03:14:14.940
Das update sich einmal in der Sekunde, das ist die, der Counter, der geht permanent rauf

03:14:14.940 --> 03:14:31.820
und das geteilt durch die, durch die Frequency, so also das bedeutet jetzt haben wir hier

03:14:31.820 --> 03:15:01.740
die Frequency, was, war, das ist kein JavaScript, war, wie ist das aus, was ist das, was ist

03:15:01.740 --> 03:15:02.740
das?

03:15:02.740 --> 03:15:28.240
Wie check ich das nicht, was ich was, was ich da jetzt eigentlich für eine Zeit habe.

03:15:28.240 --> 03:15:43.240
Also wenn ich das jetzt habe, dann das jetzt in der Sekunde ist.

03:15:43.240 --> 03:16:12.240
Also es leuchtet mir ehrlich gesagt nicht.

03:16:12.240 --> 03:16:14.240
Was soll das jetzt genau sein?

03:16:42.240 --> 03:17:11.240
Der Query das hier am Anfang, dann speichert er sich das irgendwo, wo speichert er sich

03:17:11.240 --> 03:17:19.240
das da, das nicht hier oben speichern, das ist im Prinzip ein bisschen was ich oben beim

03:17:19.240 --> 03:17:29.240
FPS Counter auch mache, oder?

03:17:29.240 --> 03:17:52.240
Also brauche ich hier sowas wie, ne, hä?

03:17:52.240 --> 03:17:58.240
Ich will im Prinzip doch einfach nur wissen, ob ich jetzt schon 60 Millisekunden gewartet

03:17:58.240 --> 03:18:18.240
oder in dem Fall 16 Millisekunden, also.

03:18:18.240 --> 03:18:28.240
Äh, wie macht man das da draus?

03:18:28.240 --> 03:18:41.240
Scheiße ich sie scharf stark von C++, ja.

03:18:41.240 --> 03:18:49.240
Was, Double Counter, ich kann sowas nicht Copy Paste, ich muss das jetzt erstmal checken,

03:18:49.240 --> 03:18:58.240
was ich da habe.

03:18:58.240 --> 03:19:03.240
Jaja, dass es die Millisekunden sind, das ist mir schon klar, aber ich will doch einfach

03:19:03.240 --> 03:19:12.240
glaube ich mehr als, ich muss die zwei Sachen miteinander vergleichen.

03:19:12.240 --> 03:19:25.240
Also ich muss mir einfach, ich muss mir einmal Start holen, Start Counter, so und im Prinzip

03:19:25.240 --> 03:19:34.240
muss ich doch jetzt eigentlich nur gucken, ob ich jetzt, ob das hier größer, Start Counter,

03:19:34.240 --> 03:19:41.240
so und hier muss ich jetzt dazu rechnen, was ich brauche zur Zahl für Millisekunden.

03:19:41.240 --> 03:19:51.240
Also irgendwie keine Ahnung, wie auch immer, wie viel das ist.

03:19:51.240 --> 03:19:58.240
So, wenn ich das jetzt dazu rechne, dürfte es dann wieder bei einer Sekunde sein, jaja,

03:19:58.240 --> 03:20:22.240
das sieht so aus, ne nicht plus Frequency.

03:20:22.240 --> 03:20:37.240
Easy peasy.

03:21:07.240 --> 03:21:30.080
Wir können mal gucken was passiert, genau auskennfuchs, sowas in der richtung hab ich

03:21:30.080 --> 03:21:39.840
auch gar nicht, wenn man die krams voneinander abzieht, da müsste ja was relativ kleines

03:21:39.840 --> 03:22:09.760
rauskommen, genau, und das

03:22:09.760 --> 03:22:14.920
die frequenzie ist ja nicht in millisekunden, irgendwie ist das der übelste brainfuck dieser

03:22:39.760 --> 03:22:43.840
also projekt soll ich noch einmal

03:23:09.760 --> 03:23:37.960
das ist das ist übelst ob die ecke

03:23:39.760 --> 03:23:49.320
ich glaube ich habe heute schon zu lange vom rechner gesessen das zu checken

03:24:09.760 --> 03:24:25.120
stimmt das jetzt?

03:24:25.120 --> 03:24:46.760
ich glaube das jetzt irgendwie sind was ich da gebastelt habe

03:24:55.120 --> 03:25:22.760
ja klar kann man es mit einem kleinen sleep ersetzen, das ist ja auch genau genug

03:25:22.760 --> 03:25:30.880
aber ich glaube ich bin heute nicht in der lage sowas zu checken mehr, das ist echt wahnsinn

03:25:30.880 --> 03:25:40.720
ich kann gerade keinen klaren gedanken fassen was so ein bisschen logik anbelangt

03:25:40.720 --> 03:25:49.240
es war halt einfach schon zu lange rum gebastelt, ja ja das gif hat das gif hat 25 fps das ist easy

03:25:49.240 --> 03:25:53.920
das war kein ding aber ich will ja trotzdem gucken wie ich konstante 60 fps hinkriege

03:25:53.920 --> 03:25:55.760
das würde mich einfach mal interessieren

03:25:55.760 --> 03:26:03.000
ja timer timer habe ich keinen gefunden der genau genug ist

03:26:03.000 --> 03:26:28.320
ich mache jetzt mal kurz was

03:26:28.320 --> 03:26:35.120
ich glaube die idee ist gar nicht so schlecht

03:26:35.120 --> 03:26:42.200
ich mein von der idee her war das einfach richtig wenn mein counter größer ist als start counter

03:26:42.200 --> 03:26:59.000
und jetzt halt hier quasi sowas wie plus 16 millisekunden in ticks so kann ich jetzt nicht

03:26:59.000 --> 03:27:08.720
sagen okay frequency frequency ist das was pro sekunde frequency ist ticks also das frequency

03:27:08.720 --> 03:27:27.000
ist ticks von diesem counter pro sekunde

03:27:27.000 --> 03:27:37.280
das heißt was kommt da jetzt raus

03:27:37.280 --> 03:27:39.160
ist das jetzt teilweise 16 millisekunden

03:27:39.160 --> 03:27:59.280
ich will ich will rauskriegen wie viel frequency quasi 16 millisekunden also wie viele wie

03:27:59.280 --> 03:28:01.800
viele ticks quasi 16 millisekunden entsprechen

03:28:01.800 --> 03:28:12.840
das bedeutet ich muss gerade was ausprobieren

03:28:12.840 --> 03:28:14.800
einfach mal gucken wie viele ungefähr rauskommen muss jetzt

03:28:14.800 --> 03:28:33.640
also irgendwas in dieser größe

03:28:33.640 --> 03:28:49.880
ich kann heute nichts mehr umrechnen ich bin nicht in der lagen irgendwas zu rechnen

03:28:49.880 --> 03:29:09.360
so also irgendwas um 50.000 müsste rauskommen deswegen mit dem dreh und das ist auch relativ

03:29:09.360 --> 03:29:34.160
schwer

03:29:34.160 --> 03:29:50.920
Wenn ich 60 mal wenn ich wenn ich quasi weiß das ist pro sekunde und ich weiß das ist

03:29:50.920 --> 03:30:05.920
pro sekunde da kann ich das doch eigentlich durcheinander teilen oder

03:30:05.920 --> 03:30:17.400
oder mein von der idee müsste es doch so was hier sein aber aus irgendwelchen gründen ist es das nicht oder oder ist es das doch

03:30:35.920 --> 03:30:53.600
was kann man auch machen das dauert auch keinen großen unterschied

03:31:06.360 --> 03:31:07.960
so kann unterschied

03:31:07.960 --> 03:31:17.520
so genau das gleiche im endeffekt weil es beides ist auch beides pro sekunde das müsste doch im

03:31:17.520 --> 03:31:20.320
prinzip das müsste doch eigentlich genau das gleiche sein

03:31:20.320 --> 03:31:39.200
ist doch

03:31:39.200 --> 03:31:52.600
das habe ich jetzt falsch gemacht ich kann echt nicht mehr denken heute

03:31:52.600 --> 03:32:15.920
ich blicke immer durch gerade

03:32:15.920 --> 03:32:21.560
ich will doch keinen so großen unterschied machen

03:32:21.560 --> 03:32:43.080
das ist irgendeine konversion geschichte weil ich meine im prinzip das da ich das jetzt davon

03:32:43.080 --> 03:32:47.440
handeintrag geht es ja auch aber das warum geht das vorher nicht

03:32:47.440 --> 03:32:54.600
auf 9000

03:32:54.600 --> 03:33:03.160
das ist irgendeine konversion geschichte

03:33:03.160 --> 03:33:12.440
ok das hatte ich doch vor fünf minuten schon was ist denn jetzt daran verkehrt

03:33:12.440 --> 03:33:15.280
das ist doch von der logik her ok das müsste

03:33:15.280 --> 03:33:44.200
ja das

03:33:44.200 --> 03:33:46.200
sieht nicht so aus wie man normalerweise performt

03:33:46.200 --> 03:33:48.200
ich hab, ich hab auch keine ahnung wie man das macht

03:33:52.200 --> 03:33:53.200
wisst ihr was?

03:33:53.200 --> 03:33:55.200
da muss ich mir noch mal Gedanken drüber machen

03:33:55.200 --> 03:33:56.200
wie wir das am besten machen

03:33:56.200 --> 03:33:58.200
hier drinnen zu sleepen ist eh keine

03:33:58.200 --> 03:34:00.200
sondern nicht clevere Idee

03:34:00.200 --> 03:34:02.200
aber ich glaub wir können es jetzt erst mal kurz

03:34:02.200 --> 03:34:04.200
als erstes mal

03:34:04.200 --> 03:34:06.200
für heute können wir das so lassen

03:34:06.200 --> 03:34:08.200
ich mein prinzipiell funktioniert es ja

03:34:08.200 --> 03:34:09.200
na?

03:34:09.200 --> 03:34:19.200
25 fps gif

03:34:19.200 --> 03:34:32.200
passt

03:34:32.200 --> 03:34:34.200
start counter form rendering hole

03:34:34.200 --> 03:34:43.200
ok, machen wir

03:34:43.200 --> 03:34:45.200
ich mach jetzt, ich mach jetzt alles

03:34:45.200 --> 03:34:50.200
ich kann heute eh nur mal richtig denken

03:34:50.200 --> 03:34:54.200
du warst aber schon vor, vor dem Durchgang, ne?

03:34:54.200 --> 03:35:02.200
pro Durchgang

03:35:02.200 --> 03:35:07.200
hm

03:35:07.200 --> 03:35:22.200
jetzt ist es sogar, jetzt ist es sogar ein ticken zu schnell

03:35:22.200 --> 03:35:24.200
aber das liegt daran

03:35:24.200 --> 03:35:26.200
wahrscheinlich, dass ich hier

03:35:26.200 --> 03:35:31.200
Komma-Stellen verliere irgendwie, ne?

03:35:31.200 --> 03:35:33.200
weil mir das jetzt ja mal einer erklären muss

03:35:33.200 --> 03:35:48.200
was hat er denn jetzt, was macht er denn hier wieder für conversion-dinger

03:35:48.200 --> 03:35:51.200
zack

03:35:51.200 --> 03:36:10.200
damit kann ich leben

03:36:10.200 --> 03:36:37.200
so

03:36:37.200 --> 03:36:54.200
das sieht doch jetzt ziemlich gleich aus, oder?

03:36:54.200 --> 03:37:04.200
gifs übertaktet, yeah

03:37:04.200 --> 03:37:07.200
ja, thera fox, das klingt logisch, ich muss mir noch mal Gedanken drüber machen

03:37:07.200 --> 03:37:11.200
von der logik her müsste es doch stimmen, weil ich da gewastelt habe, oder?

03:37:11.200 --> 03:37:35.200
ich meine, das GIF sieht jetzt auch schön SYNC aus

03:37:35.200 --> 03:37:50.200
das ist präzise genug

03:37:50.200 --> 03:38:05.200
das ist nicht lang

03:38:05.200 --> 03:38:20.200
guck mal mal, wir gucken mal wie lange das dauert, so ein, ein, einmal malen

03:38:20.200 --> 03:38:24.200
ja, und das stimmt, die Trot-Zeit wird tatsächlich abgezogen, weil wir den Krams am Anfang nehmen

03:38:24.200 --> 03:38:30.200
da hab ich jetzt gar nicht dran gedacht am Anfang

03:38:30.200 --> 03:38:35.200
also, wo fangen wir an? das eigentliche Malen ist ja hier

03:38:35.200 --> 03:38:40.200
start

03:38:40.200 --> 03:38:44.200
painter, paint

03:38:44.200 --> 03:38:52.200
bis da, würde ich sagen, ne?

03:38:52.200 --> 03:38:58.200
hier oben müssen wir übrigens, äh, ein bisschen reset müssen wir an der Stelle machen

03:38:58.200 --> 03:39:02.200
ne, nicht reset, stopp

03:39:02.200 --> 03:39:12.200
so, ähm, gucken wir mal

03:39:12.200 --> 03:39:41.200
wir haben Millisekunden, so, und danach haben wir reset

03:39:41.200 --> 03:39:44.200
dauert keine Millisekunde

03:39:44.200 --> 03:39:47.200
guck mal, das braucht nichts im Endeffekt

03:39:47.200 --> 03:39:54.200
in Ticks sind 100 Nanosekunden irgendwie an der Stelle, ja?

03:39:54.200 --> 03:39:57.200
das, das Drawn braucht nichts

03:39:57.200 --> 03:40:21.200
das braucht wirklich unter einer Millisekunde, ja?

03:40:21.200 --> 03:40:24.200
hier, guck mal

03:40:24.200 --> 03:40:27.200
unter einer halben Millisekunde braucht das Ganze

03:40:27.200 --> 03:40:51.200
das Drawn, das ist nichts im Endeffekt

03:40:51.200 --> 03:40:59.200
das ist wirklich nichts

03:40:59.200 --> 03:41:19.200
eigentlich könnten wir anstatt, wir könnten auch den Stopwatch-Timer da unten nehmen, ne?

03:41:19.200 --> 03:41:23.200
was, wenn das Drawn länger dauern würde, wie lang würden dann 3D-Spiele dauern?

03:41:23.200 --> 03:41:26.200
lange, das muss schnell gehen

03:41:26.200 --> 03:41:32.200
ich mein, wir Drawn ja hier im Endeffekt auch nichts, ne?

03:41:32.200 --> 03:41:34.200
ne, ne, das macht schon selbst alles

03:41:34.200 --> 03:41:37.200
ähm, wir machen hier am Endeffekt auch nichts, ne?

03:41:37.200 --> 03:41:46.200
wir haben hier oben ein paar komische Scale und ähm, na, Transparenzgeschichten

03:41:46.200 --> 03:41:52.200
und ähm, dann malen wir noch einen FPS-Counter und ein Bild

03:41:52.200 --> 03:41:56.200
also, das ist im Endeffekt ja nichts

03:41:56.200 --> 03:42:06.200
bringt das, das, das geht aus dem Bild raus, oder?

03:42:06.200 --> 03:42:09.200
das geht aus dem Bild raus

03:42:09.200 --> 03:42:12.200
seht ihr das?

03:42:12.200 --> 03:42:15.200
den lassen wir mal

03:42:15.200 --> 03:42:19.200
20, äh, 22 Pixels weiter unten starten

03:42:19.200 --> 03:42:21.200
ja, jetzt ist es besser

03:42:21.200 --> 03:42:28.200
wobei, nicht weiter unten, 20 weiter, weiter rechts starten

03:42:28.200 --> 03:42:34.200
ja

03:42:34.200 --> 03:42:35.200
oder?

03:42:35.200 --> 03:42:38.200
ne, ich glaub oben klippt er

03:42:38.200 --> 03:42:44.200
oben klippt er

03:42:44.200 --> 03:42:51.200
ja, oben hat er ein bisschen geklippt

03:42:51.200 --> 03:43:01.200
so, machen wir das Ganze jetzt mal mit 5 FPS

03:43:01.200 --> 03:43:09.200
rechts und oben klippt er oben, oben klippt er noch ein bisschen, oder?

03:43:09.200 --> 03:43:15.200
oben klippt er noch, aber es könnte sogar sein, dass das im Bild so ist

03:43:15.200 --> 03:43:20.200
machen wir mal oben ganz viel Abstand

03:43:20.200 --> 03:43:22.200
ah, ne, ok, noch mal 30 oben

03:43:22.200 --> 03:43:25.200
muss ich mal gucken, warum das oben überhaupt klippt

03:43:25.200 --> 03:43:27.200
ja, so ist gut

03:43:27.200 --> 03:43:42.200
hier oben, das ist, das ist im Bild so, dass der oben kurz geklippt ist

03:43:42.200 --> 03:43:58.200
wunderbar, zack, bam

03:43:58.200 --> 03:44:07.200
sehr schön

03:44:07.200 --> 03:44:10.200
das ist doch nice, das gefällt, ja

03:44:10.200 --> 03:44:14.200
durchklicken

03:44:14.200 --> 03:44:16.200
GIF am Start

03:44:16.200 --> 03:44:19.200
und, ich mein, guck mal

03:44:19.200 --> 03:44:25.200
wir brauchen jetzt 90 MB

03:44:25.200 --> 03:44:33.200
machen wir mal, stellen wir das Ganze mal wieder um auf Window Only

03:44:33.200 --> 03:44:40.200
Window Only, stellen wir das Ganze um, Release Mode

03:44:40.200 --> 03:44:47.200
wir brauchen ziemlich genau 88 MB

03:44:47.200 --> 03:44:51.200
oder auch nicht

03:44:51.200 --> 03:45:03.200
80, was für ne komische Anzeige

03:45:03.200 --> 03:45:06.200
angeblich haben wir 80, aber hier oben ist 9,8

03:45:06.200 --> 03:45:10.200
also wir brauchen 80 MB im Vergleich zu 850

03:45:10.200 --> 03:45:13.200
und es startet übel schnell

03:45:13.200 --> 03:45:19.200
also wenn man sich überlegt, das, guck mal, es startet jetzt die ganze, das ganze Programm startet jetzt

03:45:19.200 --> 03:45:26.200
das ganze Programm startet schneller und zeigt das GIF an, als das andere

03:45:26.200 --> 03:45:30.200
jetzt nehmen wir mal ein großes GIF, was beim anderen Probleme macht

03:45:30.200 --> 03:45:33.200
z.B.

03:45:33.200 --> 03:45:36.200
Brain, irgendwas mit Brain

03:45:36.200 --> 03:45:48.200
Mindblown heißt das Ding hier, Mindblown, das GIF brauchen wir jetzt noch

03:45:48.200 --> 03:45:52.200
Ups, jetzt hab ich es gelöscht

03:45:52.200 --> 03:45:59.200
so lange Dateifahne

03:45:59.200 --> 03:46:09.200
ich hab mich irgendwo verschrieben

03:46:09.200 --> 03:46:26.200
und auch übelst flüssig im Vergleich zum anderen

03:46:26.200 --> 03:46:32.200
wir könnten noch, das Bilderscalen könnten wir noch ein bisschen schöner machen

03:46:32.200 --> 03:46:59.200
weil hier sieht er besser aus

03:46:59.200 --> 03:47:03.200
fehlt da ein bisschen was

03:47:03.200 --> 03:47:07.200
oder ich glaub mein Scaling ist nicht ganz so sinnvoll

03:47:07.200 --> 03:47:14.200
mein Scaling ist nicht ganz richtig würde ich sagen

03:47:14.200 --> 03:47:28.200
mein Scaling ist nicht so ganz korrekt

03:47:28.200 --> 03:47:37.200
sagen wir mal so, hier ist er schöner skaliert

03:47:37.200 --> 03:47:45.200
wobei Leute ohne Scheiß, ich würde fast eher sagen, mein Scaling sieht mir irgendwie

03:47:45.200 --> 03:47:54.200
also von Abmaßen her scheint mir das aber

03:47:54.200 --> 03:48:08.200
guck mal wie flüssig das hier ist, seht ihr das wie flüssig das ist und wie sehr es da rumleckt

03:48:08.200 --> 03:48:13.200
wir können das noch mal ein bisschen ändern wie er das ganze macht, wir können jetzt mal hier

03:48:13.200 --> 03:48:20.200
Nearest Neighbor ist das schlechteste von der Qualität hier mit dem Cubic, das ist glaube ich beste Quali

03:48:20.200 --> 03:48:37.200
na guck jetzt sieht es auch gleich besser aus

03:48:37.200 --> 03:48:51.200
es ist nicht ganz gleich groß guck mal, wir müssen nochmal einen anderen Hintergrund nehmen

03:48:51.200 --> 03:49:08.200
guck mal es ist nicht ganz gleich groß, es ist ein bisschen, meinst du es ist ein bisschen kleiner

03:49:08.200 --> 03:49:21.200
ich mein jetzt ist es gleich, jetzt ist es ungefähr gleich breit, aber das ist ein Stück höher

03:49:21.200 --> 03:49:26.200
also das heißt bei mir fehlt ein Stückchen würde ich mal sagen

03:49:26.200 --> 03:49:39.200
bei mir fehlen ein paar Pixels

03:49:39.200 --> 03:49:44.200
ja Terra Fox guck ich mir an, ich kann heute nicht mehr mir großartige Gedanken zu machen

03:49:44.200 --> 03:49:52.200
normalerweise ist das bestimmt eigentlich nichts schwieriges

03:49:52.200 --> 03:50:04.200
hier fehlt oben und unten ein bisschen was, aber das passt schon

03:50:04.200 --> 03:50:10.200
so nice, das können wir jetzt dann einbauen das nächste Mal

03:50:10.200 --> 03:50:17.200
in das eigentliche Tool wofür wir das ganze gebastelt haben und dann dauern GIFs nicht mehr 3 Sekunden zum anzeigen

03:50:17.200 --> 03:50:37.200
sind instant da, die PNGs könnten wir übrigens auch noch mit FFmpeg machen

03:50:37.200 --> 03:51:05.200
sehr schön, gefällt mir

03:51:05.200 --> 03:51:33.200
das war's für heute, bis zum nächsten Mal

03:51:33.200 --> 03:51:43.200
so Leute, genug für heute, der GIF-Player funktioniert ziemlich gut

03:51:43.200 --> 03:51:49.200
sagen wir verlieren wir immer noch irgendwo Speicher, kann das sein, nee, der braucht einfach eine Weile bis alles geladen ist

03:51:49.200 --> 03:51:56.200
guck mal, das ist ein riesen Unterschied, das fette GIF, komplett gecached, braucht 160 MB

03:51:56.200 --> 03:52:13.200
wohingegen das in WPF 850 braucht, das ist schon ein Unterschied

03:52:13.200 --> 03:52:36.200
nee, der Server ist da nicht dabei, insgesamt braucht das Zeug irgendwie 180 MB

03:52:36.200 --> 03:52:45.200
das ISP.NET Core plus das WPF Fenster, aber sobald ein GIF geladen wird gehts hier irgendwie hoch auf 850, 900 oder so

03:52:45.200 --> 03:52:52.200
also sagen wir mal, das GIF braucht 700, 700 braucht das GIF und das liegt einfach daran

03:52:52.200 --> 03:53:02.200
wir können uns das hier grad nochmal angucken, guck mal, ich hab jetzt ein paar GIFs geladen, instant 2G voll, kann doch nicht sein

03:53:02.200 --> 03:53:11.200
jetzt gehts wieder runter auf 760, guck mal, jetzt sind wir mal bei 760 und jetzt mach ich das GIF hier an

03:53:11.200 --> 03:53:22.200
das GIF hat eine schlechte Position

03:53:22.200 --> 03:53:37.200
guck, 1,1, also das ist ja schon besser, nee nicht ganz, es ist tatsächlich nicht ganz so viel, aber es ist ordentlich

03:53:37.200 --> 03:53:44.200
also irgendwie 400 aus uns immer noch und ich glaube er hat auch nicht alle aus dem Garbage-Collector geschaufelt

03:53:44.200 --> 03:54:04.200
also das ist nicht sonderlich optimiert, dieses WPF GIF Ding, da sind wir hier doch schon deutlich besser mit dabei, oder?

03:54:04.200 --> 03:54:11.200
da sind wir schon deutlich besser mit dabei, 120 MB oder so

03:54:11.200 --> 03:54:24.200
und wenn wir das ganze nicht cashen, das können wir jetzt gleich auch nochmal ausprobieren, wie viel wir dann haben

03:54:24.200 --> 03:54:32.200
ich hoffe ich hab mir den Kram irgendwo gespeichert, sagen wir das übliche, rückgängig, rückgängig, rückgängig

03:54:32.200 --> 03:54:42.200
rückgängig, rückgängig, rückgängig, wo hab ich mir gespeichert, den Scheiß, lol

03:54:42.200 --> 03:54:50.200
wenn ich mich jetzt verdrücke ist alles weg, denke ich muss ihn nicht speichern, da

03:54:50.200 --> 03:55:03.200
und wieder vorwärts, dafür hat man eigentlich ein Git oder sowas

03:55:03.200 --> 03:55:19.200
soll mal gucken wie viel das ist, wenn ich es nicht cache, dann für 25 FPS reicht es natürlich immer noch

03:55:19.200 --> 03:55:33.200
achso ich muss hier die Frames freen, sonst leaken wir

03:55:33.200 --> 03:55:51.200
na guck, 118, das ist doch top, da kann man sich echt nicht beschweren

03:55:51.200 --> 03:56:03.200
und ich könnte wetten, wenn wir jetzt wirklich so Raw Window aufmachen würden, ohne Forms und ohne den ganzen Geschiss, wären wir wahrscheinlich unter 100

03:56:03.200 --> 03:56:13.200
Bilder brauchen halt einfach ein bisschen Speicherplatz, unkomprimierte Bilder, das hat ein bisschen was

03:56:13.200 --> 03:56:33.200
jetzt mal ausrechnen, 600 x 600 x 4, so, hallo Google, please, so, bytes to MB, ok das ist nicht so wirklich viel

03:56:33.200 --> 03:56:45.200
aber Bilder brauchen halt ein bisschen was, vor allem wenn sie größer werden

03:56:45.200 --> 03:57:14.200
warte mal, doch habe ich richtig gerechnet, kann sein ich habe was vergessen, also kleine Bilder gehen noch

03:57:14.200 --> 03:57:43.200
ich stelle dir mal ein unkomprimiertes Video vor, das ist in der Regel, also rein das Anzeigen ist ziemlich angenehm, weil du nichts decoden musst

03:57:43.200 --> 03:57:55.200
also vorausgesetzt, man kann es schnell genug lesen, ist das super, das hat kaum CPU Last unkomprimierte Videos, weil du halt nichts decoden musst

03:57:55.200 --> 03:58:20.200
sie sind halt riesengroß, ja, also wenn du mit deinem C++ Zeug dann quasi 60 MB hast, ich habe hier noch ein bisschen Managed Grempel drum herum

03:58:20.200 --> 03:58:35.200
dann ist das mit 100 MB oder sowas, was das hier hat, und wie viel hatte das hier jetzt, ja dann ist das doch vollkommen ok, also 118, das ist doch top

03:58:35.200 --> 03:58:54.200
kann man nichts sagen, ja, denke ich auch, 120 MB ist wirklich top, und man muss sich mal gucken, wie sau schnell das ist, das ist halt einfach instant

03:58:54.200 --> 03:59:06.200
und man muss es halt mal ohne Debugger machen, zack da, das ist nix, wir müssen uns noch ein bisschen um das Handling kümmern, also wir müssen noch resizeen und so einbauen

03:59:06.200 --> 03:59:26.200
das müssen wir noch machen, dass wir noch resizeen können das Fenster, das müssen wir noch einbauen, das machen wir aber das nächste Mal

03:59:26.200 --> 03:59:38.200
ja Flo, du machst das nächste Mal den Giftplay in Assembler, easy, dann verwende ich den auch, wenn du mir den Assembler machst, auf, go go

03:59:38.200 --> 03:59:46.200
ja da kannst du im Prinzip, da muss ich jetzt TheraFox schon recht geben, im Prinzip kannst du ja nicht so viel unterschiedliches speichern eigentlich

03:59:46.200 --> 03:59:58.200
du hast halt deine drei Bytes für Farben und hast halt einen Byte für Transparenz, was willst du mehr machen, das einzige wo du variieren kannst ist halt, dass du wieder die RGB Dinge anordnest

03:59:58.200 --> 04:00:16.200
BGA, RGB, GAA, was auch immer es da alles für Varianten wahrscheinlich gibt

04:00:16.200 --> 04:00:34.200
das heißt bei C-Sharp nochmal der Krams den man mit Attribute meintst du

04:00:34.200 --> 04:00:50.200
Juff gibt es auch noch ja, da ist der Colorspace ein bisschen anders und noch ein paar andere Sachen, die ich jetzt, weiß ich jetzt nicht genau

04:00:50.200 --> 04:01:04.200
ja Patrick auf gehts, Assembler, go go

04:01:04.200 --> 04:01:20.200
also TheraFox ich hab mir grad mal dein C++ Beispiel angeguckt, was ich nicht checke ist, du machst ja ganz unten Sleep 4 Milliseconds, so und dann mal 1000, was für eine Zahl übergibst du denn Sleep 4, was steht denn da drin so als Beispiel

04:01:20.200 --> 04:01:46.200
sag mal ein Beispiel als Zahl, steht da da irgendwie sowas drin wie 16,7 oder was oder wie

04:01:46.200 --> 04:02:02.200
richtig, das könnte man noch viel schöner darstellen, aber die Sache ist die FFmpeg haut mir ja quasi hier an der Stelle, da müsste man sich schon richtig das Bein ausreißen

04:02:02.200 --> 04:02:18.200
weil das FFmpeg die Code gibt dir halt quasi ein BGRA Memory Block zurück

04:02:18.200 --> 04:02:40.200
also ein BGRA Memory Block zurück

04:02:40.200 --> 04:03:02.560
so leute ich werde jetzt mal meine pizza futtern

04:03:02.560 --> 04:03:22.000
er meint wenn du das quasi in milisekunden schreiben würdest oder also sprich wenn du

04:03:22.000 --> 04:03:29.680
die sekunden in milisekunden haben willst was ja natürlich mehr wird an der sista hat

04:03:29.680 --> 04:03:38.640
verschrieben ok oder auch nicht weil das aussehen ergeben hat ja also wenn es mal

04:03:38.640 --> 04:03:42.160
1000 rechnest da hast halt das was du in milisekunden schreiben müsstest dass du

04:03:42.160 --> 04:04:02.880
wieder auf sekunden kommst

04:04:02.880 --> 04:04:15.280
ich bin echt begleitet wie flüssig das ist ich finde auch wenn man sich das hier

04:04:15.280 --> 04:04:22.320
anguckt im vergleich jetzt zu zu der wpf geschichte ich finde auch es ist

04:04:22.320 --> 04:04:35.040
flüssig guckt euch das mal an die animation ist viel flüssiger guckt mal wie wie die hände hier wackeln seht ihr moment meins ist meins hat

04:04:35.040 --> 04:04:47.840
auch die falsche falschen fps kann das sein meins hat die falschen fps nö hat es nicht meins hat die richtigen fps meins hat die fps die im

04:04:47.840 --> 04:05:17.680
feil stehen wpf kriegt nicht richtig hin guck mal wie lahm das ist ich habe zwei durchläufe bis die ein haben aber meins hat die hat meins hat die fps die das feil sagt dass es hat und wpf hat was auch immer das braucht doppelt so lange oder so wahrscheinlich weil es

04:05:17.680 --> 04:05:38.480
tp um ist in hinterherkommt keine ahnung das hier hat keine ahnung 5 fps oder so und der hier hat 25 aber ich nehme das was das feil auslässt wir können ja mal gucken können wir können wir wirklich

04:05:38.480 --> 04:06:07.760
checken was das zeug hat ne vlc wir machen ff probe ff probe hat fps 12,5 und der pappagei hat 25 allerdings

04:06:07.760 --> 04:06:37.680
ah moment nee keine ahnung müsste müsste eigentlich richtig erkennen macht aber anscheinend nicht läuft ein alter plane als web overlay oder lokal das ist lokal das ist immer zwei sachen also das web interface ist ja dafür gedacht dass du es auf dem tablet oder so verwenden kannst das ist ein transparentes wpf fenster und im hinterkommende asp.net core anwendung das web interface kannst du auf dem tablet verwenden klickst du drauf

04:06:37.680 --> 04:06:42.960
und dann geht es ja auf das besteht aus dem aus quasi dem web aus der aus der asp.net core und der wpf anwendung

04:06:42.960 --> 04:07:04.240
ja ich weiß dass man gift play mit 25 fps abgespielt hat allerdings ich habe es ja nicht gesetzt guck da ich sage hier die code fps und die code fps ist an der meinung dass es 25 sind was aber

04:07:04.240 --> 04:07:22.720
anscheinend nicht stimmt wobei ff probe gibt es aus und ich mache es auch mit ffmpeg das ist irgendwie ein bisschen merkwürdig

04:07:22.720 --> 04:07:45.200
doch da ich bin bin demnächst auf 25 der denkt es sind 25 guck da 25 wo schreibe ich denn hier hin stream frame rate

04:07:45.200 --> 04:07:58.960
was habe ich noch zu bieten air rate das können wir auch nochmal machen vielleicht sind die unterschiedlich 25 was haben wir sonst noch so zur auswahl

04:07:58.960 --> 04:08:18.240
mal gucken was die anderen dinger ausspucken wenn man das jetzt nochmal richtig schreiben würde alles

04:08:18.240 --> 04:08:36.560
bitt rate sample rate was kommt da raus null frame frame rate

04:08:36.560 --> 04:08:55.120
ich habe eine idee woran das liegt aha daran liegt das ich ich ich lese das falsch aus guckt mal das richtige ist stream

04:08:55.120 --> 04:09:15.760
das richtige ist stream das hat total beknackt das richtige ist stream average frame rate und dann das da geteilt durch das da und dann stimmt das nämlich auch

04:09:15.760 --> 04:09:36.400
am 1 ist trotzdem noch flüssiger

04:09:36.400 --> 04:10:01.840
was funktioniert nun schon alles fast alles resize klappt noch nicht aber gifs abspielen geht transparente gifs abspielen geht eigentlich

04:10:01.840 --> 04:10:10.800
funktioniert alles also das schwierige ist geschafft

04:10:10.800 --> 04:10:19.760
musst du die fps nicht später auslesen wenn das das feil ist schon geöffnet ich mache das feile im konstruktor auf also sprich ich kann gar nichts vorher

04:10:19.760 --> 04:10:33.200
auslesen bevor ich überhaupt drauf zugreifen kann das feil ist auf jeden fall da ich habe es jetzt ja hier richtig ich habe den die zweite komponente nicht

04:10:33.200 --> 04:10:46.240
ausgelesen an der stelle hier jetzt stimmt ja mit 12,5 fps leider gibt es keine halben fps es gibt im prinzip nur 12 oder 13

04:10:46.240 --> 04:11:11.040
oder 13

04:11:11.040 --> 04:11:18.800
ja das ist schön das gefällt mir

04:11:18.800 --> 04:11:29.680
das gefällt mir echt gut so leute ich gehe jetzt mal eine pizza futtern wir sehen uns demnächst machts gut bis denn tschüss

04:11:29.680 --> 04:11:46.240
gibt es irgendwas zu hausten wen kann ich hausten

04:11:46.240 --> 04:12:01.200
keine ahnung irgendwie keiner da der frazier der spielt nicht

04:12:01.200 --> 04:12:21.520
da gehe ich jetzt einfach auf

04:12:21.520 --> 04:12:33.280
remix

04:12:33.280 --> 04:13:00.320
so alles gut

04:13:00.320 --> 04:13:07.520
so

04:14:07.520 --> 04:14:10.520
SWR 2020

