1
00:00:00,000 --> 00:00:02,000
Das war's für heute.

2
00:00:02,000 --> 00:00:04,000
Vielen Dank für's Zuschauen.

3
00:00:04,000 --> 00:00:31,000
Das war's für heute.

4
00:00:31,000 --> 00:00:33,000
Das war's für heute.

5
00:00:33,000 --> 00:00:35,000
Vielen Dank für's Zuschauen.

6
00:00:35,000 --> 00:00:37,000
Das war's für heute.

7
00:00:37,000 --> 00:00:39,000
Vielen Dank für's Zuschauen.

8
00:00:39,000 --> 00:01:05,000
Vielen Dank für's Zuschauen.

9
00:01:39,000 --> 00:02:01,000
Vielen Dank für's Zuschauen.

10
00:02:01,000 --> 00:02:09,320
Also die habe ich mir jetzt gekauft für meinen Baum, für meinen Weihnachtsbaum, die haben

11
00:02:09,320 --> 00:02:10,320
ja nämlich so einen...

12
00:02:10,320 --> 00:02:15,600
Wie heißen die Dudes denn?

13
00:02:15,600 --> 00:02:21,360
Ich hab vergessen wie die heißen diese Hersteller.

14
00:02:21,360 --> 00:02:25,560
Irgendwas mit Lighting.

15
00:02:25,560 --> 00:02:35,400
Zumindest habe ich eine 5 Meter Kette gefunden, die man per WLED steuern kann.

16
00:02:35,400 --> 00:02:41,120
Ja, wenn ich es jetzt finden würde, null.

17
00:02:41,120 --> 00:02:48,120
Ich gucke jetzt einfach mal kurz bei mir auf dem Handy und dann machen wir was sinnvolles

18
00:02:48,120 --> 00:02:49,120
heute mal zur Abwechslung.

19
00:02:49,120 --> 00:02:55,880
Warte mal kurz auf dem Handy gucken, weil da hatten wir es ja letztens von.

20
00:02:55,880 --> 00:02:58,880
Zeige ich mal her.

21
00:02:58,880 --> 00:02:59,880
Orders.

22
00:02:59,880 --> 00:03:16,320
BTF Lighting, ach du Große, ja ja ich habe es jetzt auch gerade gefunden, also BTF Lighting

23
00:03:16,320 --> 00:03:17,320
heißen die.

24
00:03:17,320 --> 00:03:21,560
Die haben sowas hier in der Richtung, genau.

25
00:03:21,560 --> 00:03:32,440
So und da habe ich mir eine 5 Meter Kette gehört, nö ich bin nicht krank, nee nee.

26
00:03:32,440 --> 00:03:35,960
Mein Headset ist nicht richtig dran, ich höre mich wieder auf der einen Seite nicht richtig

27
00:03:35,960 --> 00:03:36,960
sehr.

28
00:03:36,960 --> 00:03:44,280
So jetzt, jetzt passt alles gut.

29
00:03:44,280 --> 00:03:46,680
Was findest du besser, Home Assistant oder IO Broker?

30
00:03:46,680 --> 00:03:49,960
Okay ich habe nur Home Assistant, ich habe mit der IO Broker noch nichts gemacht.

31
00:03:49,960 --> 00:03:57,000
Ja, das habe ich mir gekauft, hier guck mal, das ist glaube ich die optimale Weihnachtsbeleuchtung,

32
00:03:57,000 --> 00:03:58,360
äh Weihnachtsbaumbeleuchtung.

33
00:03:58,360 --> 00:04:09,040
Hier, das sind ganz dünne Kabel und die haben einfach dieses LED Package, diese kleine Schaltung

34
00:04:09,040 --> 00:04:13,880
mit der LED oben drauf, haben die quasi einfach in Heißkleber oder was ist das Kunstharz oder

35
00:04:13,880 --> 00:04:19,080
sowas gepackt, das heißt du hast eine ganz dünne Leitung und hast 5 Meter und man kann

36
00:04:19,080 --> 00:04:23,800
es per W-LED steuern, probier mal dann aus wenn es da ist, das ist glaube ich optimal

37
00:04:23,800 --> 00:04:24,800
für einen Weihnachtsbaum.

38
00:04:24,800 --> 00:04:36,840
So, jaja Montagsstells, sind die, ja die sind einzeln ansteuerbar, das heißt du kannst

39
00:04:36,840 --> 00:04:41,520
auch Effekte machen und sowas, siehst du ja hier, du hast ja 4 Leitungen, LEDs mit 4

40
00:04:41,520 --> 00:04:51,480
Leitungen sind da eigentlich immer ansteuerbar oder auch mit 3, ne es sind auch nur 3, schlabber

41
00:04:51,480 --> 00:04:57,600
scheiße, 3, ja, kannst du auch Effekte machen und sowas, hier guck, nur dass ich das nicht

42
00:04:57,600 --> 00:05:03,240
mit dem offiziellen Controller mache, man sieht es ja auch hier, ne, Data Input, 3 Stück,

43
00:05:03,240 --> 00:05:11,440
sondern mit Gift, boah, ich krieg, weil das Kabel so schlechte Qualität ist, krieg ich

44
00:05:11,440 --> 00:05:17,040
ein Gift dabei, boah, krieg ich, da krieg ich, da krieg ich noch ein extra Stecker

45
00:05:17,040 --> 00:05:25,640
geschenkt, boah, das ist aber, jetzt muss ich das gleich nochmal bestellen, Wahnsinn,

46
00:05:25,640 --> 00:05:35,960
die China-Chinesen sind zu freundlich, ich mach mal meine VM an, easy mani, also wir gucken

47
00:05:35,960 --> 00:05:41,640
uns heute mal neue C-Sharp 10 und Dotnet 6 Features an, ich wollte mir das jetzt allgemein

48
00:05:41,640 --> 00:05:45,760
mal zu Gemüte führen und hab so vorm Rechner gesessen und hab mir gedacht, hey bevor ich

49
00:05:45,760 --> 00:05:55,000
mir das jetzt alleine anguck, können wir uns das auch zusammen angucken, zu laut oder warum

50
00:05:55,000 --> 00:06:17,800
ist die Smoke Sound zu laut, boah, ist gut, ok, alles klar, hier, das ist normal, Twitch

51
00:06:17,800 --> 00:06:24,360
kannst du die Werbung nicht mal gescheit blockieren, das einzige was geht ist mit nem Browser-Plugin,

52
00:06:24,360 --> 00:06:34,440
und dann auch meistens nur mit spezieller Config, weil Twitch hat sich gedacht, es

53
00:06:34,440 --> 00:06:49,400
ist eine gute Idee, Content und Werbung von den gleichen Servern auszuliefern, was ist

54
00:06:49,400 --> 00:06:57,560
das da im Hintergrund eigentlich, was bin ich da sehend, egal, Bing Image of the Day,

55
00:06:57,560 --> 00:07:06,080
Start New Session, zack, ne ne, erst mal Dotnet 6 installieren, was hab ich denn hier überhaupt

56
00:07:06,080 --> 00:07:12,320
drauf, gibt's das mittlerweile schon übers Package Manager, Dotnet 5 haben wir hier,

57
00:07:12,320 --> 00:07:19,680
Dotnet 3.1 haben wir Dotnet 6 hier, ich installiere das über Dotnet install, Dotnet install,

58
00:07:19,680 --> 00:07:24,040
ne, das brauchen wir nicht mehr, das brauchen wir mittlerweile nicht mehr, mittlerweile ist

59
00:07:24,040 --> 00:07:30,760
es als Release Candidate verfügbar, man kann jetzt einfach glaube ich machen minus C6,

60
00:07:30,760 --> 00:07:39,800
6.0, ja, dann kriegt man den aktuellen Release Candidate, also das ganze kommt übrigens

61
00:07:39,800 --> 00:07:46,600
raus in ungefähr zwei Wochen, dann wenn auch Battlefield am Start ist, Early Access ungefähr

62
00:07:46,600 --> 00:07:57,160
so zur gleichen Zeit, hat wahrscheinlich nichts miteinander zu tun, hier Roadmap, Dennis danke

63
00:07:57,160 --> 00:08:11,240
für den Sub, November, ich glaube am 10. war das, kurz gucken, nein nein das stimmt nicht,

64
00:08:11,240 --> 00:08:18,040
es muss doch mal ein Release Date geben, es gibt auch, ah hier, am 9. November ist es,

65
00:08:18,040 --> 00:08:26,360
9. November, naja 10. November hab ich gesagt, da war ich ja nicht, ich sage, das gibt es

66
00:08:26,360 --> 00:08:35,760
ungefähr dann, wenn auch Battlefield rauskommt, ja, was für ein Disro, das ist Manjaro mit

67
00:08:35,760 --> 00:08:40,440
i3 WM, was ich hier gemacht hab, dass es auf einmal kein Dark Seam mehr hat, bin ich mir

68
00:08:40,440 --> 00:08:48,600
nicht so ganz sicher, die haben wahrscheinlich irgendwie Versionen geupdatet, wir downcrayen

69
00:08:48,600 --> 00:08:56,480
das einfach, ah must be root, na dann, wir downcrayen das einfach wieder und dann funktioniert

70
00:08:56,480 --> 00:09:04,280
es, null, aber das ist ja auch keine, bam, einfach downcrate, schon ist wieder Dark Seam

71
00:09:04,280 --> 00:09:12,280
am Start, easy, kein Problem, kein Problem, aber so ist es bestimmt nicht gedacht auf

72
00:09:12,280 --> 00:09:23,200
Dauer, also Vanguard kommt auch in dem Dreh irgendwann, weiß ich einfach nicht wann da

73
00:09:23,200 --> 00:09:42,640
ein Release ist, ja, das geht, also mit irgendwelchen eigenen Adblockern ist da nichts mehr, zumal

74
00:09:42,640 --> 00:09:51,400
wie gesagt Twitch liefert ja von den gleichen Servern Content und Werbung aus, das ist schwierig

75
00:09:51,400 --> 00:10:01,360
das zu blocken rein mit DNS, ne, so, also wir haben.NET 6 installiert, zeigen wir mal,

76
00:10:01,360 --> 00:10:19,880
.NET, zack, so, jetzt weg machen, Version 6.0.1.0.rc2.21505.57, alter, Monarch S, die Microsoft Versionsnummern,

77
00:10:19,880 --> 00:10:30,800
ah, gut, niemand braucht das auch komplett, was für ein Desktop ist das, gar kein Desktop,

78
00:10:30,800 --> 00:10:35,880
guck mal, ich hab kein Desktop, ich hab nur das Bing Image of the Day, ich hab, ich hab

79
00:10:35,880 --> 00:10:41,120
noch nicht mal, du kannst hier noch nicht mal Icons anlegen oder irgendwas machen, das

80
00:10:41,120 --> 00:10:47,880
ist, also das ist Manjaro mit I3 WM, Arch, by the way, muss man ja immer erwähnen, hab

81
00:10:47,880 --> 00:10:59,320
mich gehört, da bruschelt einer schon von den Sub, so, wir starten mal unsere Idee und

82
00:10:59,320 --> 00:11:16,200
dann gucken wir uns das jetzt mal an, wow, wie kann denn sowas sein, unmöglich, by the

83
00:11:16,200 --> 00:11:20,880
way, bevor mir jetzt irgendwie die Leute wieder unterstellen, ich würde denen kein Geld geben,

84
00:11:20,880 --> 00:11:27,680
ich hab lizenziert, guckt, ich hab vollkommen legit account, ich hab all desktop account,

85
00:11:27,680 --> 00:11:38,120
hier, wo sieht man das, config help, about, licensed to MaxK, subscription is active until,

86
00:11:38,120 --> 00:11:41,320
also ich hab, ich hab ne Lizenz, ja, bevor jetzt wieder irgendwelche Leute kommen und

87
00:11:41,320 --> 00:11:46,920
sich beschweren sagen, Max, du gibst, du machst hier ganz böse Dinger, so ist es nicht, guck,

88
00:11:46,920 --> 00:12:02,720
ich hab ne richtig echte legit Lizenz, adresse leak, omg, zeig her, wo ist adresse leak, monka

89
00:12:02,720 --> 00:12:11,240
adresse leak, about, oh nein, subscription is active, ja, ich wohne in Frankfurt, subscription

90
00:12:11,240 --> 00:12:19,880
is active und Hausnummer 11.0.11.11, genau so, so siehts aus, excellent, habt ihr gut

91
00:12:19,880 --> 00:12:27,320
erkannt, chat, ja, das ist, Sicherheitskopien kann man auch benutzen, ja, aber das ist keine

92
00:12:27,320 --> 00:12:40,000
Sicherheitskopie, wie gesagt, das ist eine legit all access desktop Version, ich hab

93
00:12:40,000 --> 00:12:44,200
euch absichtlich ausgeplendet, nicht, dass, nicht, dass ihr jetzt denkt, ich würde hier

94
00:12:44,200 --> 00:12:49,880
irgendwie komische Dinger machen oder so, das glaubt ihr ja selber nicht, dass ich so

95
00:12:49,880 --> 00:13:01,680
was mache, würde mir, würde mir nie einfallen, da jetzt irgendwelche, irgendwelche Sachen

96
00:13:01,680 --> 00:13:08,520
zu treiben oder so, musste den Key eingeben, korrekt, ich hab jetzt den Key eingegeben,

97
00:13:08,520 --> 00:13:17,240
wie man hier sieht, den Key eingegeben und jetzt funktioniert das auch, so, auf gehts,

98
00:13:17,240 --> 00:13:22,400
also, aber wie gesagt, ihr habt's gesehen, ich hab ne richtig echte legit Lizenz plus

99
00:13:22,400 --> 00:13:27,200
hier in meiner VM noch nicht angemeldet und ich hab jetzt auch keinen Bock den Kram raus

100
00:13:27,200 --> 00:13:31,560
zu suchen, also Patrick, danke schön für den Sub, 28 Monate, es wird echt mal langsam

101
00:13:31,560 --> 00:13:36,800
Zeit, dass ich ne neue, neue, neue Kicks-Batch mache für Leute, die schon so lange dabei

102
00:13:36,800 --> 00:13:41,360
sind, vier Monate, Carlo, danke für den Sub, so, jetzt müssen wir erst mal.NET 6 einrichten

103
00:13:41,360 --> 00:13:48,160
in Rider, in Rider, rein reiten, so, wo ist es denn hier,.NET, nee, ist schon, automatisch,

104
00:13:48,160 --> 00:14:01,000
exquisitieren, alles klar, ist schon, also, dann legen wir mal ein Konsolenprojekt an,

105
00:14:01,000 --> 00:14:11,440
Futust Chat 2021, Language C Sharp, Docker Support braucht kein Mensch, Framework 6.0,

106
00:14:11,440 --> 00:14:16,720
auf gehts, so, jetzt gucken wir uns mal ein paar Sachen an, ich hab nie so wirklich großartig

107
00:14:16,720 --> 00:14:20,720
geguckt im Vorfeld, ich, wie gesagt, ich wollte grad anfangen zu gucken und ich dachte mir,

108
00:14:20,720 --> 00:14:26,040
ich mach einfach mal den Stream an, ich hab ein paar Artikel gefunden und ein paar Videos,

109
00:14:26,040 --> 00:14:32,040
wo man Sachen gezeigt bekommt, Paints, danke für den Sub, auch 28 Monate, exzellent, mein

110
00:14:32,040 --> 00:14:36,160
Code schreibt, ich schau Stream, warte, dass mein Backup von meinem Server fertig wird

111
00:14:36,160 --> 00:14:45,120
und programmiere, tja, das nenne ich mal hier Multithreading, also, das ist der originale

112
00:14:45,120 --> 00:14:55,960
Microsoft Artikel, dann hab ich noch was anderes gefunden zu.NET 6 Link Improvements und dann

113
00:14:55,960 --> 00:15:04,400
hab ich noch irgendeinen Blog Eintrag gefunden zu, was es für neue spannende.NET 6 APs gibt,

114
00:15:04,400 --> 00:15:08,280
wir gucken uns, ich würde sagen, wir fangen mit den C Sharp Feature erst mal an, das ist

115
00:15:08,280 --> 00:15:12,960
so das Spannendste, finde ich und dann hab ich noch zwei Videos gefunden, aber die müssen

116
00:15:12,960 --> 00:15:17,840
wir auf dem, vielleicht gucken wir die danach mal schnell durch, ob da noch irgendwas dabei

117
00:15:17,840 --> 00:15:26,920
ist, zwei Videos gefunden, von ihm hier, der hat auch zwei gemacht zu, alter, so viele Shorts

118
00:15:26,920 --> 00:15:36,280
auf einmal, der hat auch zwei Videos gemacht zu Link Features, C Sharp Features und neue

119
00:15:36,280 --> 00:15:42,200
APs, da können wir mal nachher gucken, wenn wir selbst rum probiert haben, was da noch

120
00:15:42,200 --> 00:15:45,200
so drinne ist, was ich nicht gefunden hab oder was ich nicht gecheckt hab, vielleicht

121
00:15:45,200 --> 00:15:50,200
check ich ja auch manche Sachen nicht, mittlerweile ist es vieles mega Big Brain und ich zeige

122
00:15:50,200 --> 00:15:55,080
euch mal was cooles, was ich heute Morgen rausgefunden habe, was mir so noch gar nicht klar war,

123
00:15:55,080 --> 00:15:56,080
dass man das machen kann.

124
00:15:56,080 --> 00:15:58,880
Wieso C Sharp und nicht C++?

125
00:15:58,880 --> 00:16:04,800
Ich weiß nicht, ob du oft im Stream bist, aber ich glaube, dieses Fass wollen wir nicht

126
00:16:04,800 --> 00:16:05,800
öffnen heute, oder?

127
00:16:05,800 --> 00:16:07,800
Chat, wie sieht's aus?

128
00:16:07,800 --> 00:16:13,800
Doch, ich weiß, du bist öfters im Stream, du hast auch schon viele Messages geschrieben,

129
00:16:13,800 --> 00:16:18,800
aber ich glaube, dieses Fass wollen wir heute nicht öffnen, warum nicht C++, ja?

130
00:16:18,800 --> 00:16:29,880
Aber wir wissen ja, C Sharp ist ja eigentlich C++++, wenn ich damit anfange, ist es vorbei.

131
00:16:29,880 --> 00:16:39,880
So, wir sehen schon mal ein cooles neues Feature, wobei das kein C Sharp 10 Feature ist, aber

132
00:16:39,880 --> 00:16:47,760
anscheinend sind die Templates, warum nicht Swift, Kotlin oder Objective C, aber anscheinend

133
00:16:47,760 --> 00:16:54,920
sind die Sachen jetzt soweit angepasst, dass die Templates so kommen, also früher, nur

134
00:16:54,920 --> 00:17:02,200
mal so zum Vergleich, früher sah das ein bisschen anders aus, mittlerweile ist das Fass

135
00:17:02,200 --> 00:17:10,160
so minimal wie den Python Programm, auch wenn es unter der Haube natürlich mehr generiert,

136
00:17:10,160 --> 00:17:24,040
gibt es eigentlich Toolbox, gibt es.NET Peak auch für Linux, nee anscheinend nicht, gibt

137
00:17:24,040 --> 00:17:40,640
es das hier für, den Decompiler, ups, jetzt, Alter, geht es immer auf,.NET Peak Portable

138
00:17:40,640 --> 00:17:54,400
und alles, gibt es anscheinend nur für Windows, vielleicht machen wir das auch unter Windows,

139
00:17:54,400 --> 00:17:55,400
aber ich will kein RC unter Windows installieren.

140
00:17:55,400 --> 00:18:00,400
Ich wollte euch nämlich zeigen, was der unter der Haube macht, kennt jemand einen guten.NET

141
00:18:00,400 --> 00:18:18,360
Decompiler für Linux, gibt es, EL Spy, EL Spy klingt gut, EL Spy, das will ich haben,

142
00:18:18,360 --> 00:18:33,240
habe ich das vielleicht schon, ja das will ich haben, keine Ahnung ob das was taugt,

143
00:18:33,240 --> 00:18:39,600
ich brauche, ich brauche, ich brauche irgendeinen.NET Decompiler, dass ich euch das jetzt zeigen

144
00:18:39,600 --> 00:18:50,120
kann, mal gucken ob das sich ordentlich installieren lässt, ja, schauen wir mal, weil ich will

145
00:18:50,120 --> 00:18:56,680
euch nämlich was zeigen gleich, wenn wir uns das hier minimal angucken, oh was hat der

146
00:18:56,680 --> 00:19:04,960
für Schmerzen, ich lasse den mal kurz machen, wie ist eigentlich die Sharp Support für

147
00:19:04,960 --> 00:19:10,280
Bildungssysteme, ich programmiere seit 3 Jahren nicht mehr unter Windows, ich glaube man kann

148
00:19:10,280 --> 00:19:16,800
sagen der Support ist gleichwertig, bis auf ein paar ganz kleine Ausnahmen, ja zum Beispiel

149
00:19:16,800 --> 00:19:21,520
dass es keinen gescheiten Decompiler gibt, oder ich habe noch nie geguckt, EL Spy, da

150
00:19:21,520 --> 00:19:29,640
ist er, jawoll sehr schön, also was ich euch zeigen wollte ist folgendes, früher sah das

151
00:19:29,640 --> 00:19:36,240
ganze ja so aus, wir machen mal, wir machen mal parallel, ich weiß was wir machen, wir

152
00:19:36,240 --> 00:19:43,480
machen mal parallel, achso ich habe jetzt nur das 6er, wir können die C Sharp Version

153
00:19:43,480 --> 00:19:53,600
anpassen, aber da ändern sich die Templates nicht, ne dann lasse ich, dann lasse ich,

154
00:19:53,600 --> 00:20:04,680
geh weg, ja, also früher sah das ganze ungefähr so aus, Namespace, Calc W, wie auch immer,

155
00:20:04,680 --> 00:20:10,840
und dann gab es irgendwie sowas wie Public, wie sahen eigentlich Main aus, war das Static,

156
00:20:10,840 --> 00:20:17,520
ich war nicht sicher, ich verwende immer die Templates, keine Ahnung, ich glaube ich habe

157
00:20:17,520 --> 00:20:22,440
in den letzten 10 Jahren keine Main Methode von Hand gebastelt, so also früher sah das

158
00:20:22,440 --> 00:20:30,320
die ganze Zeit so aus, wenn du Main, also der Einstieg von deinem Programm sah die ganze

159
00:20:30,320 --> 00:20:36,120
Zeit so aus, aber das braucht man jetzt nicht mehr, man kann jetzt diese Minimalgeschichte

160
00:20:36,120 --> 00:20:42,880
hier machen, aber unter der Haube, das ist übrigens kein neues C Sharp 10 Feature, das

161
00:20:42,880 --> 00:20:47,400
gibt glaube ich schon seit 9, aber unter der Haube, und das ist das was ich euch zeigen

162
00:20:47,400 --> 00:21:11,800
will, generiert das das immer, so, was, Error, wat, ah ich bin ja auch ein Kacknub, ich hab

163
00:21:11,800 --> 00:21:28,360
das mit dem falschen.NET kompiliert, ah ist schon besser, ok, also jetzt zeige ich euch

164
00:21:28,360 --> 00:21:34,480
mal nämlich was er da draus gemacht hat, das ist einfach nur Compiler Magic, also so sieht

165
00:21:34,480 --> 00:21:41,800
es jetzt aus, und wenn ich das mal hier im D-Compiler aufmache, warum startest du das

166
00:21:41,800 --> 00:21:46,080
nicht über die Edirektur, das weiß ich nicht, manche Sachen mache ich irgendwie lieber

167
00:21:46,080 --> 00:21:56,000
bei das Terminal, was ist das für Musik, die kommt mir bekannt vor, ist das Terranigma,

168
00:21:56,000 --> 00:22:07,480
was ist das, weiß es nicht, wo erkenne ich was es ist, bei 10.53, ach nee erkennt man

169
00:22:07,480 --> 00:22:13,520
gar nicht, das ist einfach nur Playlist ohne was drinsteht, so jetzt öffnen wir das ganze

170
00:22:13,520 --> 00:22:31,480
mal, OnkS, hat das jetzt funktioniert, hier schauen wir mal, ok das Ding ist mal wieder

171
00:22:31,480 --> 00:22:35,280
nicht gescheit in der Lage da rein zu gehen, also Ryder, mein Gott sieht das hässlich

172
00:22:35,280 --> 00:22:49,240
aus, ja, cutest chat 2021, Binary Debug, jetzt da ist es, so wenn wir jetzt hier die Main

173
00:22:49,240 --> 00:23:10,920
Methode angucken, da sehen wir, was ist das für ein Schrott, warum geht das nicht, was

174
00:23:10,920 --> 00:23:20,720
ist das für ein komischer D-Compiler, warum funktioniert das nicht, oder bin ich nur zu

175
00:23:20,720 --> 00:23:33,720
dumm den zu verwenden, he doesn't know, he lacks critical information, es ist egal ob

176
00:23:33,720 --> 00:23:41,680
das die Sharp 8 kann, doch was da unten rauskommt ist kein Unterschied, ok Leute ich hab legit

177
00:23:41,680 --> 00:23:48,880
keine Ahnung wie das Ding hier funktioniert, normalerweise sollte hier jetzt der Code drin

178
00:23:48,880 --> 00:23:56,360
stehen, z.B. auch wenn ich hier irgendwas öffne, dann sollte ich den Code sehen, genau, so

179
00:23:56,360 --> 00:24:07,920
und warum sehe ich hier für Main nicht, also ich kenn keinen D-Compiler in Ryder für meinen

180
00:24:07,920 --> 00:24:15,280
eigenen Code der das macht, tja, dann kann ich euch das nicht zeigen, warte mal, es gibt

181
00:24:15,280 --> 00:24:18,880
doch, wir machen das anders, es gibt doch so eine schöne Seite die das macht, wie hießen

182
00:24:18,880 --> 00:24:39,360
das, il-code-website, es gibt doch so eine Website die das kann, wie hießen das, C-Sharp,

183
00:24:39,360 --> 00:24:48,560
C-Sharp Lab, genau, so, jetzt kann man sich das ganze angucken, kann man hier irgendwie

184
00:24:48,560 --> 00:25:00,040
die C-Sharp Version einstellen, default Oktober, was auch immer, so und wir wollen als Result

185
00:25:00,040 --> 00:25:17,160
haben, il, C-Sharp, ok wunderbar, Console-Write-Line-1, so, also, das ist der aktuelle C-Sharp Code

186
00:25:17,160 --> 00:25:22,160
und was er unter der Haube macht ist das hier, also der generiert nach wie vor, das ist das,

187
00:25:22,160 --> 00:25:30,880
was ich eigentlich zeigen wollte, der generiert unter der Haube nach wie vor hier Main-Class

188
00:25:30,880 --> 00:25:37,920
mit Static-Main-Methode, man muss es bloß nicht mehr selbst schreiben und auf der anderen

189
00:25:37,920 --> 00:25:42,840
Seite kann einem das ja egal sein, aber man sieht, das ist einfach einzig und allein Compiler-Magic,

190
00:25:42,840 --> 00:25:58,560
dass das funktioniert und man spart sich sinnlose Einrückungen, also das ist wirklich praktisch,

191
00:25:58,560 --> 00:26:05,720
aber das geht schon seit, also mindestens seit C-Sharp 9, wenn nicht sogar noch eins

192
00:26:05,720 --> 00:26:10,560
davor, aber ich glaube seit C-Sharp 9 geht, ich glaube das ist seit.NET 5 C-Sharp 9 wo

193
00:26:10,560 --> 00:26:17,880
das geht, das ist natürlich schon cool, du hast C++ in der Berufsschule, das ist richtig,

194
00:26:17,880 --> 00:26:23,400
Monarch-S, weil das schon, sag mal so, das ist insofern schon mal richtig cool, weil

195
00:26:23,400 --> 00:26:31,160
es halt einfach schön kurz und knackig ist für irgendwie kleine kleine Konsolenanwendungen

196
00:26:31,160 --> 00:26:38,480
oder sowas, da ist natürlich schon enorm praktisch, so, ich wollte noch eine Sache,

197
00:26:38,480 --> 00:27:01,760
noch eine Sache hier zum Chat sagen, ja, ich hab, das ist Rider, genauer, wie gesagt,

198
00:27:01,760 --> 00:27:09,000
ich würde Rider verwenden, ja, das ist das beste, was es gibt, das ist auch das beste

199
00:27:09,000 --> 00:27:13,040
unter Windows, das ist auch besser als Wishlist Studio, finde ich persönlich, kann man sich

200
00:27:13,040 --> 00:27:17,400
jetzt drüber streiten, Microsoft hat jetzt ja angefangen verschiedene Spezialfunktionen

201
00:27:17,400 --> 00:27:23,480
in Wishlist Studio oder versucht, Spezialfunktionen in Wishlist Studio einzubauen, die es anderen

202
00:27:23,480 --> 00:27:28,360
nicht ermöglicht, das so ohne weiteres einzubauen, zum Beispiel ihre Hot Reload Geschichte, ich

203
00:27:28,360 --> 00:27:32,360
weiß nicht, ob jemand diese Hot Reload Sache mitbekommen hat, wo Microsoft Sachen entfernt

204
00:27:32,360 --> 00:27:38,200
hat aus.NET 6, um sie dann in Wishlist Studio einzubauen, danach war ein Riesenaufschrei

205
00:27:38,200 --> 00:27:49,680
auf GitHub und jetzt ist es wieder drin, richtig, richtig verkackt, ja, Wishlist Studio Code

206
00:27:49,680 --> 00:27:55,680
geht auch, aber ich finde Wishlist Studio Code für sie scharp, irgendwie nervig, also

207
00:27:55,680 --> 00:28:03,200
ich würde ehrlich gesagt sagen Rider, Rider ist gar nicht mal so teuer, also mal GitHub

208
00:28:03,200 --> 00:28:07,640
Nano getestet, nee, Rider ist gar nicht mal so teuer, also wenn man es über die Firma

209
00:28:07,640 --> 00:28:12,280
bekommt ist es natürlich noch besser, ja, Wishlist Studio Code, Wishlist Studio ist

210
00:28:12,280 --> 00:28:24,440
natürlich kostenlos, aber die, die Preise sind gar nicht so schlimm, also guck mal, wenn

211
00:28:24,440 --> 00:28:30,000
man das für persönliche Nutzung, Nutzung sich kauft und es auch, sagen wir mal, halb

212
00:28:30,000 --> 00:28:38,520
semi oft verwendet, dann bezahlst du 139 Euro im Jahr, das gibt andere Sachen, das kostet

213
00:28:38,520 --> 00:28:47,320
das im Monat, oder eben 83 Euro im Jahr, oder aber ihr sagt ihr wollt das, das Package was

214
00:28:47,320 --> 00:28:55,720
ich mir gekauft habe, ihr wollt das All Tools, oder wie das heißt, wenn ich jetzt wüsste

215
00:28:55,720 --> 00:29:05,280
wo man das finde, hier Store wahrscheinlich, die Seite ist auch, ah All Products Pack genau,

216
00:29:05,280 --> 00:29:09,600
es gibt noch mehr Möglichkeiten wie man, wie man das, wie man da rankommen kann, ja, so

217
00:29:09,600 --> 00:29:23,560
man hat das, man hat das All Products Pack, dann bezahlt man, das hab ich nicht oder, das

218
00:29:23,560 --> 00:29:33,040
ist Up for Individual Use, so teuer ist das gar nicht, dann bezahlt man 250 Euro im Jahr,

219
00:29:33,040 --> 00:29:37,640
das finde ich, das ist für mich so die beste Kombi, das nächste ist, die haben auch einige

220
00:29:37,640 --> 00:29:46,400
Sachen kostenlos, wenn man bei denen mal schaut, die Python IDE ist glaube ich kostenlos,

221
00:29:46,400 --> 00:29:55,320
schauen wir mal, also ich glaube PyCharm gibt es eine kostenlose Version, IntelliJ gibt

222
00:29:55,320 --> 00:29:59,440
es eine kostenlose Version, also wenn man das benutzen will, kann man das eh schon mal

223
00:29:59,440 --> 00:30:06,120
komplett free verwenden, dann so die Standard, so manche Tools, hier.NET Peak und sowas,

224
00:30:06,120 --> 00:30:11,160
das ist glaube ich auch alles kostenlos und der Rest, ja der Rest muss man sich kaufen,

225
00:30:11,160 --> 00:30:16,400
aber ich kann echt sagen, das Zeug ist nicht schlecht, ich finde das JetBrains Zeug wirklich

226
00:30:16,400 --> 00:30:31,440
gut, weiter im Text, kann mir wer helfen mit welcher Programmiersprache man als Anfänger

227
00:30:31,440 --> 00:30:40,680
neu zuteilen anfangen soll, ja das passt wunderbar, ich habe da ein Video letztens zugemacht und

228
00:30:40,680 --> 00:30:49,560
zwar, mit welcher Programmiersprache eignet sich für den Einstieg, da habe ich ein Video

229
00:30:49,560 --> 00:30:54,200
zusammen gemacht oder wir haben ein Video zusammen gemacht über dieses Thema, kannst

230
00:30:54,200 --> 00:30:58,080
du bei mir auf dem Channel gucken oder bei ihm auf dem Channel gucken, da haben wir uns

231
00:30:58,080 --> 00:31:02,640
darüber ausgelassen, kommt aber natürlich immer ein bisschen darauf an, was dein Ziel

232
00:31:02,640 --> 00:31:19,280
ist, ja, also GitHub Nano sagt mir gar nichts, hast du C-Sharp selbst gelernt oder eine Berufsschule,

233
00:31:19,280 --> 00:31:27,320
ne ich habe das damals selbst gelernt, das war 2003 oder so, da war.NET 2 gerade ganz

234
00:31:27,320 --> 00:31:45,680
neu, Framework, ganz neu, da gab es so viele Beispiele mit 1.1 und sowas, habe ich nie verwendet,

235
00:31:45,680 --> 00:31:49,960
habe ich immer einen großen Bogen drum gemacht, ganz ehrlich, wenn ich Mobile Apps entwickeln

236
00:31:49,960 --> 00:31:53,920
würde, ich würde es tatsächlich nicht in C-Sharp machen, auch wenn ich richtig C-Sharp

237
00:31:53,920 --> 00:31:58,040
Fan bin, aber Mobile Apps würde ich wahrscheinlich in irgendeinem Javascript gedünst machen,

238
00:31:58,040 --> 00:32:15,200
was weiß ich, irgendeine Ionic Geschichte oder so, was hältst du von der Aussage von

239
00:32:15,200 --> 00:32:18,440
einem Professor die lautet, wir lernen jetzt C++ damit alle anderen Programmiersprachen

240
00:32:18,440 --> 00:32:26,240
leisten, naja, ich weiß nicht wo da die Logik dahinter ist, es stimmt insoweit schon, wenn

241
00:32:26,240 --> 00:32:34,200
man C++ überlebt hat, kann er nichts anderes mehr so richtig schocken, aber es führt wahrscheinlich

242
00:32:34,200 --> 00:32:37,280
auch zu, dass ganz viele Leute sagen, sie haben da überhaupt keinen Bock drauf, weil

243
00:32:37,280 --> 00:32:43,560
sie C++ so abfackt und manchmal gibt es dann auch Leute, die voll in dieser C++ Denkweise

244
00:32:43,560 --> 00:32:52,240
aufgehen und die kannst du auch für etwas anderes nicht mehr verwenden, achja, als Student

245
00:32:52,240 --> 00:32:55,200
gibt es, das stimmt, als Student, wenn du eine Edu-Adresse oder so hast, kriegst du

246
00:32:55,200 --> 00:33:21,320
C++ auch kostenlos glaube, Datacryp habe ich nie verwendet, naja, ist doch auch schon

247
00:33:21,320 --> 00:33:35,760
mal was, so, ok, also, gehen wir mal rüber, also das erste was ich euch zeigen wollte,

248
00:33:35,760 --> 00:33:40,080
das ist wie gesagt kein neues, ich habe 10 Feature, aber das geht schon lange, dass man

249
00:33:40,080 --> 00:33:45,440
das so, ich weiß gar nicht wie sie das nennen, Minimales Main, übrigens, falls ihr euch

250
00:33:45,440 --> 00:33:53,560
jetzt vielleicht fragt, was passiert, wenn man eine zweite Datei anlegt, hier cacq.cs

251
00:33:53,560 --> 00:34:06,640
und man macht das auch weg und sagt hier hallo, achso, deswegen ging das Marko nicht, ja,

252
00:34:06,640 --> 00:34:12,400
dann werdet ihr feststellen, das funktioniert nicht, also man kann nicht zwei Dateien quasi

253
00:34:12,400 --> 00:34:17,560
ohne Namespace und ohne alles machen, weil, wenn ich das jetzt versuche zu kompilieren,

254
00:34:17,560 --> 00:34:34,360
dann sagt er mir, dann sagt er mir, nee, geht nicht, weil doppelt, oops, only one compilation

255
00:34:34,360 --> 00:34:40,880
you can have top level statement, also sprich, ich kann nicht jede Datei so machen, aber

256
00:34:40,880 --> 00:34:44,400
für kleine, irgendwelche Commando-Zeilen-Tools oder so, ist das natürlich wunderbar, dass

257
00:34:44,400 --> 00:34:52,480
das funktioniert, das mal weg, das ist aber nix, das ist aber nix neues, ein cooles Feature,

258
00:34:52,480 --> 00:34:56,480
was ich euch nochmal zeigen wollte, weil es mir heute Morgen selbst eingefallen ist, stellt

259
00:34:56,480 --> 00:35:02,240
euch mal vor, ihr wollt sowas hier machen, also ihr habt irgendeinen Inam, was weiß ich,

260
00:35:02,240 --> 00:35:06,960
ich mach jetzt einfach das gleiche Beispiel, wie ich es heute Morgen rausbekommen habe,

261
00:35:06,960 --> 00:35:16,760
connection state und da gibt es dann sowas wie, keine Ahnung, closed, failed, new, connected

262
00:35:16,760 --> 00:35:21,760
oder irgendwie sowas, so und jetzt wollt ihr den if machen, also ihr habt hier keine Ahnung,

263
00:35:21,760 --> 00:35:29,360
state gleich irgendwas, ach nee, das geht da nicht, das darf man nicht oben machen,

264
00:35:29,360 --> 00:35:35,880
connection state, das ist egal was, so also ihr habt ne Variable, wo ihr überprüfen

265
00:35:35,880 --> 00:35:42,480
wollt, in welchem connection state ist das ganze und es kommen zwei Stück in Frage, so

266
00:35:42,480 --> 00:35:48,840
bisher musste man das eigentlich immer so machen, du musstest sagen, state, ist das, keine Ahnung,

267
00:35:48,840 --> 00:36:02,880
failed oder ist das vielleicht closed und dann konntest du sagen, was weiß ich, fogjam,

268
00:36:02,880 --> 00:36:08,720
man kann nen switch machen, ja das geht auch, aber man kann auch einfach einen, ich glaub

269
00:36:08,720 --> 00:36:13,760
static pattern oder wie auch immer das heißt, man kann auch einfach einen pattern verwenden

270
00:36:13,760 --> 00:36:21,320
in nem if, das ist relativ neu, das geht glaube ich auch erst seit diesem oder letzten c sharp

271
00:36:21,320 --> 00:36:28,920
version, also die Auswahl ist, das ist das alte und die neue Variante, was ist die neue,

272
00:36:28,920 --> 00:36:36,480
die jetzt mögliche Variante ist die hier, du kannst sagen, state ist zum Beispiel connection

273
00:36:36,480 --> 00:36:46,160
failed oder connection closed, was hat der eigentlich für Schmerzen damit, remove ifs,

274
00:36:46,160 --> 00:36:51,720
warum, ich will das if statement nehmen, ach so, ja gut, weil der mitdenkt und weiß es

275
00:36:51,720 --> 00:36:57,240
ändert sich nie, also man kann jetzt ifs deutlich kürzer schreiben, jetzt an der Stelle macht

276
00:36:57,240 --> 00:37:02,000
es gar nicht mal so viel Unterschied, aber spätestens wenn ich hier nen dritten state

277
00:37:02,000 --> 00:37:13,040
abfragen will, spätestens wenn ich hier irgendwie nen dritten state abfragen will, dann wird

278
00:37:13,040 --> 00:37:18,880
es doch schon relativ unübersichtlich und in dem Fall find ich das deutlich besser

279
00:37:18,880 --> 00:37:27,960
lesbar, gibt es das nur bei c sharp, ich geh mal davon aus, dass wishlist basic diese updates

280
00:37:27,960 --> 00:37:40,560
nicht mehr bekommen hat, ne, also das ist auch relativ neu, das weiß ich nicht, ob

281
00:37:40,560 --> 00:38:04,800
das ein c sharp 10 feature ist, gibt es das auch mit in...was, kann ich dem chat nicht

282
00:38:04,800 --> 00:38:22,640
folgen, der chat ist zu advanced für mich mittlerweile schon, zu hoher eq im chat, ja

283
00:38:22,640 --> 00:38:28,080
also das ist tatsächlich schlecht, natürlich kann man da auch nen switch machen mit den

284
00:38:28,080 --> 00:38:34,680
3 states, man kann auch mehrere ifs machen, aber das wollte ich mal zeigen, das find ich

285
00:38:34,680 --> 00:39:03,320
echt cool, dass das mittlerweile funktioniert, dass es die kürzere Variante davon ist, so,

286
00:39:03,320 --> 00:39:09,480
der chat ist wirklich zu überlegene eq heute, ich versteh nicht was da wieder geschrieben

287
00:39:09,480 --> 00:39:22,640
wird teilweise für dinger, bekommen ein weihnachts emote switch, stimmt, ja wir könnten wieder

288
00:39:22,640 --> 00:39:41,400
weihnachtsmodes rein machen, nachdem ich jetzt ja den keqw doch ausgetauscht hab, achso if

289
00:39:41,400 --> 00:39:49,400
war in...ich glaube, ich glaube das gibt es nicht, bin ich mal gar nicht so sicher, aber

290
00:39:49,400 --> 00:39:54,280
ich glaube das irgendwie in operator hast du nicht, aber du kannst contains verwenden,

291
00:39:54,280 --> 00:40:10,000
wobei contains mit nem enum, gute frage, ich geh mal davon aus, dass du, na egal, müssen

292
00:40:10,000 --> 00:40:13,720
wir uns jetzt mal angucken was da genau Sache ist, zumindest das ist alles keine c sharp

293
00:40:13,720 --> 00:40:17,400
10 features gewesen, wir gucken uns jetzt mal an was es neues gibt, das ist ja eigentlich

294
00:40:17,400 --> 00:40:22,960
das was ich heute machen will, also fangen wir mal an mit dem offiziellen microsoft artikel,

295
00:40:22,960 --> 00:40:27,920
hast du auch vorher ein uml diagramm gemacht, ja struktogramm hab ich gemacht, nasi schneiderman

296
00:40:27,920 --> 00:40:32,360
struktogramm, das liegt hier bei mir auf dem schreibtisch, ich mein, wie könnt ich sonst

297
00:40:32,360 --> 00:40:42,400
überhaupt anfangen, ohne gehts ja wirklich nicht, also ich glaube niemand programmiert

298
00:40:42,400 --> 00:40:47,400
irgendwas ohne vorher ein struktogramm zu machen, also was gibt es denn hier schönes

299
00:40:47,400 --> 00:40:56,280
neues, whats new in c sharp 10, records struct gibt es neues, ja das ist neu, das hab ich

300
00:40:56,280 --> 00:41:01,920
auch gelesen, ich hab keine ahnung wozu das gut ist, das gucken wir uns jetzt in der rein

301
00:41:01,920 --> 00:41:09,400
folge an, wo ich was zu sagen kann, wo ich irgendwie auch schon gleich ne idee hab, wie

302
00:41:09,400 --> 00:41:14,280
man den kram verwenden könnte, also global using directives, das ist ne coole geschichte,

303
00:41:14,280 --> 00:41:23,240
das finde ich nice, wenn man jetzt hier ne neue datei macht, so wir machen jetzt mal

304
00:41:23,240 --> 00:41:35,120
irgendwie ne neue datei, new, class, pochchamp, die pochchamp class, so achja dann sagt der

305
00:41:35,120 --> 00:41:39,880
natürlich, oh das geht, muss anders geschrieben werden, wenn ich sowas hier hab, dann hab

306
00:41:39,880 --> 00:41:48,560
ich ja immer einmal namespace drum herum, ich vermute mal, dass die das gemacht haben,

307
00:41:48,560 --> 00:41:58,800
dass du beispielsweise mehrere namespaces pro file machen kannst oder so, wobei ich

308
00:41:58,800 --> 00:42:04,760
ganz ehrlich bin, ich glaube das hab ich noch nie gesehen, dass es mehrere namespaces pro

309
00:42:04,760 --> 00:42:11,680
file gibt, deswegen hat sich microsoft jetzt gedacht, man kann das kürzer machen, man

310
00:42:11,680 --> 00:42:16,520
macht das jetzt so ein bisschen c++ style, weiß ich auch nicht ganz stimmt, man sagt

311
00:42:16,520 --> 00:42:28,720
jetzt hier oben einmal ich namespace und spart sich die einrückung, also anstatt so, anstatt

312
00:42:28,720 --> 00:42:33,880
so kann ich jetzt so machen, das finde ich echt praktisch, das sind so kleine sachen,

313
00:42:33,880 --> 00:42:42,800
ich finde, microsoft hat da echt und ihr wisst, ich lobe microsoft jetzt nicht so oft, aber

314
00:42:42,800 --> 00:42:48,080
was neues die sharp features angeht, ist microsoft echt nicht schlecht, die haben da die letzten

315
00:42:48,080 --> 00:42:56,460
jahre über viele sachen eingebaut, die entweder wegweisend geworden sind, diese ganze async

316
00:42:56,460 --> 00:43:07,880
overweight geschichte zum beispiel oder aber die einfach nur nützlich sind und das kriegen

317
00:43:07,880 --> 00:43:12,800
die finde ich gut hin, achja warum das hier jetzt angezeigt wird als geht nicht, ich glaube

318
00:43:12,800 --> 00:43:17,760
ich hab es richtig gemacht, es liegt daran, rider hat noch nicht alle c sharp 10 features

319
00:43:17,760 --> 00:43:23,640
drinne, also ihr seht prinzipiell funktioniert, gar kein problem, aber rider ist der meinung,

320
00:43:23,640 --> 00:43:34,640
das ist kein gültiges statement, es gibt, ide upgrade is available, mal gucken, vielleicht

321
00:43:34,640 --> 00:43:38,560
geht es auch mit der neuesten version, können wir mauspringen, aber ich glaube sie haben

322
00:43:38,560 --> 00:43:44,400
gesagt, dass sie erst mit 2021.3 dotnet 6 vollständig unterstützen wollen, das kommt

323
00:43:44,400 --> 00:43:50,920
irgendwann demnächst, aber das meiste geht schon, das ist zum beispiel so eines der features,

324
00:43:50,920 --> 00:43:55,280
da kommt er noch ein bisschen durcheinander, der sagt, das ist nicht korrekte sonntags,

325
00:43:55,280 --> 00:44:01,680
aber man sieht ja, ich kann es ja ausführen, es ist kein problem, funktioniert, also das

326
00:44:01,680 --> 00:44:12,040
ist jetzt neu in c sharp 10 und das finde ich eine äußerst praktische neuerung, also

327
00:44:12,040 --> 00:44:16,300
das finde ich schonmal gut, es war etwas ganz kleines, aber praktisch, man spart sich quasi

328
00:44:16,300 --> 00:44:24,960
dadurch einmal einrückungstiefe, das kann eigentlich nur gut sein, so was haben wir als

329
00:44:24,960 --> 00:44:36,920
nächstes, extended property patterns, jetzt wird es advanced, was ist das, oh ne, das

330
00:44:36,920 --> 00:44:45,880
werde ich wahrscheinlich nie im leben verwenden, ok, also früher, früher musste man so machen

331
00:44:45,880 --> 00:44:51,200
und jetzt kann man so machen, alles klar, ok, wunderbar, ich glaube, ich habe diese

332
00:44:51,200 --> 00:45:18,320
neue property sonntags nicht einmal bisher verwendet, ja, schön, ahja, das ist tatsächlich

333
00:45:18,320 --> 00:45:27,920
ganz praktisch, das ist tatsächlich ganz praktisch, man kann jetzt, wenn man weiß,

334
00:45:27,920 --> 00:45:33,600
dass man immer die gleichen imports verwendet, ja, also zum beispiel ich verwende in jeder

335
00:45:33,600 --> 00:45:42,440
datei system oder so, da kann ich jetzt sagen, glaube global using und dann kann ich hier

336
00:45:42,440 --> 00:45:50,120
ohne zu importieren, ich hoffe rider checkt das jetzt, da kann ich jetzt hier ohne zu importieren

337
00:45:50,120 --> 00:46:00,520
console write line verwenden, ja, wenn ich das global weg mache, sollte es nicht mehr

338
00:46:00,520 --> 00:46:05,040
funktionieren, ja guckt, wenn ich das global weg mache, dann müsste ich in jeder datei

339
00:46:05,040 --> 00:46:11,380
quasi den graben importieren, das heißt so Sachen, die ich wirklich jedesmal brauche,

340
00:46:11,380 --> 00:46:20,600
kann ich jetzt einmal in meinem einstiegspunkt global davor schreiben und das ist dann programmweit

341
00:46:20,600 --> 00:46:26,320
verfügbar, das ist auch kleiner change aber finde ich auch ziemlich praktisch, du hast

342
00:46:26,320 --> 00:46:32,040
natürlich auf der anderen seite den nachteil, dass du nicht mehr einfach hoch scrollen kannst

343
00:46:32,040 --> 00:46:41,640
und gucken kannst, was sache ist, aber ich denke, nachdem eh niemand irgendwie ohne ideen das aufmacht,

344
00:46:41,640 --> 00:46:49,520
kann man auch einfach hier drüber gehen und zieht es trotzdem, ja das stimmt, wenn du

345
00:46:49,520 --> 00:46:53,800
es einfach copy pastest, dann geht es nicht mehr, wobei man halt sagt, wenn man was copy

346
00:46:53,800 --> 00:46:58,920
pastet, ich copy paste eigentlich nie die usings mit, du copy paste ist ja meistens

347
00:46:58,920 --> 00:47:05,360
so ein teil und nicht alles und dann drückst du 2-3 mal alt enter, weil es ist ja relativ

348
00:47:05,360 --> 00:47:09,760
easy was zu importieren, wenn das nicht importiert ist, siehst du, ah ist rot, drückst alt enter

349
00:47:09,760 --> 00:47:15,840
und dann importiert es automatisch, das geht dann meistens relativ zackig, wenn es einem

350
00:47:15,840 --> 00:47:20,200
nicht gefällt, ist das wirklich ein feature, was man auch easy ignorieren kann, ich finde

351
00:47:20,200 --> 00:47:27,600
es ganz gut, geht auch in der projektdatei, da müssen wir mal gucken, aber in der projektdatei

352
00:47:27,600 --> 00:47:37,800
finde ich dann schon ein bisschen eklig, also in der projektdatei finde ich dann sehr obskur,

353
00:47:37,800 --> 00:47:51,560
wenn das da drin steht, ach ja und was ich auch gelesen habe, irgendwo was jetzt angeblich geht

354
00:47:51,560 --> 00:48:04,800
ist, man kann jetzt string-konstanten zur compile-zeit interpolaten, toller Satz, ich

355
00:48:04,800 --> 00:48:10,840
weiß, aber was jetzt wohl geht, ist sowas hier, wenn ich sage const string, wobei kann

356
00:48:10,840 --> 00:48:21,440
ich das hier einfach so machen, const string keqv gleich keqv, const string lulv gleich

357
00:48:21,440 --> 00:48:31,800
lulv und jetzt kann ich sagen hier const string omega keq, kann ich jetzt sagen ok, omega keq

358
00:48:31,800 --> 00:48:41,360
setzt sich zusammen aus keqv, der variablet keqv und lulv und wenn das jetzt alles constant

359
00:48:41,360 --> 00:48:55,080
ist, dann macht er das wohl zur compile-zeit, dass er das hier draus zusammensetzt, also

360
00:48:55,080 --> 00:48:57,680
ich glaube das ist auch neu, wir können es mal ausbringen, ich stelle massi sharp auf

361
00:48:57,680 --> 00:49:06,280
9 zurück, ja guck das geht nicht, das ging in 9 noch nicht, ne das konnte der früher

362
00:49:06,280 --> 00:49:11,160
nicht so, wobei ich mir nicht sehe, ich weiß gar nicht ob die einfache variante, die ging

363
00:49:11,160 --> 00:49:20,840
wahrscheinlich auch nicht ne, doch die ging, also string-concat funktioniert, aber string-interpolation

364
00:49:20,840 --> 00:49:33,960
das ging früher nicht, so das heißt ich kann jetzt ja noch was dazwischenschreiben, geht

365
00:49:33,960 --> 00:49:44,000
nicht, dann stellen wir um auf si sharp 10 und zack, funktioniert das ganze, wo ist der

366
00:49:44,000 --> 00:49:49,000
Unterschied, kommt auch aufs gleiche raus, naja ich spiele das jetzt nicht mehr, wenn

367
00:49:49,000 --> 00:49:55,280
ich das jetzt von hand schreiben müsste, dann müsste ich jetzt sowas hier machen, so und

368
00:49:55,280 --> 00:50:07,360
dann ist irgendwann auch mal gut mit concat und spätestens wenn du ein bisschen komplizierter

369
00:50:07,360 --> 00:50:18,120
formatieren willst, ist das mit string-interpolation tatsächlich schöner, ja das ist jetzt möglich

370
00:50:18,120 --> 00:50:26,120
in si sharp 10, in 9 ging das noch nicht, das schreibt microsoft hier natürlich nicht wunderbar,

371
00:50:26,120 --> 00:50:38,840
gut zu wissen, ach hier ist es doch, concentrated strings, da ist es doch, ja genau, so was

372
00:50:38,840 --> 00:50:47,200
gibt es dann, record types can seal to string, ging das vorher nicht, si sharp 10 you can

373
00:50:47,200 --> 00:50:53,640
add sealed modifier when you override to string, ging das vorher nicht, ok anscheinend ging

374
00:50:53,640 --> 00:51:04,880
das vorher nicht, muss ich ehrlich sagen ich habe glaube ich noch nicht einmal to string

375
00:51:04,880 --> 00:51:13,720
gesealt, aber ok, das können wir ja mal ausbreiten, ok das betrifft jetzt nur record types, also

376
00:51:13,720 --> 00:51:23,400
probieren wir das doch mal aus, record, was weiß ich, data, mir fällt jetzt nichts gescheites

377
00:51:23,400 --> 00:51:35,360
ein, so string, name, so beste, was willst du mir vorschlagen, generate constructor,

378
00:51:35,360 --> 00:51:48,400
ja wunderbar, ok und jetzt kann ich override to string machen und das kann ich jetzt sealen

379
00:51:48,400 --> 00:52:00,640
oder was, aha und das ging vorher nicht oder was, ok wie oft das jetzt vorkommt, kein Schimmer,

380
00:52:00,640 --> 00:52:10,240
wie viel macht, wenn du das erbst, also wenn du zum Beispiel sagst, data 2 erbt von data,

381
00:52:10,240 --> 00:52:16,960
wobei ich weiß gar nicht ob records erben, ne, tja, das geht anscheinend, ja warum muss

382
00:52:16,960 --> 00:52:23,320
man das dann seal machen, ah das ist ein contain parameter, das ist constructor, ok alles klar,

383
00:52:23,320 --> 00:52:31,400
so und jetzt kann ich das nicht mehr überschreiben, guck jetzt kann ich kein to string mehr überschreiben

384
00:52:31,400 --> 00:52:40,840
und wenn ich das sealed weg mache, dann kann ich, dann kann ich to string wieder überschreiben,

385
00:52:40,840 --> 00:52:50,840
ich bin mir nicht ganz sicher wann ich das machen würde, ja, ja wieso ist eine gute

386
00:52:50,840 --> 00:52:56,200
Frage, also mir fällt jetzt da kein sinnvolles Beispiel zu ein, wenn ich ehrlich bin, wenn

387
00:52:56,200 --> 00:53:04,160
ich irgendwie sicherstellen will, dass in einem abgeleiteten Typ die Konsolenausgabe,

388
00:53:04,160 --> 00:53:15,960
was weiß ich, keine Ahnung, nein, nein data 2 kann gar kein to string überschreiben,

389
00:53:15,960 --> 00:53:26,000
das geht nicht, das einzige, das einzige was data 2 machen könnte ist, sag mal, das einzige

390
00:53:26,000 --> 00:53:33,000
was data 2 machen könnte wäre new to string, aber das ist dumm, das bringt dir nämlich

391
00:53:33,000 --> 00:53:43,220
überhaupt nichts oder auch nicht, ok dann geht das mit records zwar nicht, das könntest

392
00:53:43,220 --> 00:53:47,800
du machen, das bringt dir aber auch nichts, weil du könntest einfach data 2 zu data cast

393
00:53:47,800 --> 00:53:54,080
und dann hast du wieder das da, ja du kannst hier nichts überschreiben mit to string, anscheinend

394
00:53:54,080 --> 00:54:00,680
ist das jetzt neu, ich hab das ehrlich gesagt bisher nicht verwendet und mir fällt da jetzt

395
00:54:00,680 --> 00:54:06,840
auch wenig zu ein, wozu man das brauchen könnte, aber ja für den Nischenfall, dass man das

396
00:54:06,840 --> 00:54:13,400
mal braucht ist es jetzt da, was genau sind records, ah da kann ich auch nochmal kurz

397
00:54:13,400 --> 00:54:23,160
was zu sagen, also C sharp hat ja mittlerweile mehrere grundlegende Typen, also die häufigsten

398
00:54:23,160 --> 00:54:39,160
sind ja eindeutig struct und class, class data oder struct data 2 oder jetzt records

399
00:54:39,160 --> 00:54:44,760
data 3, was ist der Unterschied, da können wir übrigens auch gleich ein neues C sharp

400
00:54:44,760 --> 00:54:56,600
10 Feature angucken, was ist der Unterschied, das hier ist eigentlich eine Klasse, also

401
00:54:56,600 --> 00:55:04,840
im Prinzip ist es eigentlich sowas, nur das class quasi kannst du dir sparen, so und

402
00:55:04,840 --> 00:55:15,080
was record macht ist folgendes, ich lösche das mal wieder, so wir machen jetzt einfach

403
00:55:15,080 --> 00:55:27,400
mal records data, so und da gibt es string name, kann ich was anlegen, lass ich D1, name

404
00:55:27,400 --> 00:55:37,440
ist gleich, so ich brauch jetzt den chat, der Mark ist das, so erster name und was hab

405
00:55:37,440 --> 00:55:40,840
ich falsch, ach Quatsch, ja ich vergesse immer, dass man das unten drunter hinschreiben

406
00:55:40,840 --> 00:55:57,600
muss hier, so und dann haben wir K1 und D2 ist new data, einfach max jetzt, so ich glaube

407
00:55:57,600 --> 00:56:04,080
wir sind uns, also das will ich gar nicht, console, console, write line schreiben, so

408
00:56:04,080 --> 00:56:11,880
ich glaube wir sind uns alle relativ einig, was da jetzt rauskommt, doch da beißt, komm

409
00:56:11,880 --> 00:56:18,000
den machen wir auch noch hier, wenn er schon kein WIP kriegt, so wir sind uns eigentlich

410
00:56:18,000 --> 00:56:23,240
relativ einig, was da jetzt rauskommt, wenn man das ausführt, das kann ja eigentlich

411
00:56:23,240 --> 00:56:35,080
nur false sein, was da rauskommt, so jetzt ist aber die Sache die, wenn ich das so machen

412
00:56:35,080 --> 00:56:40,720
würde, dann würde man jetzt erstmal spontan sagen, ja klar da muss true rauskommen, kommt

413
00:56:40,720 --> 00:56:45,960
auch, kommt auch, aber und jetzt kommt der, und jetzt kommt der Gag, wenn ich jetzt anstatt

414
00:56:45,960 --> 00:56:58,120
den record hier mal eine normale class draus mache, was kommt denn jetzt raus, jetzt kommt

415
00:56:58,120 --> 00:57:07,680
false raus, ja also anscheinend, anscheinend macht hier der record doch der Unterschied,

416
00:57:07,680 --> 00:57:14,040
was ich gerade mache, wir gucken uns neue C sharp Features an, so das liegt daran, weil

417
00:57:14,040 --> 00:57:20,680
wenn du eine Klasse, wenn du die Instanz, zwei Instanzen von einer Klasse miteinander

418
00:57:20,680 --> 00:57:27,080
vergleicht, dann vergleicht der quasi die Referenz da drauf, also man könnte quasi

419
00:57:27,080 --> 00:57:33,800
sagen, zwar ganz abstrak, die Speicheradresse, wenn man es so will, also der guckt, ist das

420
00:57:33,800 --> 00:57:42,080
auch wirklich, zeigt das auf das gleiche Objekt, und das ist ja hier nicht so, das hier ist

421
00:57:42,080 --> 00:57:49,240
eine Instanz, und das hier ist eine Instanz, und dementsprechend ist das hier halt false,

422
00:57:49,240 --> 00:57:56,680
so und jetzt gibt es records, records sind Klassen, die so ein paar Sachen intern überschrieben

423
00:57:56,680 --> 00:58:05,880
haben, dass man sie besser verwenden kann für reine so Datencontainer, also es kommt

424
00:58:05,880 --> 00:58:11,400
ja relativ easy vor, es kommt ja relativ oft vor, dass man einfach mal Klassen braucht,

425
00:58:11,400 --> 00:58:25,320
die eigentlich nix machen, außer 5 Werte zu speichern, machen record bei DTO Sinn, ja

426
00:58:25,320 --> 00:58:32,360
da macht das durchaus Sinn, so also man hat bei record zum Beispiel überschrieben, ich

427
00:58:32,360 --> 00:58:36,760
bin mir übrigens jetzt gar nicht sicher, ob was die alles überschrieben haben, also

428
00:58:36,760 --> 00:58:40,000
die haben zum Beispiel auf jeden Fall schon mal überschrieben, man kann das übrigens

429
00:58:40,000 --> 00:58:44,800
alles von Hand machen, also record ist, wir können uns das jetzt nochmal bei sharplab angucken,

430
00:58:44,800 --> 00:58:48,520
mal gucken was da unter der Haube rauskommt, hab ich mir noch nie angeguckt, wenn ich ehrlich

431
00:58:48,520 --> 00:59:01,200
bin, schauen wir mal, was kommt unter der Haube bei dem record raus, MonkaS, what the fuck,

432
00:59:01,200 --> 00:59:15,280
so viel ist das, also bei dem record kommt unter der Haube folgendes raus, er generated

433
00:59:15,280 --> 00:59:31,320
eine class, die interface, das kann ich nicht aussprechen Leute, ach du große, ok das müssen

434
00:59:31,320 --> 00:59:52,440
wir google jetzt mal, alles klar, hab ich jetzt schon wieder vergessen, zumindest, wenn man

435
00:59:52,440 --> 01:00:00,000
sich das hier anguckt, unter der Haube ist das einfach hier compiler magic, also ein record

436
01:00:00,000 --> 01:00:13,920
ist eigentlich eine klasse, der standard record ist eine klasse, die i implementiert und noch

437
01:00:13,920 --> 01:00:25,400
ein paar andere dinge überschreibt, zum beispiel überschreibt das to string, das heißt ich

438
01:00:25,400 --> 01:00:31,560
bekomme automatisch bei einem record, ich kann ja mal den record jetzt ausgeben, ich bekomme

439
01:00:31,560 --> 01:00:36,520
automatisch bei einem record, wenn ich die auf die konsole ausgebe, eine sinnvolle, eine

440
01:00:36,520 --> 01:00:42,000
sinnvolle ausgabe, was herr streamer zwischenfrage, wo wir jetzt wieder, also wenn ich die, wenn

441
01:00:42,000 --> 01:00:51,520
ich die, die Leute sehe die das schreiben, dann glaub ichs euch schon wieder nicht, können

442
01:00:51,520 --> 01:01:03,760
sie im vorschläge channel im discord bitte mal gucken, kann ichs machen, hier kann man

443
01:01:03,760 --> 01:01:16,240
die korrekte aussprache hören, ach du große, das kann ich da nicht merken, vorschläge

444
01:01:16,240 --> 01:01:28,600
channel soll ich gucken, alles klar, vorschläge, 30 milliarden emotes, das muss ich mir doch

445
01:01:28,600 --> 01:01:33,720
jetzt nicht angucken, ich muss doch jetzt nicht, ich muss doch jetzt nicht drüber entscheiden,

446
01:01:33,720 --> 01:01:47,880
was wir für weihnachts emotes rein machen, kann man das im discord mark as unread oder

447
01:01:47,880 --> 01:01:56,320
sowas machen, da muss ich nachher gucken, jetzt machen wir erstmal streamen, doch ist

448
01:01:56,320 --> 01:02:04,600
wichtig, also wenn ich das hier ausgebe als record, dann sieht man, guckt mal, ich bekomme

449
01:02:04,600 --> 01:02:10,120
eine sinnvolle konsolenausgabe, wenn das hier eine klasse wäre, dann würde ich die standard

450
01:02:10,120 --> 01:02:17,480
klassen ausgabe bekommen, nämlich das ist einfach data class, also das macht record

451
01:02:17,480 --> 01:02:23,000
auch schon mal, die überschreiben to stream, dass ich sinnvolle datenausgabe bekomme, so

452
01:02:23,000 --> 01:02:34,920
was machen sie sonst noch beim record, äh, dinger, ja, equal, not equal wird überschrieben,

453
01:02:34,920 --> 01:02:39,120
das haben wir schon gesehen, der checkt jetzt, dass die einzelnen member übereinstimmen

454
01:02:39,120 --> 01:02:44,560
und nicht, ob es die gleiche instanz ist, not equal, equal wird überschrieben, get hashed

455
01:02:44,560 --> 01:02:54,520
wird überschrieben, equals wird überschrieben und das war's, also im prinzip ist record

456
01:02:54,520 --> 01:03:01,640
nur so ein taktischer sugar dafür, dass man den kram nicht selbst implementieren muss

457
01:03:01,640 --> 01:03:09,840
jedes mal, wenn man eben eine klasse will, die sich mehr wie werte verhält als referenzen.

458
01:03:09,840 --> 01:03:16,760
Jetzt ist natürlich die große preisfrage, warum kann man nicht einfach einen struct

459
01:03:16,760 --> 01:03:17,760
verwenden?

460
01:03:17,760 --> 01:03:28,360
Das ist ja ähnlich, aber so einfach ist das ganze nicht, man sieht es hier nämlich zum

461
01:03:28,360 --> 01:03:42,640
beispiel an der stelle schon, equals mag er nicht so gerne und bei structs kopierst du

462
01:03:42,640 --> 01:03:48,480
ja immer die werte, das heißt jedes mal, wenn du so einen struct übergibst, kopierst

463
01:03:48,480 --> 01:03:55,920
du das ding, das heißt es hat schon durchaus seinen sinn, das eben als referenz zu machen

464
01:03:55,920 --> 01:04:00,280
und dementsprechend haben sie sich gedacht, wir führen dafür records ein, das ist aber

465
01:04:00,280 --> 01:04:09,040
nix neues, das ist glaub auch schon csharp 8 oder so, aber es hat jemand gefragt, was

466
01:04:09,040 --> 01:04:16,840
records sind, anscheinend ist jetzt das neue feature, dass man jetzt bei records to strings

467
01:04:16,840 --> 01:04:26,040
bestilen kann oder sowas, es gibt jetzt, ich glaube auch mit csharp 9 oder csharp 10 ein

468
01:04:26,040 --> 01:04:30,800
neues feature, es gibt jetzt records structs, müssen wir mal gucken, ob das da drin steht,

469
01:04:30,800 --> 01:04:40,120
ja das ist auch neu, da muss ich ehrlich sagen, ich hab absolut noch keinen plassen schimmer,

470
01:04:40,120 --> 01:04:54,040
wozu das gut ist, ich hab keinen schimmer, ich weiß, das ist neu, records structs, so,

471
01:04:54,040 --> 01:05:03,200
record class ist standard, records struct ist jetzt neu, wahrscheinlich ist das im prinzip,

472
01:05:03,200 --> 01:05:09,640
wird das dann immer noch per value übergeben, aber sie haben ein paar sachen für ein überschrieben,

473
01:05:09,640 --> 01:05:15,280
vermute ich jetzt einfach mal, aber ansonsten, ich hab keine ahnung, wir können uns das

474
01:05:15,280 --> 01:05:22,880
ganze ja mal angucken, was da hier generiert, ja internal structs, es ist ne ganze ecke

475
01:05:22,880 --> 01:05:28,840
kürzer, ja dann ist das wohl wirklich so, wie ich gesagt hab, das ist, dass ich das

476
01:05:28,840 --> 01:05:33,560
hier per value übergeben kann, aber trotzdem den vorteil hab von den ganzen überschriebenen

477
01:05:33,560 --> 01:05:47,120
sachen, tja, und es ist, es macht, ja Patrick, du hast, es macht echt, finde ich, den unterschied

478
01:05:47,120 --> 01:05:54,440
sehr verschwommen, ja, record ist eine klasse, dass sich klasse mehr wie ein struct verhält,

479
01:05:54,440 --> 01:06:00,600
records struct ist dann ein struct, nein, das stimmt nicht, aber, ja, es ist nicht

480
01:06:00,600 --> 01:06:06,520
gerade intuitiv, ich glaube ganz ehrlich, records struct werde ich so gut wie nie verwenden,

481
01:06:06,520 --> 01:06:13,000
fällt irgendjemand ein gutes anwendungsbeispiel für records struct ein, mir nicht, nicht

482
01:06:13,000 --> 01:06:21,640
zumindest so spontan nicht, tja, jetzt noch was dazu, wenn man jetzt sagt, man möchte

483
01:06:21,640 --> 01:06:30,840
beispielsweise var d3 machen, also man möchte jetzt beispielsweise diese klasse, ups, vielleicht

484
01:06:30,840 --> 01:06:37,400
soll ich, jetzt hab ich gelöchter bescheuert, machen wir noch mal irgendwie pop int, irgendwie

485
01:06:37,400 --> 01:06:45,240
age oder sowas dabei, abstract records struct, würd nicht wundern, wenn das sogar funktioniert,

486
01:06:45,240 --> 01:06:57,800
so hier, sagen wir mal irgendwie age 12, ups, müssen wir irgendwie gleich so, hier, und

487
01:06:57,800 --> 01:07:04,640
der andere mark ist age 16, oh ne, der ist schon volljährig, der ist 19, jetzt stimmt

488
01:07:04,640 --> 01:07:10,120
das ganze natürlich nicht mehr überein, aber es könnte jetzt ja sein, dass ich ein d3 anlegen

489
01:07:10,120 --> 01:07:16,000
will mit grundlage d1, und dann müsste ich jetzt sagen, das verwende ich übrigens auch

490
01:07:16,000 --> 01:07:23,040
relativ selten, ja, kann ich jetzt sagen d1, ne, wie war das nochmal with, ach scheiße,

491
01:07:23,040 --> 01:07:38,360
das krieg ich nicht mehr hin, wie war die richtige sonntagsführer, Beispiel, aha, hier,

492
01:07:38,360 --> 01:07:45,440
genau, dann kannst du jetzt nämlich sagen d2 with und dann übernimmt er alles, außer

493
01:07:45,440 --> 01:07:56,240
das, was ich hier reinschreibe, also der nimmt jetzt die werte hier draus, äh die werte

494
01:07:56,240 --> 01:08:06,840
hier draus und überschreibt nur das eine, weil man verwendet, also man verwendet records

495
01:08:06,840 --> 01:08:14,360
eigentlich zum größten teil immutable, was natürlich jetzt komisch ist, sowas funktioniert,

496
01:08:14,360 --> 01:08:18,600
aber gut, ja ihr merkt schon, ich verwende das nicht sonderlich oft, muss ich auch ehrlich

497
01:08:18,600 --> 01:08:34,960
zugeben, sie schabt gleich durch java, ne überhaupt nicht, naja, so, das waren structs

498
01:08:34,960 --> 01:09:00,320
und anscheinend gibt es jetzt records structs, das muss ich jetzt mal ausfinden, geht sowas,

499
01:09:00,320 --> 01:09:06,920
probiere jetzt, abstract, record, struct, ne, ich glaube structs können nicht abstract

500
01:09:06,920 --> 01:09:15,440
sein, aber, naja, gut, man muss man nicht zu lange damit aufhalten, das ist zumindest

501
01:09:15,440 --> 01:09:29,640
jetzt neu, ja das video können wir gleich gucken, ne, das ist ein anderes, so, also

502
01:09:29,640 --> 01:09:34,520
was gibt es jetzt auch so schönes neues, zeig mal her, what's new, das haben wir uns

503
01:09:34,520 --> 01:09:38,680
jetzt angeschaut schon, records structs, improvement of structure types, das ist mir jetzt ehrlich

504
01:09:38,680 --> 01:09:50,000
gesagt nicht so spannend, pattern, constant interpolated, strings haben wir schon, record,

505
01:09:50,000 --> 01:09:54,240
seal to string haben wir auch ausgespielt, assignment and declaration in same constructor,

506
01:09:54,240 --> 01:09:59,960
ja das habe ich auch schon gesehen, dass das funktioniert, wobei ich da auch sagen muss,

507
01:09:59,960 --> 01:10:14,520
ja, ok, schön, dass das jetzt geht, das ging ja vorher auch schon, nur, dass du dich entscheiden

508
01:10:14,520 --> 01:10:24,560
musstest, zwischen, machst du, quasi, deklaration und initialisierung in einem, für beide variablen,

509
01:10:24,560 --> 01:10:28,640
oder, machst du es getrennt, du konntest es nicht mischen, dass du beispielsweise sagst,

510
01:10:28,640 --> 01:10:35,360
ok, x deklariere ich hier oben, und weiße es dann hier unten nochmal zu und y mache ich

511
01:10:35,360 --> 01:10:42,920
hier quasi alles in einem, ja, ok, gut, dass das jetzt funktioniert, ich muss ehrlich sagen,

512
01:10:42,920 --> 01:10:54,320
keine ahnung, war gerade eine botwelle, das schwankt halt ein bisschen, ich weiß nicht,

513
01:10:54,320 --> 01:11:04,640
ob da jetzt wirklich viele das so verwenden, endlich, excellent, ok, für eine schleife,

514
01:11:04,640 --> 01:11:11,000
na ich weiß nicht, du brauchst ja hier rechts den typ, den du deconstructen kannst, also,

515
01:11:11,000 --> 01:11:17,160
das ist, fällt irgendjemand, ein eingebauter typ ein, den man dekonstrucken kann, gibt

516
01:11:17,160 --> 01:11:31,840
das irgendeinen, kann man das dekonstrucken, das ding, geht das, das haben die wahrscheinlich

517
01:11:31,840 --> 01:11:39,120
dem Windows, in dem old Windows Formszeug bestimmt nicht mehr eingebaut, oder, lull,

518
01:11:39,120 --> 01:11:45,040
nein, natürlich nicht, das heißt, ich müsste mir irgendeine Klasse anlegen, die das kann,

519
01:11:45,040 --> 01:11:51,880
kein Schimmer, also, ich wüsste jetzt nicht so genau, wo und wie ich das brauchen würde,

520
01:11:51,880 --> 01:11:55,600
aber vielleicht, ich habe ja noch 2-3 Videos zu neuen Features, vielleicht gibt es da

521
01:11:55,600 --> 01:12:09,240
ein paar gute Beispiele zu, ah, tuppels, genau, da hast du recht, ja, das können wir ausbilden,

522
01:12:09,240 --> 01:12:19,040
was will ich, da kann ich euch auch gleich noch was zeigen, also, ich glaube, so geht

523
01:12:19,040 --> 01:12:35,440
das, na, create, 1, 2, 3, so, 1, 2, und jetzt können wir das zerlegen, ja, t, int, int,

524
01:12:35,440 --> 01:12:43,880
so, also, das geht jetzt, jetzt ist x, jetzt ist x ist 1 und y ist 2, guckt, so, mal hier

525
01:12:43,880 --> 01:12:52,120
cw, alter, das regt mich auf, dass das Console-Write-Line-Makro hier nicht funktioniert, also x, ne, das

526
01:12:52,120 --> 01:13:00,000
mag der nicht, ja, das ist wohl irgendeine Rider-Bug, so, jetzt ist, ja, x ist 1 und

527
01:13:00,000 --> 01:13:13,760
y ist 2, und anscheinend kann man jetzt sowas hier machen, weil, ich habe wirklich

528
01:13:13,760 --> 01:13:23,800
keine Ahnung, wann ich das mal brauche, das ist revolutionär neu, na, ob es revolutionär

529
01:13:23,800 --> 01:13:28,720
ist, weiß ich nicht, aber das ist neu, warum, weiß ich nicht so genau, aber ich kann euch

530
01:13:28,720 --> 01:13:36,600
was anderes zeigen, was ich tatsächlich ziemlich praktisch finde, was so tuppel-Geschichten

531
01:13:36,600 --> 01:13:42,400
angeht, das geht aber schon seit den letzten 32 Sharp-Versionen, aber, geht mal davon aus,

532
01:13:42,400 --> 01:13:53,960
ihr habt irgendeine Klasse, ich blub, bester, bester Klassenarme, so, und das Ding hat irgendwie

533
01:13:53,960 --> 01:14:01,400
eine Methode, was weiß ich, open, oder so, also, try open, so, was man ja ganz gerne

534
01:14:01,400 --> 01:14:07,000
macht, ist, dass man sagt, ok, ich versuche jetzt irgendwas zu öffnen, und wenn es geht,

535
01:14:07,000 --> 01:14:09,880
dann sage ich, hat funktioniert, und wenn es nicht geht, dann sage ich halt, hat nicht

536
01:14:09,880 --> 01:14:16,680
funktioniert, so, natürlich ist es praktisch, wenn man, wenn es geht, gleich auch das zurückgibt,

537
01:14:16,680 --> 01:14:21,960
was man geöffnet hat, so, und bisher macht man das in C Sharp eigentlich so, oder eigentlich

538
01:14:21,960 --> 01:14:33,920
auch immer noch, dass man sagt hier zum Beispiel try open, und dann sowas hier wie out, result,

539
01:14:33,920 --> 01:14:46,040
oder so, result, gleich lulw, so, und jetzt kann ich sagen, so, und jetzt kann ich sagen,

540
01:14:46,040 --> 01:14:53,600
das geht übrigens mit fast allen eingebauten Sachen im.NET Framework, die eben Operationen

541
01:14:53,600 --> 01:14:58,200
haben, die fehlschlagen können, zum Beispiel, wo das auch eingebaut ist, hier sowas wie

542
01:14:58,200 --> 01:15:04,800
try pass, da kann ich zum Beispiel ein String versuchen, als int zu passen, und wenn das

543
01:15:04,800 --> 01:15:11,280
geht, kommt halt hier zurück, ja, ging, ging nicht, und wenn es funktioniert hat, habe

544
01:15:11,280 --> 01:15:16,140
ich hier halt auch gleich noch das result drin, das heißt, ich kann jetzt da sowas

545
01:15:16,140 --> 01:15:22,920
hier machen, if int, 5, try pass, und dann sage ich result output, also sprich, nur wenn

546
01:15:22,920 --> 01:15:31,120
das funktioniert hat, dann gehe in das if rein, so, das ist nicht neu, das ist ziemlich

547
01:15:31,120 --> 01:15:38,900
klassisch, was man jetzt machen kann, ist mit tuppels, das ist halbwegs neu, es gibt

548
01:15:38,900 --> 01:15:47,700
jetzt named tuppels, das ist ganz, ganz abgedrehtes Zeug, alter Jailor, was ist denn hier schon

549
01:15:47,700 --> 01:15:58,300
wieder los jetzt, was ist hier, was, was, was ist hier wieder im Chat angesagt, so, es gibt

550
01:15:58,300 --> 01:16:01,760
jetzt named tuppels, was man jetzt machen kann, ist folgendes, man könnte zum Beispiel sagen

551
01:16:01,760 --> 01:16:10,680
bool result, und, ähm, äh, oder so, oder was weiß ich, ja, success, und, ähm, dann

552
01:16:10,680 --> 01:16:13,960
kann man sagen string result, es ist, ich gebe zu, das ist jetzt vielleicht nicht das

553
01:16:13,960 --> 01:16:20,660
schönste Beispiel dafür, aber das würde jetzt auch funktionieren, also man kann jetzt

554
01:16:20,660 --> 01:16:28,080
durch named tuppel quasi zwei Werte zurückgeben von einer Methode, sieht ein bisschen hässlich

555
01:16:28,080 --> 01:16:43,760
aus, aber das funktioniert, ich kann jetzt sagen, aber ich kann jetzt sagen hier try open,

556
01:16:43,760 --> 01:16:50,960
und ich bekomme jetzt zwei Werte zurück, success oder result, also man kann jetzt zwei return

557
01:16:50,960 --> 01:17:00,840
Werte aus einer Methode zurückgeben, ähm, das Beispiel ist nicht so gut, weil für diese

558
01:17:00,840 --> 01:17:06,400
Variante ist das mit dem try immer noch besser, weil du kannst das direkt in den if füttern,

559
01:17:06,400 --> 01:17:11,920
weil wie würdest du jetzt mit einem if machen, da müsstest du jetzt den Zwischenwert speichern,

560
01:17:11,920 --> 01:17:17,560
müsstest sagen if b, success, das ist jetzt fast schon go, das ist jetzt, das ist jetzt,

561
01:17:17,560 --> 01:17:25,520
das ist jetzt fast schon go, diese Geschichte hier, ähm, ja, oder aber du würdest sagen

562
01:17:25,520 --> 01:17:31,360
deconstruct, success, result, das ist jetzt richtig go style, du würdest es jetzt so

563
01:17:31,360 --> 01:17:39,040
schreiben, das ist die kürzeste Variante davon, wobei ich halt sagen muss, ganz ehrlich,

564
01:17:39,040 --> 01:17:50,160
die andere finde ich sogar schöner, aber für Methoden, die mehr als einen Rückgabewert

565
01:17:50,160 --> 01:17:56,000
brauchen, ist das echt nützlich, ist aber auch schon ein bisschen älter, ist jetzt

566
01:17:56,000 --> 01:18:10,000
auch nix super, super neues, ich, ich finde, ich finde, ich finde, ich finde es trotzdem

567
01:18:10,000 --> 01:18:23,200
so schöner, ja, also, weiß nicht, das, das finde ich irgendwie besser, als das andere,

568
01:18:23,200 --> 01:18:31,080
ist ein bisschen Geschmackssache, aber nachdem das eher die traditionelle Variante ist und

569
01:18:31,080 --> 01:18:35,600
in dem Fall sogar, finde ich, auch lesbarer ist, würde ich sagen, ich würde das hier

570
01:18:35,600 --> 01:18:40,920
schon immer noch bevorzugen, deswegen, ich sage ja, das mit dem try-on war ein doofes

571
01:18:40,920 --> 01:18:48,200
Beispiel, ja, ähm, mir fällt jetzt kein besseres ein, überall kommt ja auch nicht so oft vor,

572
01:18:48,200 --> 01:18:51,720
dass du mehr als einen Rückgabewert brauchst, aber wenn du mehr als einen Rückgabewert

573
01:18:51,720 --> 01:19:01,360
brauchst, dann ist das ganz sinnvoll, ja, ach ja, die, die, die richtig old school Variante

574
01:19:01,360 --> 01:19:09,040
wäre dann try catch, genau, ja, das ist, das wäre dann, das wäre wirklich die richtige,

575
01:19:09,040 --> 01:19:20,360
die richtige old school Variante, aber das machen wir jetzt nicht, es ist cool, ja, dass

576
01:19:20,360 --> 01:19:26,960
das funktioniert, wozu ich das auch sehr praktisch finde, ist, hat irgendjemand geschrieben,

577
01:19:26,960 --> 01:19:33,680
die benutzen das im Web-App-Umfeld relativ, relativ gerne, ja, also, wo ich das, wo ich

578
01:19:33,680 --> 01:19:39,920
das, wo ich das cool finde, ist, für so Kleinigkeiten, beispielsweise für Dictionary, Dictionary-Einträge

579
01:19:39,920 --> 01:19:50,240
oder so, also, zum Beispiel, man hat jetzt irgendwie einen Dictionary aus, ja, aus String

580
01:19:50,240 --> 01:20:02,240
und, ähm, was weiß ich, noch einen String, ist, ist, ist egal, so, und, jetzt hast du

581
01:20:02,240 --> 01:20:07,400
oftmals das Problem, wenn du multithreaded Sachen machst, ja, keine Ahnung, du, du startest

582
01:20:07,400 --> 01:20:14,640
jetzt, ähm, fünf, fünf Jobs, ja, und du merkst dir halt die Job-ID, äh, in einem Dictionary

583
01:20:14,640 --> 01:20:19,240
und irgendwie, dazu gehöre ich noch irgendwie in eine Klasse oder sowas, so, und jetzt hast

584
01:20:19,240 --> 01:20:23,980
du das Problem, du willst das manchmal cancelen, jetzt müsstest du quasi so eine extra Klasse

585
01:20:23,980 --> 01:20:29,400
machen dafür, du musst jetzt sowas irgendwie, Class, Job, ähm, und da brauchst du dann

586
01:20:29,400 --> 01:20:37,480
hier irgendwie, was weiß ich, String, ID, und dann brauchst du irgendwie noch Cancellation-Token

587
01:20:37,480 --> 01:20:45,320
oder sowas, und, und, und Zeug, ne, dann müsstest du quasi eine extra, extra Klasse für anlegen,

588
01:20:45,320 --> 01:20:51,640
und für so Kleinscheiß, da finde ich, bietet sich das hier mit diesen Name-Tuppeln tatsächlich

589
01:20:51,640 --> 01:20:57,400
sogar an, weil dann könnte man nämlich wirklich sowas hier machen, wie, ähm, Name, und dann

590
01:20:57,400 --> 01:21:02,920
kannst du hier Cancellation-Token, Token sagen, so, und dann hast du das ohne eine extra Klasse

591
01:21:02,920 --> 01:21:07,200
da drin gespeichert, du hast jetzt deine, du hast jetzt deine Background-Job-ID, irgendein

592
01:21:07,200 --> 01:21:13,600
Name und das Token gespeichert, also immer, aber dafür finde ich, finde ich tatsächlich

593
01:21:13,600 --> 01:21:24,800
ganz nützlich, so, so sieht's, so sieht's aus,

594
01:21:24,800 --> 01:21:36,360
was macht, das finde ich übrigens nice, ja, das müssen, Leute, ich finde das eine richtig

595
01:21:36,360 --> 01:21:40,240
gute Sache, ich übersehe ja öfters mal Dinger, ja, also wenn es irgendwelche interessanten

596
01:21:40,240 --> 01:21:44,120
Sachen gibt, die nicht nur einer interessant findet und ich übersehe es, dann könnt,

597
01:21:44,120 --> 01:21:48,480
dann dürft ihr, dürft ihr das hier spammen, das finde ich gut, was macht OUT wahr, ähm,

598
01:21:48,480 --> 01:21:55,240
naja, gut, was soll ich sagen, ja, im Prinzip das, was ich schon gezeigt hab eben, also,

599
01:21:55,240 --> 01:22:02,200
das ist ein OUT-Parameter, also du übergibst quasi eine Variable, wo dann diese Funktion

600
01:22:02,200 --> 01:22:07,200
das Ergebnis reinschreibt, wir können das ja mal kurz decompilen und uns angucken, ich

601
01:22:07,200 --> 01:22:14,440
glaube aber, das wird eklig aussehen, ja, nee, hier, passt doch, ne, OUT-INT-RESULT,

602
01:22:14,440 --> 01:22:25,680
ersetzt quasi hier das RESULT in die Variable, die du ihm übergeben hast, das brauchst du,

603
01:22:25,680 --> 01:22:29,920
weil es gibt halt manchmal den Fall, dass du mehr als eine Sache zurückgeben willst,

604
01:22:29,920 --> 01:22:35,400
der klassische Fall ist halt, du willst gucken, ob was funktioniert hat und hast deswegen

605
01:22:35,400 --> 01:22:41,680
als normalen RETURNWERT TRUE oder FALSE und dann, wenn es funktioniert hat, dann steht

606
01:22:41,680 --> 01:22:54,080
halt hier drin der eigentliche Wert, das ist ein bisschen wie Poynter, ja, genau, im Prinzip,

607
01:22:54,080 --> 01:23:00,400
im Prinzip schon, ja, das ist ein bisschen wie C++ Poynter übergeben und dann da drin

608
01:23:00,400 --> 01:23:05,960
im Poynter was schreiben, ich mein, hey, das, das würde auch alles anders funktionieren,

609
01:23:05,960 --> 01:23:12,480
ich könnte auch irgendwie hier eine Klasse übergeben per REFERENCE und in der Klasse

610
01:23:12,480 --> 01:23:15,400
gibt es dann ein RESULT und dann würde ich es wieder reinschreiben und es würde alles

611
01:23:15,400 --> 01:23:17,600
gehen, aber so ist halt die saubere Variante.

612
01:23:17,600 --> 01:23:29,840
Die alten Videos, ich hab mir ja selbst in den letzten Tagen mal alte Videos vor mir

613
01:23:29,840 --> 01:23:35,160
angeguckt und ich muss sagen, gerade die Videos auf der Xbox, das war schon richtig schlecht

614
01:23:35,160 --> 01:23:42,080
gespielt, aber das lag halt einfach an der Xbox, das ist mir damals, das ist mir damals

615
01:23:42,080 --> 01:23:47,080
nie aufgefallen, wie langsam und träge und behebe ich so Konsolen-Gameplay alles ist.

616
01:23:47,080 --> 01:23:57,600
Echt, das ist echt Wahnsinn, ich hab damals die Leute immer ausgelacht vom PC, die gesagt

617
01:23:57,600 --> 01:24:04,800
haben so nach dem Motto, guck mal, kannst du überhaupt nicht vergleichen.

618
01:24:04,800 --> 01:24:11,320
Es ist halt schon, ehrlich gesagt finde ich Konsolen-Gameplay von damals eklig anzugucken.

619
01:24:11,320 --> 01:24:20,120
Mittlerweile sieht es ein bisschen anders aus, man muss sagen, die meisten Warzone-Streamer

620
01:24:20,120 --> 01:24:27,920
spielen ja PS4 oder PS5, gibt es jetzt schon für die PS5 und wie gut die mittlerweile

621
01:24:27,920 --> 01:24:32,720
Controller-Aim-technisch sind, ist echt krass, also da erkennst du ja erst auf den zweiten

622
01:24:32,720 --> 01:24:38,840
Blick, dass es mit dem Controller gespielt ist, meistens am restlichen Movement, allerdings

623
01:24:38,840 --> 01:24:44,840
muss man auch sagen, Warzone hat halt auch auf der Konsole brutal dieses Ames ist, aber

624
01:24:44,840 --> 01:24:52,440
trotzdem, also die sind halt deutlich besser als ich damals auf der Xbox war, aber PC Master

625
01:24:52,440 --> 01:24:58,320
Race wissen wir, beste, ja, so, also jetzt haben wir uns das hier angeguckt, lass mal

626
01:24:58,320 --> 01:25:06,720
schauen, was gibt es denn sonst noch für neue Features?

627
01:25:06,720 --> 01:25:11,240
Wir brauchen einen Command für Streamer, hat eine, das ist eine gute Idee, das würde

628
01:25:11,240 --> 01:25:16,360
ich irgendeinem Mod überlassen, der gerade da ist, falls einer da ist, wenn nicht können

629
01:25:16,360 --> 01:25:17,960
wir uns das im Nachhinein noch überlegen.

630
01:25:17,960 --> 01:25:30,280
Ach ja, Henggin, du hast recht, es gibt noch ein neues Feature, für alle die sich gedacht

631
01:25:30,280 --> 01:25:37,440
haben, in C Sharp steckt zu wenig C++, man kann jetzt die gleiche Scheiße machen wie

632
01:25:37,440 --> 01:25:44,320
in C++, es gibt jetzt nämlich eine neue Klasse Native Memory und da kann man jetzt so Sachen

633
01:25:44,320 --> 01:25:57,720
drinne machen, das, ich weiß nicht genau wann man das machen will, aber das geht jetzt,

634
01:25:57,720 --> 01:26:02,560
doch mir fällt tatsächlich was ein, wozu man das machen will, doch, doch, mir fällt

635
01:26:02,560 --> 01:26:09,640
tatsächlich was ein, mir fällt tatsächlich was ein, allerdings nur der umgedrehte Fall,

636
01:26:09,640 --> 01:26:14,920
zum Beispiel, zum Beispiel ja, man hat irgendeine Native Funktion, von der man irgendeinen

637
01:26:14,920 --> 01:26:21,160
String zurückbekommt, den muss man ja von Hand freen und dafür, dafür stelle ich mir

638
01:26:21,160 --> 01:26:28,400
das sinnvoll vor, hier irgendwas, Native Function, das ist ja nicht String, das ist Character

639
01:26:28,400 --> 01:26:34,920
Pointer, Return und das würde ich dann freen, so, das, das könnte ich mir tatsächlich

640
01:26:34,920 --> 01:26:43,520
vorstellen, dass das dafür sinnvoll ist, allerdings der umgedrehte Fall, wann ich hier

641
01:26:43,520 --> 01:26:53,720
sowas allokaten will, tja, vielleicht wenn ich viel Interop mache mit Native Geschichten,

642
01:26:53,720 --> 01:26:58,960
aber selbst da, aber selbst da, selbst da braucht man das eigentlich gar nicht mehr,

643
01:26:58,960 --> 01:27:07,720
weil es gibt ja jetzt schon seit einer Weile Span, wo ich dann sagen kann, kann er Span

644
01:27:07,720 --> 01:27:19,560
bite, dann kann ich sagen To, ne, wie ging das mit dem Pointer, ach ne, Moment, das ging

645
01:27:19,560 --> 01:27:25,560
gar nicht To Pointer, das war nur der umgedrehte Fall, ach ne, das war der umgedrehte Fall,

646
01:27:25,560 --> 01:27:31,000
wenn es für Pointer zu Managed Typ, ach ja, ne, ne, dann, dann habe ich es jetzt falsch

647
01:27:31,000 --> 01:27:35,800
im Kopf gehabt, tja, ne, also, dann fällt mir jetzt da gar nicht wirklich viel dazu

648
01:27:35,800 --> 01:27:45,040
ein, aber das funktioniert jetzt, man kann jetzt richtig den, den Oldschool Direct Memory

649
01:27:45,040 --> 01:27:59,040
Gedöns machen hier, wann auch immer man das braucht, wann wahrscheinlich weiß man es

650
01:27:59,040 --> 01:28:04,680
erst, wenn man es braucht, dass man es braucht, also mir fällt jetzt nichts Gescheites ein,

651
01:28:04,680 --> 01:28:08,600
aber das ist jetzt auch neu, ja, tatsächlich, das ist ein neues Dotnet 6 Feature, ach ja

652
01:28:08,600 --> 01:28:17,120
und das Gute ist, die haben das ja mit bisschen Brain gemacht, das ist quasi Infrastructure

653
01:28:17,120 --> 01:28:22,080
Aware, also sprich das ruft unter Linux die richtigen Sachen auf und unter Windows die

654
01:28:22,080 --> 01:28:25,360
richtigen Sachen auf und guckt glaube ich dann auch Speicherarchitektur mäßig für

655
01:28:25,360 --> 01:28:31,800
irgendwie, dass es an bald Grenzen aligned wird und sowas, also das haben sie schon gescheit

656
01:28:31,800 --> 01:28:41,760
gemacht, wann ich es benutzen würde, also außer jetzt mit diesem hier Free in a Native Character

657
01:28:41,760 --> 01:28:47,040
Array oder so, ich wüsste es nicht, keine Ahnung, ja vielleicht das stimmt, weil man

658
01:28:47,040 --> 01:28:51,920
vielleicht irgendwie High Performance Sachen haben will, der umgedrehte Fall wie gesagt

659
01:28:51,920 --> 01:28:57,520
den kann man mit Span abdecken, also wenn ich jetzt zum Beispiel mal hier unsave, sagen

660
01:28:57,520 --> 01:29:01,840
wir mal ich hätte hier irgendwie einen Character Array drinnen, ich muss erstmal unsave code

661
01:29:01,840 --> 01:29:19,040
erlauben, also gehen wir mal davon aus, wie lege ich denn sowas überhaupt an, kann ich

662
01:29:19,040 --> 01:29:27,480
sowas hier machen, null, furchtbar safe, furchtbar safe, ja, aber was ich machen kann mit Span

663
01:29:27,480 --> 01:29:41,520
ist ja, ich kann quasi Native Memory zu Managed Memory machen, also wenn ich jetzt zum Beispiel

664
01:29:41,520 --> 01:29:49,160
von irgendeiner C Funktion oder sonst wie ein Int Array zurück bekomme und möchte

665
01:29:49,160 --> 01:29:55,640
das gescheit Managed verwalten, dann kann ich das zum Beispiel mit Span machen, ich

666
01:29:55,640 --> 01:30:05,200
kann auch einen Array draus machen oder sowas, also das ist der umgedrehte Fall, vielleicht

667
01:30:05,200 --> 01:30:13,480
braucht man das wirklich für, ich möchte dem was übergeben oder so, keine Ahnung,

668
01:30:13,480 --> 01:30:27,440
das geht aber, das hier geht schon eine Weile, was ist Span, so eine, wie soll man sagen,

669
01:30:27,440 --> 01:30:31,800
Collection für Speicher, wie kann man das am besten umschreiben, du hast Span und du

670
01:30:31,800 --> 01:30:39,560
hast Memory, das sind beides so Low Level Dinger, ich würde sagen das ist so eine Art Collection

671
01:30:39,560 --> 01:30:45,360
über rohen Arbeitsspeicher, so könnte man das glaube ich mit am besten beschreiben,

672
01:30:45,360 --> 01:30:49,280
weil du kannst dann auch sowas machen wie Slice und sowas, du kannst dann quasi Arrays

673
01:30:49,280 --> 01:30:57,440
bauen, du kannst dann quasi sagen Speicher 100 Bites in Folge und dann kannst du das

674
01:30:57,440 --> 01:31:01,120
auch slicing und sowas, dass du sagst, hey ich mach jetzt einen Array aus den ersten

675
01:31:01,120 --> 01:31:15,200
20 Elementen und einen Managed Array aus den nächsten 30 Elementen und dann hast du das

676
01:31:15,200 --> 01:31:21,440
halt, ist das ein High Level Bite Array, ne, das ist für Sachen gedacht, die du beispielsweise

677
01:31:21,440 --> 01:31:34,960
von unmanaged Sachen bekommst, dass du sie besser handeln kannst, man braucht das nicht

678
01:31:34,960 --> 01:31:46,560
wirklich oft, es hat den Vorteil, du kannst dann, du kannst dann so Sachen machen wie

679
01:31:46,560 --> 01:31:53,600
zum Beispiel, keine Ahnung, du bekommst jetzt irgendwie einen Struct oder so von irgendeinem

680
01:31:53,600 --> 01:31:59,320
unmanaged Ding und dann Pointer, Pointer auf irgendeinem Arbeitsspeicherbereich, wo

681
01:31:59,320 --> 01:32:07,400
irgendwie Daten drin liegen, da kannst du zum Beispiel, ok Slice, also 0, Bite 0 bis

682
01:32:07,400 --> 01:32:14,120
Bite 5 ist eine Sache, dann ist es irgendwie keine Ahnung, dann überspring ich 2, Bite

683
01:32:14,120 --> 01:32:21,720
8 bis Bite 20 ist eine andere Sache und keine Ahnung, das ist irgendwie B und das ist,

684
01:32:21,720 --> 01:32:29,960
so und dann, also B gibt es schon, oder kannst du dann damit Dinge machen, du kannst dann

685
01:32:29,960 --> 01:32:35,080
zum Beispiel ein richtiges echtes Managed Array draus machen, man kann das bestimmt

686
01:32:35,080 --> 01:32:39,880
auch irgendwie dann als Int oder sonst was interpretieren oder sonst wie, das braucht

687
01:32:39,880 --> 01:32:46,600
man erst, wenn man weiß, dass man es braucht, ist das wie ein Buffer in Javascript, aber

688
01:32:46,600 --> 01:32:55,160
im Endeffekt schon, da gibt es ja auch immer noch Stack, Stackalloc gibt es ja auch noch,

689
01:32:55,160 --> 01:33:01,240
für quasi Managed Memory anlegen, da bin ich mir jetzt aber gar nicht sicher, wie die

690
01:33:01,240 --> 01:33:13,960
Syntax ist, so oder, ja, da kannst du direkt, kannst du auch Speicher anlegen lassen, Alter,

691
01:33:13,960 --> 01:33:17,760
was auch immer, also wir reden hier wirklich über Sachen, die verwendest du irgendwie

692
01:33:17,760 --> 01:33:23,800
alle, was weiß ich, alle Monate einmal oder so, das ist nichts, was ist irgendwie häufig,

693
01:33:23,800 --> 01:33:32,880
was man irgendwie häufig braucht, ist bei dir heute Feiertag, nö, ich habe Montags

694
01:33:32,880 --> 01:33:38,960
immer frei, ich habe mal Systemintegration gelernt, 2007 ist schon ein bisschen her,

695
01:33:38,960 --> 01:34:07,320
hast du die neuen Timer bereits gezeigt, ne, die kenne ich noch gar nicht.

696
01:34:07,320 --> 01:34:21,200
Wo gibt es neue Timer, da, von denen habe ich ja nichts gesehen, neue Timer, gibt es

697
01:34:21,200 --> 01:34:29,760
neue Timer, ne, das kenne ich noch nicht, vielleicht kommen wir jetzt dahin, so, also

698
01:34:29,760 --> 01:34:33,640
ich glaube, diese Sachen haben wir hier durch, also das waren eigentlich schon alle neuen

699
01:34:33,640 --> 01:34:37,000
C Sharp 10 Features, das heißt, es hält sich deutlich in Grenzen, was es diesmal gibt,

700
01:34:37,000 --> 01:34:44,440
aber wie man es von Microsoft kennt, zumindest was die Sharp angeht, das meiste sinnvolle

701
01:34:44,440 --> 01:34:47,480
und angenehme, halt neue Sachen integriert.

702
01:34:47,480 --> 01:34:57,920
Wir machen Weihnachtsmorz frühestens am ersten Advent, jetzt brauchen wir glaube ich noch

703
01:34:57,920 --> 01:35:07,880
keine, auf dem Discord sind die schon, ja, auf dem Discord sind die das ganze Jahr über,

704
01:35:07,880 --> 01:35:13,240
das waren wir am ersten Advent oder so, dann, die waren nie weg, genau, so, also jetzt gucken

705
01:35:13,240 --> 01:35:19,600
wir uns das nächste an, 6, nein,.NET 6 Link Improvements, nicht 6 Link Improvements,.NET

706
01:35:19,600 --> 01:35:23,720
6 Link Improvements, wie lange wird denn.NET noch weiterentwickelt?

707
01:35:23,720 --> 01:35:35,880
Ach so meinst du das, gar nicht, also.NET, nein, Moment, ok, ok, langsam, die Microsoft

708
01:35:35,880 --> 01:35:49,840
Benamung ist wieder absoluter Pains Champ, also die Microsoft Benamung ist wirklich,

709
01:35:49,840 --> 01:36:01,640
also um es mal ganz kurz zu sagen,.NET gibt es in 3 verschiedenen Ausführungen, ich lasse

710
01:36:01,640 --> 01:36:11,400
mal Mono und so weg, die Microsoft Geschichten, es gibt.NET Framework, das ist das alte,

711
01:36:11,400 --> 01:36:20,080
das ist das was für Windows ausgeliefert wird, es gibt.NET Core, das ist das neue,

712
01:36:20,080 --> 01:36:26,560
jetzt hat sich Microsoft gedacht, scheiß drauf, wir nennen.NET Core ab.NET 5 nur noch.NET

713
01:36:26,560 --> 01:36:36,400
und lassen das Core weg, also.NET 4 gab es übrigens nicht, es gab.NET Framework 4.8,

714
01:36:36,400 --> 01:36:43,120
also es gab.NET Framework 4.8, dann hat man.NET Core gemacht,.NET Core gab es dann als

715
01:36:43,120 --> 01:36:54,360
1.0, 1.1, 2.2.1 und 3.0.3.1 oder sowas, so und nach.NET Core 3.1 hat man gesagt,

716
01:36:54,360 --> 01:37:02,160
man macht jetzt kein.NET Core 4, sondern man macht jetzt.NET 5, also.NET 5 ist quasi

717
01:37:02,160 --> 01:37:10,520
.NET Core 4 und.NET 6 ist quasi dann die Weiterentwicklung von.NET 5, was die Weiterentwicklung

718
01:37:10,520 --> 01:37:29,960
von.NET Core 3.1 ist, mal gucken, ob es da schönes Bildchen für gibt, nein, hier,

719
01:37:29,960 --> 01:37:40,880
ja, hier, das ist eine ganz gute, das ist eigentlich ein ganz gutes Bild, ne, das Bild

720
01:37:40,880 --> 01:37:53,760
sagt auch, ne, die Bilder sind alle kacke, ja, hier, so war es hier, ja, das ist ganz

721
01:37:53,760 --> 01:38:01,720
gut, also wie gesagt,.NET Core 5 heißt nicht.NET Core 5, sondern.NET 5, Microsoft hat

722
01:38:01,720 --> 01:38:10,240
mal wieder Microsoft gemacht, dann hast du.NET Framework und.NET Standard, ja, das

723
01:38:10,240 --> 01:38:16,600
sind aber auch zwei verschiedene Sachen,.NET Framework ist die alte.NET Runtime, also

724
01:38:16,600 --> 01:38:23,120
die alte.NET Implementierung von Microsoft,.NET Standard ist quasi sowas abstraktes,

725
01:38:23,120 --> 01:38:32,040
wo Microsoft definiert hat, jegliche.NET Runtime, egal, ob es Mono ist,.NET Framework,

726
01:38:32,040 --> 01:38:42,160
.NET Core, was auch immer, die quasi alles in einem.NET Standard spezifizierten unterstützt,

727
01:38:42,160 --> 01:38:46,600
kann dann Projekte laufen lassen, die eben diesen.NET Standard als Target haben, es

728
01:38:46,600 --> 01:38:55,160
ist mega für den Arsch, es ist wir, also wirklich wir hoch 10, aber das einfachste, was man

729
01:38:55,160 --> 01:39:02,560
sich merken kann ist, einfach alles vergessen, außer.NET 5 und.NET 6, also alles was nicht

730
01:39:02,560 --> 01:39:12,360
.NET 5 oder.NET 6 ist, ist alt, muss man sich keine Gedanken drüber machen, außer

731
01:39:12,360 --> 01:39:19,560
man hat irgendwelche Legacy Anwendungen oder so, also alles wo irgendwas hinter.NET steht,

732
01:39:19,560 --> 01:39:30,600
außer eine Zahl ist, vergesst einfach, ach guck mal, ist das, also hat der ein Bild,

733
01:39:30,600 --> 01:39:39,360
oh ja, das ist gut,.Knu Portable, ach du Scheiße, die haben sich da auch mal dran versucht

734
01:39:39,360 --> 01:39:46,720
oder was, das war mir noch gar nicht bewusst, dass das auch mal, dass die das auch mal versucht

735
01:39:46,720 --> 01:39:47,720
haben.

736
01:39:47,720 --> 01:40:05,520
Tja, man sieht es gibt einige.NET Frameworks,.NET Runtimes, aber hier steht, aber hier

737
01:40:05,520 --> 01:40:11,520
steht.NET 5 gar nicht drinnen, ah das ist auch von 2018, da gab es ja.NET 5 noch nicht,

738
01:40:11,520 --> 01:40:15,760
ja diesen ganzen Shit hat Microsoft jetzt gesagt, haben wir keinen Bock mehr drauf und

739
01:40:15,760 --> 01:40:22,880
hat gesagt wir machen.NET 5, oh Silverlight, fuck das habe ich ganz vergessen, Silverlight

740
01:40:22,880 --> 01:40:33,320
gab es ja auch mal, weiß ich noch nicht, sobald es irgendeinen sinnvollen Grund gibt auf Windows

741
01:40:33,320 --> 01:40:46,200
zu upgraden, sobald man, sobald man die Gruppierung hier unten ausschalten kann, also das ist

742
01:40:46,200 --> 01:40:56,840
wirklich grausam, Silverlight, alter Silverlight, hör mal bloß auf, Microsoft hat es ja selbst

743
01:40:56,840 --> 01:41:07,920
abgesägt nach irgendwie zwei Jahren oder so, okay, also wer heute noch Silverlight Anwendungen

744
01:41:07,920 --> 01:41:11,960
betreuen muss, der tut mir echt leid, weil es gibt ja quasi gar keine Browser Plugins

745
01:41:11,960 --> 01:41:16,400
mehr so richtig für Silverlight, da brauchst du auch einen alten Browser oder man verwendet

746
01:41:16,400 --> 01:41:20,280
irgendeinen Desktop Runtime, wobei wenn man das auf dem Desktop laufen lässt, hätte man

747
01:41:20,280 --> 01:41:25,280
das damals auch gleich in WPF machen können, weil Silverlight war ja quasi ein Subset von

748
01:41:25,280 --> 01:41:33,120
WPF, ich versuche es gar nicht nachzuvollziehen, was da Microsoft treibt, okay wir gucken uns

749
01:41:33,120 --> 01:41:46,920
jetzt Link Improvements an, also was gibt es jetzt Neues,.NET 6 Link Improvements, indexing

750
01:41:46,920 --> 01:41:55,720
operations on IEnumerable, das klingt ja schon wieder richtig big brain, oh das ist cool,

751
01:41:55,720 --> 01:42:02,560
das ist wirklich gut, dass das jetzt funktioniert, die unterstützen endlich Range Syntax für

752
01:42:02,560 --> 01:42:09,040
ihre Link Geschichten, das ist cool, das müssen wir gleich mal ausprobieren, ich werde den

753
01:42:09,040 --> 01:42:14,920
ganzen Krempel schon mal hier kurz auskommentieren, aber das ist wirklich cool, legen wir mal

754
01:42:14,920 --> 01:42:26,080
irgendwie eine Liste an, view list aus int, list add 1, wobei haha wir können ja auch

755
01:42:26,080 --> 01:42:38,880
den, nein, ich dachte der kann das in List Initializer irgendwie umbauen, also wir haben

756
01:42:38,880 --> 01:42:45,600
eine Liste mit 6 Elementen drinnen und was man jetzt machen kann ist mit Link anscheinend

757
01:42:45,600 --> 01:42:50,000
Range Syntax verwenden, das ist natürlich sehr nice, also kann ich jetzt zum Beispiel

758
01:42:50,000 --> 01:42:58,560
sagen, was ist Take und dann was, vom ersten Element bis zum fünften Element oder so,

759
01:42:58,560 --> 01:43:12,040
ja das ist cool, das finde ich sehr nice, dass das jetzt funktioniert, das ist tatsächlich

760
01:43:12,040 --> 01:43:18,920
sehr nützlich, dass das jetzt funktioniert, also das ist die Range Syntax, die gibt es

761
01:43:18,920 --> 01:43:26,120
ja schon eine Weile, Take gab es schon, aber die Range Syntax in Take gab es nicht, du

762
01:43:26,120 --> 01:43:32,760
konntest sagen Take 5, was dann im Prinzip, was hat er jetzt für Schmerzen, ja Take 5,

763
01:43:32,760 --> 01:43:39,200
was dann im Prinzip heißt wie nehme die ersten 5 Elemente, wenn ich jetzt aber sage Take

764
01:43:39,200 --> 01:43:48,320
Range 1 bis 5 oder Take Range 2 bis 5, dann nimmt er das zweite Element bis zum fünften

765
01:43:48,320 --> 01:43:57,880
Element, also das hier, das ist tatsächlich sehr nice, können wir mal ausprobieren,

766
01:43:57,880 --> 01:44:11,680
können wir ausprobieren was da rauskommt, 3 für 5, ah ok das ist nicht inclusive, Anzeige

767
01:44:11,680 --> 01:44:22,760
ist raus, das heißt alles ab dem zweiten dann, oder ist das mit Null Index, ah das ist Null

768
01:44:22,760 --> 01:44:33,080
Index ok, dann ergibt das Sinn, Null 1 2, dann ergibt das Sinn, das ist quasi Skip

769
01:44:33,080 --> 01:44:37,960
und dann Take, also Range Syntax ist eh eine coole Geschichte, zum Beispiel, wusstet ihr

770
01:44:37,960 --> 01:44:42,840
das Range, das Range Syntax, kannste doch sagen, wir haben hier irgendwie String, ein

771
01:44:42,840 --> 01:44:52,040
String aus blub, keqw, lulw, was auch immer, wenn ich das jetzt ausgeben will, kann ich

772
01:44:52,040 --> 01:45:01,880
jetzt auch sagen, ich möchte nur ab dem fünften Element bis zum zehnten Element ausgeben

773
01:45:01,880 --> 01:45:09,600
und dann kriege ich hier keqw raus, weil, ne, fünftes Element, 1 2 3 4 5 6 7 8 10, dann

774
01:45:09,600 --> 01:45:24,000
bis dahin, also 1 1 2 Null 1 2 3 4 5 6 7 8 9 10, das hier ist zehntes Element, ja genau,

775
01:45:24,000 --> 01:45:31,480
es geht auch umgedreht, das geht auch, ja das funktioniert auch, ich glaube aber vorletztes

776
01:45:31,480 --> 01:45:38,440
ist in dem Fall dann sogar 2 von hinten mit dem Index, ne, tatsächlich 1, ach, keine Ahnung,

777
01:45:38,440 --> 01:45:43,520
ja, also die Range Syntax gibt es schon eine Weile, die haben ein bisschen, finde ich ein

778
01:45:43,520 --> 01:45:50,640
bisschen, ist so an die Paissen Range Syntax angelehnt, ist sehr praktisch und anscheinend

779
01:45:50,640 --> 01:45:57,520
geht die jetzt auch in Link, geht auch 1, das ist eine gute Frage, du meinst, dass es

780
01:45:57,520 --> 01:46:07,080
dann von hinten nach vorne geht, ne, das funktioniert nicht, geht das auch auf den Inhalt des Arrays

781
01:46:07,080 --> 01:46:17,080
oder nur auf den Index, äh, es geht nur auf den Index, wie willst du das denn auf den

782
01:46:17,080 --> 01:46:23,560
Inhalt machen, also was du machen könntest, also was funktionieren würde ist, das geht

783
01:46:23,560 --> 01:46:27,800
mit Variante, klar, also was funktionieren würde ist folgendes, mal angenommen, du hast

784
01:46:27,800 --> 01:46:38,760
jetzt hier einen String, äh, String Liste, oh, irgendwie keine Ahnung, ABC, EF, oh, reicht

785
01:46:38,760 --> 01:46:43,960
jetzt schon als Beispiel, was du machen könntest, select zum Beispiel, kannst sagen select,

786
01:46:43,960 --> 01:46:55,080
äh, jedes Element, äh, von der Liste und darauf könntest du jetzt sagen, zum Beispiel,

787
01:46:55,080 --> 01:47:12,000
nimm den, was weiß ich, den, hier, das, das würde funktionieren, dann kannst du das auf

788
01:47:12,000 --> 01:47:22,040
jedes Element anwenden, das, das funktioniert, und jetzt, hallo, na, das würde funktionieren,

789
01:47:22,040 --> 01:47:25,320
also er nimmt jetzt quasi immer in dem Fall das zweite Element, also wir könnten auch

790
01:47:25,320 --> 01:47:31,400
sagen, hier, machs mal bis 3, also bis zum dritten, was dann das Ende ist, jetzt hast

791
01:47:31,400 --> 01:47:41,520
du quasi aus jedem Element quasi von Position 1 bis Position 3, wo dann halt hier fertig,

792
01:47:41,520 --> 01:47:47,600
also 4, weil es ab Null anfängt, nimmt er das dann, ja, das funktioniert, so kannst

793
01:47:47,600 --> 01:48:00,000
du das auch auf die Elemente anwenden, innen drinnen, du hast eine Liste mit IDs, du möchtest

794
01:48:00,000 --> 01:48:08,840
alle IDs haben, die zwischen X und Y liegen, äh, das, das würdest du anders machen, also

795
01:48:08,840 --> 01:48:12,280
wenn du eine Liste hast, was weiß ich, 1, 2, 3, 4, 5, 6, 7, 8, 9, so, und du willst jetzt

796
01:48:12,280 --> 01:48:17,560
alle ID, was hab ich falsch gemacht, ach so, int, ähm, ich mach das hier mal wieder weg,

797
01:48:17,560 --> 01:48:21,960
also wenn du jetzt alle IDs haben willst, die zwischen, keine Ahnung, die größer als

798
01:48:21,960 --> 01:48:27,720
4 sind, das ist dann relativ einfach, da würdest du, da würdest du hier innen drinnen sagen,

799
01:48:27,720 --> 01:48:32,520
keine Ahnung, E ist größer als 5, so, und jetzt kriegst du alles, was größer als 5

800
01:48:32,520 --> 01:48:58,560
ist, was, Pool, hä, ah, haha, ja, was kann ich sagen, what the fuck, das würdest du so

801
01:48:58,560 --> 01:49:11,120
machen, genau, ja, 6, 7, 8, 9, das ist der Chat, der Chat wusste es wieder, haben genug

802
01:49:11,120 --> 01:49:24,720
Leute subscribt, IQ ist hoch genug, da können wir sowas abfangen, gut, ja, so, so würdest

803
01:49:24,720 --> 01:49:28,680
du mal, du kannst natürlich umgedreht auch sagen, da können wir jetzt übrigens neues,

804
01:49:28,680 --> 01:49:32,600
neues Feature fangen, du kannst natürlich auch umgedreht sagen, keine Ahnung, E größer

805
01:49:32,600 --> 01:49:37,760
als 5 und E kleiner als 9, so, da würdest du jetzt quasi, da würdest du jetzt 6, 7,

806
01:49:37,760 --> 01:49:41,400
8 rauskriegen, allerdings kann man das jetzt anders schreiben, und ich glaube, das schlägt

807
01:49:41,400 --> 01:49:46,480
dir vielleicht Ryder sogar vor, du kannst jetzt sowas hier schreiben, E ist größer

808
01:49:46,480 --> 01:49:54,680
als 5 und kleiner als 9, das ist die Chat 9 Feature glaube ich, ist im Prinzip das gleiche,

809
01:49:54,680 --> 01:50:00,080
da kann man sich jetzt darüber streiten, was lesbarer ist, in dem Fall, ganz ehrlich,

810
01:50:00,080 --> 01:50:05,720
in dem Fall macht es von der Länge her noch nicht mal einen großen Unterschied, aber

811
01:50:05,720 --> 01:50:09,360
spätestens, wenn du noch ein paar Sachen hinten dran machst, dann, dann vielleicht

812
01:50:09,360 --> 01:50:19,800
schon, ja, also, ich wette mit euch, Python Entwickler würden sagen, das hier ist viel

813
01:50:19,800 --> 01:50:27,760
nicer und, ja, Oldschool C Sharp Leute oder C Leute würden sagen, das hier ist nicer,

814
01:50:27,760 --> 01:50:39,680
oder der Haube macht es das gleiche, Patrick, das stimmt, ich habe, wir müssen aber noch

815
01:50:39,680 --> 01:50:45,000
rausbekommen, was die äußeren Umstände sind, die das beeinflussen, also, ich könnte mir

816
01:50:45,000 --> 01:50:50,720
vorstellen, es liegt an der Anwesenheit mancher Personen im Chat, ob der IQ hoch oder runter

817
01:50:50,720 --> 01:51:02,720
geht, und je nachdem, wieviel die spammen, also, das ist übrigens jetzt, by the way,

818
01:51:02,720 --> 01:51:08,240
absolut nichts C Sharp 10 typisches hier, also, Neues, das geht schon ewig, das geht

819
01:51:08,240 --> 01:51:19,360
seit 10 Jahren oder so schon, aber so würde man das beispielsweise filtern, ach ja, und

820
01:51:19,360 --> 01:51:30,200
noch was, weil anscheinend viele Leute so Link-Dinger nicht oft gesehen haben, was man

821
01:51:30,200 --> 01:51:37,000
jetzt auch machen kann ist, man kann das nacheinander, also, man kann das chainen, also sprich, ich

822
01:51:37,000 --> 01:51:41,120
kann jetzt erstmal alles filtern, was zwischen, wir machen jetzt mal, dass wenigstens C Sharp

823
01:51:41,120 --> 01:51:47,440
10 im Titel stimmt, oder wenigstens 9, so, du kannst alles filtern, wo e, also, die Elemente

824
01:51:47,440 --> 01:51:53,480
größer als 5, kleiner als 9 sind, und danach kannst du sagen, ok, jetzt habe ich die Elemente

825
01:51:53,480 --> 01:51:58,600
gefiltert, und jetzt, nachdem ich die Elemente gefiltert habe, will ich damit irgendwas

826
01:51:58,600 --> 01:52:07,320
machen, ja, zum Beispiel, plus 1 rechnen, und jetzt sieht man, jetzt ist es auf einmal

827
01:52:07,320 --> 01:52:13,000
7 macht 9, was ja eigentlich keinen Sinn ergibt, weil es sollte eigentlich 6, 7 und 8 sein,

828
01:52:13,000 --> 01:52:19,800
oder wir machen ja plus 10, dann ist es glaube ich besser zu erkennen, ja, 16, 17, 18 ist

829
01:52:19,800 --> 01:52:28,320
es jetzt, ja, für Link gibt es mehrere Schreibweisen, das ist so diese, dass so diese Methoden-Chains

830
01:52:28,320 --> 01:52:33,880
Schreibweise, es gibt auch noch die klassische SQL Style Schreibweise, also ich kann auch

831
01:52:33,880 --> 01:52:38,480
sowas sagen, wobei ich die selten verwende, muss ich ehrlich sagen, du kannst sowas sagen,

832
01:52:38,480 --> 01:52:55,840
wie hier keiner, Result gleich, from i in lists, where, where i größer 5 und i kleiner

833
01:52:55,840 --> 01:53:10,720
9, ne, ne, ne, ach du Scheiße, wie geht das jetzt, was habe ich jetzt falsch vergessen,

834
01:53:10,720 --> 01:53:29,360
unexpected token, warum, select i, ja, funktioniert doch, oder i, eigentlich müsste es select

835
01:53:29,360 --> 01:53:34,320
i plus 10, also das ist das gleiche, das ist das gleiche, das hier und das hier, ne, also

836
01:53:34,320 --> 01:53:48,640
hier das, ehrlich gesagt, ich verwende das so gut wie nie, ja, wenn du mehr als zwei Sequenzen

837
01:53:48,640 --> 01:53:53,480
hast und die irgendwie miteinander verheiraten willst, dann ist es natürlich sinnvoll, weil

838
01:53:53,480 --> 01:53:57,440
man kann das auch mehrfach, also man kann auch mehrere Sachen da drinnen machen, ne,

839
01:53:57,440 --> 01:54:04,920
zum Beispiel Lista, das ist Lista 1, Lista 2, du kannst dann auch sagen, keine Ahnung,

840
01:54:04,920 --> 01:54:16,720
from, wir nennen das mal i1, from i2 in List 2, da kannst du das miteinander dann irgendwie

841
01:54:16,720 --> 01:54:24,840
joinen, also sprich, dass du dann sagst, hier, where, das, das und keine Ahnung, und i1

842
01:54:24,840 --> 01:54:34,240
und gleich i2 oder so komische Dinger, aber ganz ehrlich, ich benutze es selten, ja, im

843
01:54:34,240 --> 01:54:39,600
Zusammenhang mit Entity Framework oder Datenbankzeug ist es natürlich sehr nice, man sollte vielleicht

844
01:54:39,600 --> 01:54:49,360
aber an der Stelle noch eins dazu sagen, oh, wir haben Massive Nightbot Commandos exquisite,

845
01:54:49,360 --> 01:55:02,680
huge Big Brain Bots wieder, was muss man, was wollte ich jetzt sagen, genau, aber man muss,

846
01:55:02,680 --> 01:55:09,640
man muss da eine Sache dazu sagen, das kann durchaus recht langsam sein, wenn man nicht

847
01:55:09,640 --> 01:55:19,840
darauf aufpasst, weil Link durchläuft eigentlich so gut wie immer die komplette Liste bei fast

848
01:55:19,840 --> 01:55:27,440
allem, das heißt, wenn man da nicht aufpasst und macht da ganz oft Links mit vielen verschachtelten

849
01:55:27,440 --> 01:55:34,080
Dingern, dann ist das durchaus möglich, dass man das mit zwei Schleifen und einem if viel

850
01:55:34,080 --> 01:55:40,760
schneller hinbekommt als mit einem schönen Link Query, muss man ein bisschen darauf achten,

851
01:55:40,760 --> 01:55:53,440
ja, hat aber auch mit C Sharp 10 nichts zu tun bis auf das hier, das ist zumindest schon

852
01:55:53,440 --> 01:56:04,760
C Sharp 9, gut, also da hätten wir uns das angeguckt, man kann jetzt Range Operators

853
01:56:04,760 --> 01:56:13,240
verwenden in Link, das finde ich gut, ich hätte ehrlich gesagt gedacht, das ist schon

854
01:56:13,240 --> 01:56:36,960
so, aber anscheinend nicht, das ist JetBrains, ja, das ist JetBrains Rider, so, was gibt

855
01:56:36,960 --> 01:56:41,520
es dann sonst noch so, Counting Operations und ach ja, Counting ist auch so ein Ding,

856
01:56:41,520 --> 01:56:50,400
wo man das wirklich ziemlich schnell, ziemlich langsam machen kann, zum Beispiel, das geht

857
01:56:50,400 --> 01:56:53,840
mir mal voll auf den Sack, dass ich hier kein CW verwenden kann, wenn ich jetzt sowas

858
01:56:53,840 --> 01:57:00,160
hier mache und danach sage ich List Count, den da muss ich nehmen, der läuft beides mal

859
01:57:00,160 --> 01:57:04,640
die komplette Liste durch, also das ist so ein Fall, wo man halt darauf achten muss,

860
01:57:04,640 --> 01:57:11,320
ob es das nicht unnütz langsam macht, hier läuft er einmal die komplette Liste durch

861
01:57:11,320 --> 01:57:28,120
und zum zählen läuft er die komplette Liste durch, so und anscheinend gibt es da jetzt

862
01:57:28,120 --> 01:57:37,160
irgendetwas Neues, wenn ich das jetzt richtig hier erkannt habe, Counting Operations on IEnumerable,

863
01:57:37,160 --> 01:57:46,080
wenn man Count aufruft, dann läuft das komplette Ding durch, was für ein Ding, try get non-enumerated

864
01:57:46,080 --> 01:57:54,880
Count, MonkaS, was hat Microsoft da wieder getrieben, List, try, ok, ok, das müssen

865
01:57:54,880 --> 01:58:02,920
wir uns jetzt überlegen, was, was macht da, Attempts to determine just the number of elements

866
01:58:02,920 --> 01:58:14,400
in a sequence without forcing, ah, ok, das ist natürlich clever, das ist, das ist natürlich

867
01:58:14,400 --> 01:58:23,840
clever, also, wenn ich hiermit, wenn ich hiermit, ich wusste das übrigens, dass mein Beispiel

868
01:58:23,840 --> 01:58:32,800
funktioniert, darf ich da keine Liste draus machen, so, wenn ich hiermit zähle, dann muss

869
01:58:32,800 --> 01:58:40,440
der komplett einmal die Liste durchlaufen, um das zu zählen, also der nimmt dann erstes

870
01:58:40,440 --> 01:58:43,640
Element, zweites Element, drittes, viertes, fünftes und sagt damit, ah, ok, es sind 9

871
01:58:43,640 --> 01:58:52,000
Sachen drin, ok, und jetzt gibt es anscheinend die Variante, dass ich anstatt Punkt Count

872
01:58:52,000 --> 01:59:04,840
sage, try get non-enumerated Counts und dann guckt er nach, ob es die Möglichkeit gibt,

873
01:59:04,840 --> 01:59:12,840
bei der zugrundeliegenden Datenstruktur zu zählen bzw. zu gucken, wie viel drinne ist,

874
01:59:12,840 --> 01:59:25,200
ohne dass ich alles durchlaufe, so verstehe ich das zumindest, so, und in dem Fall sollte

875
01:59:25,200 --> 01:59:32,040
das allerdings funktionieren, Count ist 9, genau, in dem Fall funktioniert das, weil

876
01:59:32,040 --> 01:59:39,600
die unterliegende Datenstruktur eine Liste ist, die anscheinend das hat, ach du kacke,

877
01:59:39,600 --> 01:59:51,480
ok, das ist cool, dass das, aber von was ist das abhängig, ich vermute mal, wobei wenn

878
01:59:51,480 --> 01:59:58,920
es Reflection wäre, dann wäre das ziemlich langsam, wobei das ja nur ein Aufruf ist,

879
01:59:58,920 --> 02:00:02,040
das könnte durchaus schneller sein, wir trotzdem alles zählen, gucken wir doch mal, ich habe

880
02:00:02,040 --> 02:00:16,480
keine Ahnung, wie das funktioniert, schauen wir mal, was ist Reflection, mit Reflection

881
02:00:16,480 --> 02:00:24,360
kannst du quasi zur Laufzeit Metainformationen abfragen über den Zustand deines Programms,

882
02:00:24,360 --> 02:00:32,320
über den Zustand, also das, was gerade, wie soll man das erklären, du kannst mit Reflection

883
02:00:32,320 --> 02:00:41,800
zum Beispiel abfragen, keine Ahnung, Name der Klasse, welche Properties und Felder hat

884
02:00:41,800 --> 02:00:45,840
diese Klasse, ist das eine Generic Klasse oder sowas in der Richtung, also du kannst

885
02:00:45,840 --> 02:00:54,440
quasi so Metainformationen abrufen zur Laufzeit, wo du zum Beispiel, also ein gutes Beispiel

886
02:00:54,440 --> 02:01:04,880
für Reflection ist, du hast ein Interface, das ist aber der Klassiker, Plugin, du hast

887
02:01:04,880 --> 02:01:14,720
ein Plugin Interface, und es gibt jetzt paar Klassen, die dein Plugin Interface implementieren,

888
02:01:14,720 --> 02:01:20,680
du möchtest jetzt allerdings, also du möchtest zum Start deines Programms alle Klassen, die

889
02:01:20,680 --> 02:01:30,460
iPlugin implementieren, registrieren, und das ohne, dass du jede einzelne Klasse explizit

890
02:01:30,460 --> 02:01:35,080
hinschreiben musst, so, und das kannst du über Reflection machen, frag mich jetzt aber

891
02:01:35,080 --> 02:01:48,960
aus dem Kopf nicht, wie genau das geht, ich glaube, Assembly, Assembly, Get Types, Get

892
02:01:48,960 --> 02:02:01,360
Types, und dann kannst du sagen, Where Type, Implement oder Interface oder so, Is Interface,

893
02:02:01,360 --> 02:02:08,560
Get Interface, genau, und dann kannst du gucken, implementiert das, iPlugin, und dann kannst

894
02:02:08,560 --> 02:02:13,000
du was mitmachen und sowas, das ist ganz, das ist ganz abgedrehter, ganz abgedrehter

895
02:02:13,000 --> 02:02:27,920
Scheiß, ja, also das ist, das ist nur Only Big Brain Time, so, gucken wir uns mal an,

896
02:02:27,920 --> 02:02:33,120
die Try Get Non-Enumerated, der Name von dem Ding ist schon wieder der Wahnsinn, Try Get

897
02:02:33,120 --> 02:02:43,360
Non-Enumerated Count, was das eigentlich intern macht, so, ah, guck mal, der fragt, ist implementiert

898
02:02:43,360 --> 02:02:49,520
die Quelle iCollection, dann sagt er, wir nehmen die Count Property und es ist true,

899
02:02:49,520 --> 02:02:58,560
implementiert das iListProvider, was auch immer, Get Count Only If Cheap, ok, das ist

900
02:02:58,560 --> 02:03:04,160
nochmal special interne Funktion, die irgendwie checkt, ob man das abfragen kann, ohne alles

901
02:03:04,160 --> 02:03:10,320
zu durchlaufen, dann true, wenn es eine Collection ist, dann true, wenn nicht, dann, ja, im Prinzip

902
02:03:10,320 --> 02:03:18,520
macht es das, das guckt, was der unterliegende Datentyp eben kann, so, wie es das jetzt genau

903
02:03:18,520 --> 02:03:30,000
ist, Big Brain Time, das ist irgendwie Microsoft Implementierungsdetail, was weiß ich, was

904
02:03:30,000 --> 02:03:36,040
die da genau treiben, zumindest wüsste ich jetzt pauschal nicht, wann ich das verwenden

905
02:03:36,040 --> 02:03:42,440
würde, weil entweder brauche ich jetzt den Count und dann ist egal, ob das lange dauert

906
02:03:42,440 --> 02:03:48,720
oder nicht, oder ich brauche ihn nicht, wenn ich ihn nicht brauche, dann brauche ich ihn

907
02:03:48,720 --> 02:03:57,240
nicht, selten optional, nur wenn er schnell ist, hm, ist aber glaube ich für Performance-Optimierung

908
02:03:57,240 --> 02:04:04,280
durchaus sinnvoll, dass man die Möglichkeit hat, auch wenn mir jetzt spontan nichts einfällt,

909
02:04:04,280 --> 02:04:25,240
wozu man das braucht.

910
01:47:47,220 --> 02:04:41,280
du probierst erst, ob non-enumerated geht, das ist tatsächlich eine super Idee,

911
02:04:41,280 --> 02:04:45,560
das stimmt, da habe ich jetzt gar nicht dran gedacht, das ist natürlich sinnvoll, wenn

912
02:04:45,560 --> 02:04:51,800
ich den Count brauche, dann kann ich gucken, gibt es das schnell, wenn ja, benutzt das

913
02:04:51,800 --> 02:04:55,760
schnelle, wenn nicht, dann macht doch normalen Count, das ist natürlich sinnvoll, wobei

914
02:04:55,760 --> 02:05:00,840
man da wahrscheinlich dann eine Extension-Method drumherum bauen kann, die das für mich macht,

915
02:05:00,840 --> 02:05:08,440
quasi, counte immer, aber wenn es zwar schnelles gibt, dann nehm das schnelle, wobei jetzt

916
02:05:08,440 --> 02:05:13,680
habe ich die Frage verstanden, warum Microsoft das nicht schon intern in Count macht, ist

917
02:05:13,680 --> 02:05:20,720
die Frage, wahrscheinlich, vermute ich jetzt mal, weil es ein Trade-off ist, zwischen,

918
02:05:20,720 --> 02:05:26,600
ich mache diese ganze Logik, um rauszubekommen, ob es schnell ist, zu ich fange einfach stumpf

919
02:05:26,600 --> 02:05:37,360
an zu zählen, gibt es nicht sowas wie length, nein, gibt es nicht, das gibt es nur bei

920
02:05:37,360 --> 02:05:44,280
manchen Typen, ja, also z.B. bei list hast du sowas, bei list hast du count, bei arrays

921
02:05:44,280 --> 02:05:59,000
hast du, könnte sogar length sein, genau, ja, aber bei enumerable hast du das nicht,

922
02:05:59,000 --> 02:06:13,160
da hast du nur das standardmäßig count und jetzt halt das neue, ja, bei kleinen Listen

923
02:06:13,160 --> 02:06:18,160
kannst du das einfach counten und bei 3, 4 Elementen, oder wahrscheinlich bei 100 Elementen,

924
02:06:18,160 --> 02:06:27,560
ist es wahrscheinlich trotzdem schneller, ja, ist situationsabhängig und man muss das

925
02:06:27,560 --> 02:06:33,920
wahrscheinlich benchmarken, dass man dann für den jeweiligen Fall weiß, ob das taugt

926
02:06:33,920 --> 02:06:42,600
oder nicht, ok, also, ist aber eine sinnvolle Funktion, muss man sagen, so, was gibt es

927
02:06:42,600 --> 02:06:56,000
jetzt, der 3-way zip, was, die 3-wege zip extension method, was, jetzt wird es big brain

928
02:06:56,000 --> 02:07:10,960
time, was, haben die da irgendwie ein Beispiel für, was, first, second, third, ah, ich kann

929
02:07:10,960 --> 02:07:18,720
jetzt mehr als 2 Listen miteinander kombinieren, ach so, ja, ok, dann ist es doch relativ easy,

930
02:07:18,720 --> 02:07:27,000
also bisher konnte ich nur sowas hier machen, ich nenne es mal list 1, list 2, list 3, ich

931
02:07:27,000 --> 02:07:32,400
weiß nicht, ob der die Elemente auch, wahrscheinlich nicht bei einer normalen Liste, so, und jetzt

932
02:07:32,400 --> 02:07:53,320
sage ich hier, for each, list 1, zip, list 2, oh, list 2, list 3, ah, alter, ok, ok,

933
02:07:53,320 --> 02:08:14,640
das ist jetzt ja big brain, guck mal, jetzt kann ich das kombinieren, ok, das ist anscheinend

934
02:08:14,640 --> 02:08:35,760
jetzt neu, ah, gibt es nicht mehr hier, ok, das ging anscheinend vorher nicht, vorher

935
02:08:35,760 --> 02:08:41,600
ging anscheinend nur sowas hier, und jetzt kann man auch 3 machen, na gut, man könnte

936
02:08:41,600 --> 02:08:56,440
es übrigens de-constructen auch gleich, dann könnte man direkt hier so drauf zugreifen,

937
02:08:56,440 --> 02:09:03,200
ehrlich gesagt habe ich das noch nie vermisst, und ich verwende zip auch so gut wie nie,

938
02:09:03,200 --> 02:09:17,080
also, tja, ok, gut dass es das gibt, nice, gg eats, aber ansonsten hält sich die für

939
02:09:17,080 --> 02:09:27,960
mich sinnvolle Funktion jetzt da in Grenzen, chat jetzt übertreibt es mal nicht, muss

940
02:09:27,960 --> 02:09:35,280
jetzt nicht versuchen jetzt jegliche Escape Sequenzen da rein zu stecken und zu gucken

941
02:09:35,280 --> 02:09:48,080
ob es funktioniert, so, batch sequences, ok, was gibt es denn jetzt als Neues, chunk, oh,

942
02:09:48,080 --> 02:09:52,680
das ist cool dass es das gibt, das habe ich mir schon öfters mal gewünscht, ok, wie

943
02:09:52,680 --> 02:09:59,080
funktioniert das jetzt, das muss ich mal ausbringen, ok, for each, also was oftmals ein Problem

944
02:09:59,080 --> 02:10:06,200
war, also was wirklich öfters mal vorgekommen ist, dass du jetzt gesagt hast, du hast hier

945
02:10:06,200 --> 02:10:10,840
eine Liste, du möchtest aber nicht die Schleife so machen, dass du quasi einzeln drüber

946
02:10:10,840 --> 02:10:15,040
läufst, sondern du möchtest es quasi immer in zweier Paare haben oder in dreier Paare

947
02:10:15,040 --> 02:10:20,680
oder sowas, also du möchtest quasi pro Schleifendurchlauf 3 Stück davon, 3 Stück davon, 3 Stück

948
02:10:20,680 --> 02:10:34,440
davon und sowas, und das ist anscheinend jetzt eingebaut, chunk, chunk size 3, ja gut, kann

949
02:10:34,440 --> 02:10:41,520
jetzt schlecht ausgehen so, gibt es eine schöne Variante wie ich da draus, wie ich das jetzt

950
02:10:41,520 --> 02:10:53,280
einfach printen lassen kann, kennt da irgendjemand, was, gibt es ein schönes Overload für to

951
02:10:53,280 --> 02:11:06,000
string oder sowas, ich mein ich kann einfach sagen select, was range, wie range, so oder

952
02:11:06,000 --> 02:11:23,160
sowas, string, ach stimmt ja, string join, stimmt, ja, das ist in dem Fall tatsächlich

953
02:11:23,160 --> 02:11:33,320
sogar die beste Variante, was muss man zuerst machen, der separator oder separator, separator

954
02:11:33,320 --> 02:11:46,720
und dann die, ja, guck jetzt kriege ich das immer in 3er Häppchen, das ist tatsächlich

955
02:11:46,720 --> 02:11:51,360
schon ganz cool, so und jetzt ist natürlich die Frage, was macht der, wenn das nur hier

956
02:11:51,360 --> 02:11:57,680
ein Element zu wenig hat, also ich würde jetzt erwarten, dass der das handeln kann und beim

957
02:11:57,680 --> 02:12:05,080
letzten Durchlauf einfach nur zwei Elemente gibt, ja, macht er, das ist nicht schwer zu

958
02:12:05,080 --> 02:12:10,440
bauen sowas, also es gibt zum Beispiel ein Projekt, das habe ich ab und zu mal ganz gerne

959
02:12:10,440 --> 02:12:17,320
verwendet auf GitHub, die hatten solche Dinger schon eingebaut, die haben ganz viele, ganz

960
02:12:17,320 --> 02:12:24,480
viele Sachen drin, für Link, aber umso besser ist es, dass es jetzt standardmäßig im Framework

961
02:12:24,480 --> 02:12:28,640
drin ist, das finde ich cool, also ich muss ehrlich sagen, von allen Features, die ich

962
02:12:28,640 --> 02:12:33,040
heute gesehen habe, finde ich das eigentlich noch am praktikabelsten, neben Namespaces

963
02:12:33,040 --> 02:12:47,080
und Global Usings und sowas, ja, das ist tatsächlich sehr sinnvolles Ding, das finde ich gut, das

964
02:12:47,080 --> 02:12:52,000
kann man wirklich gebrauchen, so was haben wir als nächstes, Batching Sequence hatten

965
02:12:52,000 --> 02:13:06,400
wir gerade, Analyzer Checks, ne, das ist, By Operators, was, ah, MinBy, MaxBy, oh, das

966
02:13:06,400 --> 02:13:13,400
ist natürlich cool, das ist cool, wenn das das ist, was ich denke, haben die da ein Beispiel

967
02:13:13,400 --> 02:13:20,560
für, ne, kein Beispiel, also ich vermute mal, dass das sowas hier ist, wir machen jetzt

968
02:13:20,560 --> 02:13:34,600
einfach mal, klasse, um das auszuprobieren, class, kegw, int, age, so, und ich habe jetzt

969
02:13:34,600 --> 02:13:43,760
eine Liste mit ganz vielen kegw's drinne, new, kegw, wir machen noch einen Constructor,

970
02:13:43,760 --> 02:14:05,840
dass man das, so, wir haben jetzt eine Klasse mit ganz vielen kegw's, also kegww's, jetzt

971
02:14:05,840 --> 02:14:17,280
gucken wir mal, ob das, das ist, was ich mir so denke, so, 1, 2, 3, 4, 5, 5 mal kegw, kegwwwww,

972
02:14:17,280 --> 02:14:29,600
ja, Ctor ist, ist Makro für Constructor, so, for each lists, so, und was, was kann ich

973
02:14:29,600 --> 02:14:37,840
jetzt machen, by, distinct by, accept by, group by, der group by gab es schon die ganze Zeit,

974
02:14:37,840 --> 02:14:45,760
MaxBy, MinBy, ok, das heißt, ich kann jetzt quasi angeben, auf welches Property der filtern

975
02:14:45,760 --> 02:14:58,800
soll, also kann ich jetzt sowas machen wie, age, ne, ne, das funktioniert nicht, oder

976
02:14:58,800 --> 02:15:05,120
funktioniert das doch, ach ne, da kommt direkt, da kommt direkt jetzt raus, also, da sollte

977
02:15:05,120 --> 02:15:13,440
jetzt 5 rauskommen, da kann er keine Schleife drüber machen, ach ne, es kommt, es kommt,

978
02:15:13,440 --> 02:15:19,440
es kommt nicht 5 raus, der nimmt das Element mit dem größten Property, das heißt, wenn

979
02:15:19,440 --> 02:15:28,000
ich das jetzt hier ausgebe, mit age, dann sollte da rauskommen 5, ok, das ist tatsächlich

980
02:15:28,000 --> 02:15:38,600
sehr praktisch, zum Beispiel, zum Beispiel für, für Unic, ja, also sprich, ich möchte

981
02:15:38,600 --> 02:15:48,080
jetzt die Liste filtern, ich möchte jetzt die Liste filtern, dass nur noch ein kegw

982
02:15:48,080 --> 02:15:57,200
Element mit jeweils dem gleichen age drinne ist, das ist wirklich sehr praktisch, also,

983
02:15:57,200 --> 02:16:05,520
machen wir mal, ich habe jetzt hier keine Ahnung, ich habe jetzt hier 4 mal kegw drinne

984
02:16:05,520 --> 02:16:10,920
mit dem age 1 und einmal kegw mit dem age 5 und jetzt sollte am Ende rauskommen, dass

985
02:16:10,920 --> 02:16:19,640
nur noch 1 und 5 gibt, 1 und 5, das ist, das ist, das ist echt praktisch, das finde ich

986
02:16:19,640 --> 02:16:29,680
gut, also du kannst es jetzt quasi filtern und alles rauswerfen lassen, was quasi den

987
02:16:29,680 --> 02:16:42,560
gleichen Wert hat hier, aber da nimmt es nur das erste mit age 1, das ist eine gute

988
02:16:42,560 --> 02:16:46,520
Frage, ob er das erste oder das letzte nimmt, das können wir mal ausprobieren, ich habe

989
02:16:46,520 --> 02:17:05,040
keine Ahnung, weiß ich nicht, nicht age, sondern test, probieren wir das mal aus, keine Ahnung,

990
02:17:05,040 --> 02:17:15,080
1, 2, 3, 4, 5, so, mal gucken, welches, welches der nimmt, ob es das erste oder das letzte

991
02:17:15,080 --> 02:17:24,120
ist, das erste, es ist anscheinend das erste, ok, Moment, nicht age, t, lul, ja, es ist

992
02:17:24,120 --> 02:17:32,280
das erste, es ist das erste, was er findet anscheinend, ok, nice, aber das ist tatsächlich

993
02:17:32,280 --> 02:17:35,880
echt mal eine gute Funktion, die finde ich echt poggers, so, was haben wir ansonsten

994
02:17:35,880 --> 02:17:44,360
noch, distinct by, accept by, intersect by, union by, min, max, ja, das ist praktisch,

995
02:17:44,360 --> 02:18:01,520
das finde ich cool, pog, or default enhancement, sag mal, was ist das für eine bescheuerte

996
02:18:01,520 --> 02:18:09,600
Seite, warum haben die keine Beispiele, warum haben die keine Beispiele,.net 6 or default,

997
02:18:09,600 --> 02:18:27,360
or your first or your introduction, das gibt es ja schon eine Weile, man kann das default

998
02:18:27,360 --> 02:18:33,520
erzählen, ja, das ist auch gut, da warte ich ja schon lange drauf, dass es das gibt,

999
02:18:33,520 --> 02:18:42,760
also, mal angenommen, ich habe jetzt, ich habe jetzt, was ich, wir machen mal wieder

1000
02:18:42,760 --> 02:18:48,280
die Liste von eben, ja, wir machen mal hier wieder var, list, new, list und wir machen

1001
02:18:48,280 --> 02:18:52,280
wieder die int-liste, das ist glaube ich einfach besser damit was auszuprobieren, 1, 2, 3,

1002
02:18:52,280 --> 02:19:00,160
4, 5, 6, 7, 8, 9, so, hier, keqw kann auch wieder weg und das heißt list, nicht l, l,

1003
02:19:00,160 --> 02:19:04,920
l, l und gut, ist im Prinzip das gleiche Beispiel was sie auch haben, so, und was ich jetzt machen

1004
02:19:04,920 --> 02:19:11,580
kann, ich kann or the first, first or default, so, das heißt, ich kann jetzt filtern, ich

1005
02:19:11,580 --> 02:19:21,560
gebe mir das erste Element, wo das größer als 99 ist, das gibt es ja nicht, das gibt

1006
02:19:21,560 --> 02:19:26,900
es ja nicht, was er jetzt macht ist, er gibt irgendein default zurück für den jeweiligen

1007
02:19:26,900 --> 02:19:33,260
Typ. Das wäre in dem Fall 0. Also wenn es 99 nicht gibt, würde er mir jetzt 0 zurückgeben,

1008
02:19:33,260 --> 02:19:39,500
was wahrscheinlich nicht sonderlich sinnvoll ist. 0. So und jetzt kann ich anscheinend

1009
02:19:39,500 --> 02:19:47,940
einen Default Wert angeben, keine Ahnung, 5 oder so, einen Default Wert angeben, den

1010
02:19:47,940 --> 02:19:54,540
er nehmen soll, wenn er das erste nicht findet. Das ist tatsächlich praktisch. Das habe ich

1011
02:19:54,540 --> 02:20:00,860
mir wirklich schon ein paar Mal gewünscht. Wo das noch viel cooler ist, ist wenn es zum

1012
02:20:00,860 --> 02:20:16,020
Beispiel irgendwelche Klassen sind. Also bitte hier nicht. String. Wenn es zum Beispiel irgendwelche

1013
02:20:16,020 --> 02:20:25,820
Klassen sind und ich gucke jetzt hier irgendwie ContainsK was es nicht macht und ansonsten

1014
02:20:25,820 --> 02:20:33,700
halt DefaultCuteChat. So jetzt findet er das nicht und dann ist DefaultCuteChat. Das ist

1015
02:20:33,700 --> 02:20:56,300
wirklich praktisch. Das ist nice. Das finde ich cool. Stimmt, du hast recht, vorher hätte

1016
02:20:56,300 --> 02:21:04,740
man glaube ich sowas dann noch machen können. Stimmt, ja. Aber ich finde das andere deutlich

1017
02:21:04,740 --> 02:21:13,380
schöner. Nehmt er als Default Value auch Nullables? Ich gehe mal ganz stark davon aus, dass dein

1018
02:21:13,380 --> 02:21:17,780
Default Value exakt der gleiche Typ sein muss wie das hier vorne, sonst kann das ja nicht

1019
02:21:17,780 --> 02:21:28,100
funktionieren. Achso, du meinst, das müssen wir mal ausprobieren. Also das hier wird wahrscheinlich

1020
02:21:28,100 --> 02:21:51,100
nicht gehen. Ne. Ja anscheinend. Ja anscheinend ist er so schlau und lässt das zu. Fragezeichen,

1021
02:21:51,100 --> 02:21:56,900
Fragezeichen geht auch seit C-Shop 7. Wusste ich jetzt nicht, aber ich hatte im Hinterkopf,

1022
02:21:56,900 --> 02:22:23,860
dass es relativ neu ist, ja. So, was haben wir sonst noch schönes? Hab ich jetzt irgendwas

1023
02:22:23,860 --> 02:22:30,220
verpasst bei diesem anderen Artikel? Ja, Crap. Ok, also was haben wir sonst noch? Neue.NET

1024
02:22:30,220 --> 02:22:40,380
6 APs. Date Only and Time Only. Was? Warum nicht einfach Date Time und was weglassen?

1025
02:22:40,380 --> 02:22:45,380
Was? Eine Off Topic Frage. Eine Freundin hat ein Smartphone mit Philips und Alexa. Was

1026
02:22:45,380 --> 02:22:54,620
ist denn Philips? Gibt es ein Voice Assistant, der Philips heißt? Nein, ich weiß was du meinst.

1027
02:22:54,620 --> 02:23:00,140
Du meinst wahrscheinlich Philips Hue Lampen oder sowas. Steht ja auch da. Eine Lampe geht

1028
02:23:00,140 --> 02:23:03,500
aber nicht mit den Philips Dingern. Ist der Shelley 1 schwer zu implementieren? Den hast

1029
02:23:03,500 --> 02:23:09,100
du mal. Ne, beim Shelley 1 ist das Problem weniger die App oder irgendwie das Einrichten

1030
02:23:09,100 --> 02:23:14,060
oder sonst was. Du musst den Shelley 1 halt einbauen. Und dazu musst du die Sicherung

1031
02:23:14,060 --> 02:23:29,780
raus machen. Du musst wissen, wie du das anschließt und dich nicht selbst umbringen dabei. Die

1032
02:23:29,780 --> 02:23:49,300
Smartphone Geschichte ist gar nicht so das Problem. Ähm, ansonsten ist es nicht so schwierig

1033
02:23:49,300 --> 02:23:54,780
aber ich hab das auch nicht selbst gemacht. Ich weiß theoretisch wie es funktioniert.

1034
02:23:54,780 --> 02:23:58,260
Ich hab mir ein paar mal ein Diagramm angeguckt. Ich hab das auch vom Elektriker gemacht. Ich

1035
02:23:58,260 --> 02:24:01,620
hab das auch nicht selbst gemacht. Ich hab da keinen Bock drauf gehabt rumzuschrauben

1036
02:24:01,620 --> 02:24:07,340
und im Zweifelsfall dann irgendwas kaputt zu machen. Oder dass das irgendwann nicht

1037
02:24:07,340 --> 02:24:16,820
mehr sicher ist danach. Achso, die Shelley App. Also das Gute ist an den Shelley Dingern

1038
02:24:16,820 --> 02:24:20,500
ja, du kannst die App verwenden, du kannst über den Web API verwenden, du kannst die

1039
02:24:20,500 --> 02:24:29,940
MQTT verwenden, du kannst, meiner, mach das, der hat damit überhaupt kein Problem gehabt,

1040
02:24:29,940 --> 02:24:33,940
theoretisch auch sogar das Motor flashen oder in deine Heimautomatisierung integrieren.

1041
02:24:33,940 --> 02:24:50,220
Also Shellys haben alle möglichen Schnittstellen. Aber das ist kein Problem gewesen. Der kannte

1042
02:24:50,220 --> 02:25:02,460
die Dinger sogar. Also vorher schon. Die scheinen wohl recht beliebt zu sein. Du hast sicherlich

1043
02:25:02,460 --> 02:25:07,700
welche die sagen, das ist was auch immer nicht konform, machen das dann nicht, aber meiner

1044
02:25:07,700 --> 02:25:11,340
hatte damit keine Schmerzen. Der fand das sogar ganz gut, der hat sogar erzählt, dass

1045
02:25:11,340 --> 02:25:16,700
er selbst, also wir haben uns ein bisschen unterhalten was Richtung Smartphone, Smart Home und sowas

1046
02:25:16,700 --> 02:25:23,460
angeht, hat auch selbst erzählt, dass er da, also dass er es mit Technik nicht so wirklich

1047
02:25:23,460 --> 02:25:30,060
hat, was also irgendwie so Computerkram und Smart Home Sachen angeht und er hat wohl selbst

1048
02:25:30,060 --> 02:25:34,300
auch irgendwelche, frag mir nicht, wahrscheinlich auch Philips Hue oder irgendwie sowas gehabt.

1049
02:25:34,300 --> 02:25:43,900
Ja, aber so Home Assistant Geschichten sowas, ich hab ihm das Dashboard auch gezeigt, das

1050
02:25:43,900 --> 02:25:49,340
ist nicht so seine Welt, aber der kannte das. Es gibt einen neuen Battlefield Trailer, oh

1051
02:25:49,340 --> 02:25:55,340
ja, poste mal, den gucken wir uns jetzt an. Ich scroll mal kurz hier durch, was gibt es

1052
02:25:55,340 --> 02:25:59,180
denn sonst noch, was gibt es denn hier noch für spannende Sachen, also es gibt jetzt

1053
02:25:59,180 --> 02:26:07,460
Date Only and Time Only, Official PC Trailer RTX On. Okay Leute, wir gucken mal ganz schnell

1054
02:26:07,460 --> 02:26:14,380
den Battlefield Trailer. Ach Quatsch, das ist doch der normale Battlefield Trailer oder?

1055
02:26:14,380 --> 02:26:23,860
Nur mit RTX jetzt, das ist eher Nvidia Werbung. Warum hat es so schlechte Bewertung? I like

1056
02:26:23,860 --> 02:26:37,180
how, wahrscheinlich weil es ruckelt. Das ist doch nichts Neues oder? Das kennen wir

1057
02:26:37,180 --> 02:26:44,220
schon, das kennen wir auch schon, das kennen wir auch schon. Die Musik ist richtig ätzend.

1058
02:26:44,220 --> 02:26:51,860
Dabei hat Battlefield so ein schönes Main Theme, das kennen wir auch schon, keine Ahnung.

1059
02:26:51,860 --> 02:27:00,300
Wo genau ist da jetzt RTX? Ich erkenne ehrlich gesagt keinen Unterschied zu mit RTX oder

1060
02:27:00,300 --> 02:27:16,460
ohne RTX. Wo ist da jetzt der Unterschied? Okay, die Straße vielleicht jetzt. Es ruckelt,

1061
02:27:16,460 --> 02:27:24,580
Alter, es ruckelt, es ruckelt. Merkt ihr die Slowdowns auch? Alter, das ruckelt, fuck.

1062
02:27:24,580 --> 02:27:42,620
Wenn das schon im Trailer ruckelt. Das ist aber doch nichts Neues. Okay, du hast jetzt

1063
02:27:42,620 --> 02:27:58,260
hier so ein bisschen Sonnenlicht. Hier auf dem Boden? Weiß ich, ob das hier RTX ist,

1064
02:27:58,260 --> 02:28:00,380
auf dem Boden? Warum ist das so ein Like Dislike? Naja, wahrscheinlich weil man jetzt da nicht

1065
02:28:00,380 --> 02:28:08,900
erkennt, was jetzt daran so geil sein soll. Wo ist da RTX? Die Luft ist RTX on, das wird

1066
02:28:08,900 --> 02:28:15,700
sein. Das ist bestimmt, ja, das ist da, wo es ruckelt hat. Guck mal, Alter, das ruckelt

1067
02:28:15,700 --> 02:28:41,780
richtig hart. Huge Slowdowns. Naja, was auch immer. Ich glaube, der RTX Trailer, das ist

1068
02:28:41,780 --> 02:28:46,220
irgendwas, was sie vertraglich vereinbart haben mit Nvidia. Das mussten sie machen.

1069
02:28:46,220 --> 02:28:55,820
Das war jetzt wirklich der herausragende Trailer. Aber jetzt mal ernsthaft, das neue Battlefield,

1070
02:28:55,820 --> 02:29:02,580
das startet in elf Tagen, zwölf Tagen, je nachdem, wie man das jetzt zählt. Wo ist denn

1071
02:29:02,580 --> 02:29:08,860
die ganze Werbung? Die müssen jetzt ran. Du siehst, du hast ab und zu mal ein neues Video

1072
02:29:08,860 --> 02:29:14,740
gemacht. Es kann halt sein, dass es in zwölf Tagen rauskommt und eigentlich nirgendwo großartig

1073
02:29:14,740 --> 02:29:20,060
was ist. Die müssten doch jetzt eigentlich mal richtig krass die Werbetrommel rühren.

1074
02:29:20,060 --> 02:29:35,100
Oder sehe ich das falsch? Oder wird es nochmal verschoben? Snoop Dogg Spielevent, genau,

1075
02:29:35,100 --> 02:29:40,300
da wird er im Kram links und rechts laufen kann für zwei Stunden und sonst nichts machen.

1076
02:29:40,300 --> 02:29:50,100
Die müssen mal wieder Vogue Trailer raus haben. Ich glaube, darauf haben die nach Battlefield

1077
02:29:50,100 --> 02:29:56,860
5 keinen Bock mehr. Es hätte sich bei Battlefield 5 niemand darüber beschwert, über diesen

1078
02:29:56,860 --> 02:30:03,300
Trailer. Hätten die nicht zwei Stunden lang vorher erzählt, wie authentisch und atmosphärisch

1079
02:30:03,300 --> 02:30:08,700
und nah an der Realität sie sind, und dann kommt die Frau mit der Kralle ran. Das war

1080
02:30:08,700 --> 02:30:17,740
halt selbstown Deluxe. Es hätte keiner damit Probleme gehabt. Hätten sie nicht im Vorfeld

1081
02:30:17,740 --> 02:30:22,100
quasi das Gegenteil erzählt. Ja, und den Leuten danach zu erzählen, wenn es euch nicht

1082
02:30:22,100 --> 02:30:26,260
gefällt, dann kauft es nicht, da muss man sich... Oder wenn es die Leute dann auch machen.

1083
02:30:26,260 --> 02:30:34,660
Die haben einfach gesagt, leck mich, ich kaufe es wirklich nicht. Also wir gucken jetzt

1084
02:30:34,660 --> 02:30:39,060
nochmal kurz hier das ganze durch. Also was gibt es denn sonst noch? Date only und time

1085
02:30:39,060 --> 02:30:45,380
only gibt es jetzt. Until now, date and time span were only.net base class. Ja, warum gibt

1086
02:30:45,380 --> 02:30:54,780
es date only und time only? But why? Date only, new date only. Also sprich, das ist

1087
02:30:54,780 --> 02:31:05,580
die Portion von einem date time, ohne time und... Hä? Aber warum? Ich kann doch einfach

1088
02:31:05,580 --> 02:31:14,780
auch ein date time nehmen und das Datum auf 1.1.1970 stehen lassen oder so. Entity Framework,

1089
02:31:14,780 --> 02:31:22,220
das kann natürlich sein. Ich mein, er hat nicht unrecht, ein bisschen dumm ist es schon,

1090
02:31:22,220 --> 02:31:29,020
das mit date time zu machen. Also vom Handling her, also ich beschwer mich da nicht, das

1091
02:31:29,020 --> 02:31:36,980
gibt es schon, durchaus in Ordnung. Date only, time only. Gut, das ist im Prinzip genau

1092
02:31:36,980 --> 02:31:45,260
wie man sich vorstellt. Time zone conversion improvement, ja das ist auch dringend notwendig.

1093
02:31:45,260 --> 02:32:07,620
Okay. Also ehrlich, ich glaube, also Kalender, also Datums und Zeithandling ist glaube ich

1094
02:32:07,620 --> 02:32:14,180
eines der abgefucktesten Sachen überhaupt. Das ist so was, was auf den ersten Blick

1095
02:32:14,180 --> 02:32:18,940
einfach aussieht, aber auf den zweiten und dritten und fünften und neunundneunzigsten

1096
02:32:18,940 --> 02:32:36,260
Blick einfach unglaublich komplex ist. Das will man gar nicht machen. So, was gibt es

1097
02:32:36,260 --> 02:33:06,220
sonst? New Collection, Priority Queue. Ah, jetzt habe ich es kapiert. Okay, man hat quasi

1098
02:33:06,220 --> 02:33:13,180
eine Warteschlange und kann den Elementen, die man dort reinsteckt, Prioritätsnummern

1099
02:33:13,180 --> 02:33:20,620
geben und wenn man die dann aus der Warteschlange wieder rausholt, wird das zuerst das Element

1100
02:33:20,620 --> 02:33:31,420
mit der höchsten oder der niedrigsten, kann ich mit der niedrigsten Priorität wieder

1101
02:33:31,420 --> 02:33:39,700
rausgeholt oder also, ja, okay. Ja, nice. Also mir fällt jetzt auch spontan in letzter

1102
02:33:39,700 --> 02:33:45,820
Zeit nichts ein, wozu ich das gebraucht hätte, aber für Job Cues oder so stelle ich mir

1103
02:33:45,820 --> 02:33:52,580
das durchaus oder für irgendwelche Event Cues oder sowas stelle ich mir das durchaus

1104
02:33:52,580 --> 02:34:00,300
sinnvoll vor. Stellt euch mal vor, zum Beispiel, man hat irgendeine Warteschlange von der

1105
02:34:00,300 --> 02:34:07,980
Webanwendung für Events. So, Events können beispielsweise sein, neuer User hat sich angemeldet

1106
02:34:07,980 --> 02:34:13,620
oder ich muss den täglichen Newsletter verschicken oder ich muss täglich den Datenbankindex

1107
02:34:13,620 --> 02:34:19,940
neu auffangen, irgendwie sowas. Und dann ist natürlich klar, dass ein neuer User mehr Priorität

1108
02:34:19,940 --> 02:34:24,180
in der Abarbeitung haben sollte als jetzt vielleicht täglich einen Datenbankindex machen.

1109
02:34:24,180 --> 02:34:37,460
Könnte ich mir vorstellen, dass es da schon ganz sinnig ist. Trotzdem muss ich sagen,

1110
02:34:37,460 --> 02:34:43,980
ich glaube von, also mir fällt jetzt in letzter Zeit nichts ein, wo ich das jetzt mal, wo

1111
02:34:43,980 --> 02:34:48,780
ich jetzt dachte, ja, das wäre jetzt cool gewesen, aber das kann man definitiv brauchen.

1112
02:34:48,780 --> 02:34:53,740
Das ist ja immer gut, wenn sie sowas hinzufügen. Das sind Dinge, die sind sinnvoll, wenn man

1113
02:34:53,740 --> 02:35:03,100
das denn halt braucht. Nicht so das, was der C++-Standard immer einführt. Als wenig sinnvoll

1114
02:35:03,100 --> 02:35:13,820
davon. Ja, das ist doch schon mal nicht schlecht. Das kann man sich doch geben. So, was haben

1115
02:35:13,820 --> 02:35:18,740
wir jetzt? Link works on index and ranges. Das wissen wir schon. Das wissen wir auch

1116
02:35:18,740 --> 02:35:24,300
schon. Das wissen wir auch schon. Das wissen wir auch schon. Das wissen wir auch schon.

1117
02:35:24,300 --> 02:35:38,020
Das wissen wir auch schon. List stack queue ensure capacity. Was? Die sind doch eh dynamisch.

1118
02:35:38,020 --> 02:35:52,540
Ah, okay. Du kannst jetzt bei Listen, Stacks und Warteschlangen quasi direkt angeben,

1119
02:35:52,540 --> 02:35:58,780
wie groß die starten sollen oder so. Okay, ja, ist wahrscheinlich Performanstechnik

1120
02:35:58,780 --> 02:36:16,260
nicht schlecht. Gzbruder2, danke für den Sub. Choose one name. Naja, gute Frage. Ich habe

1121
02:36:16,260 --> 02:36:21,820
ehrlich gesagt, glaube ich nie den HTTP-Listener verwendet. TCP-Listener habe ich schon öfters

1122
02:36:21,820 --> 02:36:31,340
verwendet, weil für HTTP-Listener, also wenn du Web-Request machen willst, dann kann man

1123
02:36:31,340 --> 02:36:48,580
jetzt ja mittlerweile Minimal-APs machen, die viel cooler sind. Minimal-APs könnte man

1124
02:36:48,580 --> 02:36:53,260
sich tatsächlich nochmal angucken. Wobei, das haben wir uns schon mal angeguckt. Du

1125
02:36:53,260 --> 02:36:59,220
kannst jetzt eine Web-Anwendung mit drei Zeilen Code starten. Da werden sogar die ganzen Python-Leute

1126
02:36:59,220 --> 02:37:09,020
neidisch. Wobei es da ungefähr genauso schnell geht. Was new weight-async-Methods? Task weight

1127
02:37:09,020 --> 02:37:30,980
async. Was? Warum erwarte ich den nicht einfach? Wait. Hä? Wo? Hä? Ah, da kann ich ein Timeout

1128
02:37:30,980 --> 02:37:39,740
angeben. Ach, jetzt verstehe ich das. Ah, da kann ich ein Timeout angeben. Also entweder

1129
02:37:39,740 --> 02:37:47,460
ist er fertig in der Zeit, er wird gecancelt oder es tritt ein Timeout auf. Ok, dann verstehe

1130
02:37:47,460 --> 02:37:50,740
ich, dann ist es doch sinnvoll. Weil ich wollte gerade sagen, Task kannst du einfach awaiten

1131
02:37:50,740 --> 02:38:11,700
und gut ist. Conclusion. Wer ist da nicht drinne? Otte. Lister neuer Public Types. Ist klar.

1132
02:38:11,700 --> 02:38:16,340
Ich gucke mir natürlich jetzt jeden Public Type an und sage, ah, guck mal hier. Quick

1133
02:38:16,340 --> 02:38:22,700
Connection. Was ist denn eigentlich eine Quick Connection? Da hat sich was getan. Ja, ganz

1134
02:38:22,700 --> 02:38:29,380
bestimmt. Ganz bestimmt. Genau so werde ich es machen, Microsoft. Ist klar. Ja, Quick

1135
02:38:29,380 --> 02:38:38,980
Muffs gibt es jetzt. What? Windows Forms? Die haben wirklich was an Windows Forms gemacht?

1136
02:38:38,980 --> 02:38:44,980
Ach, Quick ist das neue Titel. Stimmt, das stimmt. Hab ich gar nicht dran gedacht. Ja,

1137
02:38:44,980 --> 02:38:51,100
jetzt weiß ich wieder, was es ist. Ja, weiß ich auch von Google. Die haben tatsächlich

1138
02:38:51,100 --> 02:39:04,660
was an Windows Forms gemacht. Was gibt es hier? Threading Task Parallel. Ah, es gibt

1139
02:39:04,660 --> 02:39:21,380
jetzt Parallel for each Async. Das ist cool. Parallel. Parallel. Ja. Hallo, Import, please.

1140
02:39:21,380 --> 02:39:26,300
For each Async. Das ist tatsächlich nützlich. Also wer das nicht kennt, das kann ich euch

1141
02:39:26,300 --> 02:39:30,060
mal zeigen, das ist schon lange drin, aber nicht in der Async Variante. Wer das nicht

1142
02:39:30,060 --> 02:39:35,780
kennt, wir machen hier nochmal unsere Liste. Unsere Liste aus ints. Int, eins, zwei, drei,

1143
02:39:35,780 --> 02:39:41,740
vier, fünf, sechs, sieben, acht, neun, zehn, was auch immer, neun, so. Wenn man jetzt keinen

1144
02:39:41,740 --> 02:39:47,020
Bock hat, irgendwie händisch Multithreading zu machen und einfach sich denkt, ey, komm,

1145
02:39:47,020 --> 02:39:51,380
vielleicht kann ich noch ein bisschen Performance mit mehr CPU Kern rausholen, kann man einfach

1146
02:39:51,380 --> 02:39:58,020
sagen Parallel zum Beispiel for each und da gibt man dann an, ich weiß gar nicht mehr

1147
02:39:58,020 --> 02:40:05,780
genau wie die Syntax ist. Da gibt man glaube ich die Liste an und dann was er mit jedem

1148
02:40:05,780 --> 02:40:17,900
Element machen soll. Und jetzt macht er das in Parallel. Also jetzt macht er keine Schleife

1149
02:40:17,900 --> 02:40:21,820
einfach nur nacheinander, sondern jetzt macht, das sieht man es auch, wenn ich es ausführe.

1150
02:40:21,820 --> 02:40:27,460
Guckt, jetzt macht er das Parallel. Deswegen kommt es jetzt auch nicht nacheinander raus,

1151
02:40:27,460 --> 02:40:39,900
sondern hier so randomized, die Elemente. Und anscheinend gibt es das jetzt auch for

1152
02:40:39,900 --> 02:40:59,060
each Async, was tatsächlich ganz nützlich, wie funktioniert das jetzt? Ah, man bekommt

1153
02:40:59,060 --> 02:41:08,180
da mehrere Sachen. Okay, man bekommt das Int und ein Cancellation Token, ob das abgeht

1154
02:41:08,180 --> 02:41:16,020
und das heißt ich kann jetzt auch sowas da drin machen. Aber das konnte ich das konnte

1155
02:41:16,020 --> 02:41:24,900
ich vorher auch schon. Aber ich kann jetzt zum Beispiel Async Operations machen, die

1156
02:41:24,900 --> 02:41:35,900
ich abbrechen kann und sowas. Okay, ja, ich glaube, das werde ich nie verwenden. Dumme

1157
02:41:35,900 --> 02:41:42,500
Frage, aber wieso gibt es dann keine Duplikate? Warum soll es Duplikate geben? Guck mal, der

1158
02:41:42,500 --> 02:41:50,700
macht ja, der splittet sich das hier einfach auf und macht ein Thread quasi pro oder ein

1159
02:41:50,700 --> 02:41:58,460
Task pro Element. Der macht einen Task pro Element, der macht ja immer noch eins pro

1160
02:41:58,460 --> 02:42:03,900
Element, aber die Ausgabe ist halt parallelisiert. Also quasi das, was parallelisiert wird, ist

1161
02:42:03,900 --> 02:42:17,260
sowas hier. Der macht jetzt nicht zehnmal die Liste oder so. Wo das sinnvoll ist, ist

1162
02:42:17,260 --> 02:42:21,940
sowas, was ich, wenn ich jetzt hier zehn verschiedene Webseiten abfragen will oder so, dann kann

1163
02:42:21,940 --> 02:42:26,220
ich das ja parallel machen. Webseiten abfragen ist ja jetzt im größten Teil warten auf irgendwelche

1164
02:42:26,220 --> 02:42:39,180
IOR-Geschichten. Okay, aber dass es das jetzt parallel gibt mit for each Async, okay, ja,

1165
02:42:39,180 --> 02:42:49,540
okay, warum nicht? Oh, Queryable gibt es auch neues Zeug. Die haben wirklich in Windows

1166
02:42:49,540 --> 02:42:54,060
Forms Gedöns gemacht, das hätte ich nicht gedacht. Das mit Chunks finde ich wirklich

1167
02:42:54,060 --> 02:42:59,460
nice. Ja, das ist eines der sinnvollsten Änderungen, die ich da diesmal jetzt heute gesehen habe

1168
02:42:59,460 --> 02:43:14,620
bei Interop gibt es neues Zeug. Safe Buffer, Alter, irgendwelches Low-Level-Shit. Drawing,

1169
02:43:14,620 --> 02:43:24,940
Pathfix. Die haben wirklich in Windows Forms Zeug gemacht, das hätte ich nicht gedacht.

1170
02:43:24,940 --> 02:43:40,940
Low-Level-Sockets. Alles klar. Ja, gut, man muss sagen, es ist nicht viel bahnbrechendes,

1171
02:43:40,940 --> 02:43:54,220
aber die meisten der Änderungen sind praktisch. Also, ich meine, es versetzt mich jetzt nicht

1172
02:43:54,220 --> 02:43:59,380
komplett in Verzückung, da ich sage, boah, ja, noch nie da gewesen, aber es ist logische

1173
02:43:59,380 --> 02:44:04,380
konsequente Weiterentwicklung. Das finde ich gut, wie das Microsoft handelt mit C Sharp

1174
02:44:04,380 --> 02:44:13,660
und.NET. WPF ist ja bereits so makellos gewesen, oh ja. Ich muss mich mal outen, Leute. Ich

1175
02:44:13,660 --> 02:44:22,300
habe WPF immer ignoriert. Ich habe ein riesen fettes Buch WPF hier. Doch, also es hat irgendwas

1176
02:44:22,300 --> 02:44:30,660
so, dass ich 1500 sein, also das ist mega fett. Ich weiß gar nicht, wo es ist. Kann

1177
02:44:30,660 --> 02:44:36,500
das hier mal irgendwo liegen? Also, das ist wirklich ein richtig ultra fettes Buch und

1178
02:44:36,500 --> 02:44:46,020
ich habe auch angefangen, mal WPF zu lernen und ich bin mit WPF einfach nie warm geworden.

1179
02:44:46,020 --> 02:44:56,340
Ich glaube, was mich an WPF immer gestört hat, ist, dass das so extrem boilerplate heavy

1180
02:44:56,340 --> 02:45:07,540
war. Also, dass du bei WPF quasi für jeden Furz 20 Zeilen schreiben musstest oder so.

1181
02:45:07,540 --> 02:45:10,780
Mittlerweile mag es vielleicht nicht mehr so sein, aber das ging mir bei WPF echt auf

1182
02:45:10,780 --> 02:45:19,180
den Keks. Und was mich bei WPF auch genervt hat, ist, dass da so komische Meinungen im

1183
02:45:19,180 --> 02:45:25,860
Umlauf waren, wie man das jetzt machen muss. So nach dem Motto, ja, Code Behind Datei ist

1184
02:45:25,860 --> 02:45:30,860
böse und sowas. Ja, ich verstehe das ja ab einer gewissen Größe, mag das alles sinnvoll

1185
02:45:30,860 --> 02:45:35,140
sein, aber für irgendwie eine Anwendung mit drei Buttons oder so ist Code Behind doch

1186
02:45:35,140 --> 02:45:40,700
vollkommen okay. Da brauche ich irgendwie keine View Models und sonst was. Also, ich

1187
02:45:40,700 --> 02:45:51,020
hatte immer den Eindruck, WPF ist einfach der bloat in Person. Doch, der Kugelfang,

1188
02:45:51,020 --> 02:46:01,780
also ich sehe, ich mag WPF nicht wirklich. Was benutzt man sonst anscheinendst WPF? Tja,

1189
02:46:01,780 --> 02:46:07,540
das ist das alte Thema Cross-Platform GUIs oder Windows, also fahr mal mit Windows-Only-GUIs

1190
02:46:07,540 --> 02:46:13,260
an. Microsoft hat es einfach verkackt die letzten 15 Jahre. WPF ist ja von 2005 oder so, WPF

1191
02:46:13,260 --> 02:46:19,300
ist ja auch schon alt. Microsoft hat es verkackt. Microsoft dachte sich irgendwann mal sie machen

1192
02:46:19,300 --> 02:46:26,900
JavaScript und danach dachten sie sich, sie machen UWP. Und alles davon war nicht so wirklich

1193
02:46:26,900 --> 02:46:40,420
für die Realität gemacht. Das war so die typische Microsoft-Logik. Wenn man nur lang

1194
02:46:40,420 --> 02:46:48,140
genug damit rumeiern benutzt es die Leute irgendwann schon. Die haben es verkackt. Jetzt

1195
02:46:48,140 --> 02:46:56,060
so langsam aber sicher fangen sie an mit WinUI 3, was ja demnächst endlich auch native Apps

1196
02:46:56,060 --> 02:47:04,900
können soll. Also, dass man sprich ganz normale unpackaged Win32 Apps machen kann. Also, das

1197
02:47:04,900 --> 02:47:08,740
was eigentlich die ganze Welt machen will, wenn sie was für Windows machen, dass man

1198
02:47:08,740 --> 02:47:13,860
das damit jetzt machen kann, quasi mit der ehemaligen UWP GUI-Technologie, aber ohne

1199
02:47:13,860 --> 02:47:21,660
Codesigning-Zertifikate, ohne Store und ohne alles. Jetzt, da haben sie 15 Jahre für gebraucht.

1200
02:47:21,660 --> 02:47:27,700
Microsoft hat es auch im Desktop verschissen. Es gab nichts unter Windows GUI-mäßig. Du

1201
02:47:27,700 --> 02:47:35,780
hast Windows Forms gemacht oder du hast WPF gemacht. Beides hoffnungslos outdated. Ich

1202
02:47:35,780 --> 02:47:42,460
finde eines der besten Tests, ob ein GUI-Framework outdated ist oder nicht ist, ob farbige Emojis

1203
02:47:42,460 --> 02:47:48,220
funktionieren. Klar werden jetzt viele sagen, farbige Emojis, sowas braucht man nicht, aber

1204
02:47:48,220 --> 02:47:55,580
es ist ein guter Test, wie aktuell die Technologie unter dem UI-Framework ist. Alles, was keine

1205
02:47:55,580 --> 02:48:06,380
farbigen Emojis kann, ist alt. UWP kann es nicht und Windows Forms kann es natürlich

1206
02:48:06,380 --> 02:48:26,180
erst recht nicht. UWP kann es, WPF kann es nicht. Also was mich an UWP nervt, ist, dass

1207
02:48:26,180 --> 02:48:34,620
du ein Codesigning-Zertifikat brauchst, was ich nicht einsehe. Wozu soll ich mir ein Codesigning-Zertifikat

1208
02:48:34,620 --> 02:48:41,460
kaufen? Und dass du lange Zeit Probleme hattest, sowas zu machen, wie einfache Screenshots.

1209
02:48:41,460 --> 02:48:54,460
Also, normaler API-Zugriff war ja da nicht. So, das heißt, da gab es nichts. Es gibt

1210
02:48:54,460 --> 02:49:00,220
paar Cross-Plattform-GUI-Frameworks, sowas wie Qt zum Beispiel, also QT, was noch eines

1211
02:49:00,220 --> 02:49:07,860
der besseren ist. Leider zum größten Teil C++, außer man gibt sich die Python-Bindings,

1212
02:49:07,860 --> 02:49:13,020
aber selbst da kommt man wahrscheinlich mit ein bisschen, weil man Customs-Sachen machen

1213
02:49:13,020 --> 02:49:20,260
will, schlecht rum und rum und Qt dann aber auch nur QML, also nicht irgendwie Forms,

1214
02:49:20,260 --> 02:49:24,780
ich weiß gar nicht, wie es bei denen heißt, Widgets, QWidgets heißt das glaube ich, das

1215
02:49:24,780 --> 02:49:34,580
klassische. Das ist auch outdated. Also Qt 5 mit QML ist noch ganz nice. Tja, und dann

1216
02:49:34,580 --> 02:49:48,220
bleibt ja eigentlich nur noch sowas wie Electron übrig. Also, so leid es mir tut. Microsoft

1217
02:49:48,220 --> 02:49:53,580
hat es mit, Microsoft ist mit dafür verantwortlich. Ja, Flutter und Dart kommt vielleicht dann

1218
02:49:53,580 --> 02:49:57,500
noch, wenn das mal richtig auf dem Desktop ordentlich läuft mit allem, was man braucht.

1219
02:49:57,500 --> 02:50:00,620
Da setze ich ja auch so ein bisschen meine Hoffnung rein, dass vielleicht Flutter und

1220
02:50:00,620 --> 02:50:06,900
Dart sich auf dem Desktop ähnlich etabliert, wie das auf Mobile-Plattformen schon ist,

1221
02:50:06,900 --> 02:50:11,380
aber aktuell Desktop-Anwendungen, entweder man macht komplett eine Web-Anwendung, wenn

1222
02:50:11,380 --> 02:50:17,140
das möglich ist, was ja bei den meisten Sachen geht, oder man macht eine Electron-Anwendung

1223
02:50:17,140 --> 02:50:22,060
oder eine Qt-Anwendung, aber so wirklich viele Alternativen gibt es sonst nicht. Selbst

1224
02:50:22,060 --> 02:50:30,060
wenn man sagt, man möchte Windows only machen, was willst du machen? UWP sagt, WPF Windows

1225
02:50:30,060 --> 02:50:36,100
Forms ist outdated. Du kannst höchstens noch ein, zwei Jahre warten, bis WinUI 3 endlich

1226
02:50:36,100 --> 02:50:41,380
mal ordentlich funktioniert und für alles verfügbar ist. Dann hat man wenigstens wieder

1227
02:50:41,380 --> 02:50:46,420
was gescheites, aber Microsoft hat einfach 15 Jahre lang kein gescheites GUI-Framework

1228
02:50:46,420 --> 02:50:51,580
für ihre eigene Plattform hinbekommen. Das ist schon echt mies. Da muss man sagen, das

1229
02:50:51,580 --> 02:50:59,860
macht Apple besser. Linux, nicht wirklich. Linux hat dann 50 verschiedene Dinger wieder,

1230
02:50:59,860 --> 02:51:10,380
aber gut Gnome könnte man vielleicht sagen, wobei Gnome auch abfuck ist. Ich habe mal

1231
02:51:10,380 --> 02:51:16,500
ein bisschen GTK-Zeug gebastelt, das war auch abartig. Du hast im Prinzip nur Qt und dann

1232
02:51:16,500 --> 02:51:20,500
kannst du es auch gleich cross-Plattform machen, aber selbst Qt hat so seine Dank C++ so seine

1233
02:51:20,500 --> 02:51:27,740
Tücken. Es bleibt cross-Plattform eigentlich nur Elektron, wenn man es aus Entwickler-Sicht

1234
02:51:27,740 --> 02:51:33,060
so sieht, wenn man es möglichst einfach entwickelt, wenn man es irgendwie händelbar haben will.

1235
02:51:33,060 --> 02:51:37,460
Es bleibt dir eigentlich aktuell bloß Elektron übrig, was echt bitter ist, dass das beste

1236
02:51:37,460 --> 02:51:50,740
cross-Plattform-Desktop-GUI-Framework irgendein JavaScript-Browser Node.js-Verschnitt ist.

1237
02:51:50,740 --> 02:52:02,180
Das, naja. Ja, da kommst du an Elektronik wirklich vorbei. Oder du machst halt gleich

1238
02:52:02,180 --> 02:52:07,740
eine Web-Anwendung, was ja glücklicherweise für den meisten, also für den meisten Kram

1239
02:52:07,740 --> 02:52:12,820
ja geht. Da kannst du auch gleich noch eine WPA draus machen, dass du es auf dem Smartphone

1240
02:52:12,820 --> 02:52:21,700
verwenden kannst, ohne dass du jetzt irgendwie das Packagen musst im App-Store packen, außer

1241
02:52:21,700 --> 02:52:32,460
du willst es auf iOS laufen lassen. Auf iOS kannst du ja es mit PWAs vergessen, zumindest

1242
02:52:32,460 --> 02:52:48,300
wenn du so Sachen wie Notifications verwenden willst und sowas. Ja. Nee, aber GUI-Frameworks

1243
02:52:48,300 --> 02:52:57,100
ist echt richtig verkackt. Es gibt, also realistisch betrachtet, so allgemein verwenden und jeder

1244
02:52:57,100 --> 02:53:03,500
benutzt, es gibt eigentlich, realistisch gesehen, nur Elektron aktuell. Qt hat den C++-Shit

1245
02:53:03,500 --> 02:53:10,580
dabei. Und sei dann, man kommt mit allem aus, was drin ist, dann gibt es noch die Python-Variante,

1246
02:53:10,580 --> 02:53:14,780
wenn du damit zufrieden bist. Aber es ist schon echt verkackt. Und da ist Microsoft

1247
02:53:14,780 --> 02:53:19,260
mit an Schuld, weil sie 15 Jahre nichts auf die Reihe gekriegt haben auf ihrem eigenen

1248
02:53:19,260 --> 02:53:32,020
Desktop. Ja, Apple hat keinen Bock auf PWAs. Es fehlt unter iOS eigentlich nur noch Web-Notifications

1249
02:53:32,020 --> 02:53:36,500
für PWAs. Dann wäre es zumindest nutzbar. Du hast zwar immer noch ein paar Sachen, die

1250
02:53:36,500 --> 02:53:42,660
nicht ordentlich funktionieren, was zum größten Teil aber an verkackten Safari liegt, aber

1251
02:53:42,660 --> 02:53:47,660
wenn du Web-Notifications hättest, dann könntest du zumindest sagen, du kannst mehr oder weniger

1252
02:53:47,660 --> 02:53:57,100
mit PWAs das Wichtigste machen auf iOS. Aber kann man, wenn man eine Elektron-Anwendung

1253
02:53:57,100 --> 02:54:02,100
baut, nicht auch gleich eine Web-Anwendung bauen? Das ist tatsächlich der Vorteil. Du

1254
02:54:02,100 --> 02:54:06,500
kannst zum Beispiel so machen wie Discord, du machst eine Web-Anwendung, aber wenn du

1255
02:54:06,500 --> 02:54:13,500
bessere Native-Plattform-Integration brauchst, was ich, Sound-Lautstärke kontrollieren oder

1256
02:54:13,500 --> 02:54:16,860
sonstige Geschichten, dann machst du es wie Discord. Dann bringst du ein Desktop-Klient

1257
02:54:16,860 --> 02:54:26,220
raus, wo du im Prinzip deine Web-Anwendung in ein eigenes Fenster packst. Wobei Discord

1258
02:54:26,220 --> 02:54:32,860
noch deutlich mehr macht. Discord hat ja noch Native Extensions in wahrscheinlich C oder

1259
02:54:32,860 --> 02:54:38,900
C++ für Discord, die bei ihrem Client mitkommen, die sich dann irgendwie Node.js da reinhucken

1260
02:54:38,900 --> 02:54:51,820
oder so. Wie gesagt, Discord ist Elektron, allerdings mit ein paar Zusatzdingern. Deswegen

1261
02:54:51,820 --> 02:54:58,620
läuft es ja auch im Browser, aber halt manche Sachen gehen nicht im Browser. Also man muss

1262
02:54:58,620 --> 02:55:04,580
sagen, das ist der eigentliche Weg, anders kann man das heutzutage gar nicht machen.

1263
02:55:04,580 --> 02:55:09,620
Und es ist halt mit Microsoft schuld, dass es da 15 Jahre verkackt wurde auf dem Desktop.

1264
02:55:09,620 --> 02:55:18,020
Es bleibt den Leuten ja gar nichts anderes übrig, als einfach nur noch Gigabyte RAM-fressende

1265
02:55:18,020 --> 02:55:39,700
Browser überall zu verschiffen für einfachste Dinge. Ja gut, Leute. Doch wir haben alles

1266
02:55:39,700 --> 02:55:47,820
ausprobiert, was wir ausprobieren konnten, hätten können. Ist da irgendwas in Plano

1267
02:55:47,820 --> 02:55:53,680
von Microsoft? Ja, wie gesagt, es gibt von Microsoft WinUI 3, aber die sind auch wieder

1268
02:55:53,680 --> 02:56:03,460
ziemlich realitätsfern unterwegs. Also WinUI 3 ist ja, ist es jetzt in diesem Bereich

1269
02:56:03,460 --> 02:56:12,860
untergekommen oder was? WinUI 3 ist ja quasi mehr oder weniger die UWP GUI Technologie

1270
02:56:12,860 --> 02:56:18,700
umgebaut, dass sie auch von nicht-UWP-Anwendungen verwenden können, verwendet werden können.

1271
02:56:18,700 --> 02:56:25,340
Aber sie sind auch schon wieder ziemlich realitätsfern unterwegs, weil du immer noch Code-Signing-Zertifikate

1272
02:56:25,340 --> 02:56:30,980
und so einen Scheiß brauchst. WinUI 3 für Unpackaged Win32-Apps sollte es schon vor

1273
02:56:30,980 --> 02:56:36,940
über einem halben Jahr geben und sie kriegen es nicht gebacken. Also es ist echt abartig.

1274
02:56:36,940 --> 02:56:49,020
Windows-App-SDK, okay. Haben die jetzt schon eine Version rausgebracht, wo Unpackaged-Apps

1275
02:56:49,020 --> 02:56:54,820
funktionieren? Dann ist es mal wieder Zeit, dass ich mir das angucke. ImGui ist nur für

1276
02:56:54,820 --> 02:57:01,180
verschiedene... naja, das ist Stateless, das ist irgendein Stateless-Overlay-Mahlprogramm,

1277
02:57:01,180 --> 02:57:08,500
das ist kein GUI-Framework. Also mit diesen ganzen, wie heißt das, Intermediate-GUI-Zeichen-Dinger,

1278
02:57:08,500 --> 02:57:14,420
da kannst du vielleicht in einem Game malen, ein Hauptmenü malen oder so. Aber sicherlich

1279
02:57:14,420 --> 02:57:23,060
keine Anwendung für den Desktop. Unpackaged geht es aber noch sehr... ja, da warte ich

1280
02:57:23,060 --> 02:57:27,700
noch drauf. Dann ist Microsoft endlich mal wieder in der Realität angekommen, was die

1281
02:57:27,700 --> 02:57:36,900
Leute eigentlich haben wollen. Muss ich mir mal angucken. Oh, ist DirectDraw. Ist DirectDraw

1282
02:57:36,900 --> 02:57:41,460
aber unterstützt? Ach, kein Stimmer. Aber Microsoft hat es echt... MAUI wird, glaube

1283
02:57:41,460 --> 02:57:47,740
ich, auch Paint-Champing, da habe ich wenig Hoffnung. MAUI ist ja quasi Xamarin, wie

1284
02:57:47,740 --> 02:57:54,420
auch immer man das ausspricht, nur ein bisschen unbenannt. Im Kern ist es ja noch das Gleiche.

1285
02:57:54,420 --> 02:57:59,860
Es wird schon mal keine Linux-Unterstützung geben, was ich sehr pepega finde. Also da

1286
02:57:59,860 --> 02:58:06,300
kann man ja nicht wirklich von Cross-Plattformen sprechen. Und ich finde den Xamarin-Ansatz

1287
02:58:06,300 --> 02:58:13,060
auch nicht gut im Vergleich zu Flutter zum Beispiel. Flutter macht das richtig. Flutter

1288
02:58:13,060 --> 02:58:20,740
sagt, wir nehmen uns irgendeine Low-Level-Grafik-Technologie, die auf der jeweiligen Plattform verfügbar ist,

1289
02:58:20,740 --> 02:58:28,420
von Vulkan bis DirectX, bis OpenGL, bis Metal, bis was auch immer. Oder Dings hier. Skia

1290
02:58:28,420 --> 02:58:36,900
heißt das, glaube ich, wo die das dann machen in Flutter. Und wir malen unser GUI halt selbst,

1291
02:58:36,900 --> 02:58:42,300
dann sieht das überall gleich aus. Xamarin macht so ein Hybrid-Ding, das versucht, die

1292
02:58:42,300 --> 02:58:54,580
jeweiligen Controls der Plattform zu verwenden. Was kacke ist, meiner Ansicht nach. Oh ja,

1293
02:58:54,580 --> 02:59:08,700
unbedingt. Und dann joinen wir bei Attila Hildmann in Telegram rein. Wireless. Ja,

1294
02:59:08,700 --> 02:59:17,100
sehe ich genauso. Ich habe Vodafone. Vodafone 400 MBit, ist auch nicht so der Wahnsinn. Aber

1295
02:59:17,100 --> 02:59:31,300
das einzige Sinnvolle, aber das einzige Sinnvolle, weil die Telekom hat bei mir, glaube ich,

1296
02:59:31,300 --> 02:59:41,460
maximal 50 MBit oder so. Halt's vergessen. Ja, nee, nee, ist so. Ist so. Was Skia dann

1297
02:59:41,460 --> 02:59:45,220
unten drunter macht, weiß ich nicht. Ich gehe mal davon aus, die werden ja auch,

1298
02:59:45,220 --> 02:59:53,380
die müssen ja auch irgendwas verwenden. Weil ich kenne keinen Grafik-Treiber, der Skia kann. Also

1299
02:59:53,380 --> 02:59:57,580
im Endeffekt muss ja unten, muss es ja irgendwas sein, was da noch drunter kommt.

1300
02:59:57,580 --> 03:00:16,660
Dazu kann ich nichts sagen. Von Java habe ich keine Ahnung. Ich habe auch noch nie eine

1301
03:00:16,660 --> 03:00:23,740
Swing GUI-Anwendung programmiert. Habe ich auch nicht vor. Sieht halt hässlich wie die Nacht aus,

1302
03:00:23,740 --> 03:00:42,540
aber wahrscheinlich funktioniert es. Also was, AWT? Ich weiß nicht, was ist AWT?

1303
03:00:42,540 --> 03:01:03,740
Abstract Window Toolkit. Ja, das ist exzellent. Das sieht ja mal richtig aus wie 2021. So stelle

1304
03:01:03,740 --> 03:01:17,420
ich mir GUI-Anwendung vor heute. Oh, das wird noch ein bisschen dauern. Ja, nur dass die kaum

1305
03:01:17,420 --> 03:01:21,500
Bedienelemente haben und wahrscheinlich das meiste selbst machen. Das ist ja das Witzige.

1306
03:01:21,500 --> 03:01:28,540
Die haben ja im Prinzip nicht wirklich jetzt hier viel drinne. Und auch nichts, was groß gestylt ist

1307
03:01:28,540 --> 03:01:33,820
oder so. Die haben ihren Erinnerung, die haben die garantiert selbst gemacht. Und ansonsten der Rest

1308
03:01:33,820 --> 03:01:45,020
ist eigentlich zum größten Teil Menüs und Menüs. Aber das hier haben die bestimmt selbst gemacht.

1309
03:01:45,020 --> 03:01:51,100
Allein schon das Font-Rendering hier ist richtig gut. Was ich da bisher von manchen Swing-Anwendungen

1310
03:01:51,100 --> 03:01:53,700
gesehen habe, da sah das Font-Rendering bei weitem nicht so gut aus.

1311
03:01:53,700 --> 03:02:11,780
Naja. So Leute, ich würde sagen, jetzt sind wir ein bisschen schlauer. Ich habe was gelernt.

1312
03:02:11,780 --> 03:02:23,540
Ich hoffe ihr auch. Ich glaube, ich gehe jetzt erstmal auf. Gibt es irgendjemand zum Hosten?

1313
03:02:23,540 --> 03:02:35,220
Das macht eigentlich. Was macht eigentlich der Frazier?

1314
03:02:35,220 --> 03:03:00,660
Er spielt immer noch seine Weep-Games hier. Alles klar. Na gut Leute, dann sehen wir uns.

1315
03:03:00,660 --> 03:03:05,220
Macht's gut. Bis dann. See you.

