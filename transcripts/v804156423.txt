So, erstmal ne Runde husten, ich weiss auch nicht warum ich dazu jetzt warten muss bis
das Stream angeht.
Aber wollte vorher nicht.
Massive Poggersound.
Moin Marc, Jojo Moink.
Kussi ist auch da, Relax ist auch am Start, jetzt kommen sich alle.
So, ich zeige euch mal was, wusst ihr das Windows mittlerweile, ähm, proprietäre Emojis
hat?
Wie sieht bei euch der Titel aus, guckt mal.
Wie sieht bei euch der Titel vom Stream aus, warte mal, ich muss mal kurz Musik ein bisschen
leiser machen.
Tja, passt mal auf, Windows hat proprietäre Emojis, schaut mal.
So sieht der Titel bei einigen von euch aus, jetzt guckt mal an wie das unter Windows aussieht.
Tja, unter Windows sieht das so aus.
Microsoft hat es tatsächlich geschafft proprietäre Windows-only Emojis zu designen.
Ich habe eigentlich gedacht Microsoft wäre aus dieser Zeit raus, wo sie proprietäre
Windows-only Sachen gemacht haben, aber dieses ist ein Windows-only Emoji.
Ja, copy-paste in Twitch-Channel ergibt das, weil Twitch das Searching replaced durch
eigene Emojis.
So sieht es im Titel aus und in Wirklichkeit ist es aus zwei Emojis zusammengesetzt.
Lustig, oder?
Dass es proprietäre Windows-only Emojis gibt.
Gut, in dem Fall wundert es mich nicht, wenn das eine Katze mit Stirnband und Windows-Logo
ist, aber trotzdem.
Ich habe nachgeguckt, das ist irgendwas, was zum Windows-Jubiläum gekommen ist von Microsoft,
was auch immer.
Ich habe es aufgegeben zu versuchen nachzuvollziehen, was Microsoft da manchmal treibt.
So, wir gucken uns jetzt mal ein paar neue, die neuen C-Sharp-9-Features an.
Das ist gar nicht so viel, auch wenn die Seite lang aussieht, aber das ist große Schriftgröße
und es ist nicht so viel wirklich Tolles.
Ich habe schon mal grob drübergescrollt vorhin und ich habe auch schon vor einem Drittel
oder so, vor einem Jahr mal einen Webcast dazu gesehen.
Das gucken wir uns jetzt mal an.
Also ich habe jetzt das neue.NET 5 installiert.
Ich habe die Rider-Test-Version installiert, also sprich das hier, hier Rider-2020-3-EAP-7,
das hat.NET 5 Support.
Ich finde es ja ein bisschen schade, dass es nicht geschafft haben zum Release von.NET
5 das fertig zu bekommen, aber wahrscheinlich hat Microsoft den auch gar nicht erzählt,
wann eigentlich Release von.NET 5 ist.
Denke ich mal.
Wow, ein bisschen groß vielleicht.
Ein bisschen Chat auf, ne, Chat, so, dass wir nichts übersehen.
Gut, genau, also wie gesagt, diese Windows-Only-Emojis wollte ich euch mal zeigen und ich würde
sagen, wir können auch mehr oder weniger gleich anfangen, gucken, was es so gibt.
Ich muss da selbst ein bisschen drüber, wie gesagt, ich habe schon vorher mal drüber
gescrollt, aber ein bisschen in Ruhe mir das angucken, weil mir manche neuen Features selber
ein bisschen schleierhaft noch sind, wozu man die benutzen soll.
Zum Beispiel das erste Feature, nämlich Record-Types.
Also, bis jetzt, ich zeige euch erst mal, wie es bis jetzt in.NET, bzw. in C-Sharp
funktioniert.
WistleBasic.NET, lasst mal mal außen vor, den ganzen Müll, da kann man, ja, und F-Sharp
weiß ich auch nicht, wie es funktioniert.
F-Sharp habe ich mal so ein Einsteiger-Tutorial gemacht an Schkalusten, funktionale Sprachen
sind einfach nix für mich.
Ich habe mich auch schon mal an, äh, ne, nicht Skala Erlang versucht, ähm, also mir
reicht, mir reicht das, was Funktionales in C-Sharp drin ist, oder kann es ja auch in
Ruby und Groovy ein bisschen Funktionales machen, aber wirklich diese Hardcore-Funktional-Sprachen,
ich werde damit nicht warm, also weder mit F-Sharp noch mit Erlang noch mit Skala noch
mit Haskell oder mit irgendwas anderem, das ist irgendwie nicht meine Welt.
Ich habe es mir schon lange vorgenommen, mir das Ganze mal anzugucken, aber, äh, warum
ich das ein bisschen scheue ist, so, ist folgendermaßen, warum ich, also warum ich mich ein bisschen
davor drücke, mich mal mit Funktional-Programmiersprachen zu beschäftigen, weil ich weiß jetzt schon,
dass ich das eigentlich nicht wirklich auszahlen werde, in Form von, dass man das, was ist,
was man wirklich sehr oft verwendet, das ist eher was, was man mal bei speziellen Problemen
rausholt und jetzt nicht so Daily, wie sagt man so, Daily-Triver, ja, ähm, deswegen bin
ich, wenn ich sehe, ob sich das wirklich lohnt, auf der anderen Seite, ich mach so viele Sachen,
die sich überhaupt nicht lohnen, einfach nur weil's mir gefällt, also insofern, warum
da nicht auch, hä? Ja man, C++ Beste, Kappa HD, Golden Kappa Check. C++ ist das Beste
im Schlechtsein, also quasi das Beste von unten. Okay, legen wir mal eine Konsolenanwendung
an und gucken uns mal an, was es hier so alles gibt. Exzellent. So, das blenden wir jetzt
mal aus, das machen wir auf einen anderen Desktop, wobei eigentlich kann ich den ganzen anderen
Müll mal wegmachen, ne? Ich lösche den ganzen Krams mal hier. So, Browser können wir auflassen,
das lassen wir auf, das verschieben wir auch mal zu, das verschieben wir auf drei, machen
so, ja, exquisite Platzeinteilung, Rider, genauso muss es sein. Gut, wunderbar, dann
gehen wir jetzt hier nach Rider, Projects, QtChat,.net watch run. What? Ah. So, gucken
wir uns das Ganze mal an. Ah, Moment, Moment, ich darf nicht.net watch run machen, ich
muss machen.net,.net SDK,.net watch run, weil ich will ja.net 5 und nicht 3.1 verwenden,
ich habe ja beides installiert, ich habe ja.net 5 erstmal als Snap installiert und Rider
als Early Access, oder wie sie es heißen, wie sie es nennen, und das gibt es noch nicht
im offiziellen Paketmanager, sind noch nicht so schnell. So, und das können wir hier auch
rüber machen und da wieder auf. Machen wir mal ein bisschen größer. Wow. Okay, vielleicht,
vielleicht doch nicht so groß, so, so, so, reicht. Der Bauer hat den Cryokühler auf
den Risen gepappt, das haben wir uns doch heute noch angeguckt. Jeder, der das jetzt
schreibt, ist zu früh im aufwachen Stream abgehauen. Das Video haben wir uns noch angeguckt.
Chat, bin ich aufgepasst wieder. Tja. Okay, fangen wir mal an, gucken wir uns das mal,
gucken wir uns das mal in Ruhe an. Also, es gibt jetzt Record Types, bisher in C Sharp,
nur mal so zur Erklärung gibt es das ja folgendermaßen, es gibt zwei verschiedene, grundsätzliche,
ja, wie soll man es nennen, nicht Typen, doch grundsätzlich verschiedene Typen gibt es
in C Sharp, zwei Stück. So, das sind einmal, wir machen das mal hier unten, da machen wir
ein bisschen Platz, so, das ist nicht hier, äh, gut, chat, ah ja, ja, so, ab hier geht
es los. So, es gibt ja in C Sharp zwei, vielleicht machen wir mal ein bisschen Erklärbeerstream,
gibt es ja zwei unterschiedliche Typen. Es gibt einmal Classes und es gibt für die Oldschool
Leute und es gibt Strucks. So, und, ähm, der Unterschied ist auf den ersten Blick gar
nicht so groß, aber wie gesagt, auf den ersten Blick. So, also man kann da mehr oder weniger
ähnliche Sachen drin machen, in so einer Klasse oder in einem Struct, also zum Beispiel,
ich kann da drin irgendwelche Methoden anlegen, sowas wie Public, also wir machen jetzt mal,
wir machen jetzt mal so die, wirklich die Low-Brain-Einsteiger-Examples, weil sonst bin ich zu, zu, zu, nicht
genug Brainpower, um mir welche auszuheilen, also wir machen jetzt sowas wie, keine Ahnung,
Door, so, oder haben wir sowas wie Open zum Beispiel drin, so. Ähm, das kann man, das
kann man übrigens in Structs und Classes machen, das ist kein Problem. So, also auf
den ersten Blick unterscheidet sich das gar nicht mal so großartig. Der eigentliche Unterschied
zwischen Classes und Structs ist folgender, dass Classes, also, also wenn ich jetzt was,
wir machen das jetzt einfach mal, so, wir machen das hier, myStruct, ah, ohje, keine
Ahnung, ohje, myClass, meistens eigentlich ganz guter Name, dann passt das, dann passt
das nämlich ganz gut. So, wenn ich die, wenn ich die jetzt anlege, so, sowas hier, bar,
myClass, so, immer, wir machen, beste, beste Variab, beste Variab in dem A, B gleich new,
myStruct. So, jetzt ist die Frage, was passiert, was passiert hier? So, was passiert bei wem?
Sieht ja erst mal relativ gleich aus. Man legt hier eine Instanz von Klasse an und man
legt hier quasi eine Instanz von myStruct an. Wenn ich jetzt die Class zuweis in einer
anderen Variabel, dann passiert hier eigentlich nix weiter. Es wird einfach, so, einen Link
erzeugt, das kann ich, das kann ich euch zeigen, zum Beispiel, wir machen jetzt hier
mal ne public, wie kommen wir mal, public int, ähm, keine Ahnung, test, so, ähm, so,
das ist, wir machen hier zwei public Variablen, test, wir machen hier keine Ahnung, test ist
null, ach nee, Moment, kann man das standardmäßig gar nicht so zuweisen? Kann man das standardmäßig
nicht zuweisen? Okay, ist egal. So, ähm, wenn ich jetzt sage, bei der Klasse, wir machen
das erstmal mit der Klasse, so, wenn ich jetzt sage, a, test ist gleich eins, so, dann können
wir uns hier ausgeben, am Anfang, am Anfang ist test null, also das ist, null ist glaub
ich default für int, so, danach ist test eins, guckt euch das mal an, erst ist test
null, dann ist test eins, also, genauso, wie man das ganze erwarten würde, Highkicks,
also was, wir gucken uns die 90 sharp Features an, was vor ein paar Tagen rausgekommen ist,
Mark Jojo, genau, danach, danach wird, danach kommt der Test, danach wird abgefragt, jetzt
Prüfung, so, also man sieht, da kommt null und eins raus, das ist ja eigentlich auch
so, wie man es erwarten würde, jetzt kommt allerdings der Trick, was passiert denn jetzt,
wenn ich sowas hier mache, b ist gleich a, was ist jetzt, was ist jetzt in b.test drinne,
was meint ihr? Also, ich nehme a und weiß, dass b zu und dann gucke ich, was in test
drin steht, da ist natürlich immer noch eins drin, weil das haben wir ja vorher reingeschrieben
und a ist ja, b ist ja nur ein Zeige auf a, aber jetzt kommt, jetzt kommt der Knackpunkt,
was passiert denn, wenn ich jetzt sowas hier mache, b, test, gleich 100, dann ist b test
100, aber, und jetzt kommt der Witz, a test ist auch 100, also sprich, das hier, b ist
einfach nur ein Zeige auf a, so, mit einem Struct sieht das schon wieder anders aus,
wenn wir das Ganze jetzt nochmal machen und nehmen jetzt hier mal my struct, das muss
ich jetzt mal ein bisschen als Intro erklären, dass man vielleicht das neue Feature besser
versteht, weil ich kapiere es selbst noch nicht so genau, so, wenn man das Ganze jetzt
mal mit structs macht, wir können das Ganze jetzt mal ein bisschen abkürzen, so, ich
klicke jetzt ein neues Struct und dann sage, a ist gleich, a ist gleich links, so, jetzt
sage ich a test ist gleich 100, oder a test, bleiben wir bei, ist gleich 1, so, gebe ich
das hier aus, wunderbar, noch nichts neues, aber jetzt, jetzt kommt der Witz, sage ich
jetzt b test gleich 100 und gebe b aus, dann ist das auch noch alles ok, aber, wenn ich
jetzt a test ausgebe, werdet ihr feststellen, tja, hoch, das scheint anders zu funktionieren,
nämlich da ist a noch 1, ja, und deswegen, das ist der hauptsächliche Unterschied, also
sprich, wenn ich eine Klasse habe, dann ist das hier immer eine Referenz und ein Struct
wird immer kopiert, das heißt, sobald ich das hier mache, hat b nichts mehr mit a zu
tun, das ist so der grundsätzliche, der basic Unterschied zwischen Structs und Classes,
wer braucht sowas, du brauchst Leute, die sowas können, dass du dein tägliches Smartphone
Zeug spielen kannst, dass du fortan ein Mobile spielen kannst, brauchst du das, und zumindest
indirekt, so, so weit zur Erklärung der ganzen Geschichte, also sprich, Structs werden immer
kopiert und Classes sind immer Referenzen aufeinander, das hat natürlich den großen
Vorteil oder auch einen Nachteil, je nachdem, wie man das sieht, hier muss ich immer was
kopieren, wenn ich das übergebe oder zuweise oder sonst was, sprich, ich muss permanent
was kapieren, und hier übergebe ich einfach nur eine Referenz, was natürlich auch heißt,
die Sachen verändere ich immer automatisch mit und hier bleibt das Original unberührt,
so, das ist so der grundsätzliche Unterschied, ich weiß, die Kenner werden jetzt anfangen
von wegen Heap und Stack und sonst was, das ist erstmal vollkommen egal, das grundsätzliche,
was man wissen muss, Structs werden kopiert und Klassen werden referenziert, exzellent,
so und jetzt können wir uns mal das neue Feature angucken, das habe ich nämlich selbst noch
nicht so ganz gecheckt, Structs sind für Boomer, das würde ich tatsächlich teilweise
so unterschreiben, weil ganz ehrlich, Structs verwendet man sehr selten, es gibt einen großen
Unterschied, den ich noch zeigen muss zwischen Structs und Classes und Structs, den ich
noch nicht gezeigt habe, so, also, wir machen jetzt mal eine Klasse, wir machen jetzt mal
hier, keine Ahnung, Struct 1 und Struct 2, so, was meint ihr, was hier rauskommt?
Wobei, ich fange mal, ich fange, vielleicht fange ich besser anders an, ja, doch, machen
wir es mal, was meint ihr, was hier rauskommt, bei dem Check, wenn ich checke, achso, darf
ich so ja gar nicht, äh, okay, Equals, machen wir es so, was meint ihr, was bei dem Check
rauskommt, wenn ich gucken will, ob Struct 1 gleich Struct 2 ist, tja, noch kommt da
True raus, noch kommt da True raus, warum?
Weil die Werte innerhalb dieses Structs in beiden Structs gleich sind, so, mache ich
Struct 1, Test gleich 5, dann wird da False rauskommen, also sprich, wenn ich überprüfe,
ob zwei Structs gleich sind, da werden immer die Werte miteinander überprüft, ob die
gleich sind, so, und jetzt machen wir das nochmal mit den Klassen, jetzt, jetzt, äh,
okay, ich pendenze mal um, so, was meint ihr, was da jetzt rauskommt?
Jetzt können wir, jetzt können wir übrigens hier auch gleich, gleich machen, ja, was
wird, achso, ja, das sind wir gleich, tja, da kommt jetzt False raus, so viel kann ich
euch schon mal spoilern, aber, und jetzt kommt der große Unterschied zu Structs, wenn ich
das hier jetzt wegmache, also sprich, jetzt sind ja die Werte zwischen Class 1 und Class
2 exakt gleich, ich hab bei keinem die Werte verändert, jetzt ist das immer noch False,
warum?
Genau, was der Void Danny sagt, zwischen Klassen wird die Referenz verglichen, also
sprich, zeig das hier mal ganz, einfach gesagt, zeig das hier auf den gleichen, äh, Startpunkt
im Speicher, wenn ja, dann ist das die gleiche Instanz und es ist true, ansonsten zwei unterschiedliche
Klasseninstanzen, wenn du die miteinander vergleichst, sind immer False, bei Structs
ist es umgedreht, Structs ist eigentlich ziemlich wurscht, wo die ganzen Sachen im Speicher
verliegen, Structs werden immer die Werte überprüft, also sprich, mit Structs lässt
sich zum Beispiel relativ gut alles abbilden, was irgendwie so eine Art Wert ist, also zum
Beispiel ein Datum oder so, oder irgendwie eine Uhrzeit, oder ein Intervall, oder sowas
in der Richtung, ja, weil es ist so, wenn ich zum Beispiel eine Klasse habe für Uhrzeit,
oder einen Struct habe für Uhrzeit und ich will überprüfen, Uhrzeit 1 ist Uhrzeit 1
gleich Uhrzeit 2, dann will ich nicht überprüfen, ob das im Speicher die gleiche Adresse ist,
sondern ich will wissen, ist das quasi logisch gesehen von den Zahlen her der gleiche Wert,
so dementsprechend, wenn bei Structs Werte überprüft miteinander und bei Klassenreferenzen.
So und jetzt kommt der Bits, was das bei C Sharp auch ein bisschen schwammiger macht,
man kann, ich lösche das Struct mal, was man machen kann, also wir wissen jetzt ja,
dass hier ist False, das wissen wir jetzt ja, also wir wissen, wir machen mal, ich mach
mal hier so einen Start, dann sieht man es besser, Start und Ende, so, dann sieht man
nämlich hier im Terminal besser, was Sache ist, so, also das wissen wir ja, das hier
ist eine Referenz auf eine Instanz von Klasse, das hier ist auch eine Instanz, eine Referenz
auf eine Instanz von Klasse, so und die sind nie, die sind nie gleich, weil es sind unterschiedliche
Referenzen, unterschiedliche Adressen im Speicher, was man jetzt machen kann in C Sharp ist folgendes,
man kann sagen, ich muss ehrlich sagen, ich hoffe ich krieg's aus dem Kopf hin, weil
man macht das nicht sehr oft, kann man sagen Over, nee, Overwrite, Equals und dann kann
man das Ganze ein bisschen faken, also sprich ich kann überschreiben, wie sich das hier
verhält und ich kann auch ne Klasse so programmieren, dass sie sich ähnlich wie den Struct verhält
beim Vergleich, wo man sich natürlich dann die Frage stellen muss, okay, macht das Sinn,
das ist natürlich von, wie machen wir das jetzt eigentlich, Return, wie funktioniert
das jetzt überhaupt nicht, ich mach das so selten, ich glaub man braucht hier dann irgendwie,
man muss das glaube ich casten, ne, da muss man irgendwie sagen, my class, ist das richtig,
man muss das irgendwie casten, also das heißt ich muss dann sagen, keine Ahnung, i, das
da, irgendwie sowas in der Richtung kann man glaube ich machen, so und jetzt werden
wir sehen, das ist immer noch falsch, was hab ich verkehrt gemacht, was hab ich falsch
gemacht, warum kommt da jetzt nicht True raus, ach ich muss Dings überschreiben, ich muss
noch gleich gleich überschreiben, jetzt kommt True raus, so und wie überschreibe ich jetzt,
wie überschreibe ich jetzt gleich gleich, das geht auch irgendwie, ja ich überleg mir auch
wie man das generieren kann, wie kann man das denken, ach hier kann man den bestimmt
sagen, ich möchte da noch generate, wow, what the fuck, und das funzt jetzt, ne, das war
ich falsch auf meinen Basics, ach man muss den Operator überladen, ach stimmt, das macht
man so selten, ja, man muss den Operator überladen, also sprich ich muss jetzt machen, was Publix
ist, Static, Bool, Operator, ernsthaft so, ach du große Scheiße, das mach ich ja nie,
und wie geht das jetzt, C Sharp, Class, Overload, Equals, sieht man mal wie oft man sowas macht,
so geht es schon mal nicht, Operator, ja, excellent, ok, wir Copy Pasting, Stack Overflow, wir wissen
ja, Stack Overflow, Copy Pasting ist prinzipiell die beste Antwort auf alle Sachen, ok, Return,
Object 1, wobei ne, ich kann doch da jetzt aufrufen, Equals, oder, wir machen das jetzt
hier einfach noch mal, aber ich kann sowas, mach du das so, ne, das geht nicht, warum geht
das nicht, ah, man muss Matching, aha, aha, oh, komm mal hier, Big Brain, man muss beides
überschreiben, jetzt kommt True raus, ok, alles klar, das ist übrigens auch ne Sache,
was ich an C Sharp mag, beziehungsweise an der Philosophie, was Microsoft macht, dass
die hier gleich sagen, ok, wenn du Equals überlädst, oder beziehungsweise den Gleichgleich
Operator überlädst, du musst auch ungleich überladen, weil es wäre ja so komplett wir,
wenn auf einmal das da True wäre und das da auch True wäre, das würde ja überhaupt
keinen Sinn ergeben, das kann man höchstens machen, um die Leute zu trollen, ja, so, also
man sieht, man kann auch Klassen fabrizieren, die sich ein bisschen wie Struts anfühlen,
aber der grundsätzliche Unterschied zwischen Klassen und Struts bleibt, Struts werden immer
kopiert und Klassen sind immer quasi Verknüpfung, ja, Referenzen aufeinander, das muss man wissen
und manchmal ist es tatsächlich sinnvoller einen Strut zu nehmen, aber meistens in, ah
man, 99% der Fälle sind es eigentlich Klassen, die man nimmt, so, und jetzt können wir uns
das neue Feature angucken, nämlich, es gibt jetzt sowas Neues, das ist quasi ein Strut
als Klasse, soweit ich das verstanden habe, ich bin da nämlich im Vorfeld schon mal drüber
gescrollt und zwar, es gibt jetzt Record Types, also sprich, bisher gab es ja in Public Strut,
Strut, also bisher gab es ja in C Sharp nur Klassen und Struts und jetzt gibt es quasi
eine verkappte Klasse als Strut, die, also, ja doch, eine Klasse, die so tut, als wäre
es ein Strut, die quasi genau das macht, was ich eben gemacht habe, aber schon standardmäßig,
also sprich, Record Types sind, soweit ich das verstanden habe, die legt man übrigens
so an, also wir können das ja mal kurz copypasten, wie die das hier machen, so, das ist jetzt
neu, also das gibt es erst seit 5 Tagen oder so, oder seit 2 Tagen, oder wie auch immer,
ich glaube seit 5 Tagen gibt es das erst, so, das ist jetzt neu, also sprich, was das
macht, ist, dass da unten können wir uns glaube ich sparen, das ist der Constructor hier,
ja, wir machen das mal kurz weg, so, das ist jetzt ein neuer Typ, und zwar, der überschreibt
das ganze jetzt, also ich kann jetzt quasi sagen, New, Rec 1, Rec 2, New, das ist jetzt
wie gesagt, das ist das erste Mal, dass ich das verwende, schauen wir mal, und wir machen
jetzt auch wirklich nur noch sowas hier, so, also, my record 1, my record 2, Rec 1 gleich
Rec 2, und jetzt wird mir sehen, es ist true, 0W, so, also sprich, den Record ist ne Klasse,
die schon Equals überschrieben hat für mich, also quasi das hier, was ich eben von Hand
gemacht hab, dieser Schmodder hier, den ich hier eben von Hand gemacht hab, den macht
Record schon für mich, warum will man sowas haben, ich habs auch erst nicht kapiert ehrlich
gesagt, und ich bin mir da noch immer noch nicht hundertprozentig sicher, aber ich denke
mal, das liegt daran, wenn man sowas hat, was eben, so gewisse Wert, wo so die Zahlen
geht, die drin gespeichert werden, nicht so sehr ob es ne Referenz ist oder nicht, aber
ich trotzdem es nicht bei jedem Aufruf kopieren will, also sprich, wenn ich aus Performance
Gründen keine Structs verwenden mag, aber ich von der Vergleichlogik her eigentlich
das verwenden will, was Structs machen, so, und deswegen haben sie das wahrscheinlich
auch Record genannt, oder sie hätten es auch Data oder so nennen können, also sprich,
um zu symbolisieren, dass es bei dieser Klasse nicht um die Methoden und sonst was geht,
die man implementiert, sondern eigentlich hauptsächlich um die Daten, die drin enthalten
sind, so, und was man jetzt damit noch großartig machen kann, muss ich mir angucken, weil hab
ich auch keine Ahnung von, genau, ach ja stimmt, man kann Records glaube ich gar nicht ändern,
ne, das ist ja das nächste Feature, was ich, so wie ich das gesehen hab, ich glaube man
kann Records nicht ändern, also was ich jetzt, ich kann doch sowas hier nicht machen, oder?
Oh doch, kann ich, warum geht das?
Ich dachte, das geht nicht, ich dachte, das ist der Sinn davon gewesen, dass das nicht
geht.
Okay, das kann man nicht, das darf man nicht wie Public Variable machen, das muss man
wohl mit irgendwelchen Properties machen.
Die große Preisfrage ist, Moment mal, REC 1, ob der das überhaupt macht, okay, okay,
wir lesen mal den Text dazu, was die geschrieben haben, also, wie gesagt, ich hab mich da nicht
großartig mit beschäftigt, zumindest, was ich in dem Webcast gesehen hab, ist, dass
eines der neuen Features von Records im Vergleich zu Structs und Klassen ist, dass man sie
immutable machen kann, also sprich, dass ich, nachdem ich sie angelegt hab, sie nicht mehr
ändern kann.
Was zum Beispiel, wenn man Multi-Threading macht, ganz nützlich ist, so, ähm, so,
also, das muss ich mir jetzt mal durchlesen, was verschreib ich denn mal, so, also, was
machen wir hier in dem Beispiel, sie legen den Record an, mit zwei Properties, die, ach,
die Get Only sind, ah, ich glaub, jetzt versteh ich das, okay, das probieren wir jetzt mal
mit dem Beispiel aus, von denen hier, also, legen wir mal den Record an, also, Persons
sind immer so dieser, alter, übelste Knees-Action, Persons sind immer so der Standard-Test von
denen, irgendwie, so, und da muss ich jetzt angeben, was First und Last Name, okay, First
Name, Max, Last Name, Q-Chat, so, und jetzt kann ich die Glaube nicht mehr ändern, ne,
ah, genau, jetzt geht das nicht mehr, okay, also sprich, wenn ich das so mache, wie die
das jetzt zeigen, also sprich, mit diesen, ähm, Get Only-Properties, dann funktioniert
das nicht, so, was ganz praktisch ist, wenn ich sicherstellen will, dass nachdem die Sache
initialisiert wurde, sie sich nie wieder ändern kann, was man jetzt, glaub ich, machen kann
ist sowas hier, ne, warte mal, wie ging das, With, da muss ich die Syntax mir mal angucken,
ach, so, genau, das geht, also sprich, man kann, hm, okay, also, also, also, also, also,
okay, dann hab ich das noch nicht so genau kapiert, ehrlich gesagt, dann müssen wir
uns das jetzt doch mal durchlesen, was sie hier geschrieben haben, zumindest mal so grob
drüber scrollen, dass wir wissen, was da, was da Sache ist, also, das haben wir ausprobiert,
das funktioniert, also, wenn ich das so anlege, kann ich das einmal anlegen und nie wieder
ändern, was jetzt nicht ganz so toll ist, jaja, das mit Init, ich, ich hab, ich glaube,
ich hab das schon gesehen, dass ich da Init eintragen muss, aber ich muss mir erstmal
durchlesen, so grob, was die sonst noch dazwischen geschrieben haben, also, sprich, wenn ich
so mache, kann ich nie wieder dieses Objekt ändern, egal, was ich mach, geht nicht, ist
nicht erlaubt, was natürlich auch seinen Charme hat, das ist, das ist zum ersten Mal in C
Sharp so, das, das gab's vorher in der Art und Weise nicht, dass es quasi nen Typ gibt,
der standardmäßig immutable ist, also sprich, den ich initialisieren kann, aber nie wieder
ändern kann, der Vorteil von sowas ist, warum man, warum man sowas zum Beispiel macht, ist,
wenn man Multi-Threading betreibt, so, ich versuch euch da mal ein Beispiel zu zeigen
und zwar, ne, kann ich euch kein Beispiel zeigen, das hab ich hier nicht, stelle euch
mal vor, ihr lest, bleiben wir mal bei diesem Beispiel mit den Webcams, was wir hier schon
mal programmiert haben, man hat einen Thread, der liest von der Webcam in den Buffer, man
möchte, kennt ihr das, wenn man bei so modernen, moderneren Aufnahmegeräten, wenn man da Fernsehprogramme
aufnimmt, oder, oder, dass man Fernsehprogramme, kennt ihr, dass man Fernsehprogramme anhalten
kann, oder auch überhaupt, dass man Amazon-Videos anhalten kann, ne, also sprich, du lädst das
Video runter, drückst du auf Pause und, ähm, dann fängt der an zu buffern, beim Fernsehprogramm
zum Beispiel, also der startet im Hintergrund ne Aufnahme, so, oder, was ihr ja auch kennt
ist bei Shadowplay, bei Shadowplay, wo man dann, ähm, beispielsweise bis zu, bis zu,
glaub, 10 Minuten rückwärts, oder Viertelstunde rückwärts, oder so Sachen aufnehmen kann,
stellt man das jetzt noch mal ein, äh, wo hat man das, wo stellt man das jetzt in Shadowplay
noch mal ein, dass man, Buffer, hier, genau, guckt, also sprich, man kann hier in Shadowplay
auch einstellen, dass man bis zu 20 Minuten rückwirkend aufnehmen kann, so, und das funktioniert
ja auch vollendermaßen, die haben im Hintergrund was, was permanent aufnimmt, und erst wenn
du dann auf rückwärts, rückwärts aufnehmen drückst, kopiert er das halt in ein neues
Video-File, der muss es ja aufnehmen, weil der kann ja nicht wirklich rückwirkend aufnehmen,
dann nehmt einfach in ein Temp-File auf, und wenn du sagst, jetzt aufnehmen, dann macht
er eine Datei draus, so, dann stellt euch mal vor, ihr macht das auch, also sprich,
ihr habt einen Thread, der im Hintergrund irgendwie was in den Buffer schreibt, und
der soll natürlich möglichst unabhängig von allen zusätzlich weiter in diesen Buffer
schreiben, sagen wir mal, so immer, so 20 Sekunden Buffer wollt ihr permanent haben,
dass wenn einer mal auf aufnehmen drückt, zum Beispiel wenn ihr eine Kamera habt, wenn
ihr eine Kamera aufnehmt, und ihr wollt auf jeden Fall den DHL-Lieferant oder den Einbrecher
drauf haben, bei Motion Detection, dann nehmt ihr immer 20 Sekunden permanent auf in so
einem Buffer, überschreibt das immer wieder, 20 Sekunden quasi vorne ein Paket raus, hinten
ein Paket rein, so dass ihr immer 20 Sekunden habt, so, und dann gibt es ein Event, zum
Beispiel, man wurde Bewegung erkannt, und dann möchte man eine neue Datei anlegen und
diese 20 Sekunden quasi in die Datei kopieren und dann weiter darin aufnehmen, das macht,
da brauchen wir unterschiedliche Threads für, also auf dem einen Thread läuft diese
Geschichte mit dem in den Buffer reinschreiben, und der andere Thread wird dann beispielsweise
das Aufnehmen in Datei schreiben machen. So, und da bietet sich sowas hier an, jetzt vielleicht
nicht mit so einem Record, wie ich es hier gemacht hab, aber dass man diesen Buffer als
Immutable List macht, der quasi bei jeder Änderung, also der nicht geändert wird, sondern
immer eine neue erzeugt wird, das hat nämlich den großen Vorteil, ich kann einen Snapshot
machen, mit Immutable Sachen kann man immer wunderbar Snapshots machen, also sprich ich
mache einen Snapshot von dem Buffer, übergebe den der Funktion, die meine Aufnahme startet,
währenddessen kann ich in dem anderen Thread weiter einlesen, das was von der Kamera kommt,
aber im Hintergrund habe ich einen Snapshot von dem Buffer, schreibe die 20 Sekunden aus
dem Buffer in der Datei, und dann nehme ich weiter auf und schreibe es hinten dran. Also,
sowas bietet sich zum Beispiel an, dass man eine Immutable List oder sowas nimmt, sprich
eine Liste, wo jedes Mal wenn ich ein Element anhänge oder entferne, eine neue Liste erzeugt
wird, anstatt die bestehende Liste zu verändern, eigentlich den Nachteil ist es ein bisschen
langsamer. Da gibt es natürlich noch andere Varianten, wie man das machen kann, man kann
das ganze auch locken, sprich ich kann auch einfach sagen, ok, während die Aufnahme läuft,
für die erste Sekunde, wie ihr zum Buffer schreiben braucht, locke ich den Buffer und
man darf in der Zwischenzeit nichts reinschreiben. Kann ich auch machen, muss man sich dann unterscheiden,
entscheiden was man dann haben will. Ja, so, jetzt gucken wir uns aber mal das Beispiel
hier genauer an, was die jetzt eigentlich genau getrieben haben. Also, Public Record
Person, Last, das haben wir ja gemacht. So, was das hier macht, soweit ich das sehe, ist
ja ein Constructor, mit dieser neuen, ich habe vergessen wie sie heißt, diese Syntax,
also sprich, anstatt das hier, kann ich auch sowas hier schreiben. Das ist neu, das gibt
es hier, das gibt es glaube ich seit C Sharp 8, die lange Schreibweise davon wäre folgendes,
so, das wäre die lange Schreibweise davon. Was jetzt schöner ist, kann man sich streiten,
ich persönlich finde immer noch das hier ein bisschen lesbare, aber nachdem ich faul
bin, finde ich die Sache hier auch ziemlich gut. Ich weiß nicht, Chat, wie es euch geht,
was ihr da bevorzugt, unter der Haube ist es das gleiche, also es kommt genau das gleiche
bei rum, also sprich, das ist die klassische Constructor Schreibweise und das ist diese
neue, ich habe vergessen wie sie heißt, Expression Member Schreibweise, Expression Body, genau,
der Void-Danny ist ja Big Brain, der kennt sich aus. Genau, also was da schöner ist,
kann man sich, ich weiß nicht, was findet ihr schöner, Chat? Also sprich, jetzt kann
man so machen, ja und das ist glaube ich seit C Sharp 8 oder 7 war das drinnen, dass man
die Sachen so schreiben kann, also sprich, das hier sind die Werte aus dem Constructor,
die man bekommt und das sind die Private, nicht die Private, das sind die Properties,
die wir zugewiesen kriegen, Geschmackssache. Das hier braucht man aber gar nicht mehr,
jetzt verstehe ich, warum es das gibt, genau, weil es gibt seit ein paar C Sharp Versionen
die Möglichkeit sowas hier zu machen, dass man keinen Constructor mehr verwenden muss,
sondern, dass man die Sachen so initialisiert, aber das, jetzt verstehe ich was sie gemacht
haben, aber das funktioniert hier nicht, normalerweise könnte ich hier sowas machen, last name gleich
Max, first name gleich Max, last name gleich Chat, so, das funktioniert aber nicht, weil
ich gesagt habe, die Dinge hier sind read only, wenn ich jetzt sowas hier machen würde,
wenn ich erlauben würde, dass man da was reinschreiben kann, dann funktioniert das ganze wunderbar,
aber das will man ja nicht, man will ja, dass das ganze immutable ist, dass man es nicht
ändern kann, deswegen funktioniert das nicht, und deswegen haben sie jetzt neue Schlüssel,
jetzt habe ich glaube ich zum ersten Mal kapiert, warum sie das gemacht haben, jetzt haben sie
nämlich ein neues Schlüsselwort eingefügt, nämlich init, das können wir alles hier skippen,
wo haben sie es hier, init, jetzt gibt es nämlich noch einen dritten, wie heißt denn das auf
deutsch, Zugriffsbeschränkungsoperator, frag mich nicht, wie das Ding genau heißt, jetzt
kann man nämlich anstatt get set oder sowas wie private set oder so, kann man jetzt init
verwenden, wenn ich init verwende, dann darf ich die Sachen so initialisieren, aber danach
sie auch nie wieder ändern, wenn ich das jetzt richtig verstanden habe, oder? Ja, ok, das
ist eine coole Sache, weil ich muss euch ehrlich sagen, ich verwende mittlerweile fast lieber
das hier zum initialisieren, als wirklich die Sachen im Constructor, wenn es was ist, wo
ein bisschen längere Einträge dazu kommen, zumal ja auch der Vorteil glaube ich relativ
auf der Hand liegt, also wenn ich jetzt eine Klasse habe, mit sagen wir mal irgendwie ganz
vielen, ganz vielen Sachen, mit ganz vielen Datenproperties, dann ist es natürlich viel
einfacher, die so zu initialisieren, als den hier zu machen, mal exemplarisch, what the
fuck, so müsste ich das ja dann machen, wenn ich einen Constructor hätte, der alle meine
Datenproperties initialisieren will, das ist ja hardcore unübersichtlich, deswegen ist
es so eigentlich schöner, dann würde ich so machen, 2, 2, 3, 3, 4, 4, easy, das ist doch
viel besser, das finde ich nett, das hat was, das hat was, das mag ich, so, genau,
so jetzt kann ich aber immer noch eine Klasse anlegen und sie hiermit initialisieren, aber
ich kann danach nichts mehr ändern von dieser Klasse, guckt, wenn ich versucht was zuzuweisen,
bei last name, da sagt er mir, nee, in it only geht nicht, was ist jetzt, wenn ich aber
doch was anlegen möchte, mit den Werten, also wenn ich die Werte ändern will, das ist,
das ist der big brain streamer am Abend heute, so und da kann ich jetzt glaube ich sagen,
reg1 with last name gleich, ah jaja, so und jetzt habe ich folgendes gemacht, ich habe
hier meine Klasse reg1, übrigens ich glaube die haben auch to string überschrieben, dass
man die Sachen ordentlich printen kann, guck mal hier, eigentlich richtig, eigentlich eine
richtig coole Sache, das ist auch was, was mir an den C sharp Entwicklern ganz gut gefällt,
die machen nicht immer so riesen über neue komplizierte Dinger, das sind einfach Sachen
die praktisch sind, so also jetzt habe ich hier reg1 und ich habe reg2 und reg2 ist der
first name, ah jaja und in reg1 hat sich nichts geändert, genau, also sprich ich habe jetzt
einen neuen record angelegt mit den Werten von record 1, also ich habe record 2 angelegt
mit den Werten von record 1 und habe den first name geändert, eigentlich ganz nett, ich glaube
ich werde es erstmal nicht verwenden, weil ich immer eine Weile brauche mit neuen Features,
bis ich die dann natürlich, natürlich quasi einbaue, ich glaube erstmal werde ich da
überhaupt gar nichts mitmachen, vermute ich jetzt einfach mal so, weil ich habe ehrlich
gesagt auch noch gar keine großartige Idee wofür ich das jetzt brauchen würde, so cool
das Feature an sich sein mag, wo würde ich es verwenden, mir fällt spontan nicht so
viel ein ehrlich gesagt, wo würde man es verwenden, was haben die hier für Beispiele,
ja gut das sind so die Standard Beispiele, record dog, record pad, das, ok was schreiben
sonst noch dazu, ja chat hat von euch immer eine Ahnung wofür man das jetzt genau verwenden
würde, also mir fällt jetzt spontan nicht so viel ein gerade, ich glaube das ist so
ein Ding, wenn man es braucht und dran denkt, dann freut man sich, dass man jetzt dran gedacht
hat, wenn man was hat, wo sich es gut für eignet, aber ich kann mir nicht vorstellen,
dass das was ist, was ich täglich mehrfach nehme, choose my name sagt vielleicht, wenn
man irgendwelche API anspricht oder Datenhaltung macht, zum Beispiel JSON Zeugs, vielleicht,
mir fällt da jetzt nicht so viel ein zu, wenn man state halten will und properties, also
in multithreading Sachen stelle ich es mir teilweise ganz praktisch vor, generell sind
immutable Sachen, wenn man multithreading macht, wo man snapshots von verschiedenen
Status braucht, ist das ganz nice, sowas wie der silver dog schreibt, ok hier schreiben
sie auch was ein record type für einen macht, methods for value based equality comparison,
das ist das, was wir gerade gesehen haben, also sprich, dass record 1 gleich gleich record
2 ist, wenn der inhalt gleich ist und nicht die referenz, get hashcode überschreiben,
das braucht man zum Beispiel für dictionaries und sowas, also man kann ja bei jedem Objekt,
hier record 2, get hashcode, man kann ja von jedem Objekt sich quasi mehr oder weniger
hoffentlich unic hashcode generieren lassen, das braucht man zum Beispiel intern verwendendes
dictionaries um die Objekte einzuordnen und sowas, so das haben sie überschreiben, copy
and clone members gibt es, das, das könnte sogar ganz nützlich sein, das könnte sogar
ganz nützlich sein, copy, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie, wie,
wie, wie, wie, wie, wie, wie kann ich die
Die list copy macht okay das muss ich nicht ist copy macht das nicht oder
Ja das ist jetzt die frage legt es jetzt dann jedes mal neue records an oder nicht das
müssen wir mal ausprobieren
Gut UntoString überschreibt es für einen das ist tatsächlich ganz nützlich deswegen
kann man sowas hier machen
deswegen kann man sowas hier machen
Wisst ihr was ich finde das ist sogar fast das nützlichste Feature da dran
dass man es einfach printen kann
So easy das jetzt aussieht und so easy das in anderen sprachen ist so einfach ist das
in C sharp gar nicht
wenn ich eine klasse habe und möchte die die die daten die drin gespeichert sind in so
einem format ausgeben da muss ich jedes mal ToString überschreiben das ist gar nicht
so einfach wie es aussieht
Okay der Chat wollte irgendwas was habe gerade ein kleines RAS programmiert das über Netzwerk
miteinander kommuniziert auf Linux kompil kompilieren kein Ding auf Windows muss man
erst mal 30GB
Ey vieles ist unter Windows was Entwicklungssachen angeht richtig eklig
Da ist dort net mit Visual Studio und so wirklich eine riesen Erholung wobei man dafür ja auch
30GB Visual Studio und SDK und alles installieren muss
Weiter bei GTK unter Windows habe ich mal gemacht ist abfuck hoch 3 oder hoch 10 hoch
100
Also GTK unter Windows ist wirklich abgefuckt da musste erst mal sys msys ne wie heißt
das
msys 2 installieren
Und ähm dann musst du GTK installieren unter msys 2 und dann hast du das Problem dass
die GTK Libraries aus msys 2 mit mingw kompiliert sind wenn du das allerdings mit dem Visual
Studio C++ compiler oder Visual Studio compiler benutzen willst dann geht das nicht total
wie also GTK unter Windows ist echt absolute Zumutung
Äh Silver Dark ja da kommen wir noch zu das habe ich auch schon gelesen dass man kein
Mainmap braucht
Äh also GTK ist absolut keine Konkurrenz gegen Qt und Electron
GTK ist so ein Linux only Ding
Ich muss euch sagen mir gefallen in der Regel die meisten GTK Programme meistens besser
als die KDE Counterparts wenn es einfache Dinger sind
Komplizierte Dinger sind eindeutig die KDE Programme oder die Qt Programme
weil die GTK Programme meistens ultra rudimentär sind
Aber generell sobald es Cross Platform ist bleibt hier nur noch Qt übrig
VLC
Gucken wir mal VLC 1 GUI
Die erste
Das erste VLC GUI ich weiß gar nicht ob es VLC 1.0 war
Die das war noch ein GTK
Das war noch ein GTK Interface
Mittlerweile ist VLC auch Qt einzig und allein aus dem Grund weil sie gesagt haben
GTK Cross Platform ist shit
Wegen Ansela kein Bock mehr drauf
Und ich kann jeden verstehen der keinen Bock hat auf GTK Cross Platform
GTK ist eigentlich so ein Ding was du da musst du schon richtig Hardcore Gnome Fan sein
Weil ich hab mal versucht mit GTK was zu machen
Die sind so Bleeding Edge bei GTK
Dass die quasi bei jeder Gnome Version was umbauen was es inkommatibel zum anderen macht
Und das dann aber auch nicht irgendwie in ihrem Gnome abfacken
Sondern im GTK und deswegen funktioniert ein GTK mit dem anderen Beispiel dann mal richtig
Und sind dann auch nie richtig dokumentiert weil das schon wieder so neu ist
Also GTK ist wirklich abfack was das angeht
GTK unter Windows verwendet ja nicht ohne Grund kein GTK 3
Ich glaub GIMP unter Windows immer noch GTK 2
Oder?
Oh ne
Haben sie es mittlerweile
Ja gut
Ja gut vor ner Woche
Vor ner Woche
GTK 3 gibt es seit 10 Jahren oder so
Haben sie es jetzt schon geschafft
Weirdchamp
Das hat schon seinen Grund warum das nicht funktioniert hat die ganze Zeit
Ok aber zu den Record Types mit ich wie gesagt ich weiß noch nicht so wirklich vor was ich
sie brauche
Aber wenn ich sie brauche find ichs bestimmt cool dass sie da sind
Was ich viel cooler finde ist Init Properties
Also Init Only Setter find ich nice
Ich hab ja schon immer gerne diese Initialisierungs Variante gemocht
Also lieber als alles in Constructor schreiben
Und ich denke mal dass das auch bei normalen Klassen geht oder
Mach mal ne Class draus
Dann geht das hier natürlich nicht mehr
Ja funktioniert auch mit ner normalen Class ok
Warum keine Init Only Getter
Du solltest ne eigene Programmiersprache designen
Ich find Init Only Getter ist ne super Idee
Das sind dann quasi Getter die zur Compile Zeit schon den gleiche also im Prinzip ein
Standard Getter mit Default Value
Ja was auch immer
Darf ich Qt nur eingeschränkt privat nutzen?
Nee also bisher war es so dass jeder Qt verwenden darf
Wie gesagt ich weiß nicht ob das geht hier
Geht um das hier Cross Platform GUI Framework
Wow
Hm MonkaS
Ah das war auch das Falsche oder
Lul
Es geht um dieses Cross Platform Framework
Also bisher war es glaube ich so es darf jeder Qt verwenden
So wie kommerziell als auch privat
Sofern er es nicht statisch linkt
So was wie statisch linken ist ein C++ Ding
Das muss man sich normalerweise in anderen Programmiersprachen heutzutage gar nicht mehr
Großartig mit beschäftigen
Aber es ist C++ da ist sowas noch an der Tagesordnung
Sachen die man 1995 machen musste macht man halt auch 2020 noch in C++
Ja soweit ich weiß ist das so
Wenn man Qt statisch linked braucht man irgendwie ne Lizenz
Und wenn man Qt Libraries ausliefert mit ausliefert und dynamisch linked
Was im Prinzip gar kein Unterschied macht wenn man die Libraries mit ausliefert
Außer dass man sie austauschen könnte was eh keiner macht
Und am Strich kommt es gleich heraus darf man es verwenden wie man will
Nee nee du musst kein Source Code Provide
Nee nee nee
LGPL ist eigentlich eines der besten Sachen die es gibt
LGPL ist du darfst quasi alles
Also LGPL ist Commercial alles
Ich weiß noch nicht mal was LGPL nicht erlaubt
Genauso so ein bisschen wie diese komische BSD Lizenz da
Da darf man auch alles
Mal ne Frage ich mach mal kurz den Chat ein bisschen größer
Mal ne Frage was sollte man in Pricen können
Und wie findet man das am besten was
Und wie findet man da am besten etwas zu
Habe bis jetzt nur Mathe und Plotting gemacht
Ok Mathe und Plotting ist jetzt meistens nicht so das was die Leute als Einstieg in Programmiersprachen
machen
Der Polar Fuchs hat Subscribed
Dankeschön für den Prime Sub
Noch mehr High IQ für den Chat heute das geht aufwärts
Dankeschön
Ja also Kali Rex das ist jetzt sehr vage gestellt diese Frage also die kann man eigentlich
so nicht beantworten
Ich mein was sollte man in Pricen können
Was solltest du keine Ahnung beim Tischfußball spielen können
Also es ist schwer zu sagen also das hängt ganz stark damit ab was du für einen Anspruch
da an dich hast was du können solltest
Und wie man da am besten was herausfindet kann man erst herausfinden wenn man überhaupt
weiß was man machen will
Weil wenn du nicht weißt was du machen willst ist ja auch schwierig was herauszufinden
Also umgedreht geht das ja schlecht
Ich bilde mir auch ein dass das so ist
Das ist das was ich auch so im Kopf habe
Du darfst nicht statisch linken ansonsten ist das alles in Ordnung
Daher ist es eigentlich schwer das zu finden wozu ich es brauche
Also wenn du kein Anwendungswerk hast dann brauchst du es ja auch nicht
Oder ich verstehe es nicht so wirklich also warte mal anders wenn du mit Pricen anfängst
du die Standardsachen die man am Anfang so macht
Das sind so die das sind so eigentlich die Basics die man in jeder Programmiersprache
macht
Man guckt sich an so ein bisschen standardmäßig eine Ausgabe sprich wie lese ich Dateien ein
wie schreibe ich Dateien
Wie programmiere ich ein paar einfache if else Geschichten wie mache ich mal eine Schleife
wie lese ich Sachen von der Kommandozeile ein wie gebe ich Sachen auf die Kommandozeile
aus
Wie schicke ich ein Webrequest wie lese ich ein Webrequest
So die Basicsachen die man in jeder Programmiersprache macht aber es ist viel einfacher zu beantworten
wenn man einen gewissen Anwendungszweck hat wo man was zu machen will
Anstatt einfach so ins blaue also so ganz ins blaue rein ist ziemlich schwierig zu beantworten
Und so einfach Pricen aussieht mittlerweile ist das auch ganz gut komplex geworden
Aber es ist echt hübsch also Pricen ist wirklich entspannend zu programmieren
Ich finde eines der größten positiven Punkte ist
Was Pricen angeht dass die eine ziemlich gute komplette Standard Library haben
Also die haben von einem DNS Client bis zu einem CSV Parser bis zu irgendwelchen abgedrehteren
Kram bis zu einem HTTP Server die haben eigentlich alles drin
Deswegen mag ich Pricen auch wenn ich wenig mitmach
Ok In It Only Setters haben wir uns auch angeguckt
Also sprich ich glaube das Feature haben wir jetzt abgefackelt halbwegs
Ich scroll nochmal kurz drüber
Positional Records
What the hell ist das eher lang?
Alter so viele Klammern
Das ist irgendwelche Vererbungsgeschichten oder so
Das werde ich eh nie verwenden
Ja das sind irgendwelche Vererbungs Sachen
Ah Moment mal das ist cool
Das ist tatsächlich ganz nice
Kann ich das hier auch verwenden?
Das geht wahrscheinlich jetzt nicht ne?
Moment das muss ich mal ausprobieren
Nein das geht nicht das geht nur wenn ich das Beispiel von oben verwende was sie hier
hatten
Ne Moment dann habe ich es noch nicht gecheckt
Ok dann habe ich es nicht kapiert was sie mir hier sagen wollen
Was macht der da anders als ich?
Ah das ist cool
Das gefällt mir
Oh das ist ja mal nice
Das ist doch mal ein cooles Feature also sprich anstatt diesen Schmodder hier zu schreiben
die klassische Class Declaration kann ich einfach die Abkürzung benutzen und der macht
das alles für mich
Also sprich das hier das hier und das hier ist genau das gleiche
Ja das ist nice das gefällt mir
Das ist nice
Ja das spart auch wirklich tippen
Ok jetzt habe ich einen Anwendungszweck dafür was ich verwenden würde
Also sprich wenn ich eine Klasse mache die nur Daten enthält dann würde ich eigentlich
so machen jetzt
Der ist neu den gibt es seit 5 Tagen quasi
Aber dass man quasi das hier schreiben kann und das hier bekommt und das hier generiert
die auch schon viel unter der Haube
Ja sie kriegt viele funktionale Features
So und jetzt guckt mal jetzt kann ich sogar deconstructen
Ja das ist das ist nice
Das ist wirklich cool
Also sprich ich kann jetzt also ich bekomme von irgendwo diesen Rekord mit FirstNameMax
LastNameLinks und ich kann jetzt den deconstructen in zwei Variablen nämlich First und Last
und kann ich nennen wie ich will die kann ich auch A und B oder so nennen das ist wurscht
muss ich wirklich First und Last heißen
Und jetzt kann ich direkt jetzt kann ich quasi aus diesem Rekordobjekt zwei Variablen erstellen
Ach nee nicht Moment nicht fest
Jetzt kann ich quasi zwei Variablen aus diesem Objekt erstellen ohne dass ich da jetzt irgendwie
großartige Sachen anlegen und zuweisen muss
Das ist ein cooles Feature das gefällt mir
Guckt ich habe jetzt quasi dieses Rekordobjekt deconstructed in die Variable First und Last
und das geht nur das geht nur weil es positional ist weil er weiß das hier ist die also das
hier steht an erster Stelle das hier steht an zweiter Stelle
Deswegen kann er deswegen um die Leute zu verwirren kann könnte man auch sowas machen
das funktioniert genauso nur dass es jetzt umgedreht ist also sprich es ist egal wie
dieser Kram hier heißt es kann auch A und B heißen wichtig ist die Position wie ich
es angelegt habe
Das ist ein cooles Feature ok das hat mich überzeugt
Das verwende ich Last Name League oh MonkaS
Das verwende ich
Übrigens kennt ihr die Big Brain Taktik eine Schleife zu machen die von 1 bis 50 zählt
also weil die einfache Variante ist das da ok sagen wir mal 0 bis 49 die einfache Variante
ist das da
So kriege ich 50 Leerzeilen jeder vor das ist die einfache Variante die Variante die
glaube ich jeder checkt aber viel Big Brainigere Variante
Enumerable range 0 bis 50 for each
nicht dass das wirklich sinnvoll ist aber irgendwie ist es mir gerade zu den Kopf gekommen
hier also wem einfache Vorschleifen zu einfach sind macht die so
ja und hier drinnen zählen ist das gleiche
natürlich wenn man ehrlich ist ist das hier die bessere Variante
das hat andere Vorteile aber machen wir vielleicht mal anders
so da gab es ein paar Fragen im Chat wo ich gerade noch was zu sagen wollte
Was ist denn der große Unterschied zwischen Python und C Sharp habe nicht so viel Knowledge
im Programmierbereich also das ist was was man einfach beantworten kann oder wirklich
ausführlich beantworten kann das sind grundsätzlich vom Ansatz her zwei unterschiedliche Sprachen
Python ist komplett dynamisch also sprich jede Variable kann zu jeder Zeit alles sein
von einer Zahl zu einem String zu einem JSON Objekt oder sonst was und C Sharp ist statisch
typisiert das bedeutet ich muss festlegen was welche Variable ist und die kann auch
ihren Typ da nicht zwischendurch wechseln
Obwohl ich bin mir gar nicht sicher kann in Python eine Variable ihren Typ wechseln?
Ja oder?
Ich glaube das geht
also die grundsätzliche Unterschiede also den finde ich markantesten Unterschied erstmal
ist unabhängig von Syntax oder sonst was C Sharp ist statisch typisiert also sprich
du weißt genau welcher Datentyp in welcher Variable zu jeder Zeit ist zur Kompilzeit
schon und in Python ist es halt komplett dynamisch das ist übrigens auch der Grund warum Python
in vielen Bereichen so schnarchlangsam ist Python ist abfuckmäßig langsam wenn es
um Performance Geschichten geht der hauptsächliche Grund ist dass es dynamisch getyped ist
es gibt doch hier diesen gRPC Benchmark
hier ist die Sharp da hatten die doch einen neuen
wenn ihr mal lachen wollt
also man sieht die Performance von dynamischen Sprachen ist ein bisschen hinten dran warum
Swift so langsam ist verstehe ich übrigens nicht
Swift sollte eigentlich auch halbwegs geschwind sein da ist wahrscheinlich die Implementierung
kacke was macht gRPC da kannst du von einem da kannst
du übers Netz da kannst du von einem kleinen übers Netzwerk Funktionen auf dem Server
aufrufen und dir Antworten schicken lassen und sowas das ist ein Binary Kommunikations
Protokoll
also keine Webrequest Binary
ich meine das
das Ruby langsam ist ist mir klar und das Python langsam ist mir auch klar warum Swift
so langsam ist verstehe ich nicht
PHP ok aber PHP ist auch besser als ein Ruf was Speed angeht dass Node so langsam ist
wobei so langsam ist
Node also generell Javascript ist viel schneller als ein Ruf
Javascript ist mittlerweile extrem schnell
also diese Geschichte mit von wegen lamen dynamisch interpretiertem Javascript ist schon
lange nicht mal so
spätestens seit V8 und Google damit angefangen haben ist da da ist wirklich ich weiß ich
habe schon oft extrem gesagt letztes Jahr aber extrem viel Big Brain in V8 drinne
also V8 platzt das Gehirn quasi was die sich da überlegt haben
die machen so abgedrehte Optimierung Sachen in in Chrome Javascript ist der Wahnsinn
die haben zum Beispiel
eine Erkennung drin ob der Wert in einer Schleife quasi überlaufen kann oder nicht
also sprich wenn du wenn du auf irgendwas zugreift in der Schleife und zählt die Schleife
hoch
da haben die quasi irgendwie so eine Logik drinne eingebaut in V8 ob es möglich ist
dass dieser Wert jemals overflowed
wenn er overflowed bleibt das langsam weil er muss jedes mal checken ob es overflowed
ist
wenn diese diese Black Magic Google Logik quasi feststellt das kann niemals overflowen
dann kompilieren die quasi im Hintergrund irgendwie so einen so einen Hot Pass Ausführungsding
für in Node und dann ist es superschnell das ist wirklich
Exploding Expanding Brain was sie in Javascript machen echt das ist das ist nicht normal
das verstehen auch Normalsterbliche nicht mehr
also also warum Swift zu langsam jetzt verstehe ich nicht PAP ok Node hätte ich eigentlich
auch ein bisschen schneller vorgestellt aber ich bin mir nicht sicher ob in diesem Benchmark
vielleicht weil es gerade einer im Chat gesagt hat irgendwelche Multithreading Sachen gemacht
werden
wenn Multithreading dann ist Node zumindest standardmäßig nicht so nicht so schön
Lua gut wer sich wirklich geben will kann sich auch Lua geben
Kotlin Java ich vermute mal Kotlin ist ein bisschen langsamer als Java entweder ist es
eine eigene neue Implementierung die einfach nicht so performant ist wie hier oder aber
die Magic die Kotlin angenehm macht im Vergleich zu Java schlägt halt ein bisschen Performance
mäßig rein
so Go, Go gRPC ist schnell muss es auch weil Go ist von Google und und na gut gRPC ist
so halb von Google
so und was wisst ihr was wirklich nice ist das C++, Go,.NET und Rust ungefähr alle
gleich schnell sind
also man sieht man kann mittlerweile auch in.NET ziemlich optimiertes Zeug fabrizieren
und ich glaube mal dass C++ das Potenzial hätte sogar in der Ecke schneller zu sein
hier als.NET aber C++ hat auch das Potenzial unnötig hässlich entwicklerfeindlich und
kompliziert zu sein deswegen kann es durchaus sein dass die gRPC Implementierung in C++
einfach suboptimal ist im Vergleich zur Implementierung von in.NET
weil in.NET blickst du durch wenn du was programmierst in C++ eigentlich nicht
zumindest nicht so gut
genau gut Rust ist ganz vorne mit dabei also ausweichlich hat C++ hier eindeutig das Potenzial
auf der gleichen Ebene von Rust zu sein
aber es hat wahrscheinlich keiner Bock eine neue performantere gRPC Implementierung für
C++ zu programmieren weil C++ so maßlos sackt und keiner C++ programmieren will
so und Kirby Musik ist vorbei muss ich wieder anmachen
gibt es ein schnelleres Minibot als den Raspberry Pi 4
ja total viele total viele musst du einfach mal suchen danach
aber ich würde trotzdem nichts anderes nehmen weil die Kombination aus Support, Tutorials,
Partikel, Boards und generell Community Unterstützung ist einfach durch nichts zu schlagen
ach da steht Single Threaded Multi Threaded ah ich sehe es hier
also C++ Multi Threaded ist genauso gut wie Go Multi Threaded ohne MT und.NET Multi Threaded
es ist nicht alles Single Threaded Multi Threaded manches ist auch unbekannt Threaded
ja zumindest worauf ich eigentlich raus wollte jetzt mit dieser ganzen Performance mit ganzen
Performance Vergleich
und Ruby Ruby auch in vielen Bereichen wobei Ruby jetzt mit der nächsten Ruby Version
einen dicken Performance Boost kriegt ich hoffe dass Ruby dadurch wieder ein bisschen
beliebter wird weil persönlich bei mir gibt es zwei Sprachen die ich am liebsten benutze
das ist C Sharp und Ruby Ruby genau leider kann man Ruby nicht mal so gut verwenden in
letzter Zeit Rails ist komplett gefallen ne wie sagt man da so komplett aus der Mode
gekommen genau und so normales Scripting Zeug macht jetzt eigentlich fast jeder irgendwie
in Preisen
schon mal mit Crystal gearbeitet ja habe ich mir vor Jahren mal angeguckt das größte
Problem was ich bei Crystal hatte ist dass sie so halb kompatibel zu Ruby sind aber
nicht richtig und dass sie nicht unter Winnows funktionieren
vielleicht ist mittlerweile alles anders
du hast keine Ideen was du programmieren könntest
das ist natürlich ein Problem
was hältst du von Webseiten
ich finde Webseiten immer am schönsten zu machen zum Einstieg weil dann sieht man was
das passiert
weil du kannst ja dann Python Backend machen
oder schwierig zu sein
spielen wir das neue Cod ich habe es noch nicht mal installiert ich will unbedingt die Kampagne
spielen vielleicht spiele ich sogar im Stream
ich habe es doch Hissi habe ich gerade beantwortet es gibt total viele Boards die schneller sind
als der Raspberry Pi 4
aber ich würde trotzdem keines empfehlen weil die von Support und Community Unterstützung
und Tutorials und Software die einfach läuft und Hardware Erweiterungen so einfach nicht
so gut sind
und meistens ist der Raspberry Pi 4 ja nicht irgendwie der limitierende Faktor bei dem
was man machen will
was haben sie hier sonst noch GAPC Benchmarks bla
ja und Python ist halt manchmal echt krass langsam so wie man hier sieht
und das liegt um jetzt mal auf die ursprüngliche Frage zurück zu kommen was der große Unterschied
zwischen.NET
und C-Sharp und Python ist das liegt zum größten Teil daran dass Python dynamisch ist
du kannst einfach den Ablauf von einem Programm viel schlechter optimisieren wenn du nicht
weißt
was für einen Datentyp und also quasi wie viel Speicher ja letztendlich
eine gewisse Variable zu welchem Zeit benötigt das ist einfach kacke zu optimieren
also dass das Python dynamisch ist ist der größte Vor- und Nachteil an der ganzen Sache
das ist schön elegant und das ist schon einfach zu programmieren und auch sehr prägnant
und aussagekräftig aber es ist halt optimierbar nur in Grenzen
ja und ob kompiliert oder interpretiert würde ich jetzt gar nicht mal in der heutigen Zeit
mal so hoch einschätzen weil viele Sachen haben da so einen hybriden Modus also sogar
in JavaScript ist es ja mittlerweile auch so JavaScript in V8 wird ja auch nicht rein
interpretiert da wird ja auch dann viele Sachen werden dann wenn sie gecheckt wurden quasi
kompiliert dass es dann recht optimierten Code gibt also vieles ist so hybridmäßig
man kann heute gar nicht mehr sagen hey das ist rein interpretiert und das ist rein ahead
of time kompiliert das ist oft mal so ein Ding und beispielsweise ist es in.NET ähnlich
bei.NET würde nie jemand sagen das ist eine interpretierte Sprache in.NET ist es so wenn
du ein Programm startest dann haben die noch keinen für deine Plattform optimierten Code
erzeugt das heißt dann läuft das ganze erstmal ein bisschen langsamer nicht wirklich interpretiert
aber quasi in so einem Art Bytecode Interpreter ist das läuft das dann und sobald du deswegen
ist es in C-Sharp auch oder in.NET auch oft so wenn du zumindest war das bisher so wenn
du eine Methode zweimal aufrufst ist sie beim zweiten mal viel schneller ja das gucken wir
uns gleich an mit Main und so da sieht man das ist also fließend was da zwischen interpretieren
kompilieren Bytecode4M und so da tricksten heute viele Sprachen rum und es gibt ja auch
schon ein paar ahead of time Compiler für Python die machen Python aber auch nicht zu
einer ultra schnellen Sprache es gibt so ein paar Versuche habe ich letztens gesehen zum
Beispiel jemand der hat einen Python Compiler gebastelt und aber mit der Beschränkung dass
man manche Features nicht verwenden darf man darf quasi nur so ein Subset von Python verwenden
das ist dann schön schnell ja ich bin mal auf die nächste Ruby Version gespannt weil
die nächste Ruby Version soll angeblich irgendwie zehnmal schneller sein oder so da bin ich
mal gespannt vielleicht also wenn Ruby es schaffen würde hier auf dieser Ebene irgendwie
zu landen wäre schon huge ja und in.NET haben sie halt die letzten die letzten Versionen
über ziemlich viel eingeführt was der Performance zugute kommt zum Beispiel was sind wir da
mal also diese ganze Task Geschichte ist ja ist ja schon alt zum Beispiel ihr ganzes
Memory Management früher war das ja so du hast für alles und jeden hast du irgendwelche
Objekte erzeugt in C Sharp oder in.NET die dann garbage collected werden müssen so und
was ganz ganz eklig war in.NET ist wenn du sowas hier machen musstest also sagen wir
jetzt mal wir machen jetzt mal eine Liste Liste int oder Array komm wir machen Array
mit Array geht das mit Liste geht das gar nicht also du hast ein Array sagen wir das
sind jetzt irgendwie 20.000 Elemente drin so und jetzt willst du dieses Array verarbeiten
an unterschiedlichen Stellen in deinem Programm unterschiedliche Abschnitte das ist gar nicht
so einfach gewesen wenn du das alles übersichtlich untereinander machst dann kannst du natürlich
da irgendwie zig vorschleifen bauen die dann wussten wo die andere gerade ist und sowas
das hat funktioniert da haben wir jetzt aber gesagt ok solche Low Level Sachen müssen
wir anders handhaben und deswegen haben sie jetzt sowas hier gemacht das ist quasi eine
Abstraction für Speicher Zugriff vorbei vielleicht soll ich eher auf Byte machen also sprich
wenn ich auf Speicher zugreife und das Splitten will und an unterschiedlichen Stellen verarbeiten
möchte dann kann ich das damit machen und ich kann da quasi da neue Slices erzeugen
neue Abschnitte von diesem Array an unterschiedliche Teile übergeben an unterschiedlichen Teilen
bearbeiten und unten drunter ist das im Prinzip immer noch das gleiche Array also sprich ich
muss hier nichts kopieren ich muss hier nichts neu anlegen an Speicher ich greife unter der
Haube immer noch auf das gleiche Array zu was natürlich irgendwelche Parser oder Sachen
die halt Multithreaded Byte Buffer Zeug verarbeiten viel viel schneller macht so das ist so ein
Feature was er eingeführt im C-Shop was echt Performance geboostet hat das nächste was
sie eingeführt haben ist dass wenn du Multithreaded wenn du Sachen Multithreaded machst dass du
gibt es dafür nicht auch GetRange kann schon sein ich weiß es ehrlich gesagt nicht ob
es sowas wie GetRange gibt GetRange nein das erzeugt eine neue Liste das ist genau das
was ich meine das erzeugt eine neue Liste mit Referenz auf die Elemente aus der alten
Liste das heißt du musst jedes mal wenn du das benutzt eine neue Liste erzeugen mit Referenzen
auf die alten Elemente was natürlich wenn du das keine Ahnung 30 Millionen mal pro
Sekunde machst oder so auch für den Garbage Collector nervig wird wenn er den ganzen Kram
aufräumen muss und sie haben selbst gesagt ich muss euch ehrlich sagen ich verwende
diese Span Geschichte auch relativ selten wo ich es verwendet habe ist zum Beispiel
bei meinem FFmpeg Video Einlese Zeug für den Buffer den man wiederbekommt von den Unmanaged
Buffer von FFmpeg mit dem komprimierten Video dafür verwende ich es an einer Stelle ansonsten
verwende ich es auch relativ selten aber sie haben gesagt dass sie beispielsweise ihre
Web Request bei ASP.NET Core um ein Vielfaches beschleunigen konnten dadurch dass sie Span
verwendet haben so noch eine Sache die sie eingebaut haben ist was in den letzten Jahren
wirklich viel Performance Boost gebracht hat bei NC Sharp ist du hattest bisher immer so
ein bisschen das Problem wenn du Multithreading gemacht hast NC Sharp du hast einen neuen
Task aufgemacht ein neuer Task ist ja NC Sharp eine Abstraktion zu einem Thread du weißt
nicht genau ob es ein eigener Thread ist oder nicht in der Regel läuft der Task in einem
eigenen Thread Pool also sprich wenn ein Task fertig ist dann gibt er den Thread zurück
in den Pool und wenn ein neuer Task anfängt kann er sich den wieder rausnehmen und der
Standard Thread Pool hat keine Ahnung ich weiß es nicht ich sag jetzt einfach mal 500
offene Threads ich hab ehrlich gesagt kein Plassen Schimmer wie groß der Standard Thread
Pool ist das hat den Vorteil man muss nicht immer neue Threads erstellen und so ja so
aber du weißt das nicht so genau so und eine Sache ist jetzt wenn du Sachen programmiert
hast die asynchron laufen in Task zum Beispiel NC Sharp dann musstest du ja als Rückgabe
von so machen wir mal irgendwie hier was Static, Void, Static, Task, Blob und wenn jetzt hier
irgendwas machst was ein Task erzeugt so hier kann ein Return, Task, Run so wenn ich das
hier jetzt aufrufe diese Methode Blob die gibt mir den Task zurück und dieser Task läuft
ein Asynchron es sei denn ich warte drauf also zum Beispiel kann ich dann hier sagen
Wait Blob was das jetzt macht ist Blob erzeugt einen Task der Asynchron läuft und ich warte
hier bis der Task vorbei ist also was heißt ich warte nicht warten ist das falsche Wort
ich springe quasi aus der Methode raus und wenn das fertig ist mache ich dann an der
Stelle weiter so was das Problem ist wenn ich das 20 wenn ich das fünf Millionen mal
mache keine Ahnung alle paar Sekunden dann ja Async, Void jetzt fangen sie wieder alle
an ne in dem Fall ist Async, Void ok hier ist Async, Void vollkommen ok weil ich await
ja den Task was willst du sonst machen ja mach da mach da by await das kann ich gleich
auch nochmal erzählen so zumindest wenn man das jetzt wenn man das jetzt irgendwie 100.000
mal die Sekunde macht das erzeugt ganz schön viel Overhead vor allem wenn man sich mal
überlegt wenn ich was habe was ich 50.000 mal 100.000 mal die Sekunde mache was ich
Asynchron machen möchte in einem extra Task dann ist halt eh die Frage wie Asynchron das
ist weil das muss ja verdammt schnell fertig sein sonst wird sich ja nicht lohnen das 50.000
mal pro Sekunde zu machen deswegen haben die jetzt was neues eingeführt und zwar Value
Task ich werde aber einfach nur erwähnen dass es das gibt Value Task ist quasi ein
Rapper um Task der den Fall optimiert dass der Task instant schon fertig ist also sprich
wenn ich was habe was ich sau oft mache pro Sekunde und ich würde dafür jedes mal einen
neuen Task erzeugen aber das Ergebnis was ich mit diesem Task berechnen will ist so schnell
meistens zumindest so schnell da dass es quasi Synchron ist da kann ich das mit Value Task
machen weil der optimiert diesen Fall dass ich Sachen quasi so fake Asynchron mache
obwohl sie eigentlich Synchron sind und dann muss der auch keine 30 Billiarden Sachen erstellen
pro Sekunde so und das ist auch eine Sache wo sie viel Performance optimieren konnten
in dotnet so dann haben wir jetzt hier noch eine Frage von springt er bei Await wieder
in die Methode ja Await ist eigentlich viel einfacher als es auf den ersten Blick also
umgedreht Await hört sich Await hört sich erstmal einfach an wenn man sich damit beschäftigt
stellt man fest fuck das ist doch gar nicht so einfach und wenn man sich dann ein bisschen
damit beschäftigt dann stellt man fest dass es viel einfacher ist wenn man sich so vorstellt
also dieses Konstrukt gibt es nicht in C-Sharp aber das ist im Prinzip das was ein Await
macht ein Await ist ein Return ein Await ist ein Return mit einem Callback wenn es weitergeht
also ein Return beendet die Methode ja komplett so und ein Await also es wäre eigentlich
fast aussagekräftiger man würde Return Await schreiben aber es ist halt in dem Fall nur
Await was dann Await macht ist folgendes also sagen wir mal so ich ruf jetzt diese Sache
hier dreimal auf und danach sage ich dann irgendwie fertig wir machen jetzt mal Task
Run Big Brain Code machen wir jetzt Threadsleep 100 Threadsleep 1000 also ich weiß ich mache
noch einen Task der ne Sekunde wartet und jetzt rufen wir das Ganze mal auf achso äh
Moment jetzt muss ich danach warten äh Moment äh Task ne äh äh erst mal ah stimmt das
geht jetzt ja ne nicht was hab ich verkehrt gemacht achso ha das kann ich jetzt nicht
erwarten doch wuppi du hast vollkommen recht das funktioniert ja so nicht keck weh jetzt
beendet er sich nämlich ja äh fuck wie mach ich das jetzt wie zeige ich das jetzt am besten
Console Readline dann beendet er sich nicht ja du hast recht in dem Fall ist es tatsächlich
blöd gewesen ja ähm so ich hätte dir wirklich Task zurückgeben sollen ja jetzt weil jetzt
kann ich jetzt auch erwarten wuppi und ich hab noch gesagt ist okay und gleich kommt
bäm ist nicht okay so also was der hier macht ist jetzt vielleicht soll ich hier noch was
dazwischen ausgeben also so das ist das ist äh quasi das erste mal wenn er rausspringt
das ist das zweite mal wenn er rausspringt und das ist das dritte mal wenn er rausspringt
so was der macht ist folgendes eins zwei drei also wenn der hier Test aufruft geht er erst
mal hin blub so blub startet ne neuen Thread ne neuen Task der ne Sekunde wartet also im
Prinzip block das quasi ne Sekunde wenn man es so will so was der jetzt hier an der Stelle
bei dem Await macht ist wenn der hier das Await sieht dann startet er das und geht wieder
raus hier mal hier mal warte ich jetzt auch also sprich an der Stelle passiert nichts
der returned und er bekommt ne Callback wenn blub fertig ist und wenn blub fertig ist macht
er hier weiter im Prinzip ist Await blub exakt das gleiche wie das hier
aber man sieht schon wie eklig das jetzt wird ne man sieht man sieht man sieht schon man
sieht schon wie eklig das jetzt wird ne Moment ich machs ja sogar falsch also man siehts
glaube ich schon man siehts glaube ich schon dass es dass es eklig wird mit der Zeit ne
das ist nämlich fast schon ein Java Callback ich kann es aber nicht mal richtig schreiben
also das hier ist das gleiche wie wenn ich das mit Await mache
also der führt blub aus wenn blub fertig ist macht führt er das hier aus wenn blub
hier fertig ist führt er das hier aus das ist genau das gleiche wie wenn ich so schreibe
also ja der returned immer an der Stelle bekommt ne Callback wenn das fertig ist und macht
dann das hier weiter intern wenn man sich das ich hab jetzt ehrlich gesagt keine Ahnung
ob Ryder nen D-Compiler dabei hat da sieht man das auch schön der hat dann ein riesig
langes Switch Statement wo er sich den Statement beim rein und rausspringen und wozu braucht
man da einen Tags der Arbeit doch von oben nach unten das sieht so aus der arbeitet von
oben nach unten aber es ist insofern asynchron mal angenommen du hättest jetzt ne grafische
Oberfläche ne grafische Oberfläche mit nem Knopf so und wenn du den Knopf drückst dann
würde hier dann würde der hier Test aufrufen und Test macht jetzt nicht das hier Test macht
nicht das hier sondern Test macht mal einfach mal ganz hardcoded sleep 50.000 so was jetzt
passieren würde in deiner grafischen Oberfläche ist das GUI würde 5 Sekunden hängen und wäre
absolut unresponsive und Windows würde wahrscheinlich sagen die Anwendung reagiert nicht wollen
sie die Anwendung beenden so nicht so mit Await weil Await plockt nicht der arbeitet
zwar von oben nach unten ab aber nicht indem er hier wartet deswegen ist Await ist schwierig
das Wort ja der wartet hier nicht der plockt nicht an der Stelle der geht raus aus der
Methode und du machst hier oben weiter jetzt nicht das kann man ohne GUI schlecht schlecht
demonstrieren mir fällt jetzt auch kein gutes Beispiel dazu ein du hast den Vorteil in nem
GUI dass hier das return zu dem thread der aufruft deswegen return Await verfasst verfasst
irgendwie prägnanter
ich überleg gerade ob ihr ein gutes gutes Beispiel einfällt
ja ok wir machen wir machen mal eins also alter die Musik
so wir machen mal was so wir machen jetzt hier oben mal nen wir tun jetzt mal als hätten
wir nen UI Task nen GUI Task der irgendwas macht der macht nun der macht ne Endlosschleife
wo nix passiert außer dass er die Schleife einmal pro Sekunde durchläuft und da ruf
ich jetzt hier unten Test auf ich sollte vielleicht noch ne Ausgabe machen 1 2 3 so und was man
jetzt hier schön sieht ist so was man jetzt hier schön sieht ist das ist ja gut hier kommt
fertig dazwischen ne das ist jetzt do also was man hier sieht ist er müsste er müsste
ja eigentlich müsste der hier drei Sekunden plocken macht er aber nicht ich nehm mal kurz
die ne mal kurz hier die dinger hier raus ne also von der Idee her müsste der jetzt
drei Sekunden plocken nach meinem 1 2 3 aber das 1 2 3 kommt einmal in der Sekunde Sekunde
Sekunde Sekunde aber eigentlich müsste der ja plocken weil ich ruf hier dreimal ne Methode
auf die die ne Sekunde dauert aber der plockt nicht der ruft das auf der führt das hier
zwar in der richtigen Reihenfolge aus aber jedes mal wenn er auf nen Await trifft macht
den Return zurück an den Task also sprich der ruft Test auf der sieht nen Await und
Returned so dann irgendwann kriegt der hier nen Callback Plop ist fertig dann springt
er hier rein und macht weiter Returned wieder kriegt wieder nen Callback macht weiter also
sprich das ganze ist asynchron ohne dass man sich großartig drum kümmern muss das macht
finde ich aber auch dementsprechend komplex weil es schwierig ist durchzusteigen wann
er was an welcher Stelle macht und ich benutze das jetzt schon eine Weile und ich muss euch
ehrlich sagen ich tu mir manchmal auch schwer warum manche Ergebnisse rauskommen so wie
sie rauskommen also das ist nicht so easy wie man sich wie es auf den ersten Blick vielleicht
aussieht aber wenn man sich den Await als Return vorstellt ist das eigentlich einfacher
finde ich als also wenn man sich als Return Await vorstellt ist es einfacher so hätten
wir jetzt ist hier ein D-Compiler dabei in also der der beste Anwendungsfall den man sich
vorstellen kann wo man auch sofort sieht dass es was bringt ist wenn man sich vorstellt
man hat eine grafische Oberfläche man klickt einen Knopf und man möchte was machen was
fünf Sekunden dauert wenn man den Knopf drückt wenn man das einfach so macht dann hängt
das GUI fünf Sekunden wenn man das in einem eigenen Task macht dann hängt das GUI nicht
dann hast du allerdings das Problem dass du dann die Reihenfolge nicht mehr richtig hin
bekommst und das ist halt mit Await einfacher weil im Prinzip kannst du mit Await den Code
schreiben wie du ihn synchron schreiben würdest also von oben nach unten aber jedes mal hier
blockt er nicht sondern Return eins oben drüber ist halt ein bisschen Eingewöhnungssache
aber mittlerweile ist fast alles was es so im.NET Framework gibt Async aber GUI ist
auch das beste Beispiel für zum Beispiel noch ein anderes Beispiel wäre zum Beispiel
du hast irgendeinen Webrequest du hast irgendeinen Webrequest und du willst halt nicht dass der
Webrequest zehn Sekunden hängt bei dein eigener Task reicht aber mit dem GUI lässt
ich glaube ich am besten am besten erklären so weiß jemand ob Rider einen D-Compiler dabei
hat hat Rider einen Explore und Decode Assembly da kann ich euch das nämlich zeigen was der mit
dem Await macht ich habe keine Ahnung wie das funktioniert habe ich noch nie gemacht wenn man
das nämlich dekompiliert was.NET hier draus macht ist das immer noch ziemlich lesbar und
man sieht was aus dem Await wird mit Rider irgendwas dekompilieren keine Ahnung kann man das?
Ah das ja ja ok das ist gut das ist richtig gut das habe ich schon in ein paar Streams gesehen ok
das machen wir jetzt mal also wir machen jetzt hier Task plupp wir kopieren uns jetzt mal den
Kram rein Using System Threading glaube ich ne wo ist wo ist Task drinnen? Weiß das gar nicht
ich lasse das immer so wo ist dann Task drinnen? Using System Threading Task ist es glaube ich
und was hat er hier für Schmerzen? Ich hab das noch nie verwendet geht das? Public Class C Await M ok dann machen wir das so, pluppieren wir das nämlich hier rein
Public kann das auch für mich formatieren Using System Threading Task und threading genau da kann man sich nämlich schön angucken was der da draus macht so und jetzt noch die Methode die das ganze aufruft
naja
ok hier sieht man es guckt es sieht übelst wie aus aber das ist was Await unter der Haube macht
so hier ist das ist jetzt halt IL Code was rauskommt also sprich das zwischenkompilierte
ding von von C-Sharp wo sind wir jetzt ok void main ist egal task test gut das hier ist meine
meine testmethode hier und das hier ist plupp plupp ist relativ easy plupp sieht dekompiliert
ungefähr so aus wie plupp im source code also so so ungefähr nicht so viel unterschied man
erkennt es immer noch so aber hier wirds jetzt hier wirds jetzt interessanter man sieht hier
oben schon dieses async state machine und das sieht jetzt schon ein bisschen anders aus das ist nämlich
die hier mit das ist die Methode also sprich Await plupp Print 1 Await plupp Print 2 Await plupp Print 2 fertig so und man sieht irgendwie
sieht diese Methode und diese so komplett anders aus warum weil der diese Methode quasi in einer
extra class wrapped und das ist die logik von Async und Await was hier oben reinkommt
also das hier ist quasi dies das ist diese klasse die regeneriert aus diesem also das hier ist mein
Async Await code wird das hier draus gemacht so und hier sieht man auch schon so ein bisschen die logik was
passiert da muss ich das jetzt gar nicht so sehr im detailer gucken 100 prozent alles kann ich euch
davon auch nicht erklären er hat zumindest eine neue klasse generiert die Async state machine
implementiert so und move next das ist quasi so der iterator den er hier aufruft also sprich
ich rufe test auf er legt eine neue state machine an nach dinger die ich jetzt auch nicht alle
erklären kann zumindest der erste das erste Await sieht man hier wo ist mein erstes Await
wo ist Print Result Moment wo ist mein console write line siehts ihr mal wo ist mein console
write line eins wo ist es hier ist mein console write line eins hier ist irgendwo mein console
write line zwei genau da geht hier rein in dieses switch und wenn der dann das ist ganz eklig
gebaut auch mit mit go tos und sonst was also sprich der geht in dieses switch rein und return
zwischendurch oder macht der irgendwelche go tos und sonst was also man sieht zwischendrin
immer der geht wieder raus also der der beendet die methode wirklich stimmt wo kann man auf dark
stellen o f mein zeug ist weg top warum ist mein zeug weg super toll ne zumindest ich hoffe man hat
es jetzt ein bisschen besser besser verstanden also sprich der macht gar nicht wirklich das hier
nacheinander sondern der macht jedes mal einen return wenn hier ein Await kommt wenn es noch nicht
fertig ist und dann springt er wieder zurück rein es ist es ist ein bisschen komplizierter was was
man aber daran schön sieht ist dass Async Await reine compiler magic ist. Async Await ist nichts
was jetzt großartig da runtime wobei mittlerweile wahrscheinlich schon ich kann es euch nicht
genau sagen was da großartig runtime mäßig unterstützt werden muss sondern das ist reine
compiler magic Async Await. Await hast du ja ja allerdings return das zu dem thread oben drüber
den es nicht gibt also das ist ja hier schon main also das ist ja schon der main thread
da kann er nicht mehr weitermachen hätte ich da jetzt noch mal was drüber was aus dem anderen
task aufruft dann wird er da return aber hier muss er ja warten bis fertig ist weil hier will
ich ja vielleicht auch das ergebnis verwenden danach weil hier muss er sich ja dran halten an
die reinfolge ja wir könnten sonst jetzt ich weiß nicht kann man das hier komplett rein kopieren
ne das funktioniert nicht oder stimmt das kann auch kein csharp 6 das kann auch kein csharp 6
neun dotnet fünf csharp neun so ja siehst du aus dieser müll kommt aus dem ganzen Async Await
hinten raus return state machine builder task ist ganz interessant aber ganz ehrlich man muss
es nicht übertreiben das ist ja gerade auch eines der vorteile von csharp dass es gut verständlich
ist ohne dass man sich die details jetzt so extrem anguckt zumindest was man sich bei Await
einfach merken kann ist dass ein Await im prinzip ein return Await ist also eigentlich ist es so
was hier wir haben übrigens auch immer nicht weiter gemacht mit dotnet 5 csharp 9 ok gab's
irgendwelche anderen sachen ich weiß es ehrlich gesagt nicht wie go to naja intern wenn die
irgendwelche compiler magic machen und das verhalten klar abgegrenzt ist was passiert
warum kein go to das wäre auch ohne go to eklig hab schon mal gefragt aber was hältst du von
co-routines in kotlin ich habe mit kotlin noch nie was gemacht ich bin quasi kotlin jungfrau
das ist kirby multithreading ist immer verwirrend ja korrekt könnte man keepers mit zwei faktor
erweitern weiß das jemand keine ahnung wie gesagt also wollte ich ich habe es dir zu gut
erklärt wie ich konnte ich hoffe man hat man hat es halblich verstanden oder gut machen wir
weiter also positionen rekords ja jetzt machen wir dieses ganze async-await zeug mal wieder weg
um mal zu der eigentlichen sache zu kommen die wir heute ausbringen das hier finde ich ein
richtig nice feature positionen rekords was sagt er mir überhaupt make class sealed ja stimmt also
positionen rekords finde ich poggers ich kann eine ganz kurze prägnante sache schreiben ohne
hier zigtausend sachen zu implementieren und rauskommt eine klasse die ich einfach als daten
container verwenden kann finde ich nice der immutable klasse wohlgemerkt gut machen wir mal weiter also
das haben wir uns angeguckt in it in it only setter haben wir uns auch angeguckt top level
statements jetzt kommt was für die python fans unter uns so muss man es jetzt machen
und man kann jetzt main top level machen das ist jetzt in valid C sharp programm
das funktioniert wie ihr seht ich sage doch das was für unsere python fans das
ist jetzt in valid C sharp programm allerdings unter der haube wir können uns das ganze mal
in diesem schapland aber schapland ist doch nicht dort net 5 aber es ist doch kein dotnet
5 kam in dotnet standard irgendwie umstellen geht das aber doch exzellent das macht der
C sharp compiler aus dem da also der macht ein ganz normales internal static class program
private static void main hello world raus also im prinzip wird das hier durch compiler magic
nur transferiert in ja so was da aber das wie gesagt das wird unsere python fans freuen
bei way was man nicht machen kann ist mehrere top level methods zu haben dann weiß er nämlich
nicht was davon main ist also wenn ich jetzt glaube ich neu noch eine zweite datei oder
so anlege ich habe ich in dem webkasten das geht nicht wobei das hier finde ich persönlich
ziemlich cool also man kann jetzt hier ganz normal dass die scharpe zeug machen das cw
lull die frage ist das kann ich erwarten ich kann sogar das ist ein erstes main das
ist doch mal was also für schnelle sachen ausprobieren ist das doch sehr nice das ist
jetzt well it's the sharp ohne ohne ganz viel boilerplate drumrum ziemlich cool kleine
änderung man sieht eigentlich nur compiler magic also reine compiler magic da ist nix
runtime support aber aber coole sachen das sieht so ungewohnt sauber aus
aus jetzt mal eins für alle funktioniert gut ich glaube die katze ist an der tür
jetzt legt sie sich auf den schrank bei mir und schläft gleich ja dann macht
das mal cico hast du dir eine neue katze geholt die habe ich jetzt schon über ein jahr bei
die cico ja genau übrigens übrigens katze heißt cico was meint ihr ob es ist weibchen
oder männlein cico also ich kann sagen es ist es ist ein grill es ist ein grill aber
sie heißt cico was irgendwie nicht so passt weil er müsste nicht eigentlich cica heißen
trans kender genau kenne kanzler soll jetzt auch cico kommt mich nicht so bös an den
bist du nicht alles gut alles ist gut guck nicht so bös meine katze ist beleidigt ja
genau ich habe assumed das hat sehr hat sehr aufgeregt ok so machen wir weiter also was
haben wir hier als nächstes noch schönes top level sicherprogramm also das passt alles
das haben wir uns anguckt da gibt es glaube ich nicht so viel dazu zu sagen ich kann jetzt
mal die tür wieder zumachen weil die katze hat sich auf den schrank gelegt
so nicht jetzt gerade auf dem schrank ob ich das bild das bild hier nicht drin so
legt sie gerade auf den schrank mich an ja ok schauen wir mal weiter moment man kann
jetzt komplett one liner machen ist das los den guck mal cute chat ajaja das ist gültiges
die schaap jetzt einfach eine zeile ich sag doch die pyson fans freuen sich jetzt genau
only one file in die application may use top level statement also das heißt wenn ich jetzt
eine zweite datei anlege und auch so was reinschreibe probieren wir das mal aus was er dann macht
dann sagt er wahrscheinlich geht nicht omega lull
wieso ja weil er unter der haube da wieder eine ganz normale meinmethode draus macht
eigentlich tibet das ist reine compiler magic reine compiler magic so also was was gibt es
sonst noch neues das ist ein feature das ist jetzt für das da explodiert der kopf leute
ich sag es euch der platzt bei diesem feature das kapiert nämlich auch nicht richtig das
ist total abgedreht was man als machen kann pattern matching enhancements also pattern
matching vielleicht ein bisschen mal ein bisschen was zu zeigen ist das wie in rust es ist mittlerweile
ähnlicher als ähnlicher wie in rust als vorher also zum beispiel so die einfachste pattern
matching geschichte kann man in dem if machen so was machen wir da für schönes beispiel
ok wir machen jetzt hier war gleich eins ich kann jetzt zum beispiel mit gucken if
das ist jetzt bescheuertes beispiel der zeit ist int das ist jetzt natürlich doof weil
ich habe hier oben ja selbst belegt das sagt ja auch es ist es ist es ist es ist es ist
always true oder so und das ist jetzt neue genau also ich kann sagen ist int und wenn
int ist wenn int wenn wenn i ein int ist dann schreiben wir den wert in b das ist jetzt
natürlich ziemlich sinnlos in dem beispiel was ich hier gezeigt habe so es wird es wird
noch advanceder es wird advanceder wenn wir einen switch draus machen switch so jetzt
kann man natürlich nicht jetzt kann man natürlich nicht cases generieren wenn wir machen wir
einen int draus ich glaube da kann man das besser zeigen so lul so emotes emotes emotes
int emotes ayaya monkaS lulw kekw so das reicht jetzt als beispiel switch emotes nee quatsch
ich muss ja erst mal was an deswegen im neuen top level verwirrt mich mega emotes ob geht
das nicht was ist happening was hat etwas okay das verstehe nicht warum geht das nicht
ob geht das nicht public ich glaube der compiler ist nicht magic genug ja ich glaube der compiler
ist echt nicht magic genug top level status must precede precede namespace and type declarations
ah ich kann keine neuen sachen anlegen okay da muss ich das so rum machen meinetwegen
so rum ist auch okay so ist auch okay so general switch labels so das ist das ist die klassische
art zu checken was denn beispielsweise gerade also wenn ich die und also mal angenommen
ich hätte eine methode und ich kann unterschiedliche werte haben so da kann ich das quasi so die
klassische art zu checken okay ist das ist es ayaya ist es monkaS ist es lulw ist es
kekw oder so was in der richtung so die neue syntax ist jetzt quasi so was in der richtung
was jetzt schwierig zu zeigen ist ehrlich gesagt ihr macht immer anders wir machen
objekt objekt draus kann jetzt ja alles sein potenziell ja wenn ich das da als obje reinkriege
so das kann ich zum beispiel sagen okay das war value beste beste name aller zeiten das
kann ich mal sagen case value ist emotes oh fuck wie geht es weiter ich bin dazu low
brain für wie immer deshalb schreiben value ist emotes where ne when ach du große kacke
emotes weh wenn weh ich krieg es nicht gebacken ich verwende das nicht so oft ich verwende
sich oft genug warum sollte man das tun warum man das tun soll ist um zu prüfen was das
für ein objekt ist zum beispiel also mal angenommen ist das könnte den ins sein das
könnte den enum sein das könnte den string sein oder sonst was also ich kann zum beispiel
sagen if case ach nee im moment ist case ist so kann ich glaube ich mache oder ist string
b ging das so ich bin zu low brain dafür wie ging das denn jetzt nochmal ok beispiel gucken
funktioniert das nicht wie sql synthax nee was du meinst ist link alter hör mal auf
ich will euch erstmal das alte zeigen bevor wir jetzt komplett mein mein plot switch pattern
matching c sharp ja genau so wie sind sie so wie sind sie schon acht war case apple man
braucht das ist gar nicht ok das heißt ich kann jetzt überprüfen ist es ein string ich
kann jetzt überprüfen ist das ein emotes in am zum beispiel und so was ok ok genauso
war das so und dann kann ich noch sagen ok wenn value den string man ist ja objekt es
könnte ja alles sein so wenn es wenn es ein string ist dann kann ich sagen wenn string
dann wenn string contains a ja ja und dann gebe ich 123 aus warum ist das warum ist das
jetzt warum ist das denn hier jetzt eigentlich grau remove unreachable code der weil der
weiß weil value der weiß weil value ist nie ist nie string der ist writer ist zu writer
ist zu big brain dafür writer ist zu schlau gut dann machen wir das jetzt anders public
void test objekt oh so ist gut jetzt jetzt ist writer nicht mehr jetzt ist writer dumm
jetzt kann writer das nicht mehr so also ich habe eine methode wo ich ein objekt reingeworfen
bekomme so jetzt kann ich überprüfen ok ist das objekt ein string und wenn es ein string
ist dann gucke ich auch ob es a ja ja enthält so dann kann ich noch gucken ok ist es ein
emote wenn es ein emote ist dann will ich gucken ob es gleich monka es ist so das ist so das
ist so ich habe sechs added
gibt es in C Sharp kein Object Slicing, ich weiß nicht, was du mit Object Slicing meinst.
Es gibt sowohl Slices über Arbeitsspeicher, also über Memory, es gibt Slices über Arrays,
es gibt Range Operator für Arrays, das ist übrigens auch ein super neues Feature, ein
tolles neues Feature von C Sharp 8 gewesen, was kaum jemand verwendet.
Also wenn ich hier eine Liste habe, wenn ich jetzt eine Liste habe und ich möchte von
dieser Liste das erste bis zum fünften Element rausholen, dann kann ich sowas hier machen.
Int B, naja, das ist neu seit C Sharp 8 glaube, das ist eigentlich richtig cool und total
underrated.
In Ruby und Python verwendet das jeder, aber diese Range Operators ist in C Sharp total
wenig verbreitet, man kann sogar sagen, ich möchte von eins bis zum Ende, da kenne ich
diese, da genau, ich glaube, ich bin mir nicht ganz sicher, ich möchte vom ersten Element
bis eins vors Ende und solche Dinger, oder war es der Raute, nee es war glaube ich das,
also sprich das ist jetzt vom, oder vom Anfang, ach nee genau, das kann man auch weglassen,
aber das sieht mega kryptisch aus, das sagt, ich möchte vom Anfang der Liste bis zum vorletzten
Element alles haben.
Ich finde es ziemlich nice, aber total underrated in C Sharp.
Ok, kommen wir mal zu diesem Pattern-Matching-Gedöns zurück.
So, was man natürlich auch machen kann ist zu sagen, ok, ich will da noch gucken, Case
ist Null, ich glaube, das ging so, oder nee einfach nur Null, so und was jetzt neu ist,
weil ich jetzt gesehen habe, was neu ist, ich kann sagen, Not Null geht auch, hier sitzt
ja aber auf dem, ja ist, so, also das ist jetzt neu, dass man checken kann, ob es Not
Null ist, so ok, das war jetzt schon Big Brain Pattern-Matching, ach das kann man übrigens
noch beliebig, beliebig weiter treiben, man kann glaube ich jetzt sogar checken, wir legen
nochmal so einen Rekord-Typ an, den wir vorher auch hatten, man kann jetzt sogar checken,
if ist das Person, so und jetzt kommt neue Big Brain Magic, alter Break, jetzt kann ich
mal gucken, ob das Person ist Max, so und das matcht jetzt nur, wenn es eine Person ist und
nur, wenn First Name Max ist, so und mit diesem, mit dieser Sorte Pattern-Matching kannst du
die abgrundtief hässlichsten, kompliziertesten Konstrukte aller Zeiten bauen, da platzt euch
der Kopf und ich glaube, da kann man auch weitermachen, when, nee, geht nicht weiter,
aber kann man end, aber man kann sagen, end, geht das, nee das geht nicht, ok und das,
es wird noch viel abgedreht, also ich hab da Beispiele gesehen, wo die checken quasi,
es ist größer, es ist kleiner, es ist gleich, so und man kann quasi hier drinnen auch nochmal
switchen, wir gucken uns, wir gucken uns mal die Beispiele an, also das ist jetzt wirklich
nur an der Oberfläche gekratzt, was man damit machen kann, das ist das eindeutig, das Big
Nächste Feature von C sharp 9, so also das ist so der Klassiker, jetzt haben wir ja gerade
gemacht, gucken ob das ein Apple ist, ok, seit C sharp 7 geht das, ja das haben wir
gerade gemacht, Moment, das ist das falsche Dokument, so also jetzt kann man neues Pattern-Matching
machen, Type Patterns, Match a variable is a type, das machen wir hier, String, Klammer,
Patterns, Presence of Pattern Combination, Conjunction, End Patterns, All Patterns, Not
Patterns, Relational Pattern, ok was auch immer, so dann kann man jetzt solche Dinger machen,
is letter, ach du große Scheiße, is letter C, also das ist wieder so eine, das ist eine
Methode mit Expression Body Dings, also im Prinzip könnte man das auch mit Klammern
schreiben, aber die haben sich gedacht, ey jetzt übertreiben wir das richtig, jetzt
schreiben wir das nicht mit Klammern, jetzt schreiben wir das auch komplett so, Moment,
ist das eine Extension Method oder was, this Char, das ist eine Extension Method oder, deswegen
muss Static sein, Phoenix, das ist eine Extension Method, du hast weil du gerade gefragt hast
hier, das ist eine Extension Method, bloß eine echt big brainste Schreibweise von einer
Extension Method aller Zeiten, also nochmal zur Erklärung, das ist auch ein, finde ich
ein ziemlich underrated, das ist die Sharp Feature und zwar, ich versuche euch das mal
zu zeigen, ich glaube das geht hier schlicht und ergreifend nicht drinnen, ich glaube
das kann man hier gar nicht, das darf man hier gar nicht drinnen machen, ok, ok, ich
zeige euch das mal, und zwar, wenn ihr hier ein Character anlegt, dann habt ihr ein gewisses
Set an Methoden für diesen Character, was ist, also Char ist ja eine eingebaute Klasse
in.NET oder in C-Sharp, also sprich, die könnt ihr nicht einfach ändern, aber ihr
könnt die erweitern, nämlich mit einer Extension Method und zwar, machen wir mal hier Public
Class Extensions, ich hoffe das darf man hier überhaupt jetzt so machen, moment, übrigens
so schon mal gar nicht, Extensions und dann machen wir das hier rein und dann darf man
das auch nicht, Moment, was, ah Static, Static, jetzt gehts, so und jetzt werdet ihr feststellen,
wenn ich jetzt auf A gehe, gibts da auf einmal Is Letter, obwohl das ein eingebauter Typ
in.NET ist, habe ich den gerade erweitert und das macht man mit einer Extension Method,
übrigens das komplette Link sind Extension Methods, also das hier, das hier sind alles
Extension Methods, es ist nicht so, dass Array diesen ganzen Scheiß implementiert, List
diesen ganzen Scheiß implementiert, Dictionary diesen ganzen Scheiß implementiert, das sind
Extension Methods, ohne dass man den Typ an sich verändern muss, sprich, ich habe jetzt
eine Extension Method für den Datentyp Char programmiert und this ist einfach nur bei
Extension Methods, der, die Syntax, das damit das aktuelle Objekt gemeint ist, also sprich,
hier wird quasi die aktuelle Instanz, wo ich drauf arbeite, reingeschoben, dass die
Methode damit arbeiten kann, Extension Methods ist auch ein ziemlich underratedes Ding, was
nicht so oft verwendet wird, was aber richtig praktisch ist, das ist übrigens auch eine
der Sachen, die ich extrem vermisse in C++, gerade in C++ wäre es richtig cool, wenn
man eingebaute Datentypen erweitern könnte, zum Beispiel ist die C++ String Klasse, die
Standard String Klasse, unglaublich scheiße, die ist, die hat keine Ahnung von jeglichen
Unicode Sachen, gut C++ sollte sagen, müssen sie auch nicht, es ist ja im Prinzip nur ein
schöneres Byte Array, die hat keinerlei guten Methoden, also sprich, es gibt noch nicht
mal to upper to lower und so was in C++ und hätte man in C++ Extension Methods, könnte
man das wunderbar machen, hat man nicht, nee, nee, das muss nicht Extensions heißen, das
kann auch so heißen, vollkommen egal wie das heißt, wie du das nennst, ist egal, das ist
reine optische Sache, reine Optik, kannst du nennen wie du willst, kannst du sagen Omega
Lul Klasse oder Ayayaya Poggers, bin ich Pegas, Poggers, Keck www kann das heißen, so und
das ist jetzt anscheinend diese neue Syntax für Pattern Matching und das ist wirklich
bisschen Mind Blown, also sprich, was es macht, kann ich erkennen, aber es ist schon echt
Hardcore, übrigens wir können es ein bisschen schöner machen, wir machen jetzt erstmal
eine normale Methode draus, ja, erstmal nur mal, dass man so Busy Busy Busy besser lesen
kann, ok, jetzt erkennt man schon mal, dass es eine Methode ist, ja, das ist eine gute
Frage, ich würde sagen es gibt einen Compiler Fehler, ich habe das noch nie ausprobiert,
ich würde sagen es gibt einen Compiler Fehler, wenn die exakt gleich ist, nope, ok, ich sollte
es vielleicht anders machen, wir machen so noch ein bisschen anders, ok, es gibt keinen
Compiler Fehler, ich habe keine Ahnung, welche davon genommen wird, ich habe keine Ahnung,
beides, ah, jetzt wird er aber meckern, dass er nicht weiß, was er aufrufen soll, genau,
ah, Moment, was mache ich verkehrt?
Ach, Moment, Moment, Schwachsinn, ich muss ja da gar nichts rein machen, das ist ja die
Referenz auf sich selber, ah, guck, jetzt sagt er, es ist doppeldeutig, also sprich
nicht das Anlegen von einer mehrdeutigen Extension-Message führt zum Compiler-Fehler, sondern das Aufrufen
einer mehrdeutigen Extension-Message führt zum Compiler-Fehler, er sagt halt keine Ahnung,
was ich nehmen soll, die Implementierung aus Iaiya Pogas Keg WWW oder die Implementierung
aus Iaiya Pogas Keg WWW 2, natürlich empfehle ich jedem seine Klassen auch immer so schön
zu nennen, wie hier, wusste ich auch noch nicht, habe ich mir das noch nicht ausprobiert,
gut zu wissen, so, aber das hier ist wirklich Next Level Shit, Alter, is letter, C is größer
a and kleiner z or größer a and kleiner, ach du große Scheiße, in dem Fall ist das
ja noch klar, aber ich weiß genau, dass die Leute das Zweck empfremden werden, bis zum
geht nicht mehr, was für ein Casing, Twitch Chat Case, Twitch Case hat die, die hat kein
Camel Case, kein K-Bub Case, kein Pascal Case, die hat Twitch Case, mal gucken, ob die noch
mehr am Beispiel, ach du Scheiße, boah, ey, what, mein, was zum Teufel, bin ich sehend,
das sieht aus wie Opfoskated, ja, das sieht wirklich aus wie, ach du Scheiße, also, ich
meine, man erkennt, was er macht, er guckt, ob C und dann ist es hier kropiert, ok, größer
a, ein kleiner gleich z oder das, das oder Punkt oder Komma, boah, fuck, ok, das ist
jetzt neu, das habe ich euch ja schon gezeigt, dass man checken kann, is not null, das ist
tatsächlich richtig gut, glaubt man gar nicht, aber mal so als Beispiel, man konnte früher
checken, Case null, man konnte nicht checken, Case not null, das heißt, man musste immer,
ich weiß gar nicht, ob man das im Case überhaupt machen kann, man musste irgendwelche komischen
Konstrukte bauen, um zu checken, ob es, ob es not null ist, wenn man das in einem Patternmatching
verwenden will, also man muss zum Beispiel gucken, hier kann, if a is not null, kann
man jetzt machen, is not null, ne, wie, das geht immer noch nicht, ah, Moment, das geht
nicht, weil es not nullable ist, Objekt, ich nehme jetzt einfach, oh, das haben wir
doch hier oben, genau, das kann man jetzt machen, das ging letztes die Sharp Version
nicht, da gab es das not Keyword nicht an der Stelle, da musste man dann solche Dinger
hier machen, is null, not, oder so, ich krieg die Syntax Tasche schon gar nicht mehr hin
aus dem Kopf, irgendwie sowas musste man da, musste man letztes die Sharp Version machen,
hat kein Mensch benutzt, so und jetzt kann man sagen, is not, is not null, ist ein bisschen
schöner, ja, man muss übrigens sagen, dass es an der Stelle natürlich, ah guck mal hier,
der Chat ist big brain, er muss natürlich sagen, dass an der Stelle macht es jetzt relativ
wenig Sinn, genau so ging das, ist hässlich wie die Nacht, an der Stelle macht das wenig
Sinn, weil hier könnte ich ja auch einfach überprüfen, ah, is oh, gleich, gleich null,
ah, das wäre hier die, oder ungleich null, das wäre hier die einfache Variante, aber
das kann ich halt nicht in Bestandteil von so einem Pattern Matching Gedöns machen,
so Performance, okay, sie sparen sich größere Beispiele dafür, also ich hab Beispiele
gesehen davon, das war abartig, was die Leute hier mitgemacht haben, ich versuch's euch
mal zu zeigen, ich hab auf YouTube ein Video gesehen, wo sich die Sharp 9 vorgestellt hat
und da hatten die den Pattern Matching, das war ein ziemlich langes Video, Pattern Matching,
guck mal was der für ein Beispiel drin hat, siehste Leute, es wird schon ekliger, du kannst
nämlich nicht nur ne Switch machen, du kannst nämlich auch irgendwie auf, als Expression
switchen, also kein Switch Statement, sondern du kannst jetzt ne Switch Expression verwenden,
dann wird's schon ekeliger, guckt euch das mal an hier, also das hier war noch poggers
lesbar was wir hier gehabt haben, was ist der Vorteil, ja das muss ich glaube ich im einzigen,
im einzelnen Fall rausstellen, ja Switch Expression sind die Sharp 8, das ist richtig, ja also
die möglichen, man kann jetzt mehr mitmachen, der Switched auf Return, genau, also sprich
der Switched, der nimmt, der setzt quasi das was hier rauskommt dann da ein, also man kann
quasi Variablen damit irgendwie befüllen dann oder so, ich verwende das so gut wie
nie, muss ich ehrlich sagen, ich will aber mal das offizielle Video mir angucken, das
war wirklich extrem Big Brain, wie heißt der Typ, Metz, Into the Future, genau, das ist
der Oberst die Sharp, die Sharp 8, ach Leute übrigens, hab ich es euch eigentlich schon
gezeigt, pass mal auf jetzt kommt's, die hat ne Konferenz und ich hab ne Frage gestellt
in der Konferenz, ich hab ne Frage gestellt in der C-Sharp, in der.NET, in der.NET,
.NET 5 Release Konferenz, hab ich ne Frage gestellt, die müssen wir uns jetzt mal anhören.
It's updating and not, there we go, can we use emojis in Variablen?
Alright guys, I'll let you get back to it.
Und wisst ihr was das beste ist, Moment, Moment, ich muss euch das andere noch zeigen, wisst
ihr was das beste ist, das war ja die übelste Trollfrage überhaupt, ja und ich hab das
auch nur zum Trollen geschrieben, nicht weil ich, weil ich wirklich wollte, dass sie das
beantworten, aber jetzt kommt's, wartet mal, guckt euch mal die Antwort an, ich muss die
Antwort suchen, wartet mal, wo ist die Antwort, so viele Tweets, sticks out for Harambee,
Alter, ja, ja, Tweet, ich hab ne 25 Dollar Giftcard mit dieser Frage gewonnen, das ist
nicht geil, ich hab die übelste Trollfrage gestellt, die haben die Trollfrage beantwortet
und ich hab noch ne 25 Dollar Giftcard gewonnen, so kann's gehen, Alter, nein, das sind Ami
25,00, hätt ich 2500 gewonnen, hätt ich auch nichts dagegen gesagt, heißt die Singleton,
ja, die heißt Singleton mit Nachname, hat mich auch erstmal voll überrascht, ja, tja
und natürlich, wenn die so ein Bild mit Maske und so drin hat, ich hab mal nach der gegoogelt,
die sieht echt hübsch aus, müsst mal googeln danach, Microsoft Stonks Frau, naja, aber
schon nice, oder, 25 Dollar Giftcard und Trollfrage beantwortet, besser geht's doch eigentlich
gar nicht, ok, ich wollt euch jetzt ja das Beispiel mit Pattern Matching zeigen, was
sie hier vorgestellt haben, also das ist der Ober C Sharp Language Designer, seitdem es
der Anders Halsberg nicht mehr macht, der ist es ja nicht mehr, der wartet, dass der
ist die Sharp Erfinder, ich weiß gar nicht, ob ihn Halsberg ausspricht oder Hilsberg,
Pattern Matching, Pattern Matching, Gibt kein Pattern Matching, habt ihr das doch irgendwo
gesehen, hier vielleicht, die hatten ein richtig gutes Beispiel was Pattern Matching angeht,
so ein richtig langes, total abartiges Beispiel, wo ich mir gedacht hab, Monka S, da blickste
dann mal durch, das war ein Beispiel mit irgendeiner Maut, mit irgendeiner LKW Maut und Berufsverkehr
war das Beispiel, vielleicht kennt ihr einer das Video, total abartig, ey hier ist es nicht
drin, ah die Inder sind natürlich auch am Start, das hier, war das das hier, ok die
arbeiten sich noch in Record Types ab, hier, hier, das geht ab hier, genau, Return Vehicle
Switch, Bus, boah, da krieg ich mir Angst zu tun, wenn ich sowas sehe, und das ist noch
ein Beispiel was gut lesbar ist, also man kann glaube ich sogar switchen in einem Switch,
ja guck hier, also ich sag, also das erste ist, so wie ich das hier mache, ist es ja
noch ne normale Statement, so ein ganz normales Switch Statement, ich kann allerdings auch
sagen ok, ich will, keine Ahnung, ich return jetzt hier ein Int und um rauszubekommen was
für ein Int ich returnen will, sag ich jetzt, return, dann switch, ne, Switch, ne, genau,
return, ach du scheiße, ich kann nicht so ein Tag sein, ich mach, ok, return, v, switch
und dann kann ich hier drinnen switchen, ne, muss ich v machen, ich weiß gar nicht, ok,
ich weiß, ach ne, ich switch, ich brauch irgendwas worauf ich switchen kann, ok, o, o, switch
of o, ok, so, das heißt jetzt return ich, je nach, je nachdem was o ist, oh, gibt es
Tiefenlimitationen, so wie ich die kennen nicht, so, so, also, nehmen wir mal jetzt
irgendwie sowas, keine Ahnung, ich hab hier, switch ist ein Int, so, und dann kann ich
jetzt quasi gucken, ist das größer als 3000, ne, ist das, ne, wie mach ich denn das jetzt,
ist das, ist das kleiner als 3000, dann, ach du kacke, ich bin da zu dumm für, muss ich
jetzt sowas machen, eins, und dann, kleiner, 3000 oder so, ne, ok, ich, klammern, wie benutze
ich das überhaupt, ah, ich weiß gar nicht wie es funktioniert, gibt es keine Interfaces,
ich hab doch klar, aber das ist halt, ich weiß noch nicht mal was ich überhaupt machen
muss, was, kleiner, kleiner, 3000, und dann, eins, ah, aber ich kann doch auch sagen, kleiner
3000, end, größer als 5000, ne, geht das nicht, ach so, end geht nicht, oh, muss es
sein, huiuiuiuiuiui, übrigens, wir können es noch, wir können es noch ganz abgedrehter
werden, wir können sagen, objekt, ich geb nen objekt zurück, ok, ich geb nen int zurück,
ich geb eins zurück, wenn es kleiner 3000 oder größer 5000 ist, so, oder ich geb ein,
ähm, genau, new, was machen wir denn, new, string, ne, ergibt eigentlich keinen Sinn,
welche Syntax ist das hier, ok, ok, ok, oah, ey, ich bin, ok, ok, hä, monka giga, ok,
Bus, im Bus, ich kann Bus zurückgeben, Bus, kann ich, kann ich, kann ich auch sowas machen,
ok, es ist größer als 10.000, größer als 10.000, und dann geb ich jetzt nen string
zurück, geht das auch, oder muss der, ah, ne, ok, ok, der return, ne, komm ma, ok, komm
ma, komm ma, pattern has already been handled, achso, oder größer 5000, ja ok, das ist klar,
also kleiner, kleiner, kleiner 10.000, ok, kleiner 10.000, alles klar, ähm, ist zwei,
an string kann ich ja nicht, doch ich kann auch an string zurückgehen, na gut, es ist
ein Objekt, ok, das wird, das wird kompliziert, so, und da kann ich jetzt noch, da noch andere
Checks drinne einbauen, oder wie, also wenn wir jetzt zum Beispiel diesen record type
da unten nehmen, ich hab doch irgendwie record person, so, person, also kann ich sagen, person,
ach ne, ich muss sagen, kleiner, kleiner dem, oh, das ist mir zu big brain, und dann kann
ich ne person zurückgeben, oder wie, new person, ja, funktioniert, kann ich jetzt darauf
wieder switchen, kann ich darauf wieder switchen, geht das jetzt, ne, oder, das, das wäre dann
glaube ich dann doch, wobei doch, das geht doch, oder, ach ne, ne, ne, ne, das geht nur,
wenn das, das ist, was da, was da reingegeben wird, oder, also quasi switch, ach, guck mal,
das kann, das kann ich nicht einmal richtig formatieren, das kann ich nicht einmal richtig
formatieren, so abgedreht ist das, generative patterns, kann ich nicht, boah, ist das, ok,
ich geb zu, dass, ok, man kann abartige Sachen mit konstruieren, zumindest das Beispiel ist
das, was ich euch zeigen wollte, also eigentlich richtig cool, was man damit machen kann, aber
es wird schon schnell, also man wechselt schnell in den, in den big brain modus, ich find's
auch cool, ja, ich find's richtig nice, also die ganzen funktionalen programmierer dudes
hier, die freuen sich jetzt in ast ab, ach ja, das gibt's ja auch noch, stimmt, es gibt
ja noch mehr neue features, sind sogar ein paar ganz coole mit dabei, halten wir uns
jetzt mal nicht zu lange an abgedrehtem pattern matching zeug auf, genau, es gibt native sized
ints, gut, das ist was, was ich relativ selten brauchen werde, das braucht man wahrscheinlich
bei performance kritischen sachen, also sprich, ein int auf ein 32 spit system ist halt, dann,
also native int ist dann auf ein 32 spit system als 32 spit und 64 spit system, ok, bestimmt
für native sachen performancemäßig ganz gut, dann haben wir noch ein bisschen andere sachen,
die jetzt nicht so spannend sind, fit and finish features, also es gibt jetzt diese
möglichkeit hier und das find ich eigentlich recht nice, also man kann jetzt, man kann
jetzt die kurzvariante schreiben, also ich zeige euch jetzt mal wofür ich denke, dass
man das gut verwenden kann, so, machen wir mal den kram hier weg und das ist void und
das ding hier will, keine ahnung, ein i enumerable von int, so, list, immer und man kann jetzt
die liste, also bisher hat man die liste so angelegt, list gleich new lists int, was man
jetzt machen kann ist, aber das ergibt da noch wenig sinn an der stelle, was man jetzt
machen kann ist das hier, also der ist jetzt quasi so schlau und erkennt, ok, wenn der
hier new macht, dann will der wahrscheinlich ne list int haben, das ist insofern ganz cool,
wenn man klassen macht, ich hoffe, wir müssen mal kurz gucken, ob das da geht, so, also
für eine sache, wo ich mir vorstelle, wo das cool ist, public class, plupp, so und dann
hat man sowas wie hier ne private read only concurrent dictionary aus int und frag mich
nicht int und irgendein tuppel aus string s und string b, sowas, macht man jetzt vielleicht
nicht so oft, aber kommt vor, so, was hat der für schmerzen, das ist auch gar keine
methode, so, dict gleich new, so und normalerweise muss man sowas hier machen, also quasi, so,
normalerweise muss man sowas machen und das ist ein bisschen kompliziert, so, jetzt kann
man da einfach nur noch, wenn ich das jetzt richtig verstehe, das da machen, das ist ganz
praktisch, das ist cool, so und wo ich mir jetzt noch, wo ich mir jetzt noch ganz praktisch
vorstelle, ist folgendes, wenn ich jetzt hier ne methode hab, die ne liste haben will
und ich will dann ne leere liste oder ne list initializer oder so übergeben, dass ich dann
sagen kann, test new, das ist jetzt ne leere, neue liste, ohne dass ichs angeben muss und
das ist automatisch quasi, so und ich kann jetzt wahrscheinlich sowas hier machen, ah
ne, das geht nicht, das geht nur wenn es list ist oder, ah ok, ist aber eigentlich auch
ganz nützlich, das ist wirklich highly sophisticated, big brain, also das ist quasi die kurzform
davon, eigentlich auch ganz nett, das sind so kleine features, die einfach das leben
ein bisschen einfacher machen, die jetzt im prinzip auch irgendwie compiler magic sind,
weiß nicht wie ich mir das ganze neues zeugs merken soll, 1337 geht mir ähnlich, deswegen
gibt es sicherlich features aus, die sharp 678, die ich kaum verwende, weil vieles untergeht,
dazu kommt ja noch, das hier ist jetzt, fuck was wollte ich sagen, das hier ist jetzt nur
die sprach features, was wir noch gar nicht haben ist, die ganze framework library zusätze,
die es bestimmt auch gibt, also es gibt bestimmt wieder zig neue klassen im framework, die
man verwenden kann, grpc, kengin ist großer grpc fan, list gleich array, what, ne, ne,
das ist eine neue synthax, das ist die kurzform hierfür, new list int, der kann jetzt seit
der neuen c sharp version, der bronc, kann man das weglassen und der ist so schlau und
erkennt, diese methode will eine list int haben und ich kann jetzt nur new schreiben
mit list initializer und er kapiert, dass mein new an der stelle eigentlich ein new
list int ist, es hat den nachteil, es ist nicht unbedingt gut lesbar ohne ide support,
ich mein guck mal selbst rider checkt das nicht, doch hier schon, also sprich jetzt
gehen wir mal von aus, test ist irgendwo da unten deklariert, wir wissen nicht wo, dann
ist uns jetzt nicht so wirklich klar auf den ersten blick, was das da für ein typ ist,
aber das ist eine sache, wo ich mir vorstellen kann, dass es ganz cool ist, aber das hier
ist für mich das was wirklich lesbarkeit auch was bringt, danno ich weiß nicht wie du das
siehst aber für den fall findest du es wahrscheinlich auch ganz praktisch oder, also hier finde
ich es cool, weil gerade wenn man solche langen sachen hat, das ist einfach abartig zu lesen
hier und total redundant gleicher scheiß und da ist das hier eigentlich, das ist nice ja,
so was haben wir noch für features, das haben wir uns grade angeguckt,
haben wir uns auch grad angeguckt, anosa, was, anosa leute, anosa, anosa nice, anosa
nice use, ah yes yes, das ist cool, das ist cool, guck mal wir haben noch hier unsere
person class, wenn ich jetzt, wenn die metode jetzt ne person haben möchte, die jetzt list
heißt, p besser, dann kann ich jetzt sagen new, auch nicht, warum nicht, ah weil, ah
die muss ich im constructor machen, die sind gar nicht in it only, ah die sind gar nicht
in it only, oh das ist ja doof, gut aber ich mein es ist immer noch kürzer, es ist immer
noch kürzer als new person, ich hätte jetzt eigentlich gedacht, man kann, kann new person,
warum, ich hätte jetzt eigentlich gedacht, das funktioniert, weil wo ist denn jetzt der
sinn davon, ja das darf ich nämlich nicht ändern, ok das verstehe ich jetzt nicht,
ach ich bin ja auch doof, ich darf keine klammern machen, oder doch, ok dann weiß ich auch nicht
so genau, ok dann muss ich die dinger quasi hier über den constructor machen, ok was
kommt da jetzt bei raus, ok ist das jetzt null oder ist es blub und lull, probieren wir mal
mal, es ist blub und lull, wie kann ich das optional machen, nee, nee oder, das glaube
ich nicht, dass es so gedacht ist, eh ok, ich glaube das erfordert noch ein wenig im
detailplanung, das ist irgendwie komisch, weil das richtig coole wäre, wenn man das
quasi standardmäßig so anlegen könnte und ich könnte das hier callen so, ohne dass ich
das da eintragen muss, das wäre cool wenn das geht, das ist schön kompakt und eigentlich
auch ganz gut lesbar, sag mal kennt jemand einen trick wie man rider dazu überreden
kann, dass es beim speichern auto format macht, das geht mir nämlich voll auf den sack, ok
was haben wir ansonsten noch für fiaturis, das haben wir uns jetzt angeguckt, why is
das denn, nee das plugin gibt es für rider nicht, ich kann einen static von lambda expression
machen, also also, ok das check ich noch nicht so genau, warum verwende lambda expression
doch als callbacks oder sowas, so also das nächste ergibt für mich schon mehr sinn,
also ich kann zum beispiel sowas machen, das ist auch ein feature, was selten verwendet
wird, was man auch nicht oft braucht, aber was ich ganz nützlich finde, so also zum
beispiel, was machen wir denn jetzt mal, was gibt es denn ein schönes beispiel für, ja
also zum beispiel process start lull, also das lässt jetzt, das startet jetzt das programm
mit dem namen lull, so und ich subscribe jetzt das event für, nee das ist ein scheiß beispiel,
das ist doofs beispiel, ok mir fällt kein gutes beispiel ein, aber manchmal braucht
man hier innerhalb von so ner metode noch eine und das kann man schon seit glaube ich
6 oder 7 machen, man kann jetzt hier drinne quasi so kleine lokale helper methoden noch
anlegen, also ich kann zum beispiel sagen int generate number, irgendwie sowas, so return
1, das geht, also man kann so nested functions machen, das geht schon ein bisschen länger,
und die kann man jetzt static machen, aha ok habe ich noch nie gebraucht, aber wenn
ich es brauche, ist es vielleicht ganz nice, also man kann jetzt quasi lokale helperfunktion
in, also helperfunktion in methoden machen, was auch ungewöhnlich ist für c-sharp in
sofern, weil die haben lambdafunktionen, also diese geschichten schon, bekommen bevor sie
anonyme funktionen hatten, normalerweise ist das eigentlich eher umgedreht, sprachen haben
zuerst das und bekommen dann das, müsste doch auch für rider punkt 2, gucken wir mal
rein, punkt 2, nein das geht nicht für rider, weil dieses plugin gibt es nicht für rider,
dieses plugin gibt es quasi für so ziemlich alles, nur nicht für rider, warum auch immer
nicht, um mich zu ärgern wahrscheinlich, ja ok das kann man jetzt static machen, mir
fällt jetzt gerade kein wirklicher anwendungszweck ein, warum ich das haben möchte, fällt euch
irgendwas ein, warum will ich eine lokal, static, local, so eine helperfunktion haben,
das ist wahrscheinlich der typische fall von, wenn man es braucht dann freut man sich, dass
es da ist, ich kann euch jetzt mal ein ganz gutes anwendungsbeispiel zeigen für so eine
anonyme lokalen funktion, ich glaube ich habe, ich weiß nicht ob ich das schon gepusht habe,
oh nein habe ich nicht, da kann ich es euch nicht zeigen, weil das hier verursacht einen
memory leak, was ich hier gebastelt habe, weil ich den callback nie unsubscriber, na gut
kann ich euch nicht zeigen, habe ich nicht gepusht, so was haben wir sonst noch für
neue sachen, können jetzt static sein, ok da habe ich wirklich keine ahnung wozu das
jetzt gut sein soll, dann warten wir mal ab, in addition for each loop, dass ich kann jetzt
for each verwenden, wenn ich irgendeinen typ habe, der die nötigen metoden implementiert,
ok, next you can use this card as parameters to lambda, oh das ist nice, das ist wirklich
cool, das hätte ich mir schon öfters mal gewünscht, also zum beispiel wenn man, ähm
action, int int int, das ist jetzt nur mal exemplarisch für ein callback oder für lambda,
so und wenn ich den jetzt hier aufrufe, dann muss ich immer, dann muss ich bisher immer
die parameter mit angeben, moment, jetzt, ach nee, moment, gleich, ähm, so, ähm,
da muss ich bisher immer die parameter mit angeben, selbst wenn ich die parameter gar
nicht haben will, und jetzt kann man so machen, wenn man die parameter nicht haben will, das
ist cool, ähm, nee, wie, ach so, das hier, ja, das, das, jetzt wo du es sagst, fällt
es mir wieder ein, jaja, also du meinst jetzt nicht an event, du meinst, dass man quasi
hier dran jetzt was, was anhängen kann, oder, ja, oder auch nicht, ich weiß aber was du
meinst, nee, das, ähm, war mir so jetzt nicht im kopf, ich hab das schon mal gesehen, ja,
wo, mir fällt es wieder ein, wo du es gesagt hast, aber ehrlich gesagt hab ich noch nie
benutzt, kopf gameplay auf youtube, ja, mal gucken, mal gucken, so, was haben wir sonst
noch schönes, also das mit discard parametern ist wirklich sehr nice, you can now apply
attributes to local functions, boah, jetzt wirds aber abgedreht, alter, nullable attribute
annotation, ähm, mal, frage an euch, die, die vielleicht die eine oder andere ist, die
sharp verwendet, verwendet ihr dieses nullable, not nullable feature eigentlich, ich muss
mich ja mal outen, ich verwende es gar nicht, dabei haben die sich so viel mühe gegeben
mit not nullable, aber ich finde man merkt, dass es irgendwie drauf gestülpt ist auf
ne sprache, die nicht so designt ist, hat das dann nen default wert statt 0, nee, kein
default wert, wenn du not nullable eingeschaltet hast, dann musst du, wenn nen referenztyp
null werden kann, musst du explizit markieren mit nem fragezeichen, also zum beispiel, wenn
ich not nullable einschalte, dann muss ich sowas hier schreiben, und das sagt dann, ok,
best ist ne funktion, der kann ich, kann ich null übergeben, als person, normalerweise
ist das der default verhalten, ne, also, die person kann ne instanz von person sein oder
null, und mit not nullable haben sie es umgedreht, ich muss das, ähm, angeben, wenn es null
sein darf, und wenn ich das mache, dann macht der compiler und, äh, die ide und sowas,
machen paar checks für mich, dass ich mich nicht vertippe, aber ich verwende das so gut
wie nie, guck der sagt mir auch, ich muss, äh, nullable sachen einschalten, jetzt hab
ichs eingeschaltet, jetzt weiß ich nicht wie ichs wieder auskriege, ach hier oben,
genau, weil jetzt, jetzt kann ich sagen, ey guck mal, hier ist null erlauben, null übergeben
erlaubt, das bedeutet, wenn ich test aufrufe mit null, anstatt der person, sagt er mir,
ok, wenn ich das fragezeichen wegmache, sagt er mir, äh, eigentlich darf man hier kein
null reinmachen, aber wie du siehst, es funktioniert trotzdem, das ist nur ne warnung, nur ne warnung,
deswegen ich verwende das so gut, ich verwende das gar nicht, ehrlich gesagt, ich hab ja
jahrelang auch gerne null zurückgegeben, ähm, mittlerweile versuche ich es ein bisschen
ordentlicher zu machen, entweder ist es was, was man logischerweise in irgendein default
wert zurückgeben kann, oder ich mach das, zumindest meistens einzig richtige, ne exception
schmeißen, wenn du nix zurückgeben kannst, ja, also wenn man hier zum beispiel diese,
ich hab doch hier eben euch gezeigt auf github, ne, zum beispiel hier, getoutput, so mittlerweile
sieht das anders aus, getoutput gibt nen channel reader zurück, so, aber getoutput kann ich
nur was zurückgeben, wenn denn überhaupt gerade zu ner kamera connected ist, so, wenn
das hier nicht fehlschlägt, was geb ich denn dann zurück, eigentlich muss ich da ne exception
schmeißen, so nach dem motto camera not connected oder sowas, weil ich kann nichts sinnvoll
zurückgeben, ja ne null reference exception passt ja nicht so ganz, das ist eher so ne
art io exception oder sowas, schwierig, also wie gesagt ich verwende das so gut wie gar
nicht, ups, hab ich zugemacht, hier, also ich glaube das wars im großen und ganzen,
ja, wenn man jetzt mal zum beispiel zurück geht zu csharp 8, da kam ein bisschen mehr
rein, ne, in csharp gab es diese ganzen features für nullable und sonst was, übrigens auch
ein feature was kaum verwendet wird, was ziemlich geil ist, wenn man mal ehrlich ist, kennt
ihr diese geschichte, also ihr habt sowas hier, void tritest, so, das gibt nen bool
zurück, also sprich tritest gibt zurück ja oder nein, also sprich, das war erfolgreich,
wenn es erfolgreich war, dann gibt es irgendeinen wert, machen wir mal, wir machen mal ein beispiel,
tryopen, was programmierst du, wir gucken uns gerade csharp 9 features an, so tryopen,
so und tryopen ist dann quasi kann ich sagen hier if, if tryopen und dann kann ich was
machen mit, so bisher hat man das so gemacht, tryopen, out, outperson, so bisher hat man
das so gemacht, ich hab gesagt if tryopen und dann hat man gesagt out, so in der richtung,
so das heißt ich kann jetzt erstmal checken, ok klappt der zugriff, wenn der zugriff klappt,
dann krieg ich als outport hier nen objekt, also person ist jetzt doof, das müsste eigentlich
eher sowas wie nen file oder so sein, ja, irgendwie sowas, also string, file, pass,
out, out ist nen file, wobei file kann man nicht, aber ich glaub ihr wisst was ich mein,
wir faken das jetzt einfach, lull, dann kann man es besser lesen, dann versteht man besser
was ich mein, so also new file, so das wär so ne typische methodik, also sprich ich geb
jetzt hier den fad ein, so keine ahnung, home, max, keqw.txt und die versuch ich zu öffnen
und wenn das funktioniert dann bekomm ich nen file zurück, so das wär so ne typische
tryopen geschichte, die es auch total oft im framework gibt, ist glaub ich relativ logisch
was es machen würde, es gibt seit csharp 8 ein richtig geiles feature, für ähnliche
fälle, der hier ist eigentlich ziemlich gut so wie er ist, aber es gibt jetzt die möglichkeit
man kann mehr als eine sache zurückgeben, also ich kann zum beispiel, ich müsste jetzt
nicht das hier zurückgeben, sondern könnte jetzt bool und das file zurückgeben, so und
wie sieht der return aus, der return sieht dann so aus, also man kann jetzt zwei sachen
zurückgeben, das funktioniert, so und dann würde ich nämlich sagen tryopen result und
dann sieht man mein result ist jetzt ein tuppel mit item 1 und 2, dementsprechend kann ich
jetzt auch sagen, mal gucken ob der das für mich machen kann, kann ich jetzt auch sagen
result und file und jetzt kann ich hier drauf zugreifen, result und file, das geht glaub
ich mit bis zu 9, ja ich kanns benennen, stimmt das ist auch ein feature, das kann ich mal
sagen, also ich glaube es geht bis zu 9 return sachen, ok nein es geht noch mehr, excellent
alles klar, so muss das sein, so und was auch richtig cool ist, man kann die hier benennen,
man kann sagen result und man kann sagen hier file handle oder so und wenn ich das jetzt
ausführe, dann kann der das automatisch eigentlich deconstructen unter dem name, ne das geht
nicht oder, aber ich glaube rider ist so schlau und kapiert das, konnte rider die dinger nicht
deconstructen für mich, ne oder, aber zumindest wenn ich hier das objekt jetzt hab, dann seh
ich, dann sind die dinger sogar hier richtig benannt, also man kann sogar die return parameter
benennen, allerdings ist das ne reine kosmetik, unter der haube heißen die nach wie vor weiter
item 1 und item 2, kann ich das irgendwie deconstructen, kann das rider, doch easy, kann rider für
mich machen, so und jetzt hab ich hier den result und den file handle, jetzt kann ich
wieder quasi sagen, if result file handle, ja das ist ein ziemlich underratedes feature
finde ich, wofür das ziemlich gut ist, ist es für solche sachen hier, also zum beispiel
ich hab hier nen dictionary mit nem key, möchte aber jetzt nicht, also die standard variante
wäre, wenn ich nen dictionary hab mit nem key und möchte hier als value mehr als einen
wert speichern, dann würde ich irgendwie ne klasse machen, keine ahnung was weiß ich
hier, dict info und dann dort 2 sachen anlegen und hier sagen, es ist nen dict info, so, so
wird man das normalerweise machen, aber wenn das was ganz easy ist, was aus 2 sachen besteht,
dann kann man das auch hier so machen, so und wenn man jetzt hier drauf zugreifen will,
sieht man zum beispiel dict, genau und try oder hier get und wenn ich hier drauf zugreife,
sieht man hier, dass ich b und s kriege, also sprich das was ich hier benannt hab, das ist
ziemlich underratedes feature, ok und hier sind 30 milliarden sachen noch drin, das
gucken wir uns jetzt nicht an, eines meiner lieblings sachen in csharp 8 ist das hier,
das ist richtig nice, async enumerator, das ist quasi, da kann ich quasi ne for each
schleife machen, in der ich awaiten kann, das ist sehr praktisch, ja das geht auch,
fips das funktioniert auch, man kann auch sagen, man kann auch sagen, das, ach geht
das nicht, ah moment, was mache ich denn da, ich bin doch falsch, ich kann auch sagen,
das filehandel interessiert mich nicht, das geht auch, channels sind richtig nice, channels
haben wir hier irgendwo schon mal drin eingebaut, ah meine ordnung, ja channels, da haben wir
schon channels eingebaut und irgendwo machen wir auch async hier, das ist eines der geilsten
features aus csharp 8, man kann jetzt ne for each machen, in der man quasi sowohl return
mit await, als auch mit nem neuen element, das ist ziemlich cool, ja, boah leute, das
war jetzt big brain stream, was ist hängen geblieben von den neuen csharp features, lasst
mal überlegen, also, was ist hängen geblieben, also, records, coole sache, die kurzschreibweise,
rest weiß ich nicht so wirklich, init only setups, werde ich wahrscheinlich hier nur
im zusammenhang mit records verwenden, ich glaube nicht, dass ich das oft da anwendungszweck
finde, top level statements finde ich cool, aber nachdem ich selten konsolenanwendungen
mache in letzter zeit und wenn es zum beispiel ne asp.net anwendung ist, dass eh das template
für einen generiert, eher für vorführezwecke, pattern matching werde ich wahrscheinlich
in zukunft häufiger verwenden, allerdings dauert es ein bisschen bis ich da mein hirn
rum gerappt habe, dass ich das checke, wann man wie was verwenden kann, csharp hat sich
pyson generieren, bisschen vielleicht eigentlich nicht, eher, eher rust vielleicht oder skala
oder so, irgendwas in dieser richtung, hier lernt man was, guck mal was ich für techs
drinne hab, lehrreich, educational habe ich als tech drinne vom video, da muss das ja
auch mal, muss ja auch educational sein, so native size integers habe ich eigentlich
keine verwendung für, function habe ich mir gar nicht angeschaut, äh brauchen wir die,
brauchen wir nicht, ähm target type new expressions stelle ich mir cool für, gerade für ne variabler
in der klasse, das jetzt nicht, dictionary von dictionary mit dictionary gleich new dictionary
von dictionary mit dictionary schreiben muss, sondern einfach nur gleich new, finde ich
cool, static anonymos functions, ich hab keinen plastenschimmer, wozu man das braucht, ich
hab da gerade überhaupt kein anwendungszweck im kopf, ähm target type conditional expressions,
dann hab ich schon wieder vergessen was es ist, ähm hab ich auch schon wieder vergessen
was es ist, hab ich auch schon wieder vergessen was es ist, ok, discard parameter für lambdas,
das werde ich auf jeden fall oft verwenden, das ist nice, weil meistens brauchst du gar
nicht alles was da so zurückkommt, oder oftmals, oftmals, so attributes on local function werde
ich wahrscheinlich auch so gut wie nie verwenden, module final initializer weiß gar nicht mehr
was es ist und new features for partial method interessiert mich auch nicht, also man muss
sagen c sharp 9, äh bei weitem nicht so dieses riesen feature release wie jetzt c sharp 8,
aber trotzdem nice Sachen und es ist ne ganze ecke funktionaler geworden, als es davor war,
also gerade diese pattern matching geschichte und auch diese record types, also man sieht
und das ist ne sache die ich wirklich cool finde an c sharp, man sieht das die nicht
stehen bleiben mit der sprache, man sieht das die aktuelle trends auch aufgreifen die
sich bewährt haben, dass sie cool sind, dass sie gut funktionieren und sie bauen das ein,
und zwar mit hirn bauen sie das ein, nicht so wie das t++ cremium wo jeder was anderes
einbaut und du überhaupt nicht mehr verstehst was eigentlich sache ist, ahja interface default
implementation, ähm weißt du elsa weißt du warum ich glaube warum die das gemacht
haben, ich glaube das hat also interface default implementation der einzige grund warum die
das gemacht haben ist eigennutz, weil microsoft gerade was office angeht 75 interfaces hat
die interfaces erweitern die schon da war, also die haben dann office interface 1, office
interface 1x, office interface xx, office interface xx, office interface 5x, office 555x, so und
die hatten einfach keinen bock mehr drauf und haben deswegen die default implementations
für interfaces eingebaut, ich glaube kein mensch verwende das außer microsoft selbst,
verwende einer von euch die default implementations in interfaces, ergibt eigentlich keinen sinn
das das gibt aber ok, also es gibt ja die möglichkeit ein interface anzulegen in c
sharp, so ai interface beste, so und ähm, da kann ich jetzt neuerdings defaultsachen
implementations, ich weiß gar nicht wie es funktioniert wenn ich ehrlich bin, einfach
so ok, total wir, gibt es interfaces mit default implementations, habe ich noch nie
verwendet, ja bei comobjekten ist das ja generell bei microsoft native sachen ist das total
beliebt dass die ihre interfaces 1, 2, 3 bis 5075x, xx, xx, xx haben und ich glaube das
haben die aus reinem eigennutz gemacht, das ist keine abstract class, nee das ist keine
abstract class, das ist ein interface, ich kanns dir nicht genau erklären ehrlich gesagt
da muss ich jetzt mal nachgucken, ich hab, ich verwende das nicht, glaub der unterschied
ist zwischen der abstract class und dem interface, dass du, ähm, gut du kannst ein paar sachen
im interfacing machen wie private methoden und sowas in der richtung, das ist der prinzipielle
unterschied und dass das hier weiter rückwärts kompatibel ist, also ne abstract class ist
so, wenn du ne abstract class erweiterst, dann muss alles was virtual ist implementiert
werden, so bei nem interface ist es jetzt so, mal angenommen ich hab hier nen interface
voidplub, so, so sah das interface mal ursprünglich aus, so und jetzt komm ich auf die idee ich
möchte eigentlich das interface erweitern mit lull, jetzt ist ja die sache so, ich hab
schon ganz viele klassen dieses interface implementieren und ne eigene lull, ne eigene
plub methode haben, wenn ich das interface jetzt erweitern will ohne, dass ich 50 oder
500 klassen die das interface implementieren anfassen will, dann kann ich ne default implementation
hier reinhauen und dann geht nix kaputt, wie gut sich das umsetzen lässt und wie gut sich
das dann in die alten klassen integriert sei mal dahingestellt, hab ich keine erfahrungen
mit hab ich noch nie verwendet, chat ich weiß nicht wie es bei euch aussieht ob das einer
von euch verwendet, hab ich noch nie verwendet, hab ich noch nie benutzt, kein klassen shimmer
ich hab keine ahnung was taugt, ja, so chat das war echt anstrengend big brain stream
dreieinhalb stunden, solange haben wir uns jetzt die sharp features eingeguckt, chat war
anstrengend, ich hoffe euch hat es gefallen, ich muss mich da selbst erstmal ein bisschen
dran tasten was es da für neue sachen gibt, sagt mir mal chat, hat man wenigstens ein
bisschen was gelernt bei, ja auf jeden fall nice wenn der ein oder andere vielleicht noch
was gelernt hätte, war ja immerhin educational stream, ja und ihr merkt vielleicht ich mein
ich weiß das auch nicht bei allem, also bei sachen die ich selten verwende hab ich da
auch oftmals keinen plan, geht glaube ich jedem so, die sachen die man nicht oft macht
die man kann sie nicht alles wissen, ist ja letztendlich das wo man auch mal irgendwie
drauf klarkommen muss, man kann einfach nicht alles wissen und es ist auch letztendlich
keine schande, man muss einfach nur wissen wie man sucht, poggers google skills sind
das wichtigste was man haben kann wenn man in der IT arbeitet, das sag ich auch den azubis
immer, ihr müsst so weit ahnung haben, dass ihr wisst wonach ihr suchen müsst, kannst
du mal deine meinung zur ps5 sagen, ja und ne weil ich hab mich weder mit der neuen xbox
noch mit der playstation großartig beschäftigt, ich finde nur dass die playstation 5 ultra
groß ist oder der japaner das vorgestellt hat war ziemlich klein, ansonsten kann ich
da gar nichts zu sagen, es sind im prinzip beides mehr oder weniger stink normale pcs,
halt mit exklusiv sachen, stack overflow triffen programming ja sieht so aus, ist
aber so, wenn man mal ehrlich ist, die leute denken zwar programmieren würde so aussehen,
krasse Hacker man am start, die leute denken in wirklichkeit so sieht programmieren aus
ja ja aber in wirklichkeit sieht programmieren so aus
das ist das somit eigentlich programmieren ja, true 0w, jeder der es macht weiß dass
es so ist, jeder der in dem bereich arbeitet, was man was macht privat ist egal, jeder weiß
dass es so ist, die außenstehenden noobs denken man ist ein richtiger hacker man, in
wirklichkeit programmieren, eigentlich klaut man sich nicht auf stack overflow zusammen,
man guckt sich da was an und ändert das dann auf das was man braucht, genau das genau
wie in dem video ist das, übrigens bestes programm hier, ah yes, ich hoffe ihr seid
auch die krassen hacker mans wie ich hier, vor allem der matrix bildschirm schon da unten,
der ist ganz ganz wichtig, ich hab legit keine ahnung was da passiert, das ist ein h-top,
was auch immer da überhaupt passiert, er generiert nicht, was ist speedometer 2.8,
irgendeinen hacksdump, ist das eine weltkarte, ist das ein ascii video oder matrix bildschirm
schon naja, ja so muss das sein, das ist der richtige hacker mode, ja so ist es in wirklichkeit
und dann arrow geht nicht, vor allem ist es auch noch java, so genau so siehts aus, ist
sein haus fertig renoviert, jaja klar seit jahren schon, ich mein 2013 sind wir eingezogen,
das war dark, ich muss sagen, egal wie ordentlich ich was programmiere, wenn ich da nach einer
gewissen zeit wieder ran muss hab ich nie bock, wann kommt das gartenstells video 3.0, ja
ich hatte ja vor im december viele videos zu machen, von denen ich noch so gut wie nichts
erledigt hab, ihr kennt mich, vielleicht gibt es dann auch wieder ein gartenvideo, arayan
twitch prime, dankeschön, für den sub, eigentlich wollte ich jetzt Schluss machen, eigentlich
wollte ich jetzt Schluss machen für heute, 21.55, ich bin müde, ich mein guck doch mal
an wie lang ich heute gestreamt hab, war hier, heute morgen, heute morgen 4 Stunden und jetzt
noch mal 3.5 Stunden, morgen cold war story stream, könnten wir eigentlich machen, ja
ich freu mich wirklich auf die cold war story, ich fand black ops 2, 3 nicht schön von der
story, 3 hab ich glaub ich die story gar nicht gespielt, aber 2, wirklich nice fand
ich die black ops 1 story, also black ops 1 story find ich mit die beste cold of duty
story, überhaupt ja, ok leute wisst ihr was, ich geh jetzt ins bett, machts gut, wir sehen
uns, see you.
