So Leute, ich hatte jetzt die Auswahl, ob Battlefield 5 oder ein bisschen an unsere
Steam-Board weiterprogrammieren und ich hab... ich war schon kurz davor, Battlefield 5 anzumachen.
Ich hab quasi schon... ich hab quasi schon so dargesessen, so hier.
Gerade Battlefield 5 starten, da hab ich mir gedacht, nee, eigentlich hast du keinen Bock.
Das ging mir so auf den Sack eigentlich, ich hab da nochmal so drüber, wie nennt man das,
resümiert. Ich hab da noch ein bisschen, aber gestern Abend so ein bisschen bin ich in mich gegangen.
Irgendwie hat mir Battlefield 5 nicht gefallen.
So nun jetzt vom ersten Eintritt hier in der Alpha.
Da waren so viele Sachen dabei, die nicht gekonnt sind einfach.
Wo ich mich frage, hat da jetzt keine Leute mehr? Warum?
Ich weiß nicht.
So, jetzt mal kurz Musik quasi leiser machen und was anderes anmachen als 24-7-200-Princess-Musik.
Was machen wir denn mal an?
Was machen wir denn mal an?
Ähm, gibt's denn da so schönes?
Lass mal kurz überlegen, was könnte man dann schon... irgendwas entspannendes?
Gucken wir mal, was es hier gibt.
Äh, Chill Music Radio.
Horizon Zero Dawn Soundtrack, den kenn ich nicht.
Taugt der?
Gatschi-Bass.
Mal mal an.
Nee, da wird zu viel gesungen, weil das ist nicht entspannt genug.
Ost.
Oh, vier Stunden ist gut.
Ah, das ist zu monkeis.
Ich brauch irgendwas entspannendes.
Depth of Field Mix, was?
Was für ne Mix?
Das klingt entspannt.
Darf befehlen, nein, nein, nein, nein, nein, nein.
Das hatten wir gestern schon, das reicht.
Was ist das denn?
Was ist das denn?
Was ist das denn?
Was ist das denn?
Das klingt entspannt, das reicht.
Oder, ich muss euch wieder quälen.
Nein, heute nicht, heute nicht, heute ist gut.
Heute nicht.
Komm, Leute, bevor es losgeht, wir müssen jetzt, wir müssen noch einmal den Mega Upload Song anmachen.
Den haben wir schon lange nicht mehr gehabt, den Mega Upload Song.
Das ist doch schlecht.
Bevor wir anfangen.
Upload to me today.
My name is Peter.
Low, low, load.
Low, low, load.
Ob die Typen wussten, in was sie da eigentlich auftreten?
Never, oder? Niemals.
Mega Upload.
So schlecht.
Aber, ich meine, das ketscht schon, ne?
Mega Upload.
Das müssen wir abbrechen, das müssen wir abbrechen kurz vor Schluss, weil dann loopt das ja nur noch.
Oh, ich weiß, was wir danach machen wollen.
Easy.
Lucio Song, 10 Minuten.
Alter, Chat, ist ja gut.
Off the Internet.
Get the Mega Manager.
It's ten times faster.
Bit by bit.
Unlimited.
It's a hit.
It's a hit.
N-E-G-A.
Upload to me today.
Send me a file.
Mega Upload.
Mega Upload.
N-E-G-A.
N-E-G-A.
N-E-G-A.
N-E-G-A.
Upload to me today.
It's 10 times faster.
It's a hit.
N-E-G-A.
Kleigh escaping from ped cocside.
Guck mal, guck, sagst du die Rammer aus, sagst du gar nicht, aber guck, bis der Garbage-Collector einmal gelaufen ist, dann ist gut.
Ah, es zahlt so, es zahlt kein 10++, dauert halt ein bisschen bis es aufgeräumt ist, ob es auch nicht schlimm.
Geht dann auch wieder runter.
Garbage-Collector und 2k18.
OBS 10 Hotkey, nee.
Nicht OBS 10 Hotkey.
Viel besser.
Viel besser.
Selbst gebastelt.
Oh, ich halte es aber aus.
Wo, wo habe ich es auf?
Vor allem, das geht so lange.
Tropical Beach-Musik, das ist auch immer super.
Ruhe jetzt.
Die One Hour Kirby Jazz Remix.
Boah.
Ich habe gleich da auf dem Screen.
Ach, sagt es doch auch Leute.
Siehste.
Das ist wieder ein Grund dafür, warum ich dieses Ding programmiert habe.
Weil ich immer vergesse, Sachen auszuplenden.
Oh, das lassen wir jetzt.
Das ist nice.
Mal für jemanden komplett out of the loop, was kann das tun?
Bilder anzeigen, GIFs anzeigen.
Demnächst Sounds abspielen, auf Hotkeys gelegt.
Du hörst hier.
Das kann das.
Und das Beste ist, der Streamer sieht es selbst.
Was bei OBS Hotkeys nicht der Fall ist.
Und es hat keinerlei Auswirkungen auf andere Anwendungen.
Das ist wie, als wäre es nicht da.
Guckt, wenn ich es ausblende, das Markieren bleibt immer noch da.
So, und was wir heute machen, ist,
ihr baut ein Web-Interface ein.
Aktuell, ich zeige euch mal den Ordner.
Guckt mal, ich habe jetzt zum Beispiel, wenn ich hier diesen Ordner nehme,
als Quelle für meine Bildchen und für meine Shortcuts.
Also aktuell hat das Ding auch noch keine Config-Datei oder so, das funktioniert relativ simpel.
Man legt halt alle Bilder, die man hat, in einen Ordner und auf den Hotkey,
wo man das binden möchte, also auf die Tastatur,
wie mit dem Stream Deck von Elgato,
sagst du zum Beispiel hier, Pogjam auf P, 0.3.D
ist auf 3,
auf F7 ist Bless RNG, kannst du draufmappen.
Genau, das wären ganz schön viele Hotkeys.
Deswegen werden wir zwei Sachen einbauen, einmal
so ein Profilsystem für einen Nummern-Block.
Dass man quasi den Nummern-Block verschiedene Ebenen hat auf dem Nummern-Block.
Zeig euch mal, wie ich das meine.
Also hier hat man ja so einen Nummern-Block auf der Tastatur.
Und das ist ein richtig dummer Nummern-Block.
Wenn man den Nummern-Block hat,
dann kann man das so machen, man belegt das hier von 0 bis 9 mit Bildern
und mit Plus und Minus kann man dann quasi Profile switchen.
Die Musikleiter, klar. Ja, ist zu laut.
So.
Ja, so ist es viel angenehmer.
So ist es viel besser.
So, und wo bin ich jetzt stehen geblieben?
Genau, und da kann man dann mit Plus und Minus umschalten.
Dann sagt man dann zum Beispiel,
man kann das ja dann quasi gucken. Man sagt dann hier, alle Bilder für
positive Sachen macht man dann 0 bis 9, das erste Profil dann drückt man Plus und dann
schaltet es auf das zweite Profil, dann ist 0 bis 9 die nächsten Bilder. Irgendwie sowas.
Gehen auch Modifier wie Shift und Control. Ja, also aktuell ist Hardcoded
alles, alles
alles auf Control.
Lull, Lull, Lullshake.
Ich habe übrigens zwei Pull-Requests, die
Rotationsgeschwindigkeit und Rotationsrichtung noch per Hotkey ändern.
Die gucken wir uns nachher mal an.
Was geht mit der Musik jetzt ab?
So, deswegen, das ist eine Sache, die wir noch einbauen werden.
Wird das ein bisschen lauter?
So, machen wir das anders.
Wir machen hier ein bisschen lauter und da mal runter.
Weil es ist ja immer, es ist irgendwie nach jedem Windows Update umgestellt.
Irgendwie stellt es nach jedem Windows Update, sind die Soundsettings anders.
Ganz, ganz Fail. So, das ist eine Sache, die wir bauen.
Aber noch viel wichtiger ist, ich will ein Webinterface haben, wo man die Bilder
durchklicken kann im Browser. Also sprich, dass man dann im Browser das aufmachen kann,
eine Liste mit Bildern klickt, kriegt, also quasi sowas hier im Browser,
und man das dann über den Browser an- und ausschalten kann die
Overlays.
Also sprich, dass ich dann einen Browser auf dem zweiten Rechner aufmachen kann
und klick dort auf LUL und dann geht halt das auf. Da kann ich nämlich auch Bilder
reinhauen ohne Shortcuts.
Das heißt, ich könnte dann hier 60 Bilder reinmachen und gebe einfach nur,
sag mal so, den 10 wichtigsten Shortcuts und den Rest kann ich dann quasi von meinem zweiten Rechner aus.
Der Trend beim Streaming geht ja hin zum Zweitrechner für
Streaming und Upload und Gedöns. Dann kann man das auch einfach dort auf dem
zweiten Rechner im Browser aufmachen und gut ist.
So, ich will halt einfach mal gucken, wie man das am besten macht, weil
ich hab zwar schon ein bisschen rumgespielt, aber mit irgendwelchen Web-
APs, Web-Anwendungen und sowas hab ich noch nicht so viel gemacht.
Moin, JSP64.
Ist die Musik so okay?
Wisst ihr was, wir machen mal was anderes. Ich mach mir selbst die Musik ein bisschen lauter,
also ich bin jetzt zu leise und mach hier ein bisschen runter.
Ah.
Perfekt. So ist das gut.
So.
Ich glaub, so ist eigentlich ganz gut von der Lautstärke her, ne?
Ich hab heute Morgen Windows 10 Update gemacht.
Das ist auch geil, das ist das April-Update.
Am 30.06. hab ich das April-Update gemacht. Das April-Update kam ja auch nicht im April, das ist Microsoft-Logik.
Geh weg.
So, nachdem ich eigentlich noch nie irgendwelche Web-Anwendungen gemacht hab,
müssen wir ein bisschen basteln. Und zwar, wir machen das ziemlich simpel.
Ich bau das auch erstmal alles hier in das Fenster rein, das gehört da zwar nicht hin,
das machen wir dann irgendwann so eine eigene AP-Server, sonst war's klasse.
Aber das machen wir gleich. Machen wir das gleich ordentlich.
Machen wir das gleich ordentlich, so und dann...
Ne, wir machen es erstmal unordentlich, weil ich erstmal gucken muss, wie es überhaupt funktioniert.
Dann schmeißen wir das hier wieder raus.
Also ich hab gesehen, Microsoft hat sowas, das nennt sich SignalR,
oder wie auch immer das heißt. Das ist sowas wie ein...
nicht wirklich wie ein Chat-Protokoll, sowas.
Ein VLenses Real-Time-Messaging, oder irgendwie sowas.
Notification, Kleinzeitwerber, was auch immer.
Da kann man zumindest, ohne dass ich jetzt irgendwie eine großartige Web-AP basteln muss,
oder sonst was, kann ich einfach nen Port aufmachen, wo SignalR draufläuft,
und dann mit meiner Webseite dann mit der Anwendung reden.
Weil wir brauchen ja in beide Seiten Updates.
Das ist ja so, wenn ich dann das Web-Interface hab, dann kann ich einmal im Web-Interface anklicken,
welches Meme ich anzeigen will.
Alternativ kann ich auch den Shortcut drücken.
Das heißt, ich brauch Messaging in beide Seiten.
Nachdem ich mich mit so Webzeug jetzt nicht so perfekt auskenne,
und ich auch keinen Bock hab irgendwelche Websocket-Geschichten voran zu machen,
sind so Real-Time-Updates immer so eine Sache.
Weil wenn ich per Shortcut ein Bild aufmache, will ich das ja sofort im Web-Interface sehen, dass das an ist.
Und wenn ich im Web-Interface was klicke, soll es sofort hier erscheinen.
Deswegen müssen wir erstmal gucken, wie wir das machen.
Und ich muss mal auf dem zweiten Monitor mein Zettel so abgucken aufmachen,
weil ich hab ja im Vorfeld, ich cheate ja immer so ein bisschen bei diesen Streams,
ich hab mir im Vorfeld immer schon so ein paar Sachen aufgeschrieben,
dass ich nicht jeden Scheiß nachgucken muss.
Sonst wird das alles viel zu lange dauern.
So, das erste, was wir machen müssen, ist,
weil ich hab mir nämlich aufgehört, was wir für Pakete brauchen,
das erste, was wir hinzufügen müssen, ist...
Ach so, ich musste den Stream noch auf Twitter posten, hab ich ja ganz vergessen.
Ich hab ganz vergessen.
Battlefield hat mich gestern so fertig gemacht.
Ich bin heute immer noch voll neben der Spur.
Das hat mich so aufgeregt.
Das Update ist schrecklich wegen dem Intel SSD-Bug.
Ich wusste gar nicht, dass das neue Windows-Update einen SSD-Bug hat,
beziehungsweise einen Intel SSD-Bug auslöst.
Was ist denn der Intel SSD-Bug?
Browse.
Laden.
So, ich poste das Ganze mal kurz auf Twitter.
Hat nicht nur ich fertig gemacht, das war schlimm.
Wisst ihr, was witzig war?
Ich hab mir im Nachhinein nochmal...
Ich hab mir im Nachhinein nochmal die paar Clips angeguckt, ey.
Das ist richtig dumm, ey.
Warte mal.
Okay, jetzt ist er hier.
Das Windows-Update gestern.
Das ist ja voll im Trend zu sein, eigenen Videos zu reacten.
Das wollte ich jetzt auch mal machen.
Ich glaube, in ein paar Jahren ist es dann voll um die Ecke auf YouTube.
Reaktet man dann zu seinen Reaction-Videos, wo man auch seine Videos reaktet hat.
Installieren wir mal hier SignalR, SignalR.
Ich weiß nicht, wie ich spreche.
Okay, hier steht jetzt sogar, was es ist.
Eine Komponent für eine Real-Time Bi-Directional Communication Across the Web.
Das klingt als gäbe es das bereits, ey.
Das würde mich nicht wundern.
Das gibt es bestimmt schon.
Reaction-Videos auf Reaction-Videos, mit denen ich dann reacten kann.
Also, es gibt sowas schon nicht auf eigenen Videos.
Ich habe zum Beispiel letztens irgendwas gesehen.
Irgendwie so nach dem Motto, Unge reactet auf irgendwelche Leute, die reacten.
Und dann gucken sich Leute an, wie Unge auf Leute reactet, die auf Leute reactet haben.
Das ist wirklich, das ist komplett.
Da fällt mir bloß noch zu ein.
Moment, ich muss mal kurz starten.
Also, das ist wirklich mindblown, solche Videos.
Das ist wirklich komplett mindblown.
Als komplette React-Inception, ja.
Was hat er für Schmerzen?
Okay, ich weiß nicht so genau, was der meckert, ehrlich gesagt gerade.
Aber anscheinend hat er ja keine großartigen Probleme.
Weil es läuft ja alles.
Hat das Tool gerade 63 MB RAM verbraucht?
Ja, ja.
Wenn du viele Bilder startest, muss erst mal der Garbage-Collector laufen, bis es wieder runtergeht.
Guck mal, wenn ich hier schnell drücke, aber da kann man nichts dagegen machen.
Außer nach jedem Bildwechsel manuell den Garbage-Collector laufen lassen, was aber ziemlich doof ist.
Guck mal, wenn ich ganz schnell die Bilder drücke, dann geht der RAM-Verbrauch erst mal übelst hoch.
Vor allem bei GIFs.
GIFs gehen übelst hoch, aber nach einer Weile geht es dann halt wieder runter.
Wenn man das jetzt eine Weile laufen lässt, dann geht es wieder runter.
Guck mal.
Die da unten.
Die da unten dauern halt ein bisschen.
Und das Gelbe sind glaube ich Garbage-Collector-Runs.
So, wir wollen dieses Ding irgendwie als Web-Interface verpassen.
Wie gesagt, ich habe ja schon ein bisschen im Vorfeld geguckt, wie wir das machen.
Also, ich habe aber noch nie was mit rsp.net gemacht.
Noch nie.
Schon gerade ich mit rsp.net core.
Aber nachdem ich ja immer ein bisschen cheate in diesen Streams, habe ich zumindest schon mal geguckt, so grob wie über den Krampen verwendet.
Also, das erste, was man machen muss, ist sagen, auf welchem Port man seine Anwendung laufen lassen möchte.
Und quasi welche Ordner man einbinden will.
Also Ordner mit Konten drin, sowas hier zum Beispiel.
Und dann welche Dienste man verwenden will.
Nach dem Motto, okay, ich brauche einen...
Mein Webserver soll jetzt quasi auf diesem Verzeichnis die Bilder raushauen und irgendwelche anderen Sachen registrieren und sowas.
Das muss man am Anfang machen, das habe ich schon mal nachgeguckt.
Deswegen, das kriegen wir jetzt hin.
So, und diese SignalR-Geschichte funktioniert folgendermaßen.
Übrigens, eine Sache wollte ich hier noch einbauen.
Einmal will ich hier einen Name noch haben, wo einfach nur drin steht, wie das Bild heißt.
Und damit halten wir uns auch offen, dass wir das später mit Sounds abspielen können und sowas, weil das ist alles kein großer Akt.
Bilder anzeigen, Sounds abspielen, das macht keinen großen Unterschied. Das ist alles WPF eingebaut, muss man nichts Großartiges machen.
So, und jetzt habe ich den kurzen Namen, nicht immer den langen, das ist besser.
So, und hier wollte ich mir merken, für welchen Pfad ich das angelegt habe.
Das sind Sachen, die brauchen wir bestimmt noch.
So, ok, dann werden wir mal versuchen, den Webserver hier drinnen zu starten, gucken wir mal, wie man das am besten macht.
Also ich habe mir hier so etwas rauskopiert von Microsoft, da gibt es so eine Anleitung, wie das funktioniert.
Und das erste, was man machen muss, ist einen Hub erstellen.
Und danach seinen Webserver so konfigurieren, dass dieser Hub verwendet wird.
Jetzt gucken wir mal, ob das Ganze funktioniert. So einen Hub zu erstellen ist relativ simpel.
So, und ich sage euch jetzt gleich so, so werden wir das nicht lassen, aber ich will einfach mal gucken, wie es geht.
Games Done Quick läuft wieder. Ja, mir gefällt, also ich habe immer Games Done Quick geguckt.
Sowohl die Summer Games als auch die Awesome Games, ich habe immer geguckt.
Allerdings, seitdem sie den Chat zu extrem streng in der Hand haben und seitdem man gezwungen wird zu subscriben,
um im Chat was zu schreiben und sowas, nachdem sie auch angefangen haben, irgendwelche Leute zu bannen,
weil sie mal ein bisschen was Fragwürdiges gesagt haben, irgendwie habe ich gar keinen Bock, mal das hier hinzugucken.
Ich habe dieses Mal kaum Runs geguckt.
So, ich baue das jetzt mal alle.
Ich will einfach mal rausfinden, wie das Ganze funktioniert.
Deswegen mache ich jetzt hier mal eine Klasse innen drinnen, dass ich auf meine internen Sachen zugreifen kann.
So, ein Hub. Das ist das, worüber später dann mit der Webseite die Kommunikation läuft.
Wenn ich das bei Microsoft richtig verstanden habe, ist das der Meme Hub.
Das muss natürlich einbinden.
Moment, habe ich das nicht gerade installiert? Egal, installieren wir es nochmal neu.
Ja, das stimmt.
Also, das zum Beispiel, das, als ich meinen Hub wiesel, das ist ja schon ein wenig extrem ausgedrückt, wie du das geschrieben hast.
Das würde ich so nicht sagen.
Allerdings, im Kern ist es bescheuert, dass sie sich ausgerechnet über Dance Gaming aufgeregt haben, weil er einen Emote hatte,
wo man ihn selbst gesehen hatte, mit so Luftballonbrüsten, hat er einen Emote gehabt.
Sie selbst, ja, wohlgemerkt.
Und dann haben sie sich darüber aufgeregt, wie böse Dance Gaming ist, weil irgendjemand anderes dieses Emote dann dort in dem Channel verwendet hat.
Richtig bescheuert, ja.
Und vor allem, dass sie sich bei Dance Gaming aufregt, ist noch bescheuerter, weil er hat schon oft erzählt, dass er selbst schwul ist
und selbst da schon einige Probleme hat.
Also, total beknackt.
Also, richtig hängen geblieben einfach nur im Kopf.
Mortal Subscriber only.
Ne, das werde ich nie machen.
So, Hub.
So, Microsoft, wie geht denn das jetzt weiter?
Warte mal, da habe ich doch Chat, Example, Docs, da habe ich doch was Schönes gefunden, wo man nachgucken kann.
War das das?
Nein.
Oh, die Musik.
Ich habe bei Microsoft ein schönes Beispiel gefunden, wie das funktioniert, aber natürlich finde das jetzt die Google-Suche nicht.
Ah ja, doch, hier.
Hubs.
Chat.
Ah, das ist kompliziert.
Heil, Jüder.
Ich werde geradet.
Ich wurde noch nie geradet.
Krasser Shit.
Danke für den Raid.
Ich weiß gar nicht, was man dann sagt.
Was sagt man denn bei einem Raid überhaupt?
Oder was, was ist der Unterschied eigentlich zwischen einem Raid und, ähm, was ist der Unterschied zwischen einem Raid und einem Host?
Asp.net, not like this, ja.
Ja, das ist so.
Ich habe, wie gesagt, ich habe eigentlich keine Ahnung von, aber ich darf mich in sich soweit ablenken lassen.
Ich muss jetzt mal irgendwie gucken, dass ich da, ich muss gucken, wie das funktioniert.
Leute kommen in zu den Channels, aha.
Danke für den Raid, oder für den Host.
So, nice.
Host is basically a host.
Ach nee, Hopwiesel, da wäre ich jetzt nicht gekommen.
Nicht drauf gekommen.
Ähm.
Okay, wie funktioniert der Cramp jetzt?
Microsoft, erzähl uns doch mal, wie das funktioniert.
So.
Okay, also das ist wohl irgendwie so, dass man in diesem Hub Zeugs definiert, was der Client aufrufen kann.
Und im Client dann wiederum Sachen definiert, was man dann vom Hub aufrufen kann.
Habe ich noch nie verwendet.
Ähm.
Wir testen das jetzt einfach.
Wir machen jetzt mal einfach dieses komische, diesen Test hier.
Gucken, wie das funktioniert.
Wir machen das auch ohne Essung, wir machen das wie der letzte Kacknoob.
Und auch ohne irgendwelche Parameter oder so.
Vollkommen, ganz, ganz billig.
Test.
Bei einem Raid schickt man die Zuschauer das eigene Stream von dem Stream, dem man raidet.
Ist das aber bei einem Host ist das doch im Prinzip auch so, oder?
Also ich kenne das nur von früher.
Dann hat man halt gesagt, so nach dem Motto, man hostet jemand.
Und dann sind halt die anderen immer in den Channel rein.
Haben halt irgendwie rumgeschrieben.
Raid.
Oder haben irgendwelche anstößigen Bilder gepostet.
Oder irgendwas, um die anderen zu ärgern.
Keine Ahnung.
Ähm.
Anscheinend haben sie das jetzt in Twitch integriert.
Aber ich bin ja absoluter Twitch-Noob.
Ich glaube, ich habe immer noch kein Profil auf Twitch, kann das sein?
Nö.
Das ist ja noob.
Und danach wird der Channel direkt...
Ah, verstehe.
Ja, danke für den Host.
Huge Host.
Massive.
Ähm.
So.
Big Brain, wie geht es denn jetzt weiter?
Wie teste ich das jetzt?
Ich brauche jetzt irgendeine Webseite mit diesem JavaScript-Gedöns drinne,
wo ich das dann aufrufe.
Und da muss ich gucken...
Nee, ich muss erstmal in den ASP-Web-Server starten.
Ich bin verwirrt.
Ich sollte nicht onstream Dinge machen, die ich noch nie gemacht habe.
So, ich muss jetzt erstmal dieses ASP.net-Zeug irgendwie starten.
Da habe ich mir was rauskopiert, wie das funktioniert.
So, irgendwie Webhost.
So.
Da muss ich jetzt aber abgucken.
Microsoft, erzähl mir, wie es funktioniert.
War nicht klein.
Nein, nein, nein.
Warum haben die...
Die haben...
Ich habe doch irgendwo so eine Seite gefunden, wo die das schön beschrieben haben.
Chat.
Ähm.
Nehmen wir mal schreiben.
Erbuchen, Einführungsservice.
Was ist das denn?
Es ist alles von 2014.
Ah, hier.
Das sieht gut aus.
Ja, diese Anleitung habe ich gesucht.
Das ist nämlich für die letzten Noobs, die keine Ahnung haben, beschrieben, wie man das macht.
So, als erstes macht man einen Hub.
Okay.
Und dann muss man seinen Web-Server irgendwie konfigurieren.
Gut, das habe ich mir rauskopiert, wie das funktioniert.
Das ist einfach.
Da macht man irgendwie Web-Post, Create, Default, Build.
Eieieiei.
Wie ein Programmierer versteht Basic Features von Twitch nicht.
Aber eins muss ich sagen, ne, bei...
Also, ich war ja skeptisch.
Bei der Übernahme von Twitch...
Ich lenke jetzt mal davon ab, dass ich nicht weiß, was ich genau mache, sondern eigentlich einfach nur abtippe, wie das funktioniert.
Ähm.
Wobei ich weiß, dass es funktioniert, weil das habe ich vorher mir schon mal rauskopiert, mal kurz getestet.
Eins muss ich sagen, ich war ja bei der Übernahme von Twitch zu Amazon, war ich wirklich skeptisch.
Weil bei anderen Übernahmen, so was weiß ich, was Microsoft zu übernommen hat oder Google, vor allem Google,
was Google schon übernommen hat, ist halt echt so ein Ding, wo ich gedacht habe,
ok, entweder machen sie das jetzt irgendwie, naja, nicht dicht, sie integrieren das irgendwie in ihr komisches Amazon-Zeug
und es wird dann einfach nicht mehr das Gleiche sein wie früher.
Aber insgesamt, oder mal eure Meinung jetzt, ne, ich persönlich finde, dass seit der Übernahme von Twitch durch Amazon
Twitch nicht schlechter geworden ist, sondern eigentlich besser.
Das Einzige, was bei Twitch wirklich sagt, ist die Mobil-App.
Die Mobile-App ist gräudig.
Also die Mobile-App ist wirklich gottenschlecht.
Das wird nur noch getoppt von der Android-TV YouTube-App, die ist noch schlechter.
So, machen wir hier einen Zeilenumbruch, genug gelabert.
Services.
Services add SignalR.
Ok, das ist nicht drinne, das muss ich noch einbinden.
Das heißt, ich muss irgendwas include oben noch.
Und was brauche ich, das da brauche ich. Den ganzen Kampel brauche ich.
Gut, dass ich das vorher schon mal gemacht habe.
Geht immer noch.
Hab ich was vergessen zu include?
Ich hab bestimmt irgendwas nicht hinzugefügt.
Was? Das hab ich doch eben hinzugefügt.
Hä?
Ah! Oh!
Moment, ich hab das falsche.
Ich hab ASP-Net-Signal-Core...
Oh nein, Moment, remove.
Weg, weg damit, piss dich.
ASP-Net-Core-Signal-R brauche ich.
Um die Sachen noch ein bisschen komplizierter zu machen, hat Microsoft natürlich
mehrere Pakete, die fast gleich heißen.
Das ist natürlich toll.
Ja, jetzt wird es wahrscheinlich auch gleich funktionieren.
Vielleicht wird ja sogar GitHub nach der Übernahme von Microsoft besser.
Instinktiv will man immer sagen, ah ne, Microsoft verkackts bestimmt.
Aber es könnte sein, weil man muss da sagen, GitHub hat nie großartig Kohle verdient.
Und jetzt hat GitHub, die haben jetzt einfach Geld.
Dadurch, dass sie zu Microsoft gehören.
Es ist jetzt ja nicht so, dass die sich da jetzt irgendwie noch Geld...
Da ist jetzt genug Kohle da.
Das war ja ein Problem, was GitHub hatte.
So, gehts denn jetzt?
Was ist das?
Oh, die Kirby-Musik hier.
Rare Parod.
Oder wir haben Party Parrot, haben wir jetzt ja auch.
Oh, es funktioniert, ok, sehr nice.
Ok, Configure Services, sehr schön.
So, dann, wir tasten uns da jetzt mal ganz einfach an, wie das jetzt weitergeht.
So, und danach muss man sagen, Configure Services, ne, Configure einfach nur so.
App.
So, und dann sagt man hier drinnen, was man eigentlich alles aktivieren möchte.
So, und da will ich jetzt einmal sagen, dass ich Static Files, das muss ich noch einbinden.
Static, wie heißt das?
Static Files, wie heißt das?
Moment, warum finde das Ding denn bitte schön?
Microsoft ASP.NET Core Static nicht, aber Static Files.
Muss das wirklich exakt matchen?
Ganz schön doof.
So.
Und was sage ich jetzt, ne, ich muss das erst nochmal included.
Und da muss ich jetzt irgendwie sowas sagen wie Surf Static Files, dann kann ich zumindest über den Browser schon mal meine Bilder abrufen, wenn das funktioniert.
Ups.
Oder brauchst du das überhaupt?
Gucken wir mal.
Ne, Use Static Files, genau, Use Static Files, File Options.
Gucken wir mal, ob wir die Klammern richtig hinkriegen.
Use Static File Options.
So, File Provider wollen wir von der Festplatte Files ausliefern.
Physical File Provider und dann nehmen wir jetzt mal hardcoded unseren Fad.
Den da.
Was hat er für Schmerzen?
Warte mal, ich habe irgendwo die Klammern glaube ich falsch.
Oder? Schick Klammern falsch.
Achso.
Ja, da brauche ich was, klar.
Wir machen das erst mal ganz billig, wir nehmen hardcoded den Fad von hier oben und gucken dann mal ob wir dem Browser überhaupt Bilder abrufen können.
Wenn das geht, dann weiß ich zumindest schon mal wie man so ein Ding startet.
So, dann muss man eben irgendwie sagen Request Pass, also das ist dann der Teil den man im Browser eingeben muss.
Da nehmen wir jetzt mal slash Image.
So, danach muss man eben noch sagen AppUseSignaler.
So, und nun muss man das Ding starten.
Ach ne, Moment, jetzt muss ich eben noch sagen welche Hubklasse ich verwenden will.
Irgendwie config-hub, genau hub, da nehmen wir hier mal unseren Memehub und der ist unter url-memehub.
Wunderbar.
So, und dann sagt man jetzt einfach nur noch welche Uhr er lauschen soll.
Wir sagen erst mal einfach nur localhost.
Das müssen wir dann natürlich erweitern, dass er nicht auf localhost lauscht, weil sonst ist ja der Sinn verfehlt.
Wir wollen ja unser Programm von einem anderen Rechner aus fernstellen können, weil wir den bloß localhost lauschen lassen, dann ist das ganz schön fair.
So, und jetzt sagt man noch Build und dann Start.
Und jetzt bin ich mal gespannt ob das funktioniert.
Also von der Idee her sollte ich jetzt unter localhost Port 5001 Image ein Bild abrufen können.
Mal gucken ob das funktioniert.
Okay.
Wir werden schon mal ausgelacht.
Ja, ich muss den anderen Ordner nehmen, ich hab ja alle meine Shortcuts überschrieben.
So, und jetzt nehmen wir mal das Bild, irgendwie das da.
Oh das ist schlimm, ich kann die Steuerung C drücken, wie machen wir das jetzt?
Image.
Man, von png, ob man das jetzt richtig schreibt.
Hey, es funktioniert.
Nice.
Okay, dann haben wir prinzipiell den Challenge schon mal richtig gestartet.
Ich bin übelst aufgeregt, weil ich jetzt, normalerweise mache ich ja wenigstens Dinger und Stream jetzt hier Programmiertechnik, die ich schon mal gemacht habe.
Aber ich habe wirklich keinen Plan davon.
Ich muss jetzt mal in den Chat gucken.
Aber okay, das ist gut, ich bin beruhigt, dass es funktioniert.
Wir nehmen übrigens mal das andere.
Kannst du dich noch an meine shitty Übungsapp im Play Store erinnern?
Hat mir schon 15 Euro Werbeeinnahmen gebracht.
Klar, das war doch Dings hier.
Fortnite, warte mal, Fortnite Play Store, irgendwie Random Drop oder irgendwie sowas.
Das da, war das das hier?
Ach, Real Royal Drop Picker war es, nicht Fortnite Drop Picker.
15 Euro kann man damit also verdienen.
Wie ist denn deine Meinung zu Python?
Das ist eine sehr schöne Sprache.
Obwohl ich ja eher Ruby-Fan bin.
Ich bin ja eher Ruby-Fan, aber Python ist auch toll.
Das Einzige, was ich ein bisschen doof an Python finde, das Schöne an Ruby ist, dass man das auch, wenn man Kommandozeilen mäßig was macht auf einem System, schön verwenden kann.
Man kann damit ganz kurz und knackig irgendwelche Dateien nach speziellen Textmustern durchsuchen oder irgendwelchen Text umwandeln oder so.
Das geht mit Ruby wunderbar für Kommandozeile, so One-Liner, fast so schön wie mit Pearl.
Bei Pearl kannst du mich jagen mit, aber mit Python funktioniert das nicht.
Bei Python steht halt auf Einrückung und Newline und sowas, das halt schön formatiert ist.
Und schön formatiert widerspricht halt Einzeiler, weil Einzeiler sind nicht schön formatiert.
Das ist, was ja irgendwie logisch ist.
Ich habe einmal Ruby und Rails versucht und habe 30 Minuten aufgegeben.
Rails ist schon, also ich habe ja einen ASP.NET, bevor ich jetzt hier mit angefangen habe, einen ASP.NET Guide gelesen.
Und das hat sehr viele Parallelen zu Ruby und Rails. Zum Beispiel, dass Controller, Controller heißen müssen.
Man kann die nicht anders nennen. Man muss den Controller Ordner haben oder irgendwie so.
Das ist sehr stark von Ruby und Rails inspiriert.
Rails hat ja damals auch gesagt, irgendwie, wir scheißen einfach drauf, dass die Leute ihre Sachen nennen können, wie sie wollen.
Es gibt jetzt Vorschriften, wie Dinge heißen müssen, sonst gehen sie einfach nicht.
Patrick, ist das jetzt irgendein Rätsel, was das macht?
Das machen wir jetzt mal.
Leute, wir gucken uns jetzt mal den Regex an, den der Patrick gepostet hat und überlegen uns mal, was der machen könnte.
So, Perl minus E ist bestimmt irgendwie Extended Regex oder sowas.
Boah, ist das hässlich. Boah, ist das hässlich, ey.
Ich gebe dir also den Spruch, willst du ein Problem mit Regex lösen, hast du zwei.
Lol.
Okay, also, say, soweit klar.
Search and replace ist das. Das ist search and replace, gehe ich mal voll aus in Perl, oder?
Ist das search and replace? Was auch immer.
Ach du Scheiße, was ist das denn für eine Regex, the fuck.
Also das hier ist auf jeden Fall, das ist eine Zeichengruppe mit Plus und Minus.
Beginnt, okay, beginnt mit, beginnt mit Plus oder Minus optional, also muss nicht, kann mit Plus oder Minus beginnen.
Danach können Zahlen kommen beliebig oft.
Das ergibt irgendwie keinen Sinn.
Ach doch, das ist non-creedy, also sprich, alter Regex.
Also sprich, es müssen danach beliebig viele Zahlen kommen.
Der Match ist allerdings non-creedy.
Non-creedy heißt, dass wenn ich einen Regex habe, wenn ich jetzt sowas hier habe.
So, sowas hier, so eine Zeile.
Und ich habe einen Regex, sowas hier.
Der Regex würde quasi, ne, das ist ein scheiß Beispiel.
Das ist ein dummes Beispiel.
Das ist ein scheiß Beispiel.
Was nämlich da für ein Beispiel für eine große?
Ach, keine Ahnung, der verletzt keinen Regex.
Scheiß drauf.
Zumindest non-creedy bedeutet, der Match plus mindestens so viel wie notwendig ist, mit dem Fragezeichen.
Und Standardverhältnis heißt, er matcht so viel wie geht.
So.
Das ist optionale Parameter, wo was steht.
Look ahead oder sowas.
Ach, kein Schimmer, was dieser kack Regex macht.
Optional.
Ne, das ist Backreference, irgendwie Reference merken und dann einsetzen.
Keine Ahnung.
Patrick, ich habe legit keine Ahnung, was dieser Regex macht.
Ach, da hat noch was gefehlt.
Es geht noch weiter.
Okay.
Na, das ist doch, das ist doch gleich viel lesbarer jetzt.
Paul Regex.
Hast du dir den ausgedacht oder hast du den irgendwoher kopiert?
Also ich weiß nicht, was er macht.
Ich kann mir das, also ich könnte mir das jetzt innerhalb von zwei, drei Stunden so zusammenreimen.
Ja, was der, was der macht.
Ich meine, muss man mal nachgucken, was das hier in Paul macht.
Und dann wird das irgendwie look ahead, look behind, dann irgendwie Reference.
So und das interessante ist ja, das hier, das hier ist die erste Gruppe.
Und das ist ein oder die zweite Gruppe.
Also entweder match das oder das.
Und dann replace er das durch, wahrscheinlich was er hier gestorrt hat oder so.
Ach, was weiß ich.
Scheiß drauf.
Geh weg.
Nee, nee, nee, nee.
Okay, wir machen jetzt, wir machen jetzt erstmal weiter.
Also.
Ich wollte den Meme-Ordner umstellen.
Hab ich.
Okay, das heißt, wenn wir das jetzt starten und auf Local Host, auf Local Host, ähm,
links gehen, dann kriegen wir ein Bild.
Das ist schon mal ganz toll.
Da wissen wir schon mal, dass das prinzipiell funktioniert.
Ähm.
Start.
Es macht auch einen eigenen Thread auf, sonst würde mein UI hängen.
So.
Ähm, ist mal gleich angemerkt, das muss alles aus dem UI und alles aus dieser Klasse raus.
Ich will jetzt einfach mal gucken, wie das überhaupt funktioniert.
So, der Meme-Hub funktioniert auch.
Das bedeutet, es läuft jetzt eigentlich alles, was laufen muss.
Wir haben hier unseren Hub mit, mit, äh, Write-Line-Test.
Das sehen wir dann auf der Konsole, ob ich das aufrufen kann vom Browser auf.
Ähm, das heißt, jetzt müssten wir eigentlich eine HTML-Seite anlegen und dort die SignalR
JavaScript-Library einbinden.
Musik.
So.
Ich muss gerade nochmal hier Follows und Gedöns aufmachen.
Das nehme ich irgendwie weg.
Musik.
Ja, danke für die ganzen Follows.
Also, wir bauen das alles in eine eigene Klasse später ein.
Ähm, ok, jetzt müssen wir, das heißt, jetzt müssen wir eine Website anlegen.
Oh, jetzt können wir ja gleich mal meine krassen JavaScript-Skills sehen.
Das wird grausam.
Äh, Add, New Item, HTML-Page.
Index.
Wir machen das jetzt ganz, ganz, ähm, ne, machen wir nicht, machen wir nicht.
So, ähm, tja, aber immer.
Einfach mal testen, ob das, äh, ob das dann prinzipiell, stremsor, ob das dann prinzipiell
ausgeliefert wird, diese Seite.
So, ähm, das heißt, wir kopieren die Seite in, in Output-Verzeichnis.
Komm, ob wir die ja irgendwie aufgerufen kriegen.
So, das heißt, wir wollen nicht nur Images mapen.
Wir wollen auch, das aktuelle Verzeichnis wollen wir mapen.
Also sprich.
Was ist denn das aktuelle Verzeichnis, wenn ich das hier starte?
Das müssen wir mal ausprobieren.
System, IO, Directory, irgendwie Current Directory, ja.
Mal gucken, ob das geht.
Mal gucken, ob das geht, bin ich echt gespannt.
Sorry, irgendwie keine Ahnung.
Mal gucken, ob das jetzt funktioniert.
Ich glaub ja nicht.
Wir müssen das Bild, das standardmäßig kein Bild mehr anzeigt, oder was?
Hey!
Funktioniert!
Porgos!
Hätte ich nicht gedacht.
Wir müssen die Klimaanlage ausmachen, das ist zu kalt.
Okay, das funktioniert, sehr schön.
Hallo Streamsor.
Man hatte sogar auch Debug-Ausgabe in der Konsole, das ist schön.
Gut, das heißt, da müssen wir jetzt die Signal-R JavaScript Library einbinden.
So, und ich hab das in diesem Tutorial gelesen.
Die haben da irgendein CDN verwendet.
Hier Signal-R, genau.
Nee, nee, es war ASP.
Wie waren denn die Roller für jetzt richtig?
Ah, hier, steht auch sogar da.
Genau, NPM, ASP.net.
Jetzt kommt die AVA-Skript, das wird grausam.
Signal-R.
Aha!
Kompassionsnummer.
Dann BIST.
Ja, sehr schön.
Wir könnten das auch selbst ausliefern, aber wir binden das jetzt mal von extern ein.
So, den da, zack.
So, und jetzt den ganzen Kernbild hier einbinden.
Skript, Source.
Wobei, das kann man irgendwie so machen, ne?
So, schön.
Was hat der für Schmerzen?
Warum ist das so böse und anders, also warum ist das so ok und andersrum schlecht?
Ok, das ist Microsoft-Joke.
Mir egal.
Ok, jetzt machen wir das Bild hier mal weg,
dass ich nicht standardmäßig immer LUL angezeigt kriege, weil das geht mir auf den Keks.
So, Local Host Index.
Gehen wir mal in den Debugger vom Browser.
Ok, wie kann man das jetzt aufrufen?
Genau, Signal.
Ich teste das jetzt mal in der Debug-Konsole.
Musik zu laut, zu leise, ok so.
Ok, das heißt, es müsste dann so funktionieren.
Ich hab das doch hier irgendwo drin stehen.
Das stand doch irgendwo in der Anleitung drin, aber Microsoft, wie das geht.
Genau, hier.
Connection, also Hub-Connection-Bilder.
Das scheint bei Microsoft voll angesagt zu sein, mittlerweile Sachen mit Bild aufzurufen.
So, und dann muss man das vorher noch ok...
Was hab ich falsch gemacht?
New.
Warum auch immer.
Weil ja, was kommt.
Ha, funktioniert.
Ok, und jetzt kann man sagen...
Connection Start.
Jetzt kommen wir uns einfach mal...
Ne, Con, Con Start ist es bei mir.
Und dann gucken wir mal, ob das funktioniert.
Ja, geht.
Websocket connected to 5.000 Memhub.
Sehr, sehr nice.
Ok, jetzt sind wir connected.
Jetzt kann man sagen, Con Invoke.
So, und jetzt kann ich nämlich von meinem Browser aus...
Hier, Send Message aufrufen.
Das, was ich in diesem Hub definiert hab.
Also sprich, dieses Signal R nimmt einem die ganze Arbeit ab.
Wie man irgendwie für Websocket Kommunikation und so braucht.
Das ist gut, weil von Websocket keine Ahnung.
Invoke.
Send Message.
Test.
Hat funktioniert.
Das ist super easy.
Das ist mega einfach.
Das ist geil.
Das ist wirklich extrem simpel.
Quasi vom Browser zum Backend, vom Backend zurück.
Quasi in Echtzeit irgendwelche Messages auszutauschen.
Das ist gut.
Das finde ich sehr, sehr nice.
Das ist schick.
Das gefällt mir wirklich gut.
So, das heißt nämlich auch, wir können jetzt mal mal zu...
Das heißt, wir können jetzt hier auch einbauen.
Das sagen wir jetzt mal so was wie...
Wie weit geht das überhaupt?
Kann ich jetzt von hier was da oben drüber auflösen?
Da müsste ich jetzt hier in den Constructor von dem Hub mir mein Window rein.
Oh, das wird eklig.
Das wird, das wird eklig.
Aber es ist ja nur zum Testen, wie es funktioniert.
Es ist ja nur zum Testen, wie es funktioniert.
So, und da habe ich gelesen, wenn man in so einer ASP-Anwendung
Sachen verwenden will, die nicht...
Quasi die man hinzufügen muss, die es nicht kennt,
muss man irgendwie sagen, Services add...
Wie war das?
Configuration add?
Nee.
Aber wenn, ich muss cheaten, ich muss nachgucken.
Ah doch, doch, mach ich doch richtig.
Add.
Genau.
Da kann man jetzt nämlich sagen,
dass ich eine Referenz von meinem Window-Objekt reinhaben will
und dann kann ich die hier drinnen verwenden.
Das ist nicht...
Also wie gesagt, so macht man es nicht.
Ich betone das noch mal, ja.
Also wir lagern das dann schon auch aus in eine eigene Klasse,
die wir irgendwie, weißt du nicht, Memboard Server oder irgendwie sowas nennen.
Ich mache das jetzt aber aus einem Grund hier intern,
weil ich dann Zugriff auf meine internen Funktionen und so habe.
Das ist dann relativ einfach.
Okay, wir basteln uns jetzt mal was,
wo wir uns eine Liste zurückgeben lassen können
mit allen verfügbaren Memes
und dann machen wir eine Schleife in JavaScript,
wo wir diese Memes in die Seite einbinden,
weil abrufen können wir die Bilder ja hier rüber.
So, das ist einfach kleine Schritte, ja.
Guck mal, wie das funktioniert.
So, das heißt, wir nennen das Ganze jetzt nicht SendMessage,
sondern... wie können wir das jetzt nennen?
Äh...
Äh...
Request.
Äh...
Beams. Request.
Was ist?
Moment.
Moment.
Ich kann ja so gar nicht antworten.
Moment.
De-de-de-de-de-de-de-de-de-de-de.
Okay, das nennen wir jetzt RequestUpdate.
So, und dann antworte ich von hier
an den Typ, also an die Webseite, die hier anfragt,
antworte ich,
ne, beziehungsweise ich antworte ich, ich rufe dann hier drin wieder
was auf, was dann dort die Bilder einfügt.
Irgendwie voll um die Ecke, ja.
So, und das nennen wir dann irgendwie, keine Ahnung, Update.
Fällt jetzt grad nichts Besseres ein.
So, und da pumpen wir dann unsere Memelist rein.
Und angeblich kümmert sich
dieses ganze SignalR und ASP.NET Zeug
komplett für uns drum,
unsere Memes zu serialisieren
und das JavaScript Zeug auf der kleinen Seite
wieder zu deserialisieren, das ich verwenden kann.
Das probieren wir jetzt mal aus.
So, dazu müssen wir aber das, was ich hier grad im Browser gemacht hab,
müssen wir nochmal hier drinne machen.
Und wir verwenden jetzt mal was,
was neu ist.
Also, was irgendwie in JavaScript 6 oder so dabei ist.
Nämlich, dass wir was Async ausführen.
Also, sagen wir erst mal Script,
machen wir erst mal Connection.
Ah, Konk, blablabla, Bild.
Okay, das ist gut.
Das haben wir im Browser grad gemacht, das funktioniert.
Da wissen wir, dass das klappt.
Oh, den Punkt lieber da vorne hin.
Oh, Bild.
So, dann sagen wir Await.
Ich glaub, dass das an der Stelle überhaupt geht
oder ob wir das irgendwie eine Funktion basteln müssen.
Ich glaub, dass man da eine Funktion bastelt.
Probieren wir das mal. Await.
Connection.
Start.
Und...
Danach sagen wir irgendwie Await.
Connection.
Invoke.
Und jetzt können wir das aufrufen,
was wir auf der Server-Seite haben.
RequestUpdate hieß.
Das klappt so nicht.
Das heißt, wir müssen den ganzen Kram
irgendwie mal einmal rappen in Funktion.
In Async Function.
Nee.
Function.
Function.
Connect.
Ich weiß nicht, wie man das Ding nennt.
Wir machen das jetzt mal C-Style. Main.
So, da machen wir jetzt den ganzen Mist drinne.
Jetzt muss man bestimmt Async machen.
Oh, oh, man ja, aber Skript.
Das geht aber so bestimmt jetzt.
Ja!
Hat er das jetzt invoked?
Man schkeppt ja gar nichts mehr aus.
Ah ja, okay. Wir rufen jetzt
ja hier wieder auf der kleinen Seite was auf.
Das heißt, da muss ich jetzt mich...
Okay, okay, okay.
Okay.
On... OnReceive.
OnUpdate brauch ich da jetzt.
Falls es so wirkt, als wüsste ich,
was ich mache, es hält sich in Grenzen.
OnOnUpdate.
Und da kriegen wir jetzt die Memeliste rein.
Und damit machen wir nichts anderes,
wie den Krams mal auszugeben.
Okay.
Von der Idee her, sollte er sich jetzt
finden zum Server.
Auf dem Server ruft er RequestUpdates auf.
Und der Server
schickt an ihn zurück
unsere Memeliste.
Und die Memeliste gebe ich hier
wieder aus.
Ich guck, ob das klappt.
Hey.
Das klappt.
Ich bin begeistert.
Das ist ja super einfach.
Das ist super einfach.
Das hätte ich gar nicht gedacht.
Guck mal, unser ganzes Zeug ist
sterilisiert. Das ist super einfach.
Guck mal, eine ganze Krempel ist
im Frontend verfügbar.
Das ist wirklich geil.
Okay, der Pass bringt mir jetzt
im Frontend ehrlich gesagt nichts.
Das ist super einfach.
Das ist nice. Sehr nice.
Dann können wir jetzt hier drin auch die Bilder anzeigen.
Jetzt kommt
javascript gehackt vor mir.
ID
Content.
Von der Idee her ist es ja so,
wir sagen Server Request Update
und der Server updated
schickt uns ein Update zurück.
Hier kriege ich die Memes rein.
In diesem Callback
könnte man es quasi nennen.
In diesem Callback kann ich jetzt
meine Seite updaten.
Wie macht man das gescheit?
Gut.
Ich weiß nicht, wie das funktioniert.
Create Element, okay.
Document Create Element.
Das wollen wir haben.
Mozilla Seite sind wir ganz gut
mit Beispielen.
Okay, also von der Idee
her,
also was wir jetzt
machen müssen ist, wir brauchen sowas wie
Source oder Route
oder so.
Document Get,
oh fuck, wie ging das Element?
Element, nee.
Document Get,
genau.
Get Element by ID brauchen wir
und zwar die ID Content
von unserem
javascript.
Come on brah.
So, und da
appenden wir das Ganze dann dran.
Document Create, also
nennen wir das mal Image.
Document Create Element Image.
Image Source
Image Source
und Source ist jetzt
ah nee wir brauchen noch eine Schleife.
Wie sieht ein ForEach in
JavaScript aus?
ForIn
ForEach
ForIn
ForIn
Das sieht nach einer
ordentlichen ForEach Schleife aus.
Also,
ForIn
Moment, bevor wir anfangen,
geben wir uns den Krempel noch einfach mal
aus, dann wissen wir nämlich, dass die Schleife
so wenigstens funktioniert.
Jetzt müssen wir die eigentlich untereinander alle kriegen.
Ja, funktioniert.
Warte, 01?
Nein, ich will
ForEach haben.
ForIn, was?
ForOff?
Okay, ForOff, brauchen wir mal ForOff.
Weil JavaScript.
Also, ForIn
ist ja auch von der ForEach viel zu
unlogisch, ja, das ist in JavaScript nicht so.
Ja, das ist gut.
Also nicht ForIn, wie sich das eigentlich
richtet, sondern ForOff.
Also JavaScript, äh
JQuery, nee, nee, nee.
JQuery verwenden wir nicht.
JQuery ist für Noobs.
JQuery kann das ja jeder.
Lagerst du das JavaScript später noch aus?
Ich lager alles aus. Ich lager auch das Teufel,
was ich in meiner Klasse da gemacht hab, aus.
Remind me later Windows Update,
ja.
Ähm, an zweiter Rechte
wollte ich gar nicht Windows Update neu starten.
Lul, Alter.
So.
Okay, das funktioniert, da können wir den
Krempel jetzt hier drinnen machen.
Nee, im Moment das
können wir hier oben anlegen.
JavaScript.
Krieg Anfälle, JavaScript.
Ich mein, das ist kein schönes JavaScript, ja.
Also, Web-Entwickler
werden sich jetzt in die Haare greifen und sagen, Max,
warum machst du das nicht mit React
oder mit Vue oder mit
was noch so im Trend?
Was gibt's noch für hyper, hippe
Web-Frameworks?
Angular oder mit
ähm,
es gibt's noch
Ember
oder, ähm,
mir fällt nichts mehr ein.
Es gibt's noch für hippe JavaScript. JavaScript
Frameworks gibt's ja jede Woche neue.
Was sind so angesagt zur Zeit?
Also, ich weiß, dass React
ist angesagt, Angular ist angesagt
und Vue ist angesagt. Das sind so die,
da stehen sie drauf.
Ah, und
damit wär das wahrscheinlich sogar schöner,
als Stats hier raw
JavaScript DOM Manipulation,
aber ich will einfach
besser ausfunktionieren. So, Source.
Source ist ja in dem Fall,
wir haben hier geguckt, ähm,
Name. Also sprich,
also, theoretisch,
localhost
5001
Image
plus
plus meme dot
Name.
Oder?
Ja.
So.
Vue und Meteor sind beliebt.
Okay, von Meteor hab ich, doch
Meteor hab ich auch schonmal gehört. War Meteor
nicht so ein Ding für Backend und Frontend
irgendwie in einem Framework?
So, machen wir mal Breite 100.
Ähm,
Höhe auch 100.
Was denn noch?
Brauchen wir noch irgendwas?
Nö, das war's.
Wir gucken erstmal, ob es überhaupt angezeigt wird.
So, und dann sagen wir
root add
ne, Moment, wie hat man Zeug hinzugefügt?
Warte mal.
A pan child.
Image.
So, und dann müssen wir das noch,
dann müssen wir das noch einmal leeren,
falls da schon Sachen drin sind.
So.
Ich denke mal,
das müsste so funktionieren.
Das heißt, wir müssten jetzt eine Seite kriegen
mit allen unseren Memes drauf.
Poggers!
Funktioniert!
Krasser Shit, oder?
Ist doch sehr nice.
Sehr, sehr nice.
Das ist wirklich simpel. Ich sag das zum 50. Mal.
Ich find's wirklich nicht schwierig.
Direkt auf der Dom-Arbeit in 2018.
Nachdem ich weder
großartig React, noch View, noch
Angular kann, ist das jetzt erstmal das Einfachste,
um zu kommen, was prinzipiell funktioniert.
Okay, nice, das klappt.
So, und dann
machen wir mal
...
...
...
...
Jetzt machen wir noch ein bisschen...
...
...
...
...
...
...
So, jetzt, also
die eine Richtung funktioniert
jetzt ja schon mal.
Also, ich krieg schon mal alle
aktuellen Memes vom Server.
Aber solange ich Request Update
mache...
...
Jetzt muss ich's da irgendwie umgedreht noch
schaffen. Wenn ich drauf
klicke...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
So, wir brauchen jetzt noch ein Click, wir brauchen noch ein Click Event.
Click, click, nee, on, on click, on click.
Noch ein Click Event, das ausgeführt wird, wenn ich auf das Bild klicke.
Man kann auch in Javascript jetzt auch so Lambda Functions machen, ne.
Element.
Oh, das ist jetzt aber geraten, ob die Syntax so ist.
Ok, anscheinend ist die Syntax so.
Ist die Syntax echt so?
Lull, alala.
Gucken wir mal, ob es das jetzt ausgibt, wenn ich auf Bild klicke.
Ja, das klappt.
Das ist ja einfach.
Javascript ist gar nicht mehr so schlimm, wie ich es in Erinnerung habe.
So, in Element müsste jetzt mein jeweiliges Image drin sein.
Und ich muss mir ja noch irgendwie den Name merken, dass ich den aktivieren lassen kann.
Name?
Kann man sowas hier machen?
Ne, ne, gibt es schon.
Name.
Wo speichern wir uns denn den Name drin?
Alt.
Typescript ist nice.
Da habe ich schon ein bisschen was mitgemacht.
Das ist echt nice.
Memename haste eh schon.
Ne, hier drinnen doch nicht.
Das ist ja.
Das hier ist ja der Eventhandler, der aufgerufen wird, wenn ich das Bild klicke.
Und dann habe ich zu dem Zeitpunkt ja, habe ich das Memename hier gar nicht mehr.
Das heißt, ich habe nur noch das Element, wo ich drauf geklickt habe.
Geht das so jetzt?
Wenn ich einfach jetzt sage, Element alt, gibt er mir dann den Namen aus?
Funzt das?
Undefined.
Nope.
Okay, so einfach ist das schon mal nicht.
War ich das überhaupt richtig so?
Mit onClick und Element und so?
Gucken wir mal.
Gucken wir mal, ob das überhaupt funktioniert, was ich da mache.
Ja.
Ah, Moment, Moment.
Das ist nicht das Element, das ist das Mausklick-Event.
So, das Mausklick-Event.
Target.
Target ist das Wichtige.
Target braucht, oder Source-Element.
Source-Element klickt irgendwie besser.
Source-Element.
Source-Element.
Und dann alt.
Und auch noch shake.
Gucken wir mal, ob es geht.
Nice, nice, nice, das funktioniert.
Okay, jetzt brauche ich auf dem Server eine Methode, die ich aufrufen kann für...
Ja, aktiviere mir mal das Bild.
Heißt, wir gehen wieder da hin.
Und machen da jetzt eine...
Äh...
Void...
Nennen wir irgendwie...
Push...
Push-Update.
Und dann brauchen wir die ID, also den Namen vom Meme, dass er das aktivieren kann.
Und dann aktiviert er das, und zwar über das Fenster mit...
Toggle-Meme.
Da kann man natürlich das nicht direkt übergeben.
Ich muss mir das erst raussuchen.
Oh, das ist alles echt hässlich, was ich hier mache.
Find.
Nee, First.
First.
Komm, wir machen jetzt mal ein bisschen Fehler.
Ein bisschen fehlersicher.
Wir sagen jetzt hier First.
First.
Oh, Default.
Wir suchen einen Meme mit...
Mit Name gleich ID.
So.
Fangen wir mal krass, das C-Sharp-7-Feature.
Boah.
Was ist jetzt?
If...
If...
Ähm...
Is...
Meme...
So.
Nee.
Is...
M.
Dann...
Update das Ding mit...
Okay.
Okay, nice.
So.
Also, von der Idee her sollte jetzt, wenn ich auf ein Bild draufklicke, das gleich aktiviert werden.
Das heißt, ich sag jetzt hier...
Invoke.
Fuck, ob das funktioniert?
Invoke, Push, Update.
Damit.
So, das heißt, wenn ich jetzt auf ein Bild im Browser draufklicke, dann sollte das jetzt gleich aufgehen.
Oh.
Boah.
Fail to invoke Hub-Method Push.
Ach.
Multithreading, Leute.
Könnt ihr euch noch dran erinnern, dass ich das letzte Mal eine halbe Stunde gelabert hab, wie sehr man aufpassen muss, wenn man aus einem anderen Thread was aufruft im UI-Thread?
Könnt ihr euch das noch dran erinnern?
So.
Und nachdem ich das das letzte Mal eine halbe Stunde erzählt hab, hab ich das jetzt selbst nicht gemacht.
Lambda sind was ganz Tolles.
Kann man IFs noch hässlicher machen damit.
Jetzt geht's.
Das Problem war jetzt...
Weil es nicht so ganz offensichtlich ist, versuch ich das nochmal zu erklären.
Das Problem war jetzt, ich hab jetzt hier mal einen Webserver laufen, der jetzt eine Nachricht gekriegt hat von meinem Browser, dass hier was aufgerufen werden soll.
Der ruft da ein Push-Update auf, so und ein Push-Update ruf ich was auf in meinem UI-Thread, was nochmal das hier unterstreicht, dass man das an dieser Stelle gar nicht macht.
So.
Und nachdem ich jetzt von einem anderen Thread in meinem UI-Thread versucht hab, was zu schreiben im Endeffekt, oder was aufzurufen, hat er gesagt, darfst du nicht.
Und wie man das richtig macht ist, man sagt, lieber UI-Thread, leg mal in deinen Event-Warteschlange, dass das hier ausgeführt wird.
Und dann funktioniert das auch.
So, also von der Idee an, ich klick jetzt auf den Bild und es wird angezeigt.
Bam.
Poggers und es toggelt sogar.
Das ist geil.
Funst.
Easy Remote Control.
So und das Geile ist jetzt,
das kann ich jetzt vom zweiten Rechner ausrufen, von meinem zweiten Streaming-PC kann ich das aufrufen.
Wartet mal Leute.
Nur mal so, dass man sieht, dass es halt mit mehr Bildern durchaus Sinn ergibt, als mit fünf.
Ne, ne, ne, ne, ne, ne. String und String ist das gleiche, wenn sie schreibt.
Also das hier,
das hier ist das gleiche wie das hier.
Exakt das gleiche.
Das ist ein Alias auf das oder das ist ein Alias auf das oder sowas.
Was genau, was genau macht das hier?
Ich weiß nicht wie man es offiziell nennt.
Ich nenne das Ding immer irgendwie Lambda-File oder Lambda-Operator oder so.
Du kannst anstelle, wo haben wir denn hier sowas mal?
Also du kannst an dieser Stelle, wenn du mal guckst, was diese Funktion haben möchte,
diese Funktion möchte eigentlich als Parameter eine andere Funktion, die sie aufrufen kann.
Und ich könnte jetzt hier auch sowas reinschreiben wie halt das Ding, bla, haste mich gesehen,
halt irgendeine Funktion, die ihre aufrufen soll.
So, allerdings müsste ich dann extra eine Funktion definieren, die ich aufrufen will
und bla und Parameter und alles.
Und wenn ich das mit Lambda-Filen mache, kann ich ihm sagen, okay, nehme einfach diese
anonyme Funktion hier und ruf die auf.
Also eigentlich die hier.
Hier sieht man es besser.
Ruf diese anonyme Funktion auf anstatt eine benahmte Funktion, die irgendwo steht.
Und was die anonyme Funktion macht, ist das hier aufrufen.
Also das hier ist quasi der Body von der Methode.
Man kann da auch Klammern drumherum machen und dann kann man das mehrzeitig machen.
Das funktioniert auch.
Und das ist in JavaScript ganz cool, weil früher musste man in JavaScript, konnte man sowas
nicht hier machen, sondern musste dann so komische, guck ob ich das jetzt noch zusammenkriege,
in JavaScript musste man dann früher sowas hier machen, irgendwie Funktion, Funktion,
mehr, bla, also in JavaScript hattest du irgendwann mal das Problem, dass du quasi Funktion, Funktion,
Funktion in Funktion von Funktion irgendwas hattest und das sah extrem hässlich aus
früher in JavaScript.
So ist das schöner.
Das war ein dummes Beispiel, das eine hat mit dem anderen gar nichts zu tun, aber das
geht trotzdem mit Lambda-File oder Lambda-Expressions besser.
Ok, also prinzipiell funktioniert ja jetzt das, man kann das hier jetzt vom, das geht
jetzt nicht, weil ich den Server nicht laufen hab, man kann das hier jetzt vom Rechner aus
aufrufen, das ist mega geil.
Guckt, also stellt euch vor, ich bin hier gerade auf meinem zweiten Rechner, auf dem
gleichen Rechner ist das bescheuert, auf dem gleichen Rechner ergibt das ja wenig Sinn,
da kann ich ja Shortcuts drücken, aber vom zweiten Rechner aus ist das halt extrem geil.
Und Leute, nicht nur vom zweiten Rechner, vom Smartphone auch, also sprich, wenn ihr
jetzt am Stream seid und das Memboard laufen habt und wollt dann quasi irgendwie eins von
euren 80 Memes einblenden, was keinen Shortcut hat, also Lul hat einen Shortcut, mal angenommen
irgendwie ResidentSleeper hat keinen Shortcut, dann geht ihr mit eurem Smartphone oder Tablet
auf das Webinterface, weil das muss halt im WLAN sein, wie euer Rechner, geht ihr auf
das Webinterface und klickt auf eurem Smartphone das Bild und auf eurem Spiele-PC, den ihr
gerade streamt, wird es angezeigt und noch mal klicken macht es wieder weg.
Das ist halt schon, das ist schon big, big, big brain, muss man sagen.
Ja, du kannst das auch mit zwei Leuten gleichzeitig steuern.
Das funktioniert, da kommst du dir halt ein bisschen in die Quere, wenn du mit mehreren
Leuten zeitgleich drin rumklickst, aber das Dreckentropfen funktioniert.
Also, ich werde es ja wieder nach dem Stream dann hochladen, ich mach jetzt null Optik
hier in diesem JavaScript und ich weiß, ich hab noch zwei Pull-Requests, ich weiß nicht,
ob die Leute da sind, die die gestellt haben, ich hab noch zwei Pull-Requests, die Rotationsgeschwindigkeiten
sowas anpassen, das guck ich mir das nächste Mal an, weil das bauen wir auch noch ein,
aber falls hier ein paar JavaScript-Leute am Start sind, ich bau das jetzt hier noch
fertig, dass das quasi auch Status updatet und noch einen grünen Rahmen oder so macht
je nach aktiven Meme, aber wenn ihr das JavaScript ein bisschen schöner machen wollt, ich freue
mich über jeden Pull-Request, kommen da noch mehr Memes rein, du kannst Memes reinziehen
wie du willst, da müssen mehr, man kann so viel reinkopieren wie man will, du kannst
hier einfach Bilder runterladen und reinziehen und dann funktioniert es.
Das sind jetzt ja nur die, die ich hier für den A-Stream damals hier runtergeladen habe.
Ah, du kannst da reinmachen, was du willst, das sind jetzt ja nur meine.
Du kannst sogar während es läuft eins reinziehen und dann lädt das quasi während es läuft nach.
Ok, nur dass ich nicht vergesse, also wir müssen jetzt noch zwei Sachen machen, wir brauchen
einen Status Update an Client, wenn sich was geändert hat auf dem Server und wir brauchen
Status Update an Client, wenn sich was geändert hat.
Also wir können jetzt vom Client an den Server pushen, dass er ein neues Meme anzeigen soll
und wir können uns initial einmal den Stand holen.
Wir brauchen jetzt auch Status Update an Client, wenn der Client hier Push Update
triggert, dann kriegt er das ja gar nicht mit, ob der Server das angezeigt hat und das
müssen wir jetzt ändern. Also das heißt, das heißt, jetzt müssen wir dem Client irgendwie
Bescheid sagen, nachdem das hier erfolgreich getriggert wurde auf dem Server.
Wie machen wir das jetzt? Das ist ASP.NET Core.
Also ich hätte jetzt zwei Ideen, wie wir das machen, wir können entweder dem Client
jetzt sowas wie ein Invalidate oder so schicken und sobald er das bekommt, fragt er selbst
nach Request Update, das können wir machen, oder aber wir müssen irgendwie eklig aus
dem Event hier aufrufen, dass der Client sich update. Wir rufen das erstmal eklig aus dem
Window auf. Jaja, das machen wir erstmal, da müssen wir einfach noch gucken, ob das
funktioniert. Reapparret. Oder? Weil das andere ist schöner. Also es wäre schöner, wenn
ich hier dem Client jetzt einfach sage, update dich, der Client dann anfragt beim Server,
hallo, ich würde gerne updaten und dann schickt ihm das Server das zurück. Ja, das wäre eigentlich
schon schöner, ne? Dann sagen wir, this Client caller sent. Irgendwie nennt es jetzt einfach
Invalidate. Genau, und wenn es eine Anfrage bekommt, dann soll er sich vom Server ein Update
holen. Invalidate, dann soll er sagen Invoke Request Update. Soweit von der Idee her sollte
es funktionieren. Wäre es viel Aufwand, es so zu programmieren, dass man mehrere Memes
gleichzeitig anzeigen lassen kann? Nö. Also ich vermute mal, dass es funktioniert, weil
er keine Fehler wirft. Das wäre kein Problem, mehrere Memes anzeigen zu lassen. Müsste man
sich nur überlegen, ob man einen Knopf zum Löschen der Memes macht oder dass es durchschaltet.
Erstes Memes anzeigen, zweites, drittes und beim vierten dann wieder das erste überschreiben.
Das müsste man sich überlegen, aber sonst wäre das kein großer Akt. Eine Sache, die
ich mir noch überlegt habe, die wir noch einbauen ist, dass man die Sachen platzieren
kann und resizeen kann, wie man will. Also sprich, dass ich einmal initial sage, ich hätte
gerne meine Memes hier anzeigen und nicht so groß, sondern nur in der anderen Größe
und so. Das machen wir noch, weil aktuell ist es halt immer so groß wie geht, im Endeffekt
immer an dieser Stelle hier. Okay, so, das scheint zu funktionieren. Jetzt müssen wir
ein bisschen CSS noch einbauen. Und wir müssen irgendwie dem Klein noch sagen können, welches
Meme überhaupt an ist. Weil sonst klappt das ja nicht. Okay, das müssen wir anders
machen. File, Response, Memes. Okay, wir formatieren uns das jetzt ein bisschen um. Wir müssen
dann nämlich noch, wir brauchen irgendwie noch ein Active und den ganzen anderen Sachen
brauchen wir nicht. Wir brauchen nur den Name und wir brauchen, ob es aktiv ist. Den brauchen
wir nicht. Und dann schicken wir nicht die Memes direkt zurück, sondern die aufbereitete
Reste für die Antwort. Select new name und dann sowas wie Active. So, und das Meme ist
active. Relativ simple. Ist das das, was, wenn das da gleich dem ist, was angezeigt
wird. Ja. Und die Form sichtbar ist, genau. Visible, is visible. Und, okay, das ist hässlich,
aber das müsste funktionieren. Jetzt funktioniert aber mein JavaScript nicht mehr. Okay. Oder?
Oh, da wird funktioniert. Wahrscheinlich funktioniert das sogar noch. Ja, okay, funktioniert
noch. So, weil jetzt habe ich drinne stehen, ob das Active ist oder nicht. So, und wenn
es Active ist, dann malen wir einen grünen Rahmen um das Bild, wenn es Active ist. Also
sprich, if Meme active, dann geben wir jetzt erstmal aus, active plus Meme name. Gucken,
ob das funktioniert. Ja. Nice, nice, nice, das klappt. Also, ich muss sagen, dass mit
diesem Signal R, das ist wirklich simple gemacht. Das ist echt, das ist gut und simple. So,
Meme active, name. So, und da machen wir jetzt irgendwie ein bisschen CSS noch dran, dass
es nicht mehr ganz so hässlich aussieht. So, irgendwie sowas, image, style, inline CSS,
ja, da habt ihr drauf gewartet. CSS, inner border, wir wollen, dass das ordentlich skaliert,
die Seite. Placing border inside, genau, das wollen wir haben. Doch, inline CSS. Noch
schlimmer, es ist ja nicht mal inline CSS, es ist inline CSS, weil es ist inline JavaScript,
JavaScript, was inline CSS setzt. Wobei, also nach Webentwicklungsstandards ist es ja dann
wieder gut, weil zwei schlechte Sachen zusammen sind, sind bei vielen Web-Sachen meistens
wieder okay. Nur eine schlechte Sache ist nicht gut. Das ist Massive Brain, Massive
Logik, outlogicked. Box sizing, border box, wollen wir haben. Und dann wollen wir background,
ne, border, border, border. So, und dann, was ist denn F-Things für eine Farbe? Ach
so, das ist ja 0.0, okay, das ist, äh, äh, äh, green. Green, hex, was denn, ah. So,
das setzen wir jetzt mal. So, und von der Idee her ist das Active Meme, hat jetzt den grünen
Rand drum gleich. Mal gespannt, ob das klappt. Das inline kürzt sich beim inline CSS weg,
ja so ist es. Achtung, Achtung, bam, poggers. Und guck mal, wie schnell das update, seht
ihr das? Das ist wirklich, das ist ohne lag, also natürlich muss es im gleichen Netzwerk
sein, ist klar. Also ohne lag, schlick es an, bam, grün, grün, grün. Und das, obwohl
es zweimal einen Ping Pong über den Server macht. Okay, der Rahmen ist vielleicht ein
bisschen dick, das gebe ich zu. Das ist sehr, das ist sehr nice, das gefällt mir wirklich
sehr. Ich weiß, wir machen zwei Umwege über den Server. Wir holen uns erstmal alle, also
wir requesten erstmal, schicken mir alle Memes, dann sagen wir, dann ruft der Server auf meinem
Client, update auf mit allen Memes drinnen, ich setze die, wenn ich ein Bild klicke, pushe
ich das Update zum Server, der Server setzt das Bild, ruft dann wiederum auf, Client,
mein Status hat sich geändert, update dich mal. Und dann macht der Client quasi das gleiche
nochmal und lädt wieder alle Bilder runter, die er hoffentlich gecashed hat zwischenzeitlich.
Das ist, das ist highly efficient, ja. Das ist pöpfer im Kreis. Und dann ruft er nochmal
alles ab und erkennt, dass das neue Bild active ist, aber so muss man sagen, hat er, gibt
es keine, es gibt keine State Probleme. Weil wenn ich jetzt sagen würde, dass ich nach
dem Click, also mal angenommen, ich würde jetzt sagen, okay, nachdem ich zum Server
geschickt habe, dass ich möchte, dass der Server was neues anzeigt, wenn ich dann hier
das Bild gleich setzen würde, auf grün, weiß ich ja nicht, ob der Server das gemacht hat.
Wenn ich das hier setze, quasi nachdem mir der Server schickt, es gibt ein Update, ein
Update, was wahrscheinlich aus meinem Push resultiert, dann weiß ich, dass der Status,
den ich hier bekomme, der richtige ist. Also eigentlich haben wir hier quasi fast ungewollt,
was ziemlich, von der Logik her ziemlich sinnvoll ist gebaut. Okay, wir müssen jetzt bloß
noch einbauen, dass der Rahmen ein bisschen kleiner ist, also mal fünf Pixel reicht. Fünf
Pixel. Und kann man hier nicht einfach sagen, green, geht das nicht? Doch, geht, ist besser.
Okay, aber das Resize ist noch so hässlich, das gefällt mir nicht. Da machen wir einfach
standardmäßig um jedes Bild einen Rahmen drum, der halt einfach weiß ist. Okay, das
ist standardmäßig, ist da einfach ein Rahmen drum, der weiß, dass den keiner sieht. Dann
haben die Bilder auch ein bisschen Abstand voneinander. Nice, geht. Boah, das ist sehr,
sehr nice. Das ist hyper nice. Guck mal, wie einfach das jetzt war, Leute. Und jetzt hat
man am Streaming-Rechner am zweiten ein Dashboard, wo man die Bilder ohne Shortcuts anklicken
kann. Wie gesagt, das kann man auch viel schöner machen, man kann sich hier noch die Shortcuts
drunter anzeigen lassen und so was in der Richtung. Alles kein Ding. Man sieht übrigens
auch, dass der relativ clever ist und die Bilder nicht neu lädt, die der schon hat,
das JavaScript-Zeug. Also sehr nice, muss ich sagen. Sehr, sehr schick. So, wie gesagt,
das ist mega hässlich, das Ganze hier. Das ist nicht schick. Wenn irgendjemand so ein
bisschen mit JavaScript Frontend-Zeug auskennt, Pull-Requests sind wirklich willkommen, die
das ein bisschen schöner machen. Und dann auch noch ein bisschen hier beispielsweise
den Shortcut drunter schreiben oder so was, den man drücken muss für das Bild, das beispielsweise
angezeigt wird, ob es ein GIF ist oder nicht oder irgendwie sowas. Ja, und das Ganze halt
nicht einfach so stumpf nebeneinander, sondern vielleicht in einem schönen Grid, vielleicht
auch noch ordentlich im Hintergrund, dass man das auch ein bisschen nach einem Dashboard
aussieht. Und natürlich auch gerne meinen JavaScript wegschmeißen und schön machen,
weil das ist kacke. Memes mit Track'n'Trop, auch das ist eine schöne Idee. Allerdings
müsste man diese Konfiguration ja irgendwo speichern, dass sie das nächste Mal wieder
da ist, dann wird es schon wieder kompliziert. Aber das schreibe ich immer noch auf, Memes
mit Track'n'Trop. Ja, dann später noch anzeigen, in welchem Profil die Memes sind, dass man
das Profileleben switchen kann oder so, irgendwie sowas. Könnt ihr eure Kreativität freien
Lauf lassen, also wenn jemand gut hier JavaScript, HTML, CSS kann, haut rein und macht das
schön. Ist mir egal, ich meine, hier gibt es nichts dabei, hier ist ja nichts an Design
dabei. Könnt ihr euch austoben, wie ihr wollt. Das werden wir dann das nächste Mal merken.
Alexa-Integration. Das ist was, was sinnlos ist bei der Geschichte, weil du willst ja nicht
während einem Livestream sagen, Alexa, plände WTF ein oder so. So, schönes, hässliches
JavaScript. So direkt wie DOM-Manipulation, direkt von Hand. Raw DOM. So, jetzt haben
wir jetzt noch ein Status-Update, ein kleines haben wir gemacht. Gut, wir lagern das noch
aus dann, weil das Ding hat ja als Inline in dieser Klasse überhaupt gar, das muss man
hier erst groß hinschreiben, hat ja überhaupt nichts drinnen zu suchen. Ich finde gut, dass
das funktioniert. Und ich muss sagen, das hat wirklich einfach funktioniert. Da kann
ich sagen, das Microsoft Zeugster ist echt ein Übel. Guck mal, das reagiert übel schnell.
Null lag oder sonst was. Klick, klick, klick, klick, klick, klick, klick. Doppelklicks
in Menge. Das bringt jetzt überhaupt keine Probleme. Ok, das Tracking-Drop ist kacke,
was man aus Versehen macht, weil es halt Bilder sind, das können wir auch noch abschalten.
Ja, das gefällt mir gut. Wind Waker. Ne, was ist denn mal Wind Waker? Ist das Wind
Waker? Ich glaube schon, oder? Ok, ähm, sehr nice. Gibt es denn noch irgendwas kleines,
was wir machen können? So, diese Hardcoded-Krempel-Ding, der musste auch mal hier raus, ja. Hat ja
nämlich überhaupt nichts zu suchen, das ist überall Hardcoded, das ist kacke, wir sollten
das. Wir machen das einfach, also von der Idee her ist es eigentlich am besten, man sagt,
man nimmt den Ordner relativ zu dem, wo das Programm liegt. Aber das machen wir zum Schluss.
Das ist nichts Großartiges und es nervt beim Basteln, wenn ich dann jedes Mal die Bilder
mit kopieren muss und sowas. Joa, gibt es noch irgendwas, was wir machen müssen? Weil
das an sich hat wunderbar funktioniert. Und ich krieg's SMS. Wenn du noch was wissen
willst, schieß los, Leute. Ich muss gleich zum Opa auf dem Friedhof noch mal das Zeug
hinbringen, also ich bin nur noch irgendwie 20 Minuten da. Ähm, weil irgendjemand hat,
ist ohne Scheiß, muss ich mir mal vorstellen, auf dem Friedhof, jetzt hat jemand die Blumen
vom Grab geklaut beim Opa. Weg. Also ich weiß nicht, ob er die geklaut hat oder drüber
gefahren ist oder sowas, es sah aus, als ist einer drüber gefahren und hat die Dinger
davor, er hat davor die Dinger geklaut und, nein, das war keine SMS bei iMessage, ähm,
jetzt ist er davor drüber gefahren und, nee, davor geklaut und danach noch mal drüber
gefahren. So sah es aus, so richtig, alles was noch da war, war komplett, komplett platt
gewalzt und die Hälfte war auch weg. Also hat irgendjemand einfach mal die Blumen geklaut
vom Grab, vom Opa, also verstehe ich nicht warum. Ah. Das ist wirklich confused. Das
ist super confused. So ist das eigentlich eher. Twitch Chat Integration bei Emotes spamming.
Leute, das habe ich mir sogar schon aufgeschrieben. Ich habe mir nämlich überlegt, weil letztendlich,
ne, ist das ja einfach so ein Endlosprojekt. Du kannst immer noch was einbauen. Ich habe
gesagt, wenn wir, wenn wir dann, wenn wir, wenn wir die erste Version fertig haben. Check
it out. Englisch UK. Boah, geil. Local Experience Pack. Endlich, Microsoft. Danke, danke, dass
ihr das jetzt installiert habt. Hat ja eine Top-Bewertung, dieses Language Pack. Gibst
du ein Instagram Fails? Ähm, ja, das ist ja so ein nicht enden wollendes Projekt eigentlich.
Das heißt, wir können dann noch so viel einbauen. Also ich erzähle euch mal, was ich mir, was
ich mir nur aufgeschrieben habe, was wir machen. Also, ähm, wo ist es denn? Also wir bauen
jetzt erstmal ein, dass es noch Sounds abspielen kann. Also sprich, dann kann man Sounds reinlegen
mit einem Bild dabei. Das muss dann halt ähnlich heißen. Ähm, dann spielt er halt den Sound
ab oder den Sound plus das Bild oder sowas in der Rechnung. Das bauen wir noch ein. Dann,
dass man die Bilder bewegen kann, beziehungsweise resizen kann. Halt, je nachdem, wo man es haben
will, weil immer an der gleichen Stelle und immer an der gleichen Größe ist vielleicht
nicht für jeden so sinnvoll. Ähm, Track and Drop Memes habe ich mir gerade auch geschrieben.
Webinterface, müssen wir mal gucken, wie wir das machen. Dann, zwei richtig geile Sachen,
die wir machen. Wie gesagt, das mit dem Profil über Numpad machen wir auch. Und das werden
wir kombinieren mit, zeigt euch fest, einmal mit, ähm, ich zeige es euch mal, wartet.
Das werden wir einmal kombinieren mit, mit damit, damit kann man nämlich RGB, ähm,
RGB-Beleuchtung an Keyboards dafür verwenden, quasi, ähm, also man kann, man kann mit
dieser Library, kann man RGB, nee damit, RGB net was, genau, kann man Keyboards ansteuern,
aus dem Programm, RGB-Keyboards und da kann man dann quasi auf dem Keyboard den Status
anzeigen, in welchem Memeprofil man gerade ist. Also sprich, wenn man wirklich dann
irgendwann mal 80 Bilder oder so hat, die man in verschiedene Profile kopiert hat, dann
kann ich dann quasi, je nachdem, in welcher Farbe die Tasten an meinem Numpad leuchten,
weiß ich, ok, ich bin jetzt gerade im Profil für, ähm, Porra-Memes, ich bin gerade im
Profil für Z-Memes, so ist er in der Richtung. Jetzt weiß man, man baut RGB-Beleuchtung
ein, weil, ich muss ehrlich sagen, jeder, der was auf sich hält, braucht in irgendeiner
Form was mit RGB-Beleuchtung, ganz wichtig, und wir bauen Support für Elgato Stream Deck
ein, da freue ich mich ja schon am meisten drauf, weil ich habe nämlich gefunden, es
gibt eine Stream Deck, Stream Deck Library, zwar nichts offizielles von Elgato, aber das
hier, da bauen wir Unterstützung für Elgato Stream Deck ein und das ist dann ein richtig
ultra geiles Feature, weil, dann habe ich dann, ähm, nicht nur ein Web-Interface vom
zweiten Rechner, sondern kann den ganzen Mist auch über meinen Elgato Stream Deck, inklusive
Vorschau von den Bildern, über Elgato Stream Deck bedienen, wenn man einen hat. Das ist
richtig geil dann, dann hole ich mir, dann hole ich mir einen Elgato Stream, oder frag
mal Elgato, je nachdem, ähm, hole ich mir irgendwo einen Elgato Stream Deck und dann
basteln wir das hier noch. Und dann haben wir RGB-Unterstützung plus Elgato Stream Deck
Support und dann haben wir das beste Meme-Tool aller Zeiten, konkurrenzlos. Es gibt ja irgendwie
nichts Vergleichbares, ist ja der Witz dabei. Ich verstehe auch nicht warum, ich habe hier
selbst danach gesucht, ich habe ja gesagt, ok, es muss es doch geben, Shortcut-Bildanzeig-Programme,
kann doch nicht sein, dass es nicht gibt, aber irgendwie gibt es nichts und die, die
Skipsacken. Da habe ich mir gedacht, gut, dann müssen wir uns selbst was basteln. Und
wir sind ja schon relativ weit gekommen, ich meine immerhin, man kann ohne Probleme mittlerweile
Memes on the fly rein und raus ziehen aus dem Ordner, die werden dann geladen und unloaded,
inklusive Key-Bindings. Man kann massig alle möglichen Keys belegen mit Memes, wo man
sich halt irgendwie noch leider genau merken muss, wo was ist. Und seit was wir heute eingebaut
haben ist halt, dass man sogar ein Web-Interface hat, was man vom zweiten Rechner oder vom
Tablet oder vom Smartphone verwenden kann, um aus seinem Streaming-Rechner quasi Bilder
zu aktivieren. Es gibt nichts anderes was das hat, es ist massiv Poggers würde ich sagen.
Das ist übrigens nur eine Debug-Version dieses Ding, das ist denn da eigentlich die Version
nicht da.
Guck, diese Version hat das nicht, die Release-Version. Aber dein Meme-Tool geht halt nicht auf das
OBS-Interface. Will nicht wissen, was passiert, wenn du deine Hotkeys in Game drückst. Nix,
was soll dann passieren? Wenn ich Hotkeys nehme, die das Game nicht belegt hat, passiert
nichts, dann zeigt es das Meme an. Und der Witz daran ist ja, dass es gerade nicht auf
OBS geht. Das ist ja gerade die Idee hinter dem Ganzen, dass es nicht über OBS geht.
Man kann das nämlich in OBS eingebaut machen, man kann hier irgendwo in OBS Shortcuts definieren,
was man dann Sachen ausblenden kann, Szenen switchen kann und sowas. Das Problem dabei
ist, man sieht es selber nicht. Und das war eigentlich der ausschlaggebende Grund, warum
ich gesagt habe, ich brauch sowas. Weil das Problem ist, wenn ich OBS was einblende, dann
sehe ich das selbst nicht. Und wenn ich das selbst nicht sehe, vergesse ich es wieder
auszublenden, dann habt ihr dann eine halbe Stunde 03D gekreisen oder so, weil ich es
per Shortcut angemacht habe im OBS und sehe es nicht. Das einzige, wo das Problem ein
bisschen weniger ist, ist wenn man es über ein Stream Deck macht von Elgato, da sieht
man ja, was man gedrückt hat. Aber so finde ich, ist es die optimale Lösung. Und nachdem
ich es ja letztendlich für mich zum Stream selbst gebaut habe, ist es halt auch genau
so, wie man es braucht zum Streamen. Es ist halt aus der Not geboren, dass es nichts
gibt, was das macht. Wird es dich dann nicht erstmal aus dem Vollbildgame rauswerfen?
Nein. Achso, wie der Milchmann es schreibt, genau. Also wenn du exklusiv Fullscreen machst,
dann funktioniert das logischerweise nicht. Das geht nicht, das kann man nicht machen.
Exklusiv Fullscreen ist exklusiv Fullscreen. Du musst das im Borderless-Fullscreen laufen lassen.
Aber es gibt kaum ein aktuelles Game, was kein Borderless-Fullscreen hat. Und ich sage
mal so, wenn ich jetzt Ultra-Tryhard-Mode Overwatch mit Pre-Made-Gruppe spiele, dann
würde ich auch Fullscreen spielen oder CS oder so in der Ultra-Tryhard-Modus. Aber man
ist ja meistens im Stream nicht unbedingt im 110%-Tryhard-Modus und ich streame alles
mit Borderless-Fullscreen. Einfach weil es Capturen einfacher ist und man einfacher
raustappen kann und Zeug im Hintergrund machen. Und in Borderless-Fullscreen funktioniert
das und das Beste ist, dass es eben halt noch nicht mal, es hat keinen Einfluss drauf.
Ich hab gestern im Battlefield-Stream, hatten wir es ja laufen und man sieht ja, ich kann
durchklicken, es crappt kein Fokus oder sonst was. Mit Borderless-Fullscreen hat man immer
wenige FPS, das habe ich auch mal in meinen Zweifeln, das dürfte nicht nennenswerten
Unterschied machen. Du hast theoretisch, theoretisch, aber auch nur ganz theoretisch, wenige FPS,
weil das Bild nicht direkt quasi in den Grafikkarten-Buffer reinrendert, sondern quasi
über den Window-Display-Manager rendert, weil es ja noch andere Fenster angezeigt werden
können. Aber ich habe noch kein Game gesehen, wo das praktisch einen Unterschied macht
mit dem FPS. Warum sollte man überhaupt den Exclusive-Fullscreen nutzen? Weil man theoretisch
ein bisschen schneller das Bild auf dem Monitor hat, ein bisschen schneller. Also wir reden
hier nicht von lang, wir reden hier von, keine Ahnung, zwei Millisekunden oder so. Nicht
viel. Also vor allem mit einem 144-Hertz-Monitor beziehungsweise einem 240-Hertz-Monitor und
den entsprechenden FPS, die man in Games hat, wenn man quasi Triad Comp spielt, dann wird
die Grafik so weit runtergestellt, dass man die eben hat, dann... Also, nicht wirklich.
Und wenn das in Games so ist, dann haben die Entwickler irgendwie komische Dinge gemacht.
Weil es ist ja für das Game, es ist ja kein Unterschied. Das Game rendert sein DirectX
Zeug, benutzt sein DirectX-Gedöns und wenn du Exclusive-Fullscreen hast, dann ist es halt
der Windows-Display-Manager, dieser Windows... Wie heißt der? DWM. Für was steht denn DWM?
Dynamic Window Manager, Desktop Window Manager. Der ist dann halt nicht mehr dazwischen. Was
halt bei Borderless Fullscreen so ist. Dafür hast du halt auch den Vorteil, wenn du Borderless
Fullscreen hast, dass du quasi aus Spielen raus tappen kannst, ohne dass es fünf Sekunden
erst mal Kontext switchen musst, DirectX. Ja und wenn es ein Rechner ist, auf dem man
quasi streamen kann, spielen kann, streamen kann und sonst was, das macht keinen Unterschied.
Das macht wirklich keinen... Ich bin was Input-Lag angeht und soll ich sagen, ich bin... Also,
ich kenne niemand, ich sage mal so, ich kenne niemand, der so empfindlich ist, außer vielleicht
der Eax, der geht noch mehr ab auf Mikro-Ruckler und sowas, der so empfindlich ist, was Input-Lag
und irgendwelche Verzögerungen angeht, ich merke den Unterschied zwischen Fullscreen
und Borderless Windows, merke ich nicht. Null. Wohlgemerkt in Spielen, die halt eh massig
FPS haben, ja. Also sprich, wenn ich Overwatch anhab und das läuft dann irgendwie auf 300
FPS oder so, nee, was ist Max FPS bei Overwatch 240? Irgendwie sowas, dann merke ich es Null.
Und ich stelle eh immer runter, ja. Aber da muss man sich halt entscheiden, ja. Also wenn
man Fullscreen haben möchte und Fullscreen haben will, dann geht das nicht. Dann muss
man es halt beispielsweise über OBS-Shortcuts machen und hat halt auch die Nachteile davon,
von OBS-Shortcuts. Und wir haben auch noch ein paar coole Sachen drin, dass wir die Min-Bildchen
animieren können und sowas, das kann ja ein OBS auch nicht. Plus wir können auch noch
Sounds abspielen und Gedöns und haben vor allem einen Dashboard, was wir vom zweiten
Rechner aussteuern können und sowas. Wenn man dann wirklich Fullscreen Windows braucht,
wenn man wirklich Fullscreen braucht, dann kann man es halt nicht nehmen. Muss man sich
halt was anderes überlegen. Aber es ist auf jeden Fall die deutlich komfortablere Variante,
wenn man das verwenden kann, als OBS-Shortcuts. Nee, auf den Ping hat das keinen Einfluss,
Milchmann. Aber ich muss ehrlich sagen, ich bin begeistert davon, dass diese Signal-R-Geschichte,
das ist super-simple. Guck mal, das war super-simple. Und das war meinem Kack JavaScript-Skills
noch super-simple und schnell. Achso, eine Sache müssen wir noch machen, wir müssen
ja noch mal einstellen, dass der nicht nur auf Localhost lauscht, sondern dass man auch
vom Smartphone oder so drauf zugreifen kann oder vom zweiten Rechner. Da brauche ich ja
bestimmt Admin-Rechte für Firewall jetzt. Ja, Hello Access. Ah, ist gut. Oh, jetzt geht's
wieder. So, und jetzt kann ich vom zweiten Rechner drauf zugreifen. Ich kanns euch jetzt
nicht zeigen, weil ich halt keinen zweiten... Ich kanns in der VM zeigen. Ich zeig euch
das mal in der VM. Also, das ist jetzt mein zweiter Rechner, weil ich kann euch halt keinen
zweiten Rechner zeigen, so richtig. Starten wir das jetzt noch mal hier über... Release.
Und dann werden wir auch gucken, dass wir das alles noch in eine Excel anpacken. Memboard,
über, zack. Die IP raussuchen. Ich probier grad mal aus, ob's vom zweiten Rechner, ob's
hier funktioniert. Warum nicht? Ah ne, weil da ein T drin ist. Kann nicht funktionieren.
Jop, vom zweiten Rechner aus. Spackts rum. Ach, weil ich hardcoded localhost drin hab.
Siehste mal, ich kack Noob. Ne, machen wir das nächste Mal. Also, prinzipiell geht das.
Wenn ich jetzt hier natürlich hardcoded irgendwo localhost drinne stehen hab in meinem HTML,
dann... Ja, da kann das natürlich nicht funktionieren. Aber ich hab's grad vom zweiten Rechner aufgemacht,
die Seite geht auf. Also das funktioniert prinzipiell alles. Wenn man so ein Scheiß hier
macht mit hardcoded IP überhaupt, wie wird man das überhaupt JavaScript-mäßig richtig
machen? Ich will... Wie setz ich in JavaScript die Url ein, die im Browser steht quasi,
oder der Domain Name? Wie krieg ich an der Stelle den Domain Name von der Seite, auf
der ich drauf bin? Also den Teil hier. Wie krieg ich den denn? Ach, stimmt. Ja, natürlich.
Ich muss da gar nichts angeben. Ich mach einfach so. Oder? Was ist, wenn ich einfach
so mach? Geht das? Okay, das kann ich einfach so machen. Ja. Easy. Oder? Nee. Oder doch?
Nice. Jetzt mach ich's. Ihr seht, meine Maus ist nicht hier. Ich geh jetzt auf den zweiten
Bildschirm. Zack. Kann ich fernsteuern. Nein, nein, nein, nein, nein. Ich will das nicht
connecten. Ich will garantiert nicht mein Mikro irgendwie hier... Geh weg. Genau, alles.
Test, test. Ja. So, zeig euch mal, dass das funktioniert. Also, ich bin jetzt in meiner
VM drin. Wobei, nee, das kann ich euch dann richtig zeigen, weil das immer noch... Egal,
scheiß drauf. Ich bin jetzt in meiner VM und das hat mein zweiter Rechner im Endeffekt.
Und von hier kann ich quasi jetzt mein Greenboard fernsteuern. Wie man sieht. Funktioniert.
Und man kann durchklicken. Habt ihr das gesehen? Nice. Ja, so muss das sein. Das finde ich extrem
nice. Das gefällt mir echt gut. Ich bin begeistert davon. So, ich bin jetzt auf dem zweiten Monitor.
Quasi am Streaming-Rechner, wenn man es so will. Am zweiten Rechner. Hab's im Browser auf
und kann das Zeug anzeigen. So. Und jetzt brauchen wir bloß noch ein paar Leute, die
sich gut mit Yammer-Skripte hier als erstes noch HTML auskennen, die das Ganze noch ein
bisschen hübsch machen. Wie gesagt, ich freue mich über alle Pull-Requests. Die zwei Pull-Requests,
die offen sind, gucken wir uns das nächste Mal an, wo wir dann ein paar Animationen und
Gedulds einbauen. Ja. So sieht's aus.
Innerhalb von zwei Stunden? Ja! Das ist wirklich simpel, der Scheiß. Ich bin wirklich begeistert,
wie einfach das ist. Ich meine, es ist nicht schön, muss man sagen. Das muss man noch
aufräumen, ja. Ach so, ich pushe das gleich auf Git noch. Ich pushe das, Git, Git.
Oh, jetzt habe ich mir das Problem, dass ich mein Passwort nicht weiß. Jetzt muss ich
wieder nachgucken auf dem zweiten Rechner. Nach meinem GitHub-Passwort. Oder habe ich
mittlerweile Keypass gespeichert. Egal. Source, Repos. So, und jetzt müssen wir nach
Meme. Moment, in welchen Ordner müssen wir? Memeboard, Copy, Memeboard. Aber Max, das
ist auch wieder sehr intuitiv gewesen, wie du das Zeug genannt hast. So, machen wir
mal Commit. Mein Gott, ist das Git-Plugin-Scheiße von Visual Studio. Commit. Ich weiß, weil
ich immer im Stream erzähle, man muss ordentliche Commit-Messages machen, müssen wir jetzt
auch noch ordentliche Commit-Messages machen. Web-Interface for remote. Remote-Controller.
Commit. Pass. Ich habe meine Git-Aliase nicht hier. Nothing to commit. So, push, push, push.
Push origin. So, Passwort. Muss ich nachgucken. Saved Logins. GitHub.
Ok, ähm, das wurde gerade verartet. Ich muss endlich mal meine Keys dahinter legen. Jetzt
geilen wahrscheinlich schon alle drauf, dass ich mich vertippe und das Passwort irgendwo
auftaucht. Ok, ich hab's gepusht. Neueste Version. GitHub, Wubblors, Memeboard. Keine
Readme Triller, nix. Wenn ihr euch berufen fühlt, Web-Interface ein bisschen zu verschönern,
haut rein. Ihr könnt auch gerne im Backend noch ein paar Sachen anpassen, zum Beispiel,
wenn ihr sagt, dass... Na, an der Stelle, ich schicke ja quasi zum Kleinen, schicke
ich ja nur den Namen vom Bild und ob es gerade benutzt wird. Also wenn ihr sagt, ich brauche
auch noch die Keybindings, dass ich die dort quasi als Spickzettel anzeigen lassen kann,
tragt euch halt hier noch die Keybindings übergeben oder so. Ist kein Ding, könnt ihr
auch anpassen. Und wie gesagt, ich freu mich da über jeden Pull-Request. Oder nutzt ihr
mal CMDA, beste CMDA, beste. So, ich muss mal kurz gucken, ich hab ein paar Sachen im
Chat, das hab ich nicht gesehen. Wie grabst du eigentlich die Hotkeys? Ich verwende eine
Library von... Ich glaub, das da. Aber was der macht, ist, das ist wirklich ein ganz
dünner Rapper um Windows Funktionen. Also ich hab das einfach mal gesucht auf GitHub,
ja, und das macht genau das, was ich will. Das funktioniert ziemlich simpel. Du sagst
einfach hier, Hotkey, Modifierkey, in dem Fall halt CTRL, Page Up, und dann halt, was
er machen soll. Du kannst dir aber auch hier angucken, wie er das macht. Das ist wirklich
ziemlich simpel, ja. Das ist im Prinzip alles. Du brauchst hier Register-Hotkey an, Register-Hotkey
aus der Windows API und guck dir an, wie er das macht. Das kann man auch easy selbst
machen. Ich hab mir halt gedacht, warum soll ich das selbst machen, wenn es schon fertig
ist? Ach so, Zekro, das kann sein. Je nachdem, was du machen willst. Es gibt bestimmt die
ein oder anderen Spiele, die keine Keypresses annehmen, was eigentlich auch aus Cheatsicherheit
nicht so unlogisch ist. Willst du überhaupt Keypress an ein Spiel senden oder verstehe
ich das jetzt falsch? Weil die Hotkeys sollte LOL eigentlich nicht creppen, weil dann wird
es ja Systemfunktionen aushebeln. Das wäre blöd, wenn. Kann aber sein, dass die das
machen. Ich meine, gehen tut das. Du kannst das ja abfangen. Vmware macht das ja auch.
Wenn du Vmware Workstation aufhast, kannst du auch keine Windows-Hotkeys drücken. Das
ist aber ein bisschen, brauchst du irgendeinen eigenen Tastaturtreiber für. Nimm doch einfach
ein Frameware für Bootstrap fürs Layout. Ja klar, kann ich machen. Kann ich alles
machen. Ähm, trotzdem muss ich es ja irgendwie einbauen. Und dann gucken, dass es im Grid
richtig angeordnet wird und sonst was. Einfach nur Bootstrap einbinden auf dieser Seite
hier, bringt es ja jetzt im Prinzip alleine auch nicht. Wenn ich jetzt hier einfach mal
Bootstrap einbilde, sieht es im Prinzip genau so aus wie vorher. Fallen dir gerade ein paar
Bad-Practice-Beispiele für schlechte Comment-Messages an? Ja, fix. Fix ist sehr beliebt. Also ich
habe da mal ganz viele Comments, wo irgendwie fix in irgendwelchen Abwandlungen drinne steht.
Der eine schreibt, da hat mal einer wörtlich reingeschrieben, edit Dinge. Okay, edit Dinge.
Hat er noch einen Comment gehabt, edit mehr Dinge. Okay, was denn für Dinge. Und wir hatten
mal einen, der war ganz stinkig, der hat Comment-Messages gemacht. Fuck it, shit it, suck it.
Das war sogar der Felix, den Felix kennt ihr sogar, wenn ihr das Video von der Gamescom
mit ihm geguckt habt. Das war der Felix. Im Prinzip kann man bei Comment-Messages, es
ist jetzt auch nicht so essentiell, weil man kann ja immer noch in das Div gucken. Also
es sollte schon was, ich will jetzt nicht sagen, ich will euch auf die Idee bringen,
scheiß Comment-Messages zu schreiben, aber selbst wenn man jetzt eine nicht so tolle
Comment-Message geschrieben hat, man kriegt immer noch ein bisschen den Gedanken raus
von demjenigen. Aber es hilft natürlich schon. Was kann das denn jetzt genau? Overlay-Bilder
anzeigen. Einmal per Remote-Steuerung, Web-Interface, oder per Shortcuts auf der Tastatur.
Als Overlay, es hat keinen Einfluss auf das Browser-Fenster, wie du siehst hier unten
drunter. Ich kann hier Firefox bedienen und so und das juckt überhaupt nicht. Firefox
tracken, droppen und so. Der merkt überhaupt nicht, dass das Bild da ist. Und es kann
rotieren. LUL 4D.
Pogas. Leute, Pogas.
CSS-Crit wäre dafür optimal. Ja, seht ihr was Max? Wenn du dich damit auskennst, hau
einfach Pull-Request rein, dann nehme ich dann das nächste Mal das Ding und dann haben
wir ein schickes Web-Interface. Also ich fände es ja eh ganz nice, wenn man zum Beispiel
sagen würde, hey, ich meine, es ist simpel und funktional. Die Fernsteuerung, die ist
simpel und funktional. Ich meine, gibt es dann viel, was dann funktioniert. Man könnte
da noch ein ordentliches, wie gesagt, ein ordentliches CSS-Crit dahinter machen. Man
könnte noch anzeigen, wenn es auf einen Shortcut gebunden ist. Warte, das ist doch Chrome,
ja, das ist Chrome. Habe ich Firefox gesagt? Ach, was? War ich denn jetzt gerade dabei?
Genau, ein ordentliches Crit hier machen, wo das drin angezeigt wird. Wenn es viele
Bilder sind, vielleicht noch Paging oder so. Keine Ahnung, nee, Paging ist doof. Da sieht
man immer alle Bilder. Ein ordentliches Crit vielleicht noch in irgendein passender
Hintergrund, so in so einem Rahmen oder so, das ein bisschen mehr aussieht wie ein
Dashboard oder so. Dann drunter anzeigen lassen, was das für einen Shortcut hat, das
jeweilige Bild. Also man kann ja die Bilder nicht nur über die Fernsteuerung aktivieren,
sondern auch per Shortcuts. Und man kann es ja dann später immer noch weiter ausbauen,
zum Beispiel, dass man sogar die Shortcuts ändern könnte über das Webinterface, also
da sind Open End. Hast du die WinAPI benutzt, um das auszugeben? Teilweise. Das meiste
ist ganz normal WPF, dort nennt WPF, aber ein paar Sachen sind über die WinAPI zum
Beispiel die Hotkey-Geschichte, ja, also dass man, dass man jetzt beispielsweise
Steuerung L drücken kann und dann kommt Total Bizkit und Lult oder Steuerung 3 für
Lult 3D oder Bild hoch und runter für Animation. Das geht über die WinAPI. Und was
noch über die WinAPI geht, ist die Geschichte mit, dass man, ups, ich versuche es gerade
zu starten, obwohl es schon läuft. Ich glaube, das crasht jetzt. Ich glaube, das spackt
jetzt rum. Machen wir das mal zu. Okay, funktioniert. Zum Beispiel die Geschichte,
dass man durchklicken kann, dass das Bild komplett transparent ist. Dafür muss man
WinAPI verwenden. Und vor allem, das ist auch kein Focus-Crap, weil guck hier, ich bin
jetzt im Hintergrund im Visual Studio markiere und wenn ich, es crappt halt keinen
Fokus und nix, da muss man ein bisschen WinAPI-Hacksworn, dass das funktioniert. Und
Disclaimer, ich bin da auch nicht selbst drauf gekommen, das ist Stack Overflow Copy
Paste, wie das funktioniert. Ich habe versucht nachzugucken bei Microsoft auf der
Seite, was das jetzt eigentlich genau macht, habe ich nicht richtig rausgekriegt. Aber
es funktioniert. Das ist das Wichtige. Ja, gibt es noch irgendwelche Fragen sonst?
Sonst gehe ich jetzt mal wieder Plumen auf das Grab von meinem Opa bringen, nachdem
er da letztens einer mit dem Traktor oder so drüber gefahren ist und alles platt gemacht
hat. Wie hast du die Pixel-Ausgabe gemacht? Äh, das da? Du meinst das Overlay an sich?
Und ausbalzte. Die Ausgabe des Pilzes, das ist WPF. Was ist WPF? Das ist, äh, ja.
Ja, da hast du das. Einfach Image. Image Element und dann hier. Where is it then?
BTF. Da. Genau. Und hier setzt er halt einfach nur die Source von dem jeweiligen Bild.
Wieso fährt einer mit dem Traktor über... Ich habe keine Ahnung. Es war platt gewalzt
komplett. Das Beet, ja, die Plume waren platt gewalzt und manche sogar geklaut. Also weg.
Weil ich weiß nicht warum, wenn ich das wüsste, dann würde ich dem was erzählen, aber ich
weiß es nicht. Und ich weiß nicht geschweige denn wer, ja. Keine Ahnung. Muss ja ein bisschen
schick machen wieder das Ganze. Ja. Anzeige, Quatsch. Weil da einer, das ist ja nicht
kaputt, das ist ja nicht irgendwie zerbrochen oder so, sondern das ist einfach nur platt.
Anzeige ist raus. Das ist mit zu viel Arbeit, ehrlich gesagt. Wegen 2, 2, 3 Plumentöpfen
und ein bisschen plattgedrückter Erde da. Anzeige ist raus, wird bearbeitet, ist abgelehnt.
So. Ich hoffe euch hat es gefallen. Wir sehen uns eventuell noch mal heute Abend ein bisschen
weiter, falls da noch Battlefield 5 läuft. Vielleicht spielen wir noch eine Runde Battlefield
5. Ansonsten sehen wir uns morgen. Vielleicht kriegen wir dann morgen die erste Version
vom MemeTool hin, die wir auch mal auf die Öffentlichkeit loslassen können. Releasen
wir dann auf GitHub, falls wir morgen soweit kommen. Und wir sehen uns. Bis dann, machts
gut, tschüss.
