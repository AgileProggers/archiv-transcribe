Siddi dit, dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit dit
auoo åu
Wir haben ja auch Quality Options, falls schon irgendjemand da ist, dann schreibt mal bitte was in den Chat, weil ich seh grad nichts.
Und ich muss ja erstmal checken, dass alles funktioniert, bevor ich hier loslege und bis ich durchdrehen werde, weil wir irgendwie, warte mal sich, wie viele Zeilen in Assembler basteln müssen heute.
Da hab ich ja schon Bock drauf, ey. Das wird grausam, Leute, ich sag's euch, das wird ganz schlimm.
Vor allem, diese Art von Assembler, das ist ja nicht zu vergleichen, du kannst auf dieser Mini-CPU fast nichts machen.
Also wenn das Stream dann mal richtig live ist, also nicht nur faked live zu sein, dann kann ich auch erzählen, was wir heute machen.
Oh, tatsächlich, jetzt, jetzt, ja, ja, hallo Leute, also jetzt hat anscheinend Twitch es geschafft, die Benachrichtigung rauszuschicken, das ist doch schon mal toll.
Ich warte noch mal, ich warte noch mal kurz, paar Minuten, weil, also irgendwie ist Twitch jedes Mal, jedes Mal wenn ich drauf komm anders kaputt.
Wisst ihr übrigens, was mich an Twitch übelst, übelst nervt? Ich mein, es ist jetzt vielleicht ein bisschen so, beeist sich das, wenn ich quasi auf Twitch streame
und jetzt als erstes mal erzähle im Stream, was mich auf Twitch nervt, aber rein aus, aus Viewersicht nervt mich eine Sache auf Twitch, Kirby halt mal kurz die Klappe.
Aus Viewers und hier der Vogel muss auch mal weg, der Vogel muss weg, wo ist der Vogel? Easy. Also was mich als Viewer übelst nervt in der Zeit, auf Twitch ist
und auf YouTube übrigens auch, es war nicht mal auf Twitch exklusiv, dass es so viel Werbung gibt.
Habt ihr nicht auch das Gefühl, dass Twitch mittlerweile viel mehr Werbung hat als noch vor einem Jahr?
Also mir kommt das so vor und YouTube auch, YouTube hat neuerdings doppelt, doppelt Werbung.
Also vor YouTube Videos kriegst du doppelt Werbung. Habt ihr das auch? Das machst du ein YouTube Video auf und du kriegst nicht nur einmal Werbung,
sondern du kriegst gleich zweimal Werbung hintereinander. Ganz, ganz merkwürdiges Zeug.
Ja und es geht mir auf Twitch ehrlich gesagt ein bisschen auf den Keks, dass es so viel Werbung gibt und vor allem kriegst du auf Twitch mittlerweile wirklich bei, bei jedem Mist Werbung.
Ich rede jetzt nicht auf dem Desktop, wenn man genau, genauso wie das der Online-Ritter gerade schreibt, ich rede jetzt nicht irgendwie auf dem Desktop,
wo man einen Ad-Blocker hier installiert hat oder so, sondern ich rede auf dem iPhone zum Beispiel. Auf dem iPhone.
Und auf dem iPhone musst du ja quasi mehr oder weniger die offizielle App verwenden, weil es gibt ja keine anderen Twitch Apps.
Im Safari ist Twitch räudig. P-Haul regelt auf dem Handy. Ne, das funktioniert mit Twitch nicht. Oder funktioniert das bei dir?
Interro. Also meines Wissens nach, und deswegen habe ich es auch mittlerweile nicht mehr, funktioniert P-Haul, das hört sich irgendwie schon, hört sich so ein bisschen verkehrt an,
aber deswegen funktioniert hier P-Haul nicht auf Twitch, weil, also wie das Ganze funktioniert, ich meine vielleicht kennt das die eine oder andere,
aber wer es nicht kennt, ich erzähle es mal kurz, das ist ein DNS-Server, der einfach alle möglichen Domains, die bekannt sind dafür Werbung zu verteilen, nicht auflöst.
Von der Idee her ist das natürlich nicht schlecht. Twitch macht es allerdings mittlerweile relativ clever und verteilt die Werbung von Twitch.
Und nicht von der extra Domain. Das heißt du kannst es nicht mehr blocken. YouTube macht es wahrscheinlich mittlerweile ähnlich.
Zumindest du kannst auf dem iPhone oder auf dem iPad kannst du nur die offizielle App verwenden, was halt ein bisschen doof ist, weil da kannst du die Werbung nicht ausschalten.
Und ich habe ja gar nichts dagegen, wenn manche Leute im Stream ein bisschen Werbung laufen lassen, oder wenn ab und zu mal ein bisschen Werbung kommt,
wo es mich halt nervt, ist einmal wenn man pennt dabei, ich mache öfters mal einen Stream an, und dann penne ich ein und dann geht auf einmal die Werbung los.
Ich meine die Lautstärke ist natürlich auch schon viel lauter wieder bei der Werbung App als bei dem, wenn du dir irgendwie einen Streamer anguckst,
der entspannt sitzt und irgendwas spielt. Ich gucke mir meistens gerne so ein bisschen ältere Games an, so irgendwelche.
Zum Beispiel was ich mir ganz gerne angucke sind so Link to the Past, Randomizer Turniere oder sowas. Das ist eigentlich super entspannt.
Ja da sitzt einer oder labern dazu, das ist relativ ruhig und dann geht auf einmal, schaltet Twitch auf einmal auf die Werbung um,
und da musst du dir dann irgendwie das neue Clean Shave sonst was in übelster Lautstärke anhören. Das ist doof, wirklich doof.
Und du kannst das nicht überspringen. Pyhall hilft dir nix, weil es DNS, weil DNS-Blocken nix mehr bringt auf Twitch und Ad-Blocker für die mobile Twitch App gibt es nix.
Ist nervig. Genauso wisst ihr was mich auch übelst, übelst aufregt ist YouTube App Pop-Up. Das hier. Weiß ich ob es da ein Bild zu gibt.
Trial Pop-Up? Ey Leute, wie mir dieses Pop-Up auf den Sack geht. Ey das geht mir mega auf den Keks. Ja genau, Akenas.
Immer wenn man sich guckt, der Akenas will sich jetzt Bob Ross angucken, liegt dann, was weiß ich, abends im Bett, will mal pennen, denkt, achja gut, jetzt noch mal eine Runde Happy Little Trees und hier den, wie macht der immer?
Moment, ich krieg das mit dem Finger nicht hin. So, der Devil. War doch ziemlich original, oder? Leute, so gehört sich das ja immer an.
Und da kommt auf einmal irgendwie eine kack Werbung. Und ich hab nix dagegen, dass ab und zu Werbung läuft, allerdings manchmal ist es wirklich sehr nervig.
Und vor allem auf dem iPhone, wo du nix machen kannst. So und dieses Pop-Up geht mir auch richtig auf den Keks auf YouTube.
Und es ist nicht so, dass es reichen würde, dass du das mal wegklickst. Das kommt gefühlt quasi jedesmal, wenn du die App aufmachst und jedesmal, wenn du das Video switchst.
Deswegen, was du in Assembler programmierst, ja ich warte jetzt bis der Stream richtig live ist. Das ist ja, ist ja gerade erst angegangen, dann erzähl ich gleich, was wir machen.
Ich weiß nicht, ob ich das überhaupt im Kopf aushalte, heute so viel Assembler-Gramm. Also ich vergesse, was ich sagen wollte.
Ja genau, wie gesagt, ich hab nix dagegen, aber man kann ja im Prinzip nix dagegen machen, vor allem auf dem iPhone.
Und deswegen hab ich mir überlegt, und da hab ich gestern mal geguckt, ob es nicht irgendwelche Proxy-Lösungen gibt.
Also sprich, wo man sein ganzes HTTP-Zeug dann drüberleitet und das für einen die Werbung rausfiltert. Hab ich ein paar Sachen gefunden, wo ich mal auspumpt, ob das Ganze funktioniert.
Wird schwierig, ich meine letztendlich geht es über HTTPS.
Ich weiß nicht, was ich hier für ein Textdokument auf hab. Weiß nicht, ob ich euch das zeigen kann. Oh, reveal.
Boah, das war schlecht, oder?
Ja.
Mittlerweile subscriben? Nein, und ich kann mich als auch nicht mehr bewerben, weil ich jetzt irgendwie drei Monate oder so nicht mehr gestrebt hab.
Und deswegen jetzt mein Partnerbewerbungsstell nicht mehr funktioniert.
So, also, ich guck mal kurz, ob ich irgendwas im Chat überlesen hab. Und falls nicht, dann fangen wir jetzt gleich an.
Ne, ich hab nichts übersehen. Also, was wir heute machen. Lautstärke passt, denke ich, ganz gut von Geschwätze und von Musik.
Also, was wir heute machen. Ihr wisst ja, dass ich, ich mach doch irgendwann mal ein Stream oder ein Video zu, dass ich bei mir ziemlich viel in Richtung Heimautomatisierung und Sachen, die drum herum dazugehören.
Bei mir daheim aber aufrüsten bin. Und ich hab ja schon ein paar Raspberries rum, es steht auch ein paar Raspberry Zeros.
Ich hab auch schon die ein oder anderen Microcontrollers rumhängen, die beispielsweise den Wasserstand von den Blumen auf dem Balkon und auf dem Beet im Hof messen.
Und das ist so ein billig China-Bodenfeuchtigkeits-Bluetooth-Messer ist das und da hängt an der Tür so ein Ding, was das ganze Bluthoos abfragt. Und so und so Dinge.
So, und zumindest, ja, SilentPain, du hast recht, wenn ich auf Android wäre, also ich hab ja im Prinzip nur Android-Tablets, allerdings, Smartphone ist halt ein iPhone, dann würd ich auch ne andere YouTube-App nehmen.
So, und aktuell versuch ich noch zwei Sachen. Ich versuch nen Schalter zu basteln, den ich ans Hoftor machen kann, wo mir das dann beim Öffnen Bescheid sagt.
Das ist, aber das machen wir heute nicht. Was wir heute machen ist, und da muss ich jetzt ein bisschen weiter ausholen, wozu das ganze da sein soll, weil ich muss mal kurz in mich gehen.
Ich weiß gar nicht, ob ich das überhaupt erklären muss, ob man das versteht, ne, das erzähl ich, wenn wir dann dabei sind, das ist sonst zu viel Geschwätze davor.
Zumindest, ich hab hier ne ganze Reihe ESP32 und ESP, ach lass mir das nicht, 2866, kann man immer nicht die Reihenfolge merken, wie der Krempel heißt. Genau, rumliegen. Und aktuell hab ich hier so einen.
Zum Testen hier gerade hier nebendran liegen. Aber ich hab mir ne ganze Reihe in China gekauft. Und, ähm, mal zur Erklärung für jemand, der sowas noch nicht in der Hand hatte, weil bei mir ist es auch noch nicht so lange her, dass ich mit dem ganzen Krams angefangen hab.
Ähm, das sieht zwar auf den ersten Blick aus wie ne, wie ne Raspberry Pi. Zero ist es allerdings nicht. Es ist ungefähr so groß wie ne Pi Zero. Allerdings läuft da drauf kein Linux.
Da drauf läuft im Prinzip, also bis auf ein paar ganz kleine Ausnahmen läuft da nichts drauf, außer was man draufflasht. Das heißt, man muss das wirklich so ganz roh programmieren, draufflaschen und dann macht er was man will.
Ähm, die Dinger haben jede Menge IOs, also ich glaub sogar mehr als so ein Raspberry IOs hat. Und ich hab mir einen Bodenfeuchtigkeitssensor gekauft. Und den versuchen wir heute mal auszulesen.
Allerdings nicht so einfach. Wo ist es im Moment? Den da hab ich mir gekauft, genau. Das ist so ein Ding, da musst du hier oben, musst du was drüber pappen und das hier unten stöpselst du dann in den Boden.
Und dann kannst du messen quasi wie die Bodenfeuchtigkeit ist. Eher wie ein Arduino, genau. Klapperrottel. Das ist auch Arduino kompatibel das Ding. Also wir werden auch Arduino als Framework nehmen.
Allerdings, und jetzt kommen wir zum eigentlichen Punkt, warum Assembler im Titel drinne steht. Ich will das Ganze natürlich nicht so Noobstyle machen, ja.
Sondern ich will das ordentlich machen. Also sprich, das Ding soll, wenn es nichts tut, schlafen, dass es nicht so viel Strom verbraucht. Ich hab so, ich plan das auch an eine Batterie zu machen. So eine ganz normale 1200 oder 2000 mAh LiPo Batterie, so eine kleine.
Und das heißt, das Ding muss wirklich wenig, wenig Strom verbrauchen. So, und das geht nur, wenn man das Ding in, den hab ich hier am Start, genau. Wenn man das Ding ins Leap schickt.
Ich hab, für den niedrigen Energieverbrauch hab ich noch ein anderes Board. Das ist jetzt nur mal zum Ausprobieren. Und was halt Strom braucht, ist das Übertragen von, also erstmal überhaupt an sein verbraucht viel Strom.
Und was richtig viel Strom verbraucht, also viel, in Form von Batteriebetrieb viel. Also sprich, wenn das Ding ein Jahr laufen soll, kannst du es halt nicht ein Jahr durchgängig laufen lassen.
Und dann musst du schlafen legen und kannst es einmal die Stunde aufwecken. So, und jetzt kommt der Witz. Und das ist das, warum Assembler im Titel steht.
Ähm, richtig pro wärs natürlich, wenn das Ding den Wasserstand messen könnte, also den Boden, die Bodenfeuchtigkeit messen könnte, ohne, dass die Haupt-CPU aktiv sein muss.
Sondern quasi aus dem Deep Sleep raus. Ich hoffe, das hat man jetzt verstanden. Und das Tolle ist hier an diesem, an diesem Microcontroller.
Das hat viel mehr als so ein, als auch vor ein paar Jahren eigentlich auf so einem Board drauf war. Ähm, das Ding hat verschiedene, verschiedene Kerne.
Das Ding hat, also hier der da, genau. Also das Ding hat verschiedene Kerne. Das hat zwei 32-Bit-CPUs, Kerne.
Ähm, ich glaub mit 240 Mhz, so irgendwie in dem Dreh. Und dazu kommt, es hat hier unten einen Ultra Low Power Co-Prozessor.
So, und dieses Ding kann man nicht irgendwie etwa mit dem Standard Arduino Framework oder hier irgendwie in C programmieren.
Diesen Scheiß muss man in Assembler programmieren, dass er das macht, was man will. Und, das wird, das wird was ey.
Ich hab mir schon was rausgesucht. Ich bin nicht, ich bin nicht ganz planlos. Ich hab schon im Vorfeld ein bisschen nachgeguckt, wie das, wie das so funktioniert.
Man muss auch nicht wirklich alles von Hand machen. Man kann ein paar C-Macros verwenden dafür.
Aber im Prinzip ist es, im Prinzip sind es Assembler Befehle. Und jetzt passen wir auf, ähm, Instructions Set.
Das Ding hat, ähm, acht Befehle. Acht, acht, ähm, wie nennt man das? Acht Instructions, verschiedene.
Das Ding, also dieser, das ist alles. Das ist alles. Das ist alle, alle, alle, quasi eingebauten Microcode,
sonst was Befehle, die, die diese Ultra Low Power CPU kann. Das ist, das ist quasi nix im Endeffekt.
Ich hab keine Ahnung, wie viel, wie viel Befehle so ein aktueller X86, 64 Dings an CPU hat.
Wahrscheinlich 50.000 oder so. Ich hab gar nicht gesagt, keine Ahnung. Ähm, zumindest acht ist wenig.
Und das ist auch sehr, sehr unadvanced, was das Ding kann, ja.
Machst du es mit Inline Assembler in C. Also es gibt zwei, zwei Varianten, wie man das Ganze machen kann.
Ähm, man macht es entweder in einem eigenen Assembler File und lässt es dann in, in, quasi beim Kompilieren,
so mit rein linken, irgendwie. Oder man macht das quasi mit C-Macros.
So, so richtig Inline Assembler unterstützt der ganze Kram, nicht?
Frag mich nicht warum, aber wir, wir versuchen mal die Variante mit C-Macros.
Weil das Schöne ist, die Variante mit C-Macros geht hier ganz gut aus der Entwicklungsumgebung raus.
Die Variante mit, mit, äh, mit Assembler Files braucht ein bisschen gefuddelt drum herum.
So, ähm, genau, jetzt noch ein bisschen, bisschen mehr dazu, weil ich seh schon die ersten Fragen im Chat.
Also, so einfach ist es natürlich nicht. Also, nochmal, nochmal was anderes.
Das Schöne hieran ist, an diesem Ultra Low Power Core Prozessor, der ist aktiv.
Alle, kann man einstellen, ich sag mal alle, keine Ahnung, alle 30 Minuten, sagen wir jetzt mal, wacht er auf.
Ohne dass halt die Hauptkerne aufwachen müssen. Das bedeutet, ähm, also wir reden hier von Stromverbrauch ungefähr.
Das Ding, so ein ESP32, braucht ungefähr, ähm, wenn er über WLAN was überträgt, so ungefähr 150mA.
Und, wenn er einfach nur an ist, so um die 50mA, und wenn er im Deep Sleep ist und man das passende Board hat,
ungefähr 10mA. Also, das ist wirklich verdammt wenig. Das heißt, man tut guter dran, möglichst lange die Hauptkerne im Sleep zu lassen.
Ja, und dieser Ultra Low Power Prozessor braucht glaube ich irgendwie 2 oder 3mA für die ganz kurze Zeit, wo er aktiv ist.
Der schläft dann auch immer 30 Minuten. So, ähm, deswegen ist das Ziel, den Sensor abzufragen,
mit dem Ultra Low Power Prozessor dann zu vergleichen. Das ist ja noch nicht so einfach, ja.
Ich glaube nicht, dass wir das heute gebacken kriegen, alles komplett.
Ähm, dann muss der den letzten Wert, den er gemessen hat, mit dem aktuellen Wert vergleichen.
Also, ich erzähle mal so, was ich mir so gedacht habe, wie man das machen könnte.
Und nur, wenn der Wert über einen gewissen, gewissen Schwellwert abweicht.
Also, sag mal mal so, wenn der aktuelle gelesene Wert, sag mal mal, 100, 100 größer ist als der zuletzt gelesene Wert,
nur dann weckt er die Hauptkerne auf und nur dann wird das Ganze per WLAN übertragen.
Weil viel Strom verbraucht einmal, wenn eben die Haupt-CPU läuft.
Und was richtig viel Strom verbraucht, ist, wenn das Ding per WLAN Daten schicken muss.
Also, da reden wir von, keine Ahnung, 15.000x mehr Stromverbrauch.
Und das ist an sich nicht viel.
Das ist immer noch insgesamt, selbst wenn der einfach nur läuft und nichts macht,
ist es immer noch viel, viel, viel, viel, viel sparsamer als beispielsweise den Raspberry Pi Zero.
Allerdings, an der Batterie kann man nicht sparsam genug sein.
Hat man das jetzt verstanden?
Äh, Kappa-Rottel, das bin ich noch am überlegen.
Aktuell will ich jetzt erst mal gucken, wie man diesen Low-Power-Prozessor programmieren kann.
So, und als erstes, was wir als erstes machen, wir legen hier mal ein neues Projekt an.
Und ich habe leider mein einziges Wasserglas hier jetzt stehen,
mit Wasser drin, wo der Bodenfeuchtigkeitssensor drin hängt.
Das heißt, es kann sein, dass ich gleich mal runtergehen muss, was zu trinken holen.
Ich habe jetzt bloß noch hier halbe Tasse Tee.
So, wir legen jetzt mal ein neues Projekt an.
Und was wir als erstes machen, ist, wir lesen auf ganz traditionelle Art und Weise,
also ohne Ultra-Low-Power, sonst was.
Einfach auf dem Main-Core lesen wir einfach mal den Bodenfeuchtigkeitssensor aus
und gucken, was da für Werte rauskommen.
Also, ein neues Projekt.
Dann werden wir mal irgendwie streamtest. Dort habe ich eine NodeMCU32S.
Wir nehmen als Framework das ganz normale Arduino-Framework, da ist alles schön dabei, was man so braucht.
Das ESP-IDF ist das offizielle Framework vom Hersteller, das sind irgendwelche Chinesen.
Max baut sich einen automatisierten Hanfgarten.
Die Möglichkeiten sind theoretisch ziemlich unbegrenzt.
Ich erzähle euch gleich noch, wofür ich es eigentlich verwenden will.
Das hat nichts mit einem automatisierten Hanfgarten zu tun.
Das hat, finde ich, einen recht praktischen Sinn.
Kann ich das jetzt mal anlegen hier?
Aktuell mache ich es nämlich so.
Da habe ich bei mir im Hof und auf der Terrasse die Dinger stehen.
Das sind China Bodenfeuchtigkeits-Messensoren.
Die können Nährstoffe im Boden messen, Leitfähigkeit, also sprich, wie viel Wasser im Boden ist, Licht und Temperatur.
Allerdings, ich bin nur interessiert an der Bodenfeuchtigkeit.
Und für so einen habe ich schon so einen ESP32, unten neben der Tür hängen, der per Bluetooth die Dinger abfragt.
Allerdings, ich erzähle euch gleich, was ich genau machen will.
Open.
Ach da, da ist es schon.
Also, wir lesen jetzt diesen Sensor mal aus.
Ohne irgendwelche Sperenzen, einfach nur auslesen.
Das erste, was man immer machen muss, ist erst mal, das ist ziemlich raw heute, das ist ziemlich low-level shit.
Ich erzähle euch gleich schon.
Da ist nichts mit Konsole, Printline oder, nein, das ist jetzt ein doofes Beispiel.
Konsole, Printline gibt es da auch.
Aber da ist nichts mit irgendwelchen dynamischen Listen oder sonst was.
Das ist ziemlich, ziemlich raw.
Und deswegen nehmen wir auch hier das Standard Arduino-Framework, weil da schon viele Sachen dabei sind, die wirklich sehr angenehm sind.
So, als erstes müssen wir mal unsere serielle Schnittstelle.
Ja, und das habt ihr richtig gehört, unsere serielle Schnittstelle initialisieren.
Standardmäßig waren wir mit 9600, was ist das, Weiß pro Sekunde, Kilobits pro Sekunde.
Ich habe ehrlich gesagt keine Ahnung.
Ist auch egal, es ist langsam auf jeden Fall.
Also, wir müssen erst mal unsere serielle Schnittstelle initialisieren.
Und dann können wir hier in der Main Loop, oder wie auch immer man das nennt, geben wir einfach mal was aus.
Also hier, serielle, Printline, hallo, Tremsor.
Und jetzt, nachdem das Ding, das muss ich jetzt vielleicht auch nochmal erklären.
Das Ding ist halt, da ist kein Betriebssystem drunter oder sowas.
Das, was wir hier programmieren, wird kompiliert und dort als Firmware auf den internen Flash-Speicher geflasht.
Von diesem Teil.
Das hier, ich glaube, hier vorne wird der Flash sein, keine Ahnung.
Und das hat, glaube ich, auch nur 8 Kilobyte Flash für persistente Geschichten.
Also, das ist nicht so groß.
Dementsprechend, da läuft kein Betriebssystem oder sonst was in der Richtung drunter.
Das heißt, alles, was ich hier reinschreibe, wird direkt und genauso, wie ich es reinschreibe, ausgeführt.
Das heißt, ich muss hier auch selbst irgendwie dafür sorgen, dass die Dinger im richtigen Intervall laufen, im richtigen Timing laufen und sonstige Dinge.
Das ist jetzt auch noch relativ einfach.
Wenn ich das jetzt mal ausführe und uploade, also sprich, der kompiliert das jetzt und flasht das jetzt hier über USB, über die serielle Schnittstelle.
Das emuliert halt serielle Schnittstelle über USB.
Das flasht das jetzt über die serielle Schnittstelle auf den ESP32.
Und jetzt kann ich mir angucken, was das Ding macht.
Der sagt jetzt halt nichts großartig mehr, außer, hallo, extrem.
Ich glaube mal, ich mache die Konsolenschrift ein bisschen größer, oder?
Bisschen klein, oder?
Also Schriftgröße hier oben ist denke ich mal gut, oder?
Also hier unten könnte ich vielleicht schon ein bisschen größer machen.
Oder passt das?
Genau.
Hexor.
Ähnlich war Low Level.
So, aktuell habe ich es so gemacht.
Ähm.
Ich habe es so gemacht, wie wahrscheinlich jeder Elektriker sagen würde, man darf es nicht machen.
Ich zeige euch mal kurz den Sensor.
The Moisture Sensor.
Ähm.
1.2.
Also, dieser Sensor sieht folgendermaßen aus.
Genau das ist er.
Also etwas bessere Auflösung RL als hier.
Ähm.
Ich würde das Bild gerne...
Was ist das für eine Seite, die ich da aufgemacht habe?
Ich würde einfach nur das Bild aufmachen.
Wer weiß, was das für komische Seiten wir da sind.
Ähm.
Adresse des Bilds kopieren, okay.
Kann ich mal das Bild aufmachen?
Ich will euch das Ding noch mal groß öffnen.
Ah ja gut, hier sieht man es ganz schön.
Also genau, das sind die Pins von dem Teil.
Wir haben einmal hier.
Ich mache nebenan noch einen ESP.
Ich mache hier nebenbei noch mal den Controller auf, dass ihr das auch sehen könnt.
Da kann ich euch erzählen, wie das Ganze angeschlossen ist.
Mal gucken, ob ich jetzt auf der ordentlichen Seite rauskomme.
Pin.
Pin out.
Ja, hier sieht man es ganz gut.
Also Dankeschön für die Follows.
Das sehe ich irgendwie gerade nicht.
Aber es ist nice, dass ihr dabei seid.
Da ist gerade 140 Leute zugucken, wo ich ja mal meinen Microcontroller rumbastele.
Wieder heftig.
Also das ist der Sensor.
Und ähm.
Silent Pain ist das Analog.
Also das Ding hat folgende Pins.
Das hat 3,3 Volt in.
3,3 bis 5 Volt in.
Ground und ein Analog Output.
So und angeschlossen ist es aktuell folgendermaßen.
Das ist angeschlossen am 3,3 Volt Pin.
Logisch.
Damit.
VCC ist am 3,3 Volt Pin dran.
Analog Out ist an GPIO 34 dran.
Da.
Und jetzt kommt das, wo wahrscheinlich jeder Elektriker schreien wird.
Ground ist nicht etwa an Ground dran, sondern an GPIO 27.
Also da.
So und das hat den folgenden Hintergrund, dass ich das Ding nämlich ausschalten kann.
Ansonsten bräuchte ich irgendeinen Transistor oder irgendeinen Schalter oder sowas.
Das ist allerdings nicht so wild in der Stelle.
Der Sensor braucht höchstens laut Datenblatt 5 mA und die ESP32 GPIO Pins dürfen bis 20.
Also wir werden es überleben.
Da muss ein Transistor dazwischen.
Es ist jetzt nicht so, dass ich es gerade schon gesagt hätte, oder?
Dass da eigentlich ein Transistor dazwischen muss.
Zumindest so ist das Ganze gerade angeschlossen.
Das heißt prinzipiell funktioniert es.
Es hat halt den riesen Vorteil, dass ich mir was bestellen muss, dass ich jetzt ausprobieren kann.
Und dass ich das Ding ein- und ausschalten kann.
Weil auch 5 mA im Deep Sleep sind 5 mA zu viel.
Und wozu soll das Ding Strom verbrauchen, wenn ich es eh nicht abfragen will.
So und das erste was wir jetzt machen, wir fragen jetzt mal den Sensor ab.
So als erstes muss ich hier mal, nehme ich noch was ein, nehme ich meine Pins.
Arduino Pins.
Das sind die Definitionen für mein Board.
Also sprich, wie die Pins belegt sind.
Also sprich, da muss ich nicht jedes Mal auf das Board gucken, sondern kann einfach den Namen vom Pin eingeben.
Das ist eigentlich ganz praktisch.
So.
Cianox, Dankeschön, nice.
Oh, wird geradet mit 19 Leuten, krasser Shit.
So, genau, wo bin ich jetzt stehen geblieben?
Ich wollte...
Genau, wir wollten jetzt einfach mal den Sensor auslesen.
Das heißt, als erstes müssen wir uns mal überlegen, was brauchen wir für einen Pin.
Wir brauchen GPIO 34 und GPIO 27.
27 ist der Ein- und Ausschalter.
Und GPIO 34 ist der Input für das analoge Signal.
Das heißt, wir probieren jetzt erstmal ganz billig, einfach zu sagen, Analog Read auf GPIO 34.
Wenn ich jetzt noch richtig schreiben könnte, wäre es schon mal ganz nice.
Und wir gucken mal, was da rauskommt.
Ich vermute mal nicht allzu viel Sinnvolles, weil wir haben das Ding ja weder richtig ein- noch richtig ausgeschaltet.
Wir haben mit dem Ding gar nichts gemacht. Mal gucken, was rauskommt.
Wahrscheinlich das Maximum, was man so lesen kann von so einem GPIO.
Ja, das...
Also, wie erwartet, der Wert ergibt nicht wirklich Sinn.
Das steckt übrigens gerade im Wasserglas, der Sensor.
Cheat 195, bin ich schon zu spät? Nee, nee, wir fangen gerade an.
So, und damit das Ganze funktioniert, muss ich erstmal meinen Schalter, nämlich das in dem Fall GPIO 27,
muss ich erstmal auf Output stellen, also sprich...
Naja, auf Output, das ist eigentlich relativ selbsterklärend an der Stelle.
Und danach will ich das Ding einschalten.
Also, setzen wir das Ding auf Low.
Ich weiß, der Elektriker schreit, das hatten wir ja schon.
So, und jetzt sollte das- oh nee, Moment, das sollte ich im Setup machen und nicht hier in der Schleife.
Total beknackt ist da unten drin.
Meine Corsair-Tastatur, Leute, ne?
Aber ihr seht schon, dass das vom Sensor, die Ergebnisse vom Sensor, ergeben jetzt viel mehr Sinn.
So, und als erstes, was wir jetzt machen müssen, wir müssen den Sensor mal irgendwie halbwegs kalibrieren.
Und jetzt, ihr habt's hier gesehen, dass es doppelt eingefügt wurde.
Das liegt an meiner kack Corsair-Tastatur.
Ich hab das Ding halt vor der Weile schon angepriesen.
Was macht so ein Propeller?
Was für ein Propeller?
Ne, Propeller?
Naja, zumindest, die Tastatur hat seit neuestem doppelte Anschläge.
Wenn ich was einfüge, kann es sein, dass es zweimal einfügt.
Was beim Spiel nicht so auffällt, aber ansonsten einfach abartig nervig ist.
So, flashen wir das Ganze nochmal.
Also, was das Ding jetzt macht, und das ist bei allen Arduino-Boards gleich.
Einmal, nachdem sich der Controller startet, wird das hier im Setup ausgeführt.
Und danach wird einfach in einer Schleife immer das hier aufgerufen.
Also eigentlich ist das hier nicht die Loop, die Benamung ist ein bisschen doof.
Sondern das hier, was in der Loop-Funktion drinne steht, wird einfach immer wieder aufgerufen.
Sobald es fertig ist, wird es wieder aufgerufen.
Also im Prinzip ist da nochmal eine Endlosschleife drum herum.
Das Sensor-Teil, wozu es da ist, achso.
Das ist dieser Sensor und damit kann man Bodenfeuchtigkeit messen.
Kostet das Teil nicht 200 Taken? Nein, das Zeug ist alles übel.
Und die Tastatur, ja die Tastatur kostet nicht 200, aber irgendwie 150 oder so.
Was eigentlich total indiskutabel ist.
Ja, schöne Tastatur, was das kostet.
Ich habe mir ja für die Arbeit eine Ducky Skyline, Ducky One Skyline oder so ähnlich gekauft.
Und die ist zum Tippen einfach viel angenehmer als dieses Corsair-Ding.
Das Wichtigste, was die Corsair-Tastatur hat, ist eine halbwegs ordentliche Software,
weil man sich da auch ganz schön schwer tut bei manchen Sachen.
Und RGB-Beleuchtung.
Und halt so super krasse Speed-Trigger, sonst was Tasten, die dich zum besten Gamer ever machen sollen.
Was auch immer.
So, also unser Sensor, voll eingetaucht im Wasserglas übrigens gerade,
gibt uns jetzt einen Wert zurück von 1900, so irgendwie in dem Dreh.
1980 oder so was.
Ich nehme jetzt den Sensor mal aus dem Wasserglas raus.
Was benutzt du für Switches? Meinst du die Netzwerk-Dinger?
Nee, du meinst wahrscheinlich, du meinst die Tastatur-Switch.
Das ist Speed-Red oder irgendwie so, das was standardmäßig in dieser Tastatur angeboten wird.
So, okay, jetzt mache ich mal den Sensor aus dem Wasserglas raus.
So, man sieht, es geht auch gleich hoch.
So, und jetzt sieht man auch, jetzt kann ich euch an der Stelle auch gleich schon mal zeigen,
dass ich das Ding auch wieder besseren Wissens und zum Horror aller Elektroniker am GPIO-Pin angeschlossen habe.
Nämlich, dass ich es ein- und ausschalten kann.
Weil, wenn ich den Sensor jetzt wieder ins Wasser schiebe, dann sieht man erstmal eine Weile nichts.
Es dauert. Das geht ultra langsam runter.
So, und wenn ich den Pin, wo das dranhängt, wenn ich den Sensor kurz ein- und ausschalte vor jeder Messung,
dann geht das sofort.
Dann fragt mich nicht, wahrscheinlich haben wieder irgendwelche komischen Chinesen den Sensor gebaut und das ist nicht richtig.
Kann man die Werte linear mappen?
Naja, nicht ganz. Also wir müssen das Ding jetzt halbwegs kalibrieren.
Oder nennen wir es mal kalibrieren.
Also wir müssen uns erstmal überlegen, was denn so, wie macht man das eigentlich C++, so?
Kann man eigentlich Static-Const machen?
Passt jetzt eigentlich, also ergibt eigentlich keinen Sinn, aber kann man wahrscheinlich machen, oder?
Zumindest nennen wir das jetzt mal Sensor Max, das sind 4095, haben wir gerade gelernt.
Also sprich, wenn das Ding in der Luft hängt, liefert er ungefähr 4095 zurück.
Das ist der maximale Wert vom Analog-Digital-Converter.
Achso, wir sollten noch einstellen, mit welcher Auflösung der ADC das Ganze macht.
Static-Const, was anderes.
Da seht ihr, wie krasser C++-Owner ich bin.
Also ich dachte eigentlich immer, dass im Prinzip Const so eine Sache ist, Compile-Time reinbacken quasi.
Also wenn ich sage, das ist Const, dann ist das halt nicht mehr änderbar und zur Compile-Zeit drin.
So dachte ich mir das zumindest.
Und Static ist, wenn ich das jetzt mal aus der C-Sharp-Welt oder Java, meinetwegen, Gott helfe, aus der Java-Welt nehme,
dann heißt eigentlich Static nur, dass das einmalig initialisiert wird beim Starten vom Programm.
Das stimmt doch so ungefähr, oder?
Na gut, jetzt haben wir es super, jetzt haben wir eine Static-Const-Int.
Also der richtig krasse C-Owner, der wird natürlich sowas hier in der Richtung machen, der wird natürlich sowas hier sagen.
Das hier, das hier ist der reine C-Style, Leute, oder?
C-Owner, genau.
Also ich finde, das hier ist eigentlich schon irgendwie die schönere Variante, allerdings ist das hier keine Variante,
sondern das ist ein Makro und das sorgt dafür, dass überall, wo ich das hier verwende, einfach während ich compile,
dass das schon eingebaut wird an der Stelle.
Da hat der Werte recht, ja, das stimmt.
So, wir sehen, der Sensor geht immer noch runter, wir waren so irgendwie bei 1900 oder sowas als Minimalwert.
Was wir jetzt noch einstellen müssen, ist die Auflösung von unserem Analog-Digital-Converter.
Und lass mal überlegen, die Auflösung, wobei, müssen wir die Auflösung überhaupt einstellen?
Jetzt müssen wir ihn einstellen.
Wie sehr das Ding rauscht, sollten wir vielleicht noch einstellen.
Können wir machen, und zwar, man kann für jeden, das Ding hat, also so ein ESP32,
hat, ich glaube, 8 Analog-Digital-Converter drauf.
Noch mehr, oder? 1, 2, 3, 4, 5, 6, 7, die Benahmung ist übrigens komplett konfus,
da waren die Chinesen wieder voll nicht ganz bei der Sache, ich meine 0, 3, 6, 7, 4, 5, 18, 19,
und ADC 18 auf GPIO 25, RTC pin 14 oder so, Alter, brain.
Also Pin-Nummerierung ergibt eigentlich überhaupt keinen Sinn.
Wann kommt das nächste Video? Ich habe mir schon so viele Themen mittlerweile aufgeschrieben,
aber irgendwie fehlt mir einfach die Motivation, auf YouTube gerade was zu machen.
Genau, also das Ding hat hier noch 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
Analog-Digital-Converter, allerdings mit so einer kleinen Einschränkung, wenn man WLAN einschaltet,
fällt die Hälfte weg. Also sprich, das WLAN Modul braucht die Hälfte davon.
Weil, aber man kann WLAN jederzeit aktivieren und deaktivieren.
Ich uploade das Ding mal kurz neu, dass ich sehe, was der minimale Wert von unserem Sensor ist.
Also 1900 irgendwie in dem Dreh, oder auch nicht.
Also 1960 so rum, 1970. Also das dürfte der untere Wert sein, weil das Ding, wie gesagt, steckt gerade im Wasserglas.
Und das sollte dann wirklich der Minimalwert sein.
Was hast du jetzt eigentlich mit Assembler vor? Ja, wie gesagt, den Ultra-Low-Power-Prozessor von einem ESP32 programmieren.
So, ok. Also wir lesen jetzt den Sensor aus. Wir haben jetzt den Sensor so ungefähr uns mal die Minimal- und Maximalwerte rausgesucht.
So über den Daumen gepeilt. Wollen wir mal gucken, was der Sensor macht, wenn ich den so anschließe, dass der Elektriker sich nicht aufregt?
Probieren wir mal. Ich schließe das Ding jetzt mal nicht an den GPIO an, sondern ich schließe das Ding jetzt mal ordentlich an Cloud an.
Ich muss es aber vorher mal kurz aus dem USB-Anschluss ziehen. Wo haben wir es denn hier? GPIO 27.
Auf Ground umstöpseln und dann mal gucken, was der Sensor macht. Allerdings ist das hier an sich gerade keine Option, weil ich muss jetzt hier einen ausschalten können.
So, mal USB wieder reinstöpseln und wieder hochladen. Max, wir vermissen dich auf YouTube. Endlich mal Konter mit Niveau.
Wie gesagt, ich habe mir ganz viele Sachen schon aufgeschrieben, aber ich muss das einfach mal machen. Spätestens, also spätestens im Dezember, weil ihr wisst ja, Dezember wird schon mal ein ganzes Monat daheim.
Naja, das ist ungefähr das Gleiche. Bisschen ein Ticken niedriger. Aber das kommt schon ungefähr hin, 1950. Also der Minimalwert ist 1950 und der Maxiwale war 4095.
Das einzige Problem ist, dass der Sensor sich ziemlich lahm verhält. Deswegen stöpseln wir das jetzt mal wieder um. Auf GPIO 27.
Das machen wir jetzt im laufenden Betrieb, in der Hoffnung es passiert nichts. Vielleicht Crash. Gut, deckt. Jetzt nur noch das Expo da, der. iDesormel, ja, viel, viel, viel, also das wäre viel besser und das wäre auch die sinnvolle Variante.
Also jetzt keinen Switch, entweder ein Relay oder ein Transistor. Also im Prinzip ist ja quasi ein Transistor so was wie ein Relay.
Also jetzt hauen mich wahrscheinlich die Elektriker. Von dem was es im Prinzip macht, dass du quasi schalten kannst, also dass du den anderen Stromkern schalten kannst, ohne dass du ihn selbst reinhängen musst, macht ja sowohl ein Transistor als auch ein Relay.
Oder nicht? Die Elektriker sind wieder hier am Start. Naja, ich sehe schon mein Fortschritt ist gerade wieder wahnsinnig highspeed, wie das am Stream immer so ist.
Also für mich ist ein Transistor wie ein Relay plus kleiner. Wenn ich mir die Funktionsweise überlegen muss, ist für mich ein Transistor ein Relay plus kleiner. Viel kleiner.
Nein, das wäre kein großer Akt, also du könntest ohne Probleme einen Transistor oder einen Relay anschließen an den GPIO und darüber den Sensor ein- und ausschalten.
Das wäre mit Sicherheit auch die schönerere Variante, als das Ding direkt an den GPIO zu hängen.
Ich wäre da übrigens allgemein relativ vorsichtig, je nachdem was ich für einen Board habe, die Sachen direkt an den GPIO-Pins zu hängen.
Bei diesen Development-Boards ist das kein Ding. Da kannst du auch aus Versehen mal hier dein USB-5-Vol-Pin auf 3,3-Vol-Dings-Logik-Pin hängen.
Das passiert nichts, das ist ordentlich gemacht. Wenn man allerdings die Boards nimmt, die ein bisschen mehr raw sind oder vielleicht sogar ein...
Man bastelt sich selbst was mit einem nackten ESP32, da würde ich aufpassen. Da würde ich nicht einfach 5Vol auf einen GPIO-Pin geben, weil dann ist das Ding im Arsch.
Und man muss mal auch mit der Batterie aufpassen. Das muss auch zum Board passen.
Für mich ist Grafikspeicher das gleiche, wie Amat-Speicher. Das ist ja im Prinzip auch das gleiche, nur schneller und für andere Sachen verwendet.
So, okay, Moment. Ich bin ultra langsam verliehlaufen mit den Fahnen.
Also, wir wissen jetzt, was unser Sensor ungefähr für Minimal- und Maximalwerte hat. Das ist schon mal ganz praktisch.
Ich nehme den Sensor jetzt noch mal aus dem Glas raus und dann soll er mal kurz abtropfen lassen.
Und jetzt mache ich mal die Hand rum und so an verschiedenen Bereichen. Wir gucken mal, was es so für Werte zwischendrin gibt.
Ach Quatsch, ich muss ja erst mal das Ein- und Ausschalten einbauen, weil sonst das Messen viel zu lang dauert.
Also, wir schalten GPIO 27. Übrigens die richtige Variante ist, dass man das so macht. Das sieht nämlich auch viel schöner aus.
Ich nehme GPIO 27 auf Low, dann warten wir mal, keine Ahnung, 200 Millisekunden. Dann messen wir und dann, machen wir das Delay hier unten weg.
Und dann setzen wir GPIO wieder auf High. Also sprich, wir schalten das Ding ein, messen und schalten es wieder aus.
Kann das Arduino C++ eigentlich landen oder was? Äh, ja, ja. Also, das ist nicht das nackte Arduino C++.
Das ist Platform.io, als Entwicklungsumgebung. Das ist eine Visual Studio Code Plugin, aber unter der Haube benutzt sie den gleichen Kram.
Mit sehr viel Custom Zeug drumherum, dass es ein bisschen einfacher macht. Du kannst in der Extension hier einfach einstellen, was du für einen C++ Standard haben willst.
Also, man kann Lambdas und Gedöns verwenden. Das funktioniert. Man kann hier, irgendwo hier in den Settings kann man einstellen, was man für einen C++ Standard verwenden will.
Das ist 2017 eingestellt. Also, zumal aber die Lambda Syntax für C++ nicht richtig hinkriegt. Das müssen wir dann bei Gelegenheit mal gucken.
Ähm, so. Also, wir schalten das Ding ein, messen, geben aus, schalten das Ding wieder aus. Okay, mal gucken.
Die einfachen Werte kannst du machen. Du kannst alles machen, theoretisch, was C++ 2017 kann. So.
Jetzt sollte die Werte deutlich schneller gemessen werden. Also, Achtung Leute, ich mach mal raus. Zack. Okay. Naja, nicht wirklich, oder?
So. Ich mach's mal wieder rein. Oh, habt ihr gesehen, das geht viel schneller. Wohingegen das vorher ewig rumgerödelt ist und langsam runter.
Jetzt, wenn ich das Ding ein- und ausschalte, passiert nichts. Also, geht's richtig schnell. Aus dem Wasserklass raus.
Zackwerte gehen hoch. Als Wasserklass rein. Zackwerte sind direkt wieder unten. So. Ähm, ich stell doch mal die Konsole ein bisschen größer, oder?
Wie macht man das? Terminal. Font. Font. Font. Editor Font Size. Terminal. Terminal Font Size. 16. 18. 20. So ist gut, oder?
20 ist, denke ich, eine ganz, ganz nice Größe. So. Aus dem Wasserklass raus. Ins Wasserklass rein. Und Wert passt.
Okay. Wir wissen schon mal, der Sensor passt ungefähr und wir wissen schon mal, dass die unsere Minimal- und Maximalwerte so ungefähr hinkommen.
Ach so, genau. Was wir noch einstellen müssen, ist, wie empfindlich unser Analog-Digital-Converter ist. Und zwar, das macht man mit ADC...
ADC, was ist das nicht? ADC-Config? Ach nee, ich muss den Header erst noch einbinden. Wo das drinnen ist. Wir sind ja hier in keiner Sprache, die einem irgendwie großartig hilft.
Ist denn das für eine ESP? ADC? Nee. ADC? Tja, wie könnte denn der Header heißen? Guck mal nach. Ich habe mir so ein Beispiel schon rauskopiert.
Driver. Driver. ADC heißt der. Okay. Weil. Man weiß es nicht genau. So. Und jetzt können wir unseren Analog-Digital-Converter konfigurieren. Warum? Wo ist das Problem?
ADC1-Config? Ist doch. Hat ein bisschen gebraucht, bis es geladen hat. So. Und da kann man jetzt einstellen, was das Ding...
Erstmal muss ich sagen, was wir für einen Channel verwenden wollen. Und das ist jetzt so die typische China-Nummerierung wieder. Überall anders verwenden man GPIO 27 und GPIO 34.
Vielleicht sollten wir hier einfach auch mal 34 reinschreiben. Hier verwendet man jetzt allerdings ADC1-Channel 6. Was unter der Haube GPIO 34 ist.
Das ist der gestellte GPIO 34. Der sagt nicht, dass er einfach GPIO 34 ist. Nein, er sagt, er ist ADC1-Channel 6. Weil China-Herstellung. Anders kann ich mir nicht erklären. Das ist der totale Missbrauch von Auto. Warum?
Auto ist, soweit ich weiß, ein bisschen wie VAR in C-Sharp. Du hast das weiterhin statisch typisiert. Allerdings musst du den Typ nicht angeben. Was viel besser ist und weniger nervig ist.
Weil ich meine, du weißt den Typ ja schon anhand vom Return-Wert der Funktion. Weißt du ja schon, was das für einen Wert ist. Deswegen musst du den nicht hervorschreiben.
Jetzt muss ich mal kurz abgucken, was da sonst noch rein muss. Jetzt kann man ihm sagen, wie empfindlich das Ganze sein soll. Das geht von 0 dB bis 11 dB. Wir machen jetzt mal 11.
Dann kann man noch die Auflösung sagen. Wir drehen jetzt mal alles hoch und gucken, wie sich die Werte verändern. Ich könnte mir vorstellen, dass wir die Empfindlichkeit sogar ein bisschen runter stellen wollen.
Weil, wenn man sich das hier anguckt, das ist ganz schön am Rauschen der Sensor. Wobei, ihr meint, das bewegt sich jetzt im Plus-Minus-Zwanzig. Das passt schon. Das kann man dann nachher eigentlich rausfiltern.
Schauen wir mal, was wir noch vom Sensor rausholen können. Jetzt kann man einstellen, wie die Auflösung vom Analog-Digital-Converter ist. Das Höchste ist 12 Bit.
Wenn wir das Ganze noch mal ausführen, gucken wir mal. Ich glaube, das sind auch die Default-Settings. Da dürfte sich eigentlich nichts dran ändern.
Also, choose my name, so ziemlich alles, selbst das, was von Microsoft selbst kommt, verwendet war. Fast überall, ausschließlich.
Es kann sein, dass das in dem Style-Guide drinsteht. Aber in dem Style-Guide steht ja auch, glaube ich, drin. Man soll in C-Sharp für private Variablen, äh, nicht für private.
Ja, doch, für private Members. Ne, für private, äh, wie heißt's? Klassenvariablen halt. Soll man auch keine Unter-Anna-Score verwenden, sondern Kleinschreiben und sowas. Also, die Microsoft Style-Guides sind nicht schlecht, sich dran zu halten, ein paar Sachen haben sich aber nicht durchgesetzt.
Ich weiß gar nicht, ob es im aktuellen Style-Guide noch so ist, dass man keine Unter-Anna-Score verwenden soll. War früher auf jeden Fall so. So, im Prinzip kommt das gleich aus.
So, jetzt stellen wir das Ding mal ein bisschen weniger empfindlich und gucken mal, was passiert. Was er dann macht. Er kompiliert schon wieder eine halbe Stunde, ja.
Äh, ändert sich eigentlich nicht viel, oder? Na doch, es rauscht schon ein bisschen weniger, habe ich das Gefühl. Oder? Finde nicht auf. Vorher hat er so geschwankt um 20 rum.
Ach nee, ist eigentlich kein großer Unterschied. Egal. Lassen wir so, wir wollen jetzt zum Sampler-Part kommen. Äh, habe ich irgendwas im Chat überlesen? Und wozu willst du jetzt den Stand deiner Wasserhöhe messen?
Willst du so eine Mütze mit zwei Bechern mit? Nee, nee, nee, nee. Also ich will nicht die Wasserhöhe messen. Man misst damit, wie die, äh, wie feuchter Boden ist. Das heißt, man weiß daran, wann man wieder Blumen gießen muss, zum Beispiel.
Und warum ich das Ganze machen will, okay, ich habe ja am Anfang erzählt, ich erzähl's im Laufe des Streams, warum ich das machen will, folgendermaßen.
Ich will das gar nicht für meinen Garten oder für meinen Hof oder für meine Terrasse. Sondern, ähm, wie sag ich das jetzt am besten, ohne dass jetzt alle wieder denken, das ist was ganz furchtbar Schlimmes.
Und auch nicht das Katzenstreue, nee. Und zwar, ähm, ich will das gar nicht bei mir ins Haus stellen. Ich will das 1,5 Kilometer weiter wegstellen und von dort hierher übertragen. Weil der Friedhof ist 1,5 Kilometer hier quasi aus der Stadt oder aus dem Ort raus.
Und auf dem Friedhof ist das Grab von Opa und Oma. Und im Sommer muss man da unregelmäßig oft hin. Und man weiß eigentlich nie genau, wann man hin will oder hin muss.
Deswegen habe ich mir gedacht, ich baue einfach eine kleine Box mit einem ESP32 drin. Nicht dieses fette Modul, sondern ein kleineres oder zumindest ein deutlich stromsparenderes als das NodeMCU. Genau, der IoT Graveyard. Du hast es erkannt, Cheat1995.
So, da kommt dann eine 1200 mAh Batterie dran. Das Ding ist zum größten Teil im Deep Sleep und das muss dann auch wirklich energieeffizient sein. Und wenn es dann festgestellt hat, dass der Wert größer ist oder kleiner ist, um einen gewissen Faktor abweicht, zudem, den das letzte Mal gemessen hat, dann wacht er auf und schickt mir das ganze heim.
Und jetzt fragt ihr euch doch sicherlich, wie will der Max 1,5 Kilometer Daten übertragen?
Flo96, das mache ich auch gleich noch. SIM-Karte, nein, keine SIM-Karte. Jetzt müsst ihr beraten. Wie habe ich vor, 1,5 Kilometer zu überbrücken? Und ich habe es auch schon ausprobiert, es funktioniert. Also es ist jetzt nicht einfach, weil ich mir das in den Kopf gesetzt habe, es funktioniert auch.
Glasfaserleitung 10, nein. Long Range Wi-Fi, nein. Loravan, fast. Richtig, weil es steht im Titel. Achja, das erste, was ich übrigens geguckt habe, ist, ob es auf dem Friedhof offenes WLAN gibt.
Leider nicht. Es gibt leider kein offenes WLAN auf dem Friedhof. Es gibt auf dem Friedhof lustigerweise gar kein WLAN. Ich wusste überhaupt nicht, dass Orte in Deutschland existieren, wo es kein WLAN gibt.
Nein, wir machen das Ganze mit Lora. Nicht mit Lora warten, sondern nur mit Lora. Das habe ich schon ausprobiert, funktioniert wunderbar. Ich habe hier einen Empfänger. Den kann ich euch mal zeigen, wenn ihr wollt.
Ich mache mal den Lora Empfänger kurz an. Ich logg mich mal drauf ein und dann zeige ich euch das Ding. Das ist Lora, das sehe ich gleich.
Ich muss mal kurz gucken. Ich habe hier so ein mini, mini 80x80 Display dran, damit ich sehe, wann er an ist. So, er ist an. Das ist nämlich auch ein... kommt Telnet hier. Heute kommen wirklich die absolut High-Tech-Programme her.
Er ist aber selbst mal Telnet verwendet, um nicht einfach einen Port zu testen, sondern wirklich sich irgendwo drauf einzuloggen. Das ist nämlich auch ein ESP32, den ich als Lora-Empfänger verwende. Ich glaube, das war die IP von dem Ding. Ha, genau. Der macht aktuell nichts. Der publisht auch keine Daten, auch wenn es da steht, weil er empfängt nichts.
Genau, und als Lora-Empfänger, und da kommen wir auch gleich zu dem Punkt, was Lora ist, habe ich das Ding hier ein... nicht T-Bone, T-Bone war das Mikrofon. T-Beam. Genau, das Ding habe ich dafür.
Das ist ein ESP32 mit einem Lora-Modul drauf, also mit WLAN drauf und einem Lora-Modul drauf. Und hier sieht man, hier ist eigentlich die Erklärung ganz gut. Und hinten drauf, das ist eigentlich das ganz coole, auch wenn ich es nicht brauche, einen Batteriehalter für eine 18... 56 Batterie. So eine dicke. Für so dicke, dicke Akkus, die aussehen wie Batterien.
Genau, und fast genau so sieht das Ding bei mir auch aus. Fast eins zu eins. Ich habe da auch so ein kleines Display dran, dass ich quasi das, was ich hier im Telnet sehe, auch auf dem Display sehe. Und genau, den verwende ich als Lora-Empfänger.
Lora ist ein... Was sagen mich selber dann über sich? Long Range...
Es ist im Prinzip ein Übertragungsstandard, so ein Layer, Layer 2, 1 Standard zum Übertragen von Signalen mit sehr niedriger Bandbreite, allerdings mit sehr großer Reichweite.
Wie viel kostet der Spaß? Ja, das ist auch... Bevor ich etwas weiter zum Thema Lora erzähle, das ist alles ziemlich günstig, was ich hier baue bei mir daheim.
Also ich versuche wirklich jetzt nicht die teuren Sachen zu verwenden, sondern möglichst günstige Sachen. Das bewegt sich im Rahmen von 20 Euro.
Also das Zeug ist alles nicht teuer. Und wenn man es gar irgendwie bei AliExpress oder so kauft, ist es noch günstiger. Also diese ganzen Controller sind wirklich günstig.
Guck mal hier, also... Wenn man es aus Englisch... Wahrscheinlich ist das der Banggood sind die Inder, AliExpress sind die Chinesen, Gearbest sind glaube ich auch die Chinesen.
Zumindest sind das so die drei großen Seiten, wo man so kauft. Dann muss man sich aussuchen, welche Frequenz man haben will. In Europa kann man 433 MHz oder 860 MHz nehmen.
In den USA sind es 915 MHz glaube ich. Kann man sich so ein Modul kaufen. Und man kann sich auch, wenn man selbst nichts zusammenbauen will als Client oder als Sender oder als Node, den man irgendwo betreibt,
kann man sich auch einfach zwei Stück dafür kaufen. Eine zum Senden, eine zum Empfangen. Also das ist nicht teuer. Wir reden hier so im Bereich von 20-25 Euro.
Und das ist auch noch günstiger, weil die haben immer irgendwelche Aktionen. Man kann es direkt aus England bestellen, das ist ganz praktisch.
Und genau. Aus UK 26 Euro 52 Cent. Lasst euch das mal auf der Zunge zergehen. 52 Cent der Versand. Und das aus China teilweise.
Oh ne, aus China kostet das ganze 1,16 Euro. Also wenn du von Deutschland nach Deutschland was verschickst mit DHL, ist das deutlich teurer als wenn die China Shops verschicken.
Das kostet fast nichts bei China Shops. Genau, kann man sich so ein Ding kaufen. Ist nicht so richtig geeignet als mobiler Node, weil eben relativ stromhungrig für Batteriebetrieb.
Auch wenn es einen Batteriehalter hinten dran hat. Ich würde mal sagen, selbst wenn du da einen ordentlichen Akku hinten reinstöpselst,
das läuft vielleicht, nachdem das Ding halt keinerlei gescheite Stromsparmaßnahmen drauf hat, wahrscheinlich so zwei Monate oder so, dann ist er aus.
Den Node, den ich jetzt zusammen bastle, der dürfte so nach, wenn ich das mal hochrechne, so irgendwie zwei Jahre laufen. Mit halt zum größten Teil Deep Sleep.
Genau, ist Laura von der Bundesnetzagentur in Deutschland schon abgesegnet. Die 868 Megahertz darf jeder verwenden. Es gibt ein paar Richtlinien dazu. Du darfst glaube ich maximal, so über den Daumen gepeilt,
eine Minute oder eine halbe Minute pro Stunde senden. Eine halbe Minute ist es glaube ich so über den Daumen gepeilt. Pro Stunde, aber das reicht.
Dazu kommt, Laura ist relativ stromsparend und hat eine relativ große Reichweite. Was bedeutet das? Dreimal dürft ihr zusammen raten. Was bedeutet es, wenn stromsparend und große Reichweite zusammenkommen für die Bandbreite, die man übertragen kann?
Also wenn ich ein Gerät habe, was relativ wenig Strom braucht und eine hohe Reichweite hat, wie hoch wird dann wohl? Genau, die Bitrate ist ziemlich niedrig.
Korrekt. Allerdings ist die Bitrate gar nicht so extrem niedrig. Sie ist nur im Vergleich zu WLAN verdammt niedrig. So, wenn man sich jetzt nämlich mal die Arduino, so eine der Laura Arduino Libraries anguckt und man geht hier mal auf Bandbreite,
dann sieht man Laura unterstützt von 250 Kilobit bis runter zu 7,8. Ich glaube Kilobits sind es. Ach nee, Moment. Das stimmt doch gar nicht mal, was ich erzähle.
Das ist, ehm, doch. Das ist die, im Signal, wie breit, also wie, wie viel, wie breit, wie, über wie viel Frequenzen das Signal geht zum Datenübertrag. Irgendwie so. Zumindest ist es wenig.
So genau kann ich es euch jetzt gar nicht sagen, aber es ist wirklich nicht genau. Es ist ziemlich wenig. Ich glaube man kann das ziemlich genauso als ungefähr Kilobits pro Sekunde.
Okay, gucken wir mal. Data-Rate. So genau habe ich mir das gar nicht angeguckt. Ich weiß nur, dass es für meinen Sensor reicht. Ach hier, guckt mal, hier steht es doch, hier steht es doch. Also man hat, ha ha, Kilobit.
Vergesst, was ich gesagt habe, Leute, von wegen Kilobit. Bytes. Bytes pro Sekunde. Bytes oder Bytes pro Sekunde? Ich würde jetzt mal auf Bytes pro Sekunde tippen.
Letztendlich ist es wenig. Also wenn ich als Bandbreite einstelle, also 125 Kilohertz ist anscheinend so der Standard, dann kann ich einstellen, diese SF, das ist bei Laura der Faktor, wie lang, wenn ich das richtig im Kopf habe, ist das, wie lang jedes einzelne Bit übertragen wird.
Also quasi wie lang der Sender sendet. Hast du wirklich? Nö, habe ich nicht. Ich weiß genau, wie wenig das überträgt. Also es ist im Vergleich zu WLAN, wo du Megabit überträgst, bis theoretisch fast schon Gigabit, weil das kein WLAN Ding wirklich unter realistischen Bedingungen auf die Reihe kriegt.
Also du hast hier ungefähr, also wenn du die größte Reichweite nimmst, also dann stellst du hier SF12 ein und Bandbreite sogar noch ein bisschen runter.
Also ich habe es jetzt probiert mit SF12 und 31 Kilohertz Bandbreite, dann dauert so ein Sendevorgang irgendwie, keine Ahnung, 5 Sekunden oder so für ein Byte.
Irgendwie so in einem Dreh überlegt, lass es sich mal auf deinen Zunge zergehen. Irgendwie über den Daumen gefallen war das glaube ich, für einen Byte 5 Sekunden oder so. Also in der heutigen Zeit ist das halt schon echt wenig.
Es kann jetzt sein, dass ich Mist erzähle und es sind 5 Byte oder so. Es ist auf jeden Fall verdammt wenig Bandbreite.
Und das Schöne ist allerdings, dass die Reichweite relativ hoch ist und ich habe es ausprobiert, 1,5 Kilometer und der Empfänger, nämlich dieses Ding hier, was ich euch gerade gezeigt habe, der lag bei mir auf dem Schrank, hier im Arbeitszimmer hinten auf dem Schrank, quasi so grob in die Richtung, wo der Friedhof ist.
Und den Sender hatte ich im Rucksack drin und bin dahin gelaufen. Man hat zwischendurch mal ein paar Übertragungsfehler gehabt, aber es hat funktioniert. 1,5 Kilometer, das ist echt ordentlich, da kann man sich nicht beschweren.
Ja, heiliger Bimber, man darf nicht vergessen, dass mit geringerer Bandbreite ganze Sonden durchs Weltall geflogen werden. Ja. So sieht es aus, ja. Genau, und das ist Lora.
Die Sachen sind relativ günstig, also wenn man jetzt nicht so ein Komplett-Ding haben will, ich meine, das ist ein ESP32 mit einem Lora-Modul drauf, mit einem SMA-Antennen-Connector mit Pins und einem Batteriehalter.
Also das ist quasi ein Development Board, Batteriehalter, Lora und das ist alles in einem. Man kann das ohne Probleme auch selbst basteln. Man kann sich nämlich einfach auf Amazon zum Beispiel oder generell einen SX-Things kaufen, das ist nämlich der Lora-Chip, der überall drauf ist.
Und der Chip an sich ist, das ist Schwachsinn, viel zu teuer. Der nackte Chip, der kostet irgendwie 9 Euro bei Banggood oder so. Ich würde mir allerdings welche mit Pin kaufen.
Also man kann sich für 30 Euro ein ziemlich energiesparendes Lora-Board zusammen basteln und als ESP32-Board für Batteriebetrieb empfehle ich das hier, den ESP32 Fire Beetle.
Sieht ein bisschen aus wie der NodeMCU, den ich gerade dran habe. Allerdings, man sieht schon, man muss die Pins selber löten. Das Schöne hier an dem Ding, an diesem Board ist, das hat einen Batterie-Connector direkt dran, so normal, die normalen LiPo Batteries, die es so gibt.
Du hast allerdings auch einen USB-Anschluss, um es einfach firmware zu flashen. Das Schöne daran ist, im Batteriebetrieb deaktiviert dieses Board jegliche Developer-Hilfen. Also sprich, das deaktiviert den Spannungswander für USB, deaktiviert USB, deaktiviert alles.
Dieses Board, also der Fire Beetle hat im Deep Sleep einen Verbrauch von, ich hab's gemessen mit meinem Multimeter, von 11, also 11 µA. Das ist wirklich sau-mäßig wenig.
Für den ESP32 Board, ein komplettes Board mit allem dran. So, wir kommen echt nicht vorwärts. Okay, also wir haben den Sensor, achso, was hab ich, ich hab im Chat bestimmt irgendwas überlesen.
Du kannst ja nicht die Solarzelle dran machen, doch, kannst du. Könnte man machen, man muss halt nur irgendwo hinlegen dann. Gibt's bestimmt auch als USB-Gedanahmen einen Raspberry dran. Nö, du kannst den Chip einfach direkt an die GPIOs von einem Raspberry dran machen, funktioniert auch.
Die fertigen Libraries auf GitHub, Job-List einfach, du kaufst ja einfach hier einen SX oder du kannst ja auch einen RF-Dings, das ist der gleiche Chip im Endeffekt.
Kannst du dir kaufen, genau den hab ich hier, kannst du dir kaufen. Das ist alles viel zu teuer. Ihr müsst mal wirklich bei den Chinesen gucken. Selbst auf Amazon ist es billiger.
Wir haben ja mittlerweile die Produktnamen, genau, hier irgendwie 18 Euro. Aber wie gesagt, wenn ihr es bei Banggood oder AliExpress kauft, kostet es die Hälfte.
Und da muss man sich einfach Pins dran löten und dann kann man das direkt an die GPIOs vom Raspberry stöpseln.
Die hat unten auch eine Beschriftung dran, wie das Ganze funktioniert. Also sprich, oben links kommt die Antenne dran, dann hat es vier Crown-Pins, davon muss man nur einen connecten. Von diesen DIO-Pins muss man auch nur einen connecten, das reicht, nämlich den Nuller. Dann stöpselt man es beim Raspberry auf die 3,3 Volt-Pins.
Und die anderen sind beim Raspberry genauso beschriftet und dann installiert man sich die Library von GitHub und dann kann man das Ding verwenden.
Es gibt leider wenig gute Tutorials und wenig gute Videos zu dem Thema. Die besten Videos zu dem Thema hat der guy with the swiss accent auf YouTube.
Der macht wirklich gute Videos, wenn man sich für Microcontroller und generell solche Elektronik-Bastelgeschichten interessiert.
Der hat auch jede Menge Videos zu LoRa gemacht, also wenn man sich da einen Überblick verschaffen will, sind das wirklich gute Videos.
Er zeigt auch, wie man sich künstlich... war ich auch immer, genug geschwätzt, wir machen jetzt weiter. Und mein fast, ja, man kann da auch eine kleine Solarzelle dran machen.
Allerdings ist Solarzellen an sich nicht so einfach, weil man muss sich ja überlegen, wie man das Ganze dann an seinen Controller kriegt. Und wenn man sich das hier anguckt, wenn man hier den... genau.
Das ist ja hier das Developer-Board, was ich gerade habe. Wie schließt du die Solarzelle an? So eine normale Solarzelle hat... nimmst du so eine normale 6V Solarzelle.
Die gehen ja so von 1,5V bis, glaub, 12V, so in der normalen Größe. Dann nimmst du dir irgendwie eine 6V Solarzelle. Und da fängt schon an, wo schließt denn das Ding dran an?
Die normalen Developer-Boards verkraften auch ein bisschen mehr. Du brauchst allerdings schon mal irgendwie was, was das wieder auf USB umwandelt, ja, dass du das dann in USB stöpseln kannst.
Das Board läuft interne mit 3,3V, allerdings förderst du es mit 5, was auch schon irgendwie übertrieben ist.
Also am besten ist, du holst dir hier so ein Board mit einem Batterie-Connector und holst dir den passenden Solar-Charging-Chip. Kostet auch nur 2€. Und da hängst du die Batterie dran und deinen Controller und der macht das für dich.
Ja, cheat 1195, genau. So macht man das. Du brauchst halt irgendeinen Solar-Charging-Chip.
Okay, wir basteln jetzt mal weiter. Das wollen wir mal zum eigentlichen Punkt kommen.
Okay, also wir haben unseren Sensor halbwegs kalibriert. Und wenn ich mir das hier so angucke, sehe ich auch, das stimmt nicht, weil ich gesagt habe, der Minimalwert ist ungefähr 1720.
Und der Maximalwert ist, mal abtropfen lassen. Ja, da sind jetzt noch ein paar Wasserperlen dran. Ja, der Maximalwert ist, wir lassen einfach mal, wir machen mal, komm, wir machen mal 3800 oder so.
Okay, das ist unser Sensorwert. Darf ich fragen, für was du das Ganze machst? Ja, zum Bodenfeuchtigkeit messen.
So, jetzt haben wir den ganzen Shit mal weg. Und jetzt wird es eklig. Jetzt kommen wir mal zum Assembler-Part. Also diesen ganzen Mist brauchen wir nicht.
Also, ich mache das hier nicht alles komplett aus dem Kopf. Ich habe im Vorfeld schon ein bisschen rumgebastelt. Allerdings funktioniert das Ganze nicht gescheit.
Und ich habe mir schon ungefähr angeschaut, wie es grob funktioniert. Weil, würde ich jetzt hier an diese Geschichte komplett blind dran gehen, könnte ich es vergessen.
Ganz zu klicken. Es ist echt nicht, nicht einfach. Allein schon rauszufinden, was für Hedder man einbinden muss, wie die ganzen Makros heißen.
So, also unser Ziel ist es jetzt. Achso, ich zeige euch jetzt vielleicht noch erstmal was, bevor wir anfangen. Unser Ziel ist es jetzt, dass wir unseren Controller in Deep Sleep schicken.
Also sprich, dass der keinen Strom mehr verbraucht. Keinen in Anführungsstrichen. Und dass wir trotzdem den Wert vom Boden-Sensor, Bodenfeuchtigkeits-Sensor abfragen können.
Und die Main-Cores. Das ist das Ziel. So, und jetzt, das ist natürlich das erste, was man sich überlegen muss. Okay, wie versetze ich denn meinen Mikro-Controller in den Deep Sleep?
Das ist relativ einfach. Das kriege ich mittlerweile, glaube ich, sogar aus dem Kopf hin.
Äh, Enter, Enter Sleep oder so. Deep, Deep Sleep. Ja, Deep Sleep Start. So wäre das Ganze jetzt natürlich relativ sinnfrei.
Ich würde nämlich der Controller aufwachen, in den Deep Sleep gehen und nie wieder aufwachen. Also ziemlich, ziemlich beknackt.
So, und nachdem wir das Ganze nicht wollen, müssen wir dem Ding auch erstmal sagen, hey, du sollst nicht einfach nur in den Deep Sleep gehen, sondern du sollst auch wieder aufwachen.
Und dazu gibt es einen, ähm, Deep Sleep, wie ist das? Wake Up? Ja. ESP Sleep Enable Timer Wake Up.
Und da muss man jetzt in Nanosekunden, oder? Sind das Nanosekunden? Mikrosekunden? Ich kann, also, mit Einhalten wird es dann langsam, aber sicher irgendwann auch echt kompliziert.
Ähm, Mikrosekunden, ne? Ja, genau. Ähm, also, wann der aufwachen soll. Das bedeutet, wir haben schon mal tausend, also tausend Mikro, eine Milli, oder?
Ach so, Scheiße. Ach so, es steht sogar Mikrosekunden, Mikrosekunden. Also, also tausend, so, also das ist jetzt dann quasi eine Milli Sekunde.
Denkt mal, denkt mal mit. Ähm, so, das ist eine Milli Sekunde und ich will alle 100 Milli Sekunden aufwachen, oder alle, alle, alle Sekunde aufwachen.
Also sowas hier? Sowas hier, oder? Gibt das Sinn? Probieren wir mal aus. Also, unser ESP macht jetzt nichts anderes, wie Watchdog Timer zu setzen, in Deep Sleep zu gehen und hoffentlich jede Sekunde aufzuwachen.
Ja, er wacht auf. Gut. Also, der gibt Geschwobbel aus, weil die, ähm, weil ich das mit der falschen Bitrate initialisier. Ich glaub, ich kann es mir immer aus dem Kopf nicht merken.
Was ist, was ist das? Was da? Ich glaub, das ist die, die, die Standard, die der, die NodeMCU hat. Nein. Ach nee, ha, fast, fast. So, das ist die Standard NodeMCU, ja.
Der Fire Beetle hat 9600. Das ist halt bordspezifisch, je nachdem, wie die Typen das programmiert haben. Oder auch nicht. Ach nee, Moment. Ich muss ja, muss ja mein Projekt noch setzen.
Ach, scheiß drauf. Wir bleiben jetzt mal auf 9600. Nee, Moment. Also, ich muss mein, ich muss mein Projekt, ich muss, hier, Monitor Speed oder wie, wie war das, ähm.
Ah, mal gleich. Monitor Speed. Ah, Monitor Unterstrich Speed. Okay. Bilden wir das Ganze und jetzt gucken wir uns das nochmal an.
Stopp. Starten. Genau. So, und jetzt sollte das Ding schlafen gehen und jede Sekunde aufwachen. Ja. Ah, funktioniert. Ah ja, übrigens, auf die Uhrzeit darf man nichts geben.
Die ist standardmäßig immer nicht gesetzt, weil woher auch? Woher soll die Uhrzeit wissen? Es gibt NTP Libraries. Ähm. Äh, Kiste HD, doch, gibt's.
MaxFPS.tv oder Wublords.tv, äh, fast. Ah, da gibt's die, das ist die Seite vom Sebaro, wo es die älteren, die älteren Streams gibt.
Sind glaub ich fast alle drinnen. So, genau, also das funktioniert. Das Ding, das wacht jetzt jede Sekunde auf und geht wieder schlafen.
Das ist natürlich jetzt für sich gesehen ziemlich beknackt. Das braucht eigentlich kein Mensch, ja. Deswegen müssen wir dem jetzt erstmal was Sinnvolles beibringen, was er machen kann.
Ähm, zumindest Deep Sleep. Deep Sleep ist schon mal ganz gut. Den anderen Krempel machen wir erstmal hier weg. Ich bin halt ganz sicher, ob wir das nicht wieder brauchen.
Also die letzte Amtshandlung, die das Ding machen soll, ist in Deep Sleep gehen. So, was man jetzt noch machen muss, ist, man muss ihm sagen, welche Quellen ihn aufwecken dürfen.
So, und da gibt's ein paar Sachen. Ähm, Wake Up. Genau, also es gibt ein paar Sachen, wie man ihn aufwecken kann.
Was, Tommy? Hörst du eigentlich Rammstein? Wenn ja, wie findest du das neue Album? Ich hab mir die zwei Sachen auf YouTube angehört. Ich war noch nie großartiger Rammstein-Fan.
Ähm, und ich fand die zwei Sachen auf YouTube jetzt auch nicht, sondern echt toll. Ihr wisst, ich bin Heavy Metal-Fan, allerdings Rammstein ist nichts für mich.
So, also, wie man das Ding aufwecken kann, gibt's verschiedene Varianten. Ähm, man kann zum Beispiel sagen, über einen Pin.
Das ist praktisch, wenn man beispielsweise einen Schalter hat. Wenn ich jetzt zum Beispiel am Hofdorn einen Schalter hab, und ich stöpsel den an den GPIO-Pin dran,
und dann kann ich ihm sagen, hey, geh in Deep Sleep, verbraucht er kaum Energie, allerdings möchte ich, dass du durch einen Interrupt von GPIO aufgeweckt werden kannst.
Gibt's in der Variante X0 bedeutet für einen GPIO, nur für einen. X1 sind mehrere GPIOs, da muss ich dann genau sagen was. Per Timer, das ist das, was wir jetzt machen, ne?
Timer setzen, per Touchpad, per serielle Schriftstelle oder per ULP. Und das ist das, was wir machen wollen. ULP ist der Ultra Low Power Co-Prozessor.
Und das bedeutet, wir müssen jetzt unterscheiden können, warum wir aufgewacht sind. Also sprich, wurden wir durch den Schalter aufgeweckt,
wurden wir einfach durch den Reset-Knopf aufgeweckt, oder wurden wir eben durch den Ultra Low Power Processor aufgeweckt.
Das heißt, ich muss mir jetzt erstmal hier auslesen, warum ich aufgeweckt wurde, oder warum mein Controller aufgeweckt wurde.
Und standardmäßig kann ich euch das ja mal zeigen, was das Ding ausgibt. Gut, das wird wahrscheinlich null ausgeben. Machen wir ein Delay rein.
Batterieball Leer Interrupt. Genau, das ist viel zu niedrig für Batteriebetrieb. Also Wake Up Timer im Batteriebetrieb Stunde Minimum.
Für die Hauptkerne. Der ULP kann öfters aufwachen. Ja, okay, Wake Up Course 4 ist glaube ich Timer.
So, und wir wollen jetzt abfragen, wer hat mich aufgeweckt? Hat mich der ULP aufgeweckt? Oder besser gesagt, hat mich nicht der ULP aufgeweckt?
Weil wenn mich nicht der ULP aufgeweckt hat, dann möchte ich nämlich mein ULP starten. Also von der Logik her ist es glaube ich relativ nachvollziehbar.
Also sprich, wenn ich die Firmware flasche und das Ding sich das erste Mal startet, soll es quasi den Ultra Low Power Processor initialisieren,
starten und danach das natürlich nicht wieder machen bei jedem Aufwecken. Oder ist irgendwie nachvollziehbar.
Also sprich, wenn ich erkenne, dass ich durch den ULP aufgeweckt wurde, dann will ich eben nicht den ULP neu initialisieren, weil er läuft da schon.
So und das heißt, wir machen jetzt hier mal eine neue Funktion, irgendwie Init, oder wie nennt man das Ding? Init ULP oder irgendwie sowas in der Richtung. Start Run ULP, Start ULP. Ah, Start ULP, okay. So, Alter, ich kann dir mal tippen, ey, was ist das da?
So, Start ULP. Wir wollen das Ding, wir wollen das Ding nur einmal starten, nämlich wenn wir nicht von ihm aufgeweckt wurden.
Weil wenn wir von ihm aufgeweckt wurden, dann wäre es ja bescheuert ihn wieder zu starten.
Also Cheat 105, ich denke mal 5 Jahre sind vielleicht ein bisschen unrealistisch, allerdings ich denke 2 Jahre kriegt man schon ganz gut hin. Es gibt einen ganz guten, einen ganz guten Calculator für Batterielebensdauer.
Zwar den hier. Also wenn wir jetzt zum Beispiel sagen, wir haben eine Batterie von 1200 mAh. Das ist so nen normales Ding. Ja, das sind dann solche, sowas hier zum Beispiel.
Es ist auch, wie gesagt, das ist das Schöne daran, es ist alles nicht wahnsinnig teuer. So, du brauchst dafür nen Calculator, ja. Ich bin halt nicht der krass Elektri-Korz, der das kann.
So, und jetzt kann man zum Beispiel sagen, ok, die Batterie schaltet sich aus, wenn sie nur 20% hat, sagen wir mal 15. Ich brauche ungefähr 150 mAh, wenn ich laufe.
Das ist das Maximum. 150 mAh brauchst du ungefähr, wenn du WLAN-Daten überträgst. Also das ist das Maximum.
Dann kannst du sagen, wie lang das Ganze denn läuft. Sagen wir mal 2 Sekunden. Das kommt denke ich mal ganz gut hin.
Das Ding muss aufwachen und die Werte übertragen und wieder schlafen gehen. Das ist nicht so, nicht so der Wahnsinn.
Dann kann man sagen, wie lange das Ding schläft. Also sagen wir mal ne Stunde. Dann wacht es wieder auf, für 2 Sekunden was aus und schläft wieder.
Und im Deep Sleep brauchen wir 11 mAh. Das heißt, das Ganze läuft, so wie es konfiguriert ist, würde das Ganze ungefähr 450 Tage laufen.
Das ist schon mal recht ordentlich. Man kann das und jetzt kommen wir zu dem Punkt, warum ich das mit dem Ultra Low Power Prozessor mache.
Die Sleep Time ist in Wirklichkeit viel, viel höher. Weil eigentlich ja nur der Ultra Low Power Prozessor mal kurz aufwacht,
checkt, wie ist die Bodenfeuchtigkeit und sich dann wieder schlafen legt. Das heißt, es wird nicht jede Stunde einmal das hier verbrauchen,
sondern das wird wahrscheinlich, keine Ahnung, 2 Mal am Tag 2 Sekunden das hier verbrauchen. Also sprich, das ist eigentlich viel, viel effizienter.
Und man sieht schon, wenn man das hier hoch stellt, muss du nachher Assembly programmieren. AVR Assembly, ne, was auch immer AVR in dem Fall ist.
Ich mach das über C-Macros erstmal, weil sonst müssten wir komische Dinge machen. Und brauchen wir einen extra Compiler Step und extra Tools zum installieren und sonst was.
Ich versuche jetzt erstmal das mit den eingebauten C-Macros, die das für mich generieren. So.
Also sagen wir mal schon, guck mal, schon alle 2 Stunden läuft das ganze schon viel, viel länger. So und alle 4 Stunden, sagen wir mal, ungefähr alle 4 Stunden ist eine realistische Zeit,
wo das Ding mal aufwacht und 2 Sekunden was überträgt. Okay, das ist jetzt natürlich übertrieben. Aber sag mal mal so, 1, 2 Jahre sind da schon ganz, ähm,
äh, welches Assembly? Ja, das Standard, ULP, frag mich nicht Assembly. Keine Ahnung, was für eine Sprache das ist.
Das hier. Keine Ahnung, was das für ein Dialekt ist. Wahrscheinlich der eigene Chinesen Dialekt. Weil ich, wie gesagt, das Instruction Set hat 8 Befehle.
Ungefähr. Das ist alles, der kann das nicht. Okay. 3,3 bis 5% pro Monat, das erscheint mir jetzt allerdings ganz schön viel.
Selbstentladung. Also ich, also ich hätte jetzt eher so mit einem Prozent ungefähr 1-2% gerechnet. Na gut, wie gesagt, das hier ist natürlich jetzt auch die extreme Zahl.
Deswegen sag mal 1-2 Jahre ist okay. 1-2 Jahre reicht ja aber auch. Da stöpft sich einfach eine neue Batterie an und gut ist.
Ich sehe ja, wie lang es hält. Denn ja, wird es auf jeden Fall locker halten. Ähm, es ist auch davon auszugehen, dass ich die Batterie nicht bis zum allerletzten Rest verwenden kann.
Weil der ESP32 braucht, ich glaube, mindestens als Input, als Spannung braucht es, glaube ich, mindestens 2,5 oder 2,7 Volt.
Das heißt, achso Flow 690, das mach ich. Also die Spannung wird ausgelesen über den anderen AWC und wird mit übertragen, dass ich weiß, wann ungefähr die Batterie leer geht.
Genau. Ähm, gut, also wir initialisieren unseren realen Output, wir gucken, wie wir aufgeweckt wurden, gehen wieder in Deep Sleep, wachen alle. Wir wachen gar nicht mehr auf. Warum sollen wir aufwachen?
Der Ultra Low Power Processor soll uns hier aufwecken. Das heißt, wir gehen einmal initial an und dann starten wir unseren Ultra Low Power Processor. Und der weckt uns dann auf, wenn der Sensor einen gewissen Wert hat.
So, und jetzt muss ich, jetzt muss ich spicken, weil den Teil hab ich im Vorfeld mir schonmal angeguckt und was zusammengebastelt. Weil das würde ich jetzt alles nicht, nicht, nicht aus dem Kopf hinkriegen. Also was, was wir jetzt schonmal machen müssen, ist erstmal wieder unseren analog digital Konverter initialisieren, richtig, wie wir es haben wollen.
Ähm, by the way, das sind die Default Werte, also müssten wir an der Stelle jetzt eigentlich nicht. So, und jetzt, jetzt, jetzt kommen wir gleich zum, zum Assembler-Part. Dann müssen wir noch sagen, dass der Ultra Low Power Processor überhaupt auf den ADC zugreifen darf.
No Happy Meal for you, exakt. IOT Graveyard. Deswegen ist es auch wichtig, dass das Ganze, ähm, möglichst, möglichst kompakt wird. Und aktuell hab ich hier so ein ESP, hab ich so ein Modul, plus hier, das was ich euch gezeigt hab, das LoRa Modul. Und den Sensor, also das ist wirklich ziemlich, ziemlich kompakt. Das passt in so eine kleine, kleine Box.
So, ich bin wieder da. Ähm, das passt in so eine kleine Box. Und deswegen will ich es auch nicht mit Solarzelle machen. Es war so die ursprüngliche Idee, dass ich noch zusätzlich für die Batterie eine Solarzelle drauflege.
Dann müsste ich, könnte ich mir nämlich diesen ganzen energiesparenden Kram sparen. Ähm, allerdings sieht eine Solarzelle, und selbst wenn es nur so eine kleine 15x15cm ist, sieht es halt auf dem Krab schon ganz schön bescheuert aus.
Warum die Tastatur auf Englisch ist, ist sie nicht. Das ist Debated. Tastatur ist nicht auf Englisch.
So, ich muss mich mal kurz auslassen. Okay, weiter geht's.
Und die Box 3D Druckert er. Äh, ne, die Box hab ich mir gekauft. Das ist eine IP65-Box von Amazon. Äh, Wasserdicht, 3D Druck, so sehr trau ich meinem 3D Drucker noch nicht. Hab ich euch eigentlich schon das, das Alien-Entführungs-3D-Drucker-Bild gezeigt?
Ähm, Iris von UFO hab ich ja noch geschrieben. Sieht echt so aus.
Okay, ich zeig euch das. Ich hab nicht so viel gepostet. Da. Das da. Das sieht doch echt aus wie Alien-Entführung, oder?
Because Aliens. Ähm, falls man das hier nicht richtig erkennt, das ist der Druckkopf von meinem 3D Drucker. Und der druckt auch keine Kloschüssel, sondern ein Rohr. So ein Teil von einem Rohr.
Ähm, und da ist ein LED-Ring drum herum. Also sprich, hier vorne hängt ne Kamera dran. Am Druckbett. Eine Raspberry-Kamera.
Und hier um den Druckkopf ist einfach so ne LED, LED-Ring. Der LED-Ring selbst ist an, ähm, dort angeschlossen, wo auch der Lüfter angeschlossen ist. Also sprich, geht an, wenn der Drucker aufgeheizt ist und geht dann wieder aus.
Äh, wie viel hat der Drucker gekostet? Das ist eine der günstigeren Modelle gewesen. Das ist ne...
Oder mit oder ohne S? Ne, ne, das ist Blödsinn. Das ist Blödsinn, das ist viel günstiger.
Also ich bilde mir ein, ich hab 250... Ja, so, hier. So in dem, in dem... Äh...
Also was auch immer, also die Preise sind ein bisschen merkwürdig gerade. Also ich bilde mir ein, ich hab irgendwas, glaub, um 250 oder so bezahlt bei Amazon dafür.
Ja, die Dinger sind mittlerweile relativ günstig. Genau, und wie gesagt, er druckt keine Kloschüssel, sondern ein Rohr. Und das ist halt echt, echt nice, dass man dann quasi zugucken kann, auch im Dunklen.
Da dran ist ne, äh, ne Raspberry mit Kamera. Ich hab ne Halterung ausgedruckt, wo man quasi die Raspberry-Kam direkt vorne ans Druckbett machen kann.
Das heißt, das fährt immer mit. Und auf dem, auf dem Pi ist dann Octoprint drauf. Das heißt, ich kann auch immer nachgucken und die ganzen Sketches hochladen. Ne, wie heißt es bei 3D-Drucker? Sketches ist es bei Arduino. Was? Ähm...
Wie heißen, wie heißen die Dinger bei 3D, die gesleißten Dateien? Also im Prinzip kann ich halt die Models, sag ich mal, hochladen zum 3D-Drucker direkt übers Web-Interfacer. Das ist echt sehr praktisch.
Ja, Chico will nicht, dass man auf dem Kühlschrank zu nahe kommt. Ja, ist auch, ist ne Sie, aber der Ex-Besitzer, Besitzerin hat sie Chico genannt, was irgendwie überhaupt nicht passt.
Ja, Chica hätte ich verstanden, aber Chico, Chico für ne Katten, was auch immer. Was auch immer man sich die Leute dabei denken, ist auch wurscht.
Okay, komm mal zum Assempler-Part. Wir sind ja jetzt schon irgendwie gefühlt. Jetzt muss man selbst mal ne Uptime gucken. Uptime ist... Hab ich eigentlich den Chat eingeplendet, Leute? Sieht man den Chat?
Ja, der Chat ist eingeplendet. Also, im Prinzip eine Stunde 40 und nichts großartig gemacht.
Nice, dass du mal wieder streamst. Ja, ich sollte eigentlich viel öfter streamen. Darf ich fragen, worum es hier geht? Bist du noch da, Erhano?
1907, da kann ich nämlich nochmal kurz anreißen. Ähm, okay. Also, nachdem sich hier mein Micro-Controller die ganze Zeit rebootet und neu startet, machen wir mal was.
Ist das nicht NodeMCU? Das ist eine ESP32 NodeMCU. Du musst die allerdings nicht in Lua programmieren. Du kannst die ganz normal mit dem Standard Arduino Zeug programmieren.
Was viel angenehmer ist. Einfach wurscht Studio Code, Plattform I.O. oder Alternative, wenn man es ein bisschen roher haben will, das Arduino Plugin installieren und gut ist.
Man kann, wenn man ganz hart drauf ist, das ganze auch mit dem offiziellen ESP-Framework programmieren. Das ist dann allerdings nicht Arduino-Framework drunter, kein C++. Das ist Hardcore-C für alle C-Liebhaber.
Wollte das nicht neu flashen? Ähm, du flashst das Ding bei jedem Programm neu. Achso, den Bootloader. Nee, musst du den Bootloader nicht neu flashen?
Einfach Arduino-Zack draufflaschen, gut ist. Also muss ich nichts neu flashen. So, okay, machen wir weiter.
Als nächstes, noch ganz kurz bevor wir zum Assembler-Part kommen ist, wir müssten dem Ding jetzt erstmal sagen, da habe ich mir die Befehle dafür schon rausgesucht.
Wir müssen dem Ding erstmal sagen, dass er starten soll. So, und dazu müssen wir die passenden Header einbinden.
Habe ich alle schon rausgesucht, sonst wird es nämlich viel zu lange dauern. So, das brauchen wir nicht.
Was ist eigentlich der Unterschied zwischen Spitze-Klammern und Anführungszeichen? Wahrscheinlich ist Anführungszeichen C-Style und C++-Style und Klammern ist C-Style oder sowas, oder? Wie ist das?
Habe ich jetzt irgendwas doppelt drin? Es sieht nicht so aus. Doch, Trivers-ADC habe ich doppelt drin.
Ah, okay. Ah, verstehe, verstehe. Er sucht woanders seine Header-Dateien, okay.
Ihr wisst ja, so oft bin ich jetzt hier im C++-Land auch nicht unterwegs.
Gut, und jetzt muss ich ihm sagen, was er für ein Programm starten soll. Und, also wie gesagt, auf dem Low-Power-Coprocessor, was er für ein Programm starten soll. Und da wird es jetzt schon eine ganze Ecke mehr Low-Level.
Als erstes muss man mal einen Array definieren, in dem die Assembler-Instruktionen reinkommen, die der Prozessor später ausführt. Das lassen wir jetzt erstmal leer. Wir starten den einfach nur.
Und dann schreiben wir, doch wir schreiben Wake. Wir schreiben Wake, abschreiben wir rein. Wir lassen ihn einfach aufwecken. Mehr noch nicht. So, Datentyp muss irgendwie sein. Was hier? ULP, INSNT. Alter, was ist denn Name, ey? Das ist der Wahnsinn.
So, und dann hier irgendwie Code. Das habe ich vorher schon mal ausprobiert, dass ich weiß, dass das funktioniert. So, und jetzt einmal kompilieren.
Was habe ich jetzt hier verkehrt gemacht? Ist nicht initialisiert, warum nicht? Habe ich irgendwas vergessen? Ah, klar, ich habe ein Header-File vergessen.
Wir stehen da. Funktioniert das nämlich auch? Okay. So, die einzige Instruktion, die wir da jetzt reinschreiben, ist Wake. Danach kommt unser ganzer Assembler-Code hier rein. Wir lassen ihn jetzt einfach nur aufwecken, die Haupt-CPU.
Steht dem Co-Prozessor überhaupt die volle 12-bit-Auflösung zur Verfügung? Ja. Das ist der gleiche Konverter. Das ist exakt. Ist überhaupt kein Unterschied. Was eben nicht komplett zur Verfügung steht, ist der Speicher.
Sondern nur 8 kilobit. Kilobyte. Kilobit? Weiß nicht. Wenig auf jeden Fall. Ich glaube 8 kilobyte. Ich glaube 8 kilobyte Speicher. Und diese 8 kilobyte Speicher teilen sich Programmcode und Werte, die man speichern muss.
Das Schöne ist, der Speicher, dieser 8 kilobyte Speicher-Bereich, die sind, solange man den Controller nicht vom Strom trennt oder von der Batterie trennt, sind die per Systemt. Also sprich, die bleiben auch zwischen Deep Sleep erhalten.
Der Stream bleibt online, ja. Klar. Und wenn er auf Twitch nicht mehr da ist, ist er immer noch auf der Archiv-Seite vom Sebaro. Okay. Als nächstes muss man, das ist jetzt eine Sache, die ich aus der offiziellen Anleitung habe, also es ist jetzt nicht so, dass ich die hier irgendwo kit hab, copy pasted hab. Hab ich auch, ja. Aber das ist aus der offiziellen Anleitung so, wie man es macht.
Und zwar kann man ihm hier jetzt sagen, dass er ULP run, also sprich, dass die CPU starten soll. Das funktioniert so noch nicht. Dann muss ich ihm sagen, dass er eine Wake-Up-Period hat.
Und zwar eine Wake-Up-Period von, was sind die Parameter, was auch immer, Index, da muss Null rein. Und dann alle, jede Sekunde, jede Sekunde soll er aufwachen.
Und wohlgemerkt, jetzt reden wir nicht davon, dass der gesamte Controller jede Sekunde aufwacht, sondern nur der Ultra Low Power Prozessor wacht jede Sekunde auf. Und der Ultra Low Power Prozessor ist wirklich Ultra Low Power.
Ich weiß gar nicht, ob das, ich müsste das mal mit dem Multimeter nachmessen, aber ich hab gelesen, er braucht irgendwas um 2, 3 bis maximal 5 oder 4 mA im Vergleich zu 50 bis 150 der komplette Controller, je nachdem, was man macht.
Okay, also das Ding soll aufwachen, jede Sekunde. Jetzt muss man eben noch, dass ich copypaste mir das jetzt einfach mal, weil das ist nämlich das, was ich mir aus der offiziellen Anleitung auch schon copypastet hab.
Man braucht eine Adresse, Einstieg, nennen wir das auch mal Program, man braucht eine Einstiegsadresse in diesem, in diesem 8 Kilobyte Speicher, die für diesen Ultra Low Power Prozessor gedacht sind und Einstieg ins Programm ist logischerweise, oder meistens bei Adresse Null, wäre ja auch irgendwie ziemlich bescheuert.
Man könnte ein paar Variablen oder so vorher speichern. Hessen meldet sich zurück, ja, so sieht's aus. So, und jetzt kommt die eigentliche Geschichte, mit der man die, das Assemblerprogramm von hier oben, also das Assemblerprogramm wird aus den, ein paar Makros da erzeugt, mit dem man das lädt, und zwar damit.
Man sagt, ähm, lade mal an Adresse Null das Programm, also die Assemblerbefehle, das ist, wenn man es so will, ist das so, wahrscheinlich so eine, so eine, so eine mini, mini, mini, ähm, Compiler noch mal im Hintergrund, der dann läuft, wenn ich das eigentliche Kompilieren anwerfe, der quasi hier aus meinen 10 Makros dann das eigentliche ULP Assemblerprogramm macht.
Aber im Prinzip, Wake ist, also wenn man sich die Instruktions-Set anguckt, da ist Wake drinne. Also man benutzt hier wirklich die Assemblerinstruktion, die man auch in einem eigenen Assembler-File schreiben würde.
Bloß, dass sie hier halt schön in 10 Makros gerappt sind. Äh, Flixcoder, was ich dir empfehlen kann, ist, also als Einstieg ist der NodeMCU auf jeden Fall gut, der ist, der ist relativ günstig, ähm, vor allem der ESP 2866, NodeMCU ist wirklich günstig.
Also übrigens, ne, ich verwende hier grad zwar ein ESP32, aber, ähm, wer einfach nur ein bisschen rumspielen will, da kann sich natürlich auch hier bei Amazon einen noch günstigeren ESP, äh, 2866 bestellen.
Der hat ein bisschen weniger Pins, ein bisschen weniger ADCs, von allem ein bisschen weniger. Allerdings ist das zum Rumspielen eine super, super billige Lösung, ja.
Und was ich auch noch empfehlen kann, ist als Modul, wenn man es ein bisschen, ein bisschen kleiner haben will, ist der D1 Mini, und der ist wirklich klein.
Der ist, der ist nur ein Drittel so groß wie der NodeMCU, hat aber alle wichtigen Pins und einen Analog-Digital-Converter auch drauf.
Gratis E-Book, das schreiben, das schreiben die immer dabei, und Gratis E-Book. Das ist, das ist, das ist, ich, ich finde, die haben ein bisschen die Chance vertan, indem sie sich ADS Delivery genannt, genannt hätten.
Die hätten sich doch auch ohne Probleme EATS Delivery nennen können, oder? Easy Clap Delivery, das wäre noch viel besser, anstatt ADS.
Versteht wahrscheinlich außerhalb von Twitch keiner, aber ich fände es besser. EATS Delivery, als bisher auch immer.
Genau, hier 8 Kilo, 8 Kilobyte Speicher hat man, steht hier übrigens noch mal da.
So, und jetzt können wir ja eigentlich mal probieren, ob das Ganze funktioniert.
Also von der Idee her, mal gucken, ob das Scheiß kompiliert. Macht's. Also von der Idee her sollte alle, wir machen mal alle 10 Sekunden, sollte mein Controller alle 10 Sekunden vom Ultralow-Power-Prozessor geweckt werden.
Machen wir mal jede Sekunde und oder alle 3 Sekunden aufwachen und wieder einschlafen.
Da passiert jetzt zwar nicht allzu viel, allerdings, wenn das schon mal funktioniert, dann können wir weitermachen.
Das NodeMCU-Developer-Bord ist so groß wie mein Daumen. Ach so, ziemlich breiten Daumen. Er wacht nicht auf. Oder? Ach so, ha.
Moment. Okay, jetzt muss ich mal ein bisschen Debug-Ausgaben machen und natürlich Debug-Ausgabe, so ganz klassisch wie man das macht, per...
VS Code ist viel besser, VS Code ist richtig angenehm. Die Arduino IDE ist shit.
Ah, ich hab das Wichtigste vergessen. Ich hab's vorher noch groß erzählt. Man muss ihm natürlich sagen können, ULP-Wake-Up, man muss ihm natürlich noch sagen können, dass der ULP ihn überhaupt aufwecken darf.
Deswegen funktioniert das auch gar nicht. Space-Leap-Enable-ULP-Wake-Up. Die Dinger sind alle relativ sprechend benannt. Und jetzt wird's wahrscheinlich auch funktionieren.
Irgendwie funktioniert das nicht, oder?
Ah, jetzt funktioniert's. Was auch immer gewesen ist. Keine Ahnung, aber jetzt funktioniert's. Also man sieht, dass alle drei Sekunden wird der Controller jetzt aufgeweckt.
Oh, was sehen meine Augen, ein wildes Max am CM-Battle-Programm. Ja, so sieht's aus. Oh, und Assembler. Ja, ne? Vollen Kiosk. Es funktioniert. Alle drei Sekunden wird mein Controller aufgeweckt. Vom Ultra-Low-Power-Prozessor.
Sehr schön. Und danach geht er wieder schlafen. Ich mach mal hier Delay. Ich glaube, ich hab nix gesehen, weil das Delay nach dem Initialisieren von der seriellen Verbindung nicht da war.
Das heißt, sprich, er ist aufgewacht, hat aber nix rausgeschrieben. Probieren wir das Ganze noch mal aus, jetzt ob's funktioniert. Er hat immer noch nicht subben. Ne. Ich darf jetzt auch nicht mal gesubbt werden, weil ich wieder meine Partnergeschichte verspielt hab, indem ich nicht auf genug gestrebt hab.
Okay, es funktioniert. Es wacht auf alle drei Sekunden. Das heißt, so unsere Standard, der Ablauf an sich funktioniert. Das Ding wird geflasht, beziehungsweise wird einmal eingeschaltet oder resettet mit dem Reset-Knopf.
Er startet den ULP und geht und schläft. Der ULP, der Low-Power-Prozessor, wacht alle drei Sekunden auf und startet die zwei Haupt-CPUs. Also wenn ich da als Multimeter dranhalten würde, würde ich wahrscheinlich immer noch relativ viel messen, weil es halt über USB angeschlossen ist.
Deswegen, die Node-MCUs sind nicht unbedingt für Batteriebetrieb gedacht. Aber wie gesagt, da kommt ja, wenn es fertig ist, eh ein anderes Board dran, was halt viel weniger verbraucht.
Also jetzt dürfte ich wahrscheinlich im Deep Sleep kaum was messen. Wahrscheinlich für die kurze Zeit, da macht er nix anderes außer einen Wake ausführen. Wahrscheinlich drei Sekunden lang elf Microampere. Also wirklich sehr wenig.
Okay und jetzt können wir anfangen unser Assembler-Programm zu programmieren. Kann man der Sache so halbwegs folgen? Weil es fällt mir selbst schwer, irgendwie den Überblick zu behalten.
Aber zumindest was wir machen ist jetzt ja bis jetzt noch relativ simpel. Angehen, Low-Power-Prozessor starten, Sleep an. Low-Power-Prozessor wacht auf, weckt Main-Core, Main-Core stellt fest, er wurde vom Ultra-Low-Power-Prozessor weg, geht wieder schlafen.
Drei Sekunden später, wird wieder aufgeweckt, geht wieder schlafen. Drei Sekunden später, wird wieder aufgeweckt, geht wieder schlafen. Also passiert nicht allzu viel.
Ne, Affiliate ist doof. Wahrscheinlich kriegste keinen ordentlichen Share und du kriegst so wenig Emotes. Also wenn schon, wenn schon. Wenn schon, denn schon, denn dann richtig gepartnert. Vor allem einmal Partner, immer Partner. Der Assembler-Clickbait, da ist nichts Clickbait. Hier, da. Und jetzt gehts nämlich los. Jetzt wirds Assemblermäßig.
Also, von der Idee her, was ich jetzt machen möchte ist, quasi hier drinnen, also in dem Assembler-Programm, das mein Low-Power-Prozessor ausführt, möchte ich den hier ADC1 auslesen.
Den Analog-Digital-Converter 1 will ich auslesen. Und wir machen das erstmal ganz einfach. Ich lese das aus, schreibe es in Speicher, wecke den Haupt-Controller auf und gebe aus, was ich ausgelesen hab.
Nein, das mit Partnerschaft verspielt, mein ich nicht so. Ich war doch noch nie Partner. Partnerschaft verspielt, mein ich, du darfst dich nur als Partner bewerben, wenn du ein gewisses Kontingent gestreamt hast.
Ich könnte mich auch so Partner bewerben, weil ich könnte immer noch sagen, ich hab schon einen Follower auf Twitter und YouTube. Das würde wahrscheinlich auch funktionieren, aber ich sollte schon so in dem Modus sein, dass ich auch halbwegs oft streame. Alles andere wäre irgendwie blödsinnig.
Und wenn du einmal Partner bist, kannst du die Partnerschaft eigentlich nicht mehr verlieren, es sei denn, du, was weiß ich, machst komische Dinge, was Twitch halt für dich passend hält für die Plattform.
So, für was brauchst du ein Wassersensor? Kios, das können die Leute wahrscheinlich wunderbar erklären, weil das hab ich schon zehnmal oder so mittlerweile erzählt. Für Bodenfeuchtigkeit auslesen, kurz gesagt.
Okay, also, jetzt müssen wir als erstes, okay, wir brauchen das Instruktionsset von voller CPU. Und die CPU kann nicht allzu viel.
Nur, die kann addieren, subtrahieren, and or, left-shift, right-shift, pushen, also Dings, Werte von einem Register ins andere schieben, Werte aus dem Register ins Speicher schreiben, aus dem Speicher Werte ins Register schreiben,
zu einer absoluten Adresse springen, mit Offset-Jump und irgendwelche Condition-Jumps, eine Schleife machen, das ist ja auch schonmal was, was schon, nicht jedes Ding kann, Schleife, sich beenden, den Hauptprozessor aufwachen,
ähm, nichts tun, ne, gewisse Taktanzahl, Temperatursensor auslesen, WTF, wusste ich gar nicht, dass das Ding einen hat, probieren wir dann auch gleich mal, und das ist das, was wir machen wollen, ADC abfragen, das wollen wir machen,
dann kann es noch iSquare-C-Buzz-Geschichten auslesen und irgendwelche Register schreiben, also man sieht, der kann nicht wirklich viel, also es hält sich wirklich in Grenzen.
Ach, stimmt, der Bot ist kaputt, der Nightbot ist kaputt, Moment, Moment, ich mach den Nightbot, ich schalte den Nightbot wieder ein, Moment, wir testen mal, ob der Nightbot wieder geht, ja, der Nightbot geht wieder, der ist rausgegangen aus dem Chat, weil ich so lange nicht gestrebt hab.
Mach die coole Variante, Assembly, dein Assembly-Programm, ja, was, weil ich alles machen kann, ähm, okay, also, wir brauchen das Instructionset.
Das erste, was wir jetzt machen wollen, ist, mal eine Variante initialisieren, und zwar, das hab ich mir auch schon rausgepastet, wie das funktioniert, wie gesagt, wir haben hier acht Kilobyte, ähm, so, halb RAM, also RAM, der Deep Sleeps überlebt, leider halt nur acht Kilobyte, und, ähm, den kann man ansprechen hiermit.
Damit, das ist ein Byte Array quasi, ähm, oder besser gesagt, ein In 32 Array, was übrigens auch ganz lustig ist, der, also der Ultra Low Power Prozessor, der hat, macht alles in 32 Bit, also sprich, die Befehle sind 32 Bit, und, und, die Adressen sind 32 Bit, und, aber, die Werte selbst sind 16 Bit.
Er speichert sie allerdings in 32 Bit, das heißt, man muss immer die oberen 16 Bit wegwerfen, damit man die unteren 16 Bit auslesen kann, ganz wir, das, China-Kram, aber sie werden schon irgendeinen Grund dafür haben.
Verdient man als Informatiker wirklich so vieles komplett, darauf anerstens, was für ein Informatiker man ist, äh, und viel mehr, was man macht und wo man ist.
So, ähm, und dieses RTC, das ist, das steht wahrscheinlich für Realtime, äh, Clock, aber was auch immer das mit Clock zu tun hat, äh, also Realtime Memory, und das ist halt ein Array von eins bis, äh, von null bis 8.096 oder so.
Und, wobei, die sind 32 Bit, das sind so, bis 2048, was auch immer, ist egal, ähm, wir nehmen jetzt einfach mal Speicherplatz 34, weil, und initialisieren das mal auf null.
Und jetzt wird's interessant, jetzt müssen wir laden aus diesem Memory in Assembler. So, laden tun wir mit LD, also sprich, ILD.
So, jetzt müssen wir das Register angeben, also übrigens Register hat das Ding gerade mal vier Stück.
Wo verdient man denn am meisten? Also, ich glaub, aktuell am meisten verdient man entweder als Anwendungsentwickler in einer Sprache, die sonst keiner mehr kann, sowas wie Kobol, wenn man da noch Glück hat, oder was auch sehr beliebt ist im Security-Umfeld, wenn man da, wenn man da was kann.
Oder eben, weil's gerade Hype ist, Cloud und Kubernetes-Gedöns ist auch sehr angesagt aktuell. Aber man kann in allem eigentlich, wenn es halt was ist, was nicht jeder kann, obwohl's ein bisschen schwierig ist, Leute zu finden, kann man eigentlich in allen Sachen ganz gut, ganz gut Geld verdienen.
Es ist, wenn man halt 0.8.15 Windows-Systeme administrieren kann, dann ist es nicht so der Wahnsinn, weil davon gibt's jede Menge. Und auch, wenn man 0.8.15 Linux-Systeme administrieren kann, davon gibt's zwar weniger, aber gibt's auch immer noch genug.
Im DevOps-Bereich kann man auch ganz gut was verdienen, also sprich, wenn man sowohl ganz gut ist, was Operating angeht, also sprich, das Administrative und das Betriebssystem-mäßige, plus, wenn man dann auch gut programmieren kann und dort an der passenden Stelle sitzt, kann man auch ganz gut was verdienen.
Du hast nur die 34. Stelle mit 0 beschrieben, richtig. Also, diese 32, spit, hier, also, na, quasi auf diese, diese, äh, 8? 4 byte, ne? Diese 4 byte Speicherplatz, da steht jetzt im Prinzip nur 0 drinne aktuell.
So, und jetzt laden wir das Ganze mal in unseren, was hab ich gesagt, DevOps? DevOps-Holz. RIP-Ops. DevOps, das wär, das, äh, gut, bei manchen Firmen ist DevOps-Holz, aber bei anderen Firmen ist DevOps-Holz.
Ich muss immer aufpassen, dass ich nicht einmal ein Wasserglas, wo das Sensor drinnen steckt, trinke, weil ich hab' durst und hab' mir so, denk mir so, ey, trinke ich zwar was, aber ich will nicht unbedingt das Glas trinken, wo der China-Plastik-Sensor drinnen steckt.
Ja, Sunset hat es auch recht. Ja, diese ganze, äh, äh, äh, Data Science, äh, und, und, äh, was schreibt der Data Engineering, diese Geschichte, das ist auch, es ist, im Prinzip kann man das gar nicht so klar sagen.
Ja, genau, weil wir ja, der Maschinen-Learning ist auch so, das AI-Geschichten, ähm, es kommt ganz auf den Laden an, und ganz was man macht, und das ist halt auch entscheidend, davon abhängig, was man kann und wie gut man halt Sachen kann, die nicht jeder 0815 hat.
Und außerdem, was, auch was wahrscheinlich noch viel wichtiger ist, wovon man sogar relativ wenig Einfluss drauf hat, ist, in welcher Region man ist, und, ähm, wie händeringend in der Region was gesucht wird.
Ja, in Frankfurt hast du ja quasi an jeder Ecke, wo du hinspuckst, äh, Rechenzentren, IT-Läden, sonst was. Da finden sie keine Leute mehr. Also, es, es, ist quasi, äh, ausgetrocknet, wenn du das so willst.
Wenn du da noch Leute haben willst, musst du halt ordentlich in die, ordentlich in die Tasche graben. Aber wenn du jetzt auch mal in vielleicht anderen Gebieten bist, wo es nicht so viel gibt, dann sieht es vielleicht anders aus.
Okay, also, wir laden jetzt Speichern. Wir laden jetzt in Register R0. Das Ding hat nur vier Register. Ein Register ist quasi, ähm, ein Speicherplatz in der CPU.
Also, man kann sich das vorstellen, wie eine Variable direkt in der CPU. Also sprich, ein Speicherbereich in der CPU, wo ich halt mein Kram rein schreiben kann.
Ähm, also, wir laden jetzt in Register 0 von Adresse 34. Moment, da muss ich vorher, so mit meinen krassen Assembler-Kenntnissen, muss ich vorher erst mal Adresse 34 in ein anderes Register laden.
Da muss ich mal, muss ich mal spicken, ob das stimmt, was ich hier gesagt habe.
Ja, genau. Also, ich muss zuerst mal, also, in Register 3 laden wir jetzt die, das ist halt, jetzt wird es halt eklig, ne?
Nee, das stimmt nicht. Ich will kein Register, ich will den festen Wert laden. Also, ich will in Register 3 34 laden. 34. 34, also, ich will in Register 3 34 laden.
Nee, das stimmt nicht. Ich will kein Register, ich will den festen Wert laden. Also, ich will in Register 3 34 laden. 34. 34 ist, ähm, der Index, also, der Speicher, der Speicher-Offset, in dem ich meine, meine Werte lesen und schreiben will.
So. Also, Offset 34. Das heißt, ich schreibe jetzt den Wert 34 in Register 3. So. Und jetzt sage ich mir, jetzt sage ich ihm, lade, das muss man sich jetzt erst mal hier auf der Zunge zergehen lassen,
weil das ist das, was unter der Haube millionenfach auf jedem Rechner passiert, ähm, was, glaube ich, den meisten Leuten je verwehrt bleibt, das überhaupt zu verstehen, dass es sowas überhaupt gibt, ja?
Ähm, und was unter der Haube auch jede moderne Programmiersprache weg abstrahiert von einem, damit ich was laden kann. Und ich meine, manche Leute haben schon mit Zeigern in C ihre Schwierigkeiten.
Das ist nochmal eine ganze Ecke abgedrehter. Oder, es ist eigentlich gar nicht abgedrehter. Es ist eigentlich nah an dem dran, was so eine CPU halt macht.
Ich muss ihm jetzt sagen, okay, nehme den Wert 34. Das ist einfach ein Int. Das ist eine Zahl. Ne Zahl, nehme den Wert 34 und schreibe sie in Register 3.
Das macht man mit Move. Das macht man in ziemlich allen Assembler-Dialekten mit Move. Ähm, also nehme die Zahl 34. Also, im Prinzip in C würde das quasi so aussehen.
Schreibe mal ein paar Kommentare dahinter, dass man versteht, was da passiert. So. Ähm, also, Register 3 steht jetzt 34 drin. Und jetzt sage ich ihm, lade in das Register R0 das, was in Speicherbereich, in dem Speicherbereich, in der Speicheradresse liegt, die in Register 3 steht.
Also sprich, hier in dem Register steht die Adresse vom Speicher. Und hier sage ich ihm, lade das in Register 0, was in dieser Adresse steht. Versteht man eigentlich. Ist eigentlich relativ simpel.
Ähm, ja ja Leute, jetzt lassen wir die Kirche im Dorf. Ähm, es ist vom Ablauf her prinzipiell simpel, weil du jeden Furz sagen musst. Komplexe Sachen damit zu machen, ist trotzdem Gehirnfuck ohne Ende.
So. Ähm, ok, jetzt haben wir eben gesagt, lade mal das, was in diesem Speicher drin steht. Das sollte jetzt ja in dem Fall 0 sein, weil wir haben ja 0 reingeschrieben.
Ja. Das hier ist ja immerhin unser Programm, was auf dem, was auf der Low-Power-CPU läuft. Das hat ja mit dem Rest hier nichts zu tun. Ich setze den Wert nur initial, einmal bevor ich die CPU starte, auf 0. Und hier lese ich ihn ein. Also eigentlich sollte das da jetzt 0 drinstehen.
Nicht weil hier hinten 0 steht, dass es der Speicher aufsetzt, sondern weil ich hier 0 reingeschrieben habe. Also an die Adresse, nennen wir einfach mal Adresse 34. Ähm, wird jetzt quasi eingelesen in Register 0. Was mir jetzt gerade auffällt, ist eigentlich total beknackt. Brauche ich überhaupt nicht. Na gut, wie dem auch sei. Schön, dass wir es mal eingelesen haben.
Null. Brauche ich überhaupt nicht. Egal. Wir haben es eingelesen. Hauptsache. So, was wir jetzt machen wollen, ist, jetzt gucken wir mal wieder ins Instruktions-Set. Wir wollen unseren ADC auslesen. So, und wir wissen, dass wir ADC 1, Channel 6 auslesen wollen. Das haben wir hier oben, oben schon ja eingestellt. Und ADC 1, Channel 6 ist PIN 34. Weil die Chinesen gedacht haben, das ist eine sinnvolle Idee, das alles anders zu machen.
Okay. Ähm, und jetzt wollen wir ADC. Das ist ein Kommando, den die CPU kann. Das ist, das muss man in dem Fall unterscheiden zu einem Funktionsaufruf.
Ein Funktionsaufruf ist ne Sache, die, die, ne Funktion ist was, was man selber gebastelt hat oder nen Framework-Entwickler, nen Library-Entwickler für einen gebastelt hat. Das ist ein Funktionsaufruf. Und das ist ein Funktionsaufruf.
Die Funktion ist was, was man selber gebastelt hat oder einen Framework-Entwickler, einen
Library-Entwickler für einen gebastelt hat.
Das ist im Prinzip auch einfach nur ein Startpunkt im Speicher, wo dann dahinter Instruktionen
stehen.
Eine Funktion mit einem Namen dran.
Das hier ist wirklich der Befehl, der direkt der CPU sagt, was sie machen soll und was
sie machen kann.
Ich kann hier nicht einfach einen Befehl reinschreiben, den die CPU nicht kann.
Also sprich, die CPU hat, man kann sich das so vorstellen, so eine Mini-Mini-Mini-Firmware
drinne, jede CPU, wo halt alle Opcodes und Operation-Geschichte definiert sind.
Das ist unter anderem auch das, nicht dass ich Mist erzähle, korrigiert mich, wenn ich
Mist erzähle, was Intel ab und zu mal patcht, wenn es Probleme gibt mit den CPUs.
Also wir sind mittlerweile so weit, dass CPUs auch sowas wie eine Firmware haben.
Und das ist mehr oder weniger direkt das Kommando, was die CPU ausführt.
Das heißt, wenn die CPU nicht die Funktion hätte oder diesen Code nicht verstehen würde,
ADC auslesen, würde das nicht funktionieren.
Also ich sag der CPU jetzt schon ganz genau, was sie machen soll.
Ich sag hier jetzt zum Beispiel, okay, ich möchte einen Analog-Digital-Konverter lesen
und zwar macht man das mit ADC, haben wir hier gerade nachgeguckt, der Code ist ADC,
man muss eben sagen, in welches Register der Wert gespeichert werden soll, also R0, wobei
R0 haben wir, nee R0 haben wir nicht, in Register 0, der Index vom ADC, wie gesagt, die, ich
hab ja schon gesagt, die Chinesen haben es nicht so mit Benahmung, ADC 1 Channel 6 ist
in Wirklichkeit GPIO 34 und hier ist es wieder anders da, hier ist es ADC Index 0, Pad 6,
weil, man weiß es nicht, weil, so, jetzt haben wir den Wert hier eingelesen und jetzt werden
wir einfach diesen Wert, den wir gelesen haben, den der ADC gelesen hat, diesen Wert werden
wir jetzt hier in das RAM schreiben, in den Speicher schreiben, danach wecken wir die zwei
Haupt-CPU Kerne auf und geben den Inhalt aus.
Soweit die Idee, also, Memory speichern, weiß gar nicht, für was ST genau steht, für was
steht ein ST genau, Store, Store, genau und da muss man jetzt sagen, ok, ich möchte es
speichern in Value, genau, ich möchte den Wert, der in Register 0 steht, möchte ich
an die Adresse speichern, die in Register 3 steht, ohne Offset, ist am Anfang ein bisschen
konfus, aber ergibt eigentlich doch Sinn, wenn man sich da ein bisschen Gedanken drüber
macht.
So, jetzt haben wir das da reingeschrieben, gucken wir, ob der ganze Kram kompiliert und
irgendwie direkt abkackt oder so, sollte der jetzt nicht aufwachen?
Ich glaube nicht, dass es kaputt ist, ich glaube irgendwie, dass es rumspackt gerade,
ich drücke mal Reset kurz, ne Reset, ah, ich glaube ich habe vergessen mich zu beenden,
kann das sein, was, was schreibt der da immer mit, von wegen NoHandlerFound, ah ja, ok funktioniert,
ok, und jetzt lesen wir die Variable einfach mal aus und gucken, anstatt Init geben wir
mal die Variable aus und gucken, ob das funktioniert, da sollte jetzt der Wert vom ADC drin stehen,
ach ne, ha, ich habe was vergessen, ich habe doch gesagt, ich muss die oberen 16 Bit wegwerfen,
0 passt, 0 ist ok, ja, ich muss die oberen 16 Bit wegwerfen, sonst ergibt es keinen Sinn,
aber man hat schon gesehen, dass es prinzipiell funktioniert, weil am Anfang stand da 0 drin
und jetzt steht da 4395007 drin, ich muss aber die oberen 16 Bit wegwerfen, weil zwar bei
diesem ULP, bei dieser CPU alles in 32 Bit funktioniert, allerdings die Werte selbst
irgendwie nur die unteren 16 Bit von 32, von einem Int verwenden, ich kann es nicht erklären
warum, das wäre wahrscheinlich sonst auch viel zu einfach gewesen, so, und das ist relativ
simple, kann man einfach sagen, und, und dann kann man hier an der Stelle sagen, uint16max
oder alternativ könnte ich auch sagen ff, geht glaube ich auch, ja, müsste im Prinzip
das gleiche sein, so, und da sollte jetzt der Wert vom ADC rauskommen, also irgendwas
um, da steckt immer noch im Wasser irgendwas um 170 rum, ah, es könnte sein, dass es nicht
funktioniert, haha, es könnte sein, dass, ich habe den GPIO Pin noch nicht gesetzt,
es könnte sein, dass es nicht funktioniert, ja, guckt, also, aber doch, wir wissen, dass
es prinzipiell geht, der ADC liest 4095, das liegt daran, weil ich den GPIO Pin nicht
geschaltet habe, deswegen stöpsel ich das jetzt gerade mal um, und zwar von GPIO 27
wieder richtig auf Ground, dann, dann funktioniert es auch, guckt, haha, seht ihr es, funktioniert,
ah, also, funktioniert alles, wenn ich, ich nehme es jetzt mal aus dem Wasserbecher raus,
wir machen jetzt mal, wir machen jetzt mal, dass das Ding nicht so oft aufwacht, alle
10 Sekunden reicht das mal, so, alle 10 Sekunden soll das Ding jetzt aufwachen, alle 10 Sekunden,
also das Ding liest jetzt im Low Power Modus, ohne dass die Haupt CPU Strom verbraucht, liest
das den ADC aus, den Wert, speichert es im Speicher und weckt die Haupt CPU auf, das
ist natürlich so an sich jetzt so nicht sonderlich, sonderlich nützlich, ahm, da fehlt noch ein
bisschen Logik, aber ich glaube die Logik komplett kriegen wir nicht hin, weil ich hab
hier ne Pizza stehen und ich hab übeles Hunger, aber mal gucken, wie weit wir kommen, so und
jetzt mach ich, guckt euch den Wert an, jetzt mach ich den Sensor, den Sensor mal raus, wir
machen mal die Ausgabe noch ein bisschen schöner, machen wir irgendwie sowas, ich mach ganz
gerne machen, sind Gleichzeichen drüber, dass man sieht, dass es jetzt losgeht, das andere
ist Bootloader Debug Ausgabe, also es geht an dem Chat ab, übelste, übelste, Assembler
Diskussion, ja, ja, siehste, da kennt ihr euch besser aus als ich, ich hab da jetzt nicht
so viel Erfahrung was Assembler angeht, man kann auch CPU selber basteln, viel Spaß,
GLHF, außer mit nem rechten Schieber, das warte ich noch drauf, die Holz-CPU, so jetzt
zieh ich das mal aus dem Wasser raus und beim nächsten Wake Up, guck 3575, warten wir noch
mal den Wake Up ab, noch mal 10 Sekunden, ja, so, 8000, so wir haben gesagt, Maxivalwert
ist ungefähr 3800, das kommt so ungefähr hin, so und jetzt stöpseln wir das mal wieder
rein und jetzt sollte der Wert langsam runtergehen, weil ich schalte hier immer noch nicht an
und aus, ja, der Wert geht langsam wieder runter, das ist natürlich sehr schön, das
funktioniert, so, also wir haben jetzt unser erstes Assembler Ding zusammen gewurstet,
bei Online-Games sieht man doch oft Leute mit Holz-CPU, wo man oft Leute mit CPU sieht
in irgendwelche Minecraft, wie heißt das in Minecraft, Redstone Geschichten, da hab
ich schon Videos gesehen, die haben irgendwie gefühlt hunderter Kilometer Minecraft voll
gebaut, um quasi in Redstone eine Art CPU zu bauen, so, da haben wir ein bisschen Mini-Assembler
am Start hier, sind ja nur 5 Instruktionen, ok, machen wir das Ganze jetzt mal ein bisschen
anspruchsvoller, mein Ziel ist ja nicht jedes Mal, deswegen mach ich's ja mit dem Ultra-Low-Power-Prozessor,
nicht jedes Mal die Haupt-CPU aufzuwecken, nachdem ich was ausgelesen hab, ich mein,
das könnte ich auch auf der Haupt-CPU machen, übrigens danke für die ganzen Follows, ich
guck grad mal kurz nach, das ist ja nicht sehr ums Wege der Sache, also, herzlich willkommen,
wen haben wir denn hier alles, den Nico-Chan, Camel-Tec, Trust-Me-SC2, Kokupsi, nee, Kokupsi,
Sunflower-Lol, Label-Alter, Aroseos, Zuckerberg-Mark, der Originale, Cyanox und Antiawear, Max,
kannst du was über Wirtschaftsinformatik-Studium sagen, nee, so, und jetzt müssen wir das
ein bisschen advanceder machen, und zwar müssen wir jetzt was vergleichen, die Werte, und
dann müssen wir woanders hinspringen, bin mir noch nicht ganz sicher, wie wir das jetzt
richtig machen, also wir probieren es jetzt mal erstmal noch ein bisschen einfacher aus,
und zwar möchte ich nur die Haupt-CPU aufwecken, wenn der Wert, den ich auslese, größer ist
als der letzte Wert, ich glaube, das ist noch relativ einfach zu bewerkstelligen, es wird
allerdings schwierig, das Mini-Instruktions-Set das irgendwie hinzukriegen, okay, also nur
Haupt-CPU starten, wenn, ich lass übrigens mal das bisschen schneller aufwachen, dass
ich das schneller sehe, also, was könnten wir denn da machen, also, wir haben das hier
geschrieben in den RAM, so, also, noch ein paar Kommentare, also R0 ist ADC, also im Prinzip,
das da, GPIO34, das wäre so die C-Geschichte dementsprechend, ja, Storm-Memory, okay, das
heißt, wenn ich jetzt wissen will, ob der aktuell ausgelesene Wert größer bzw. kleiner
ist als der letzte Wert, dann muss ich erstmal den letzten Wert einlesen, und zwar muss ich
das hier oben machen, weil hier unten überschreibe ich ihn ja schon, gut, dann fahren wir mal
das ADC-Read ganz oben hin, so, wir laden den Crampel, oh, jetzt wird es kompliziert,
okay, also, wir laden diesen, den Wert aus dem Speicher, so, und jetzt will ich vergleichen
den Wert, den ich aus dem Speicher geladen habe, mit dem Moment, nee, will ich nicht,
ich will es nicht nach LD0, weil dann überschreibe ich doch mal ein Kram, LD2, müssen wir uns
danach mal angucken, okay, also, das heißt, ich will jetzt überprüfen, ob ich, ob der
neue Wert oder der alte Wert größer ist, der neue Wert steht in Register 0, der, ich
kann das hier einfach überschreiben lassen, da brauchen wir unten zum Storen noch, machen
wir das mal in 1.
Was wir schwierig finden, ist, zu Java zum Lernen, wer das an der Uni haben, welche
Entwicklungsumgebung empfiehlt es zu mir, zu Java kann ich relativ wenig sagen, wenn
es an der Uni machen, musst du es auf jeden Fall lernen, Java geht, also, Java lesen kann
man, wenn man irgendeine andere Sprache, kann Java schreiben, ist die Frage, ob man das denn
wirklich will, welche Entwicklungsumgebung, ich würde mal sagen, ich mach wenig Java,
aber mit der Sache von JetBrains, kannst du wahrscheinlich nicht verkehrt liegen, Eclipse,
wir gehen mal fort, so, also, okay, okay, okay, okay, okay, okay, okay, okay, okay,
also, wir laden den Kremplatz rein, ich will jetzt eigentlich, ich will jetzt verklaren,
ich möchte jetzt gucken, ist der aktuelle Wert größer, als der letzte Wert, das wird
beim ersten Mal aufmachen, auf jeden Fall, weil der initiale Wert ist 0, also, der Wert,
den ich einlese, ist auf jeden Fall größer, als 0, okay, also, das heißt, ich ziehe
jetzt mal den einen Wert vom anderen ab. Also hier, Subtract. Also Subtract, Subtract
und zwar Zielregister können wir hier irgendwas überschreiben. R1 können wir überschreiben,
okay das brauchen wir erstmal dann nicht mehr. So und wir vergleichen jetzt R1 minus R0 oder?
Genau, R1 ist der alte Wert und das ist der neue. Das heißt ist das negativ was rauskommt,
weiß ich, dass der neue Wert größer ist. Oder? Ja, glaube schon. Ja, klingt irgendwie so sinnvoll
was ich erzähle. Der Provokateur ist auch wieder back. So und jetzt können wir gucken. Jetzt,
okay, jetzt muss ich den IF bauen. Oh das wird lustig, den IF in der Sampler. Also erstmal
brauchen wir eine Label. Wir brauchen eine Label. Die Labels kann man hier übrigens
bloß nur mal geben. Deswegen nennen wir das mal Label 100. Label 100 ist Stop und Label.
Also das ist im Prinzip ein Go To wenn man es so will. Jetzt werdet ihr wahrscheinlich gleich sehen
warum Go To so verschrien ist. 99. So und von diesem Label müssen wir Jump. Gibt es da vielleicht
auch mal eine Hilfe, Hilfe zu? So irgendwie, ja? Ach nee, was BX? Alter wie heißt dieses komische Makro? BX?
Das ist glaube ich. Nee, Nee, Jump heißt das da nicht. Das wäre zu einfach für die
China CPU. Wie heißt das? Das heißt nicht Jump. Ah hier Label Number. Unconditional
Plunge to Label 100. Okay. Warum, warum, kompiliert doch. Okay, das Speichern machen wir nämlich
auch dann mal hier unten in dem Wake Up. Okay, so und jetzt können wir gucken was größer
oder kleiner ist. Also sprich, wenn. Also was ich doch hier mache ist ich mache R1 minus R0.
R0 ist ADC und R1 ist quasi Alterwert. Das heißt wenn das hier negativ ist dann ist R0 größer
und ich will Jumpen. So und da muss ich jetzt mal nachgucken wie das heißt. Genau. Das Ding
ist echt mega kryptisch. Genau, das ist die Jump Condition. Das ist, Hallo? Pranch to Label
if overflow. Overflow heißt, das hat den ganzen Vorzeichen. Würde ich mal so interpretieren.
Also ich ziehe das, das ist, das ist, oh ist das aber nicht. Ich ziehe das voneinander
ab und wenn Overflow gesetzt ist, weiß ich, dass R0 größer ist als, größer als R1.
Sag mal irgendwie ist die Autovervollstellung mega langsam gerade. Ich mach den ganzen
Scheiß mal zu. Zu 99, dann wollen wir aufwachen. Dann wollen wir aufwachen. So und wenn das
nicht der Fall ist, dann wollen wir direkt zum Ende Jumpen. So ey jetzt bin ich ja mal
gespannt ob das funktioniert. Lul. Meint ihr das funktioniert? Ups, musste jetzt die
serielle Konsole aufmachen, man sieht gar nichts. Ja es scheint schon mal, es wird das erste
mal, scheint schon funktioniert zu haben. Weil 1918 ist größer als Null. Ein L5 Sampler,
jetzt fängt ja Spaß an, ja ja. Kann er mal bitte ein bisschen was kleineres als ersten
Wert auslesen, dass ich dann auch sehen kann ob das größer ist oder kleiner. Ich mach
es jetzt mal aus dem Wasser raus. Ha funktioniert. Nice, funktioniert. Der Jump nur auf wake
ab, wenn der Wert der ausgelesen wird größer ist als der letzte. Das ist natürlich eine
schöne Sache ein Sampler. Du hast, wenn man es beim Programmieren durchdenkt, hat man
relativ wenige Sachen die nicht dann so sind wie man sich das gedacht hat. Ich hab jetzt
ja noch mal resettet den Sensor. Mir gefällt es einfach nicht, ich will nicht sagen dass
es scheiße ist. Eclipse ist die ältere Variante, ich finde Eclipse ist ein riesen Konstrukt
was jetzt auch nicht unbedingt durch wahnsinnige Geschwindigkeit glänzt. Ich kann aber im
Punkt wo Java entwicklt oder nicht zu viel sagen. Ich weiß dass bei uns viele mit auf
der Arbeit viele Java Fans, viele unsere Java Entwickler programmieren den Eclipse. Ja
das ist so. So jetzt probieren wir das nochmal aus. Der Sensor ist jetzt im Wasser, das heißt
der Wert der ausgelesen wird vom ADC ist nicht größer als der letzte Wert. Das bedeutet
allerdings auch, jetzt sehen wir schon einen riesen Vorteil wenn man das mit dem Low Power
Prozessor macht. Der Low Power Prozessor führt unsere Logik aus mit saumäßig niedrigem
Energieverbrauch und die Haupt CPU schläft und erst wenn quasi eine spezielle Bedingung
eintritt erst dann wird die Haupt CPU aufgeweckt und die Bedingung ist der eingelesene Wert
muss größer sein als der zuletzt eingelesene Wert. Eigentlich ziemlich simpel, das heißt
ich nehme das jetzt mal aus dem Wasser raus und zack BAM WAKE UP und immer nur wenn der
Wert größer ist, sobald ich es wieder ins Wasser reinschmeiße läuft es wieder auf und
schläft wieder. Also man sieht prinzipiell funktioniert der Shit den wir da gebastelt
haben. Ich mach mal ein paar Kommentare dahinter, dass man das noch versteht was ich da gebastelt
hab. Exit. Wir könnten jetzt natürlich auch ein bisschen, auch ein bisschen für die,
für Freude bei unseren C-Fans sorgen, indem wir tatsächlich mal ein paar Makros verwenden,
weil die Dinger, die Labels 99, 100 und so zu nennen ist ein bisschen doof. Wir machen
ein Label WAKE UP, das kriegt die ID 99 und wir machen ein Label EXIT, ne Moment haha
nicht gleich, das kriegt 100. Jetzt können wir nämlich sowas hier schreiben, WAKE UP,
WAKE UP, da sieht das auch gleich ein bisschen schöner aus und hier JUMP EXIT. Ups, ah,
sieht doch schon ein bisschen schicker aus als vorher. Ah, ich bin begeistert es funktioniert.
So, die eigentliche Logik ist damit natürlich noch nicht abgefackelt, denn wir wollen ja
eigentlich nicht sobald der Wert größer ist, die Haupt CPU aufwecken. Der letzte JUMP EXIT
ist überflüssig. Er geht eh zu EXIT, stimmt. Richtig. Ah, der fällt ja hier durch. Aber
ist es nicht, was ist denn schöner, so oder so? Eigentlich egal, oder? Aber du hast recht,
der letzte, eine Instruktion gespart, 32bit gespart. Da müssen wir jetzt wie Bob Ross
gleich mal den Speicher-Devil. 32bit gespart, Alter. Porgas. Ups, warum geht das Bild nicht
weg? Umso weniger Befehle, umso weniger Stromverbrauch. Ich weiß nicht, ob du irgendein Messgerät
findest, was das messen kann. Den niedrigeren Stromverbrauch von einer Instruktion. Ach so,
habe ich noch gar nicht gesagt. Die CPU läuft mit 8MHz, die Low Power. Die Low Power CPU,
auch der Megahertz. Der Takt ist auch ziemlich schnell. Der ist schneller. Ach, gute Taschenrechner,
ein scheiß Vergleich. 8MHz ist eigentlich schon verdammt schnell für so einen kleinen
Tag. Mit was könnte man das gut vergleichen? Mit was kann man 8MHz gut vergleichen? Also
in dem Dreh rum werden sich die ersten paar CPUs bewegt haben, ein bisschen drunter wahrscheinlich.
Ne, die waren noch weniger, oder? Kein Schimmer. Doch irgendwie 8MHz, kommt doch irgendwie
hin. Zumindest 8MHz ist gar nicht langsam. Das sind immer 8 Millionen mal pro Sekunde.
Ach ja, übrigens auch eine interessante Sache, wenn man Assembler programmiert. Die Instruktion,
wie gesagt, man ist hier für Timing und sowas alles selbstverantwortlich, aber die CPU macht
auch nicht einfach random was. Bei jeder Instruktion steht immer, wie viele CPU Cycles das Ding
braucht. Also sprich hier, wenn ich zwei Sachen voneinander abziehe, braucht das 4 Cycles,
um das subtrahieren auszuführen, und danach noch mal 4 Cycles, wo er den nächsten Befehl,
den er ausführen soll, sich holt. Also sprich für einen Sub braucht man 6 Cycles, man hat
8 Millionen pro Sekunde. Und bei der Gelegenheit kann man sich auch mal überlegen, wie verdammt
schnell eine aktuelle CPU ist, die man so im Desktoprechner hat. Für unseren Kram hier
sind 8MHz schon ultrabrutal schnell. Aber was in so einem Desktop drin ist, das kann
man damit ja überhaupt nicht mehr vergleichen. Muss ich mal überlegen. 8MHz, äh, äh, ähm,
jetzt wo es kommt, fällt mir das deutsche Wort. Was ist denn ein Cycle? Ein Tick quasi so.
Was ist denn die richtige Bezeichnung auf Deutsch? Takt? Hm. Cyklus! Ah Leute, Poggers
Chat. 8 Millionen pro Sekunde, das ist schon ganz schön viel. Und das ist bei der 8MHz
ja. Mein i7 hat übertaktet 5000MHz. Und ich mein, die CPU lacht sich schon über das Programm
hier kaputt. Man kann, man kann es ganz gut daran erkennen. Wisst ihr, woran man das ganz
gut erkennen kann? Es gibt hier eine Instruktion, die nennt sich Wait bzw. Delay. Delay gibt
man an, wie viele CPU Cycles quasi nichts getan werden sollen. Jetzt kann man sich das
mal einfach überlegen. Also 8000, äh, 8 Millionen, 8 Millionen Instruktionen pro Sekunde. 8 Millionen
Cykeln pro Sekunde macht diese CPU. Das bedeutet, ähm, so oft nichts tun ist quasi eine Sekunde
rum. Das heißt, das sind 100 Millisekunden, das sind 10 Millisekunden und das hier sind
5 Millisekunden. So. Das heißt, ein Delay von 40.000 Cykeln sind 5 Millisekunden. Das
heißt, jetzt überlegt euch mal, ich möchte einfach mal für, hier unten warte ich irgendwo
200 Millisekunden. Hier habe ich 200 Millisekunden gewartet. Also wenn ich das jetzt einfach
Copy Paste müsste, dann würde ich jetzt hier, dann müsste ich eine ganz schöne, für popelige
200 Millisekunden, 10, 20 Millisekunden, 30 Millisekunden, 40 Millisekunden, 50 Millisekunden,
100 Millisekunden, 150, 200. Also so viele Delays müsste ich da einbauen, dass ich auf
200 Millisekunden nichts tun komme. Äh, ja 5.000 Megahertz, 5 Gigahertz, genau. Ähm,
also das hier, die so oft warten für 40.000 Cykeln sind nur 200 Millisekunden und das
ist bei so einer billig 8 Megahertz Low Power Embedded CPU. Allein schon die Hauptchores
vom ESP32 mit 42 Megahertz, also die Haupt 2 und 3 Spitzchores wohl gemerkt, sind schon
nochmal vielfach schneller und jetzt kann man sich jetzt überlegt euch mal, wie lange
diese Kette an Delays für den i7 mit 5 Gigahertz sein müsste. Da könntest du aber ganz schön
lang scrollen, bis du das Delay von 200 Millisekunden drin hast. Gut, ich meine, das würdest du
ja auch nicht untereinander schreiben. Machst du eine Schleife, aber nur mal so, hier sieht
man so ungefähr die Menge, ja. Das ist bei der 8 Megahertz CPU, das heißt, den Scheiß
kann ich jetzt irgendwie ver, äh, ver, äh, fast tausendfachen, fast tausendmal diesen
Mist hier reinkopieren, dass ich ungefähr das gleiche Delay hab. Also, na, so eine Desktop
CPU, eine aktuelle, hat schon ordentlich Wumms, da kann man nichts sagen. Ja, für die CPU
musst du Sekunde warten, gefühlt, ja, Sekunde warten für eine CPU ist ewig. Zumal ja auch
eine CPU nicht wartet. Es hat zwar jede, jede Programmiersprache irgendwie den Sleep oder
den Wait oder sonst was, aber in Assembler erkennt man es eigentlich wirklich gut, was
da passiert. Wenn ich einen Wait mache, also ja, genau, ähm, das, was ich hier eingebaut
hab, also quasi einen Delay von 40.000 Taktzyklen unter der Haupe, ist das quasi so, so was
hier. Ich weiß nicht, wie die No-Op. Ja, also unter der Haupe ist quasi ein, ein No-Op,
also das ist, das sind 40.000 No-Ops. Jetzt überlegt euch mal, wie viele No-Ops das Ding
ausführen muss, um allein schon nur auf 200 Millisekunden Delay zu kommen, weil er macht
ein Megahertz Prozessor. Da kannst du, da kannst du den Messeturm mit Papier ausgedrückt
voll machen, dass du 200 Millisekunden No-Op auf einem aktuellen i7 hinkriegst, wenn du
es wirklich untereinander copypasten willst. Also ich glaube, wenn man sich sowas mal anguckt,
begreift man vielleicht mal im Ansatz ungefähr, wie schnell aktuelle CPUs überhaupt sind.
Ja, und der Flo hat recht, je nachdem, was man macht, sind 8 Megahertz auch nicht so
viel. Und weil man halt sagen muss, mit 8 Megahertz kann man relativ viel machen, 8
Megahertz hier in dieser Art und Weise, weil da, da kommt nichts dazwischen, ja. Das ist,
da ist nichts Multithreaded natürlich, da ist kein Betriebssystem dazwischen, was irgendwie
Multitask oder Sachen hin und her verwaltet. Das führt stumpf das aus, was man reinhaut
und dementsprechend kann man die Sachen auch verdammt optimiert machen. Man darf nicht
vergessen, das erste Rollercoaster Tycoon, ich sag immer Roller-Roaster Tycoon, dabei
heißt es Rollercoaster Tycoon, das erste Rollercoaster Tycoon ist zu größten Teilen
des Samplers programmiert. Du könnt ihr euch wirklich vorstellen, in so nem, na, ok, der
hat ein bisschen mehr Instruktionen zur Verfügung als hier, diese Mini-CPU. Das hier, ein Spiel
willst du programmieren? Ernsthaft? Da bist du doch kurz vorm Selbstmord jedes Mal. Da
bist du echt immer, da ist immer der ein Finger am Abzug, wenn du da drin ein Spiel
programmieren willst. Einfach gehts Kompilieren schnell. Weil du musst ja, im Prinzip, musst
ja hier nichts großartig Kompilieren. Da kommen einfach, da, die kannst du eins zu
eins, diese Instruktionen kannst du quasi in, in, in, in, in, in byte umwandeln, was
man die CPU direkt lesen kann. Deswegen heißt es ja auch Assembler. Du schreibst im Prinzip
an nackte CPU Instruktionen einfach ne Name dran. Viel mehr, in Anführungsstrichen ist
es jetzt ja nicht. Also, ich muss echt mal meine Pizza essen. Aber ich geh mal davon
aus, wir wollen noch ein bisschen weitermachen, oder? Wie lange bin ich denn schon on? Drei
Stunden fast. Okay. Also, ich will jetzt ja nur, okay, wir machen jetzt eine Sache,
mal suchen wir nochmal. Aktuell haben wir es ja so, es wird nur ein Wert ausgegeben, wenn
der größer als der letzte Wert ist. Wir machen jetzt mal so ein bisschen noch nen Filter rein,
und zwar nen Filter anhand unserer Werte, die wir hier ausgelesen haben. Also sprich,
ist der Wert drüber, machen wir nix, und ist der Wert drunter, machen wir nix, denn es
könnte ja auch mal sein, dass der, dass der ADC oder der Sensor irgendwie misst, misst,
ne? Wer misst, misst, misst. Und den Wert wollen wir natürlich gar nicht erst da irgendwie
drinne haben. Jawohl, Werder, wenn du mir, such mal aus dem Instruktionsset raus, wie
man das macht, dann Longjumpen wir auch. Aber als erstes, was wir jetzt hier machen, wir
machen jetzt nochmal nen Compare quasi, und wenn der Wert unterhalb davon liegt, dann
gehen wir direkt Exit ohne Wake ab, legt der Wert oberhalb hier von, dann gehen wir auch
direkt Exit, Exit, ohne. So und das machen wir direkt nach dem Read vom ADC, weil hier
können wir schon feststellen, ich würde übrigens gerne noch ne Schleife machen, ne? Ich würde
übrigens gerne noch ne Schleife machen, dass ich den ADC einfach, keine Ahnung, 4 mal abfrage
und die Sachen dann addiere und am Ende durch 4 teile, weil dann hat man auch ein bisschen
abgefangen, dass das Ding rauscht, beziehungsweise, falls der einen Mistwert mal gemessen hat,
dann, na. Das probieren wir jetzt mal, mit der Schleife, weil ich nicht glaube, wir
können das hinkriegen. Da muss ich erstmal gucken, wie die Makros heißen. Also, aber
das andere können wir jetzt machen, weil da hab ich mir nämlich den Befehl schon mal
rausgesucht im Vorfeld, wenn ich ihn finde, genau, mbge, da kann ich jetzt ihm sagen,
hier Jumper zu Label 100, ne nicht 100, Exit haben wir das Label genannt, Jumper zu Exit,
achso, ist Exit vielleicht schon vorbelegt? Warte mal kurz, mal gucken, ob Exit schon
vorbelegt ist, ne, ist es nicht. Jumper zu Exit, wenn R0, R0 ist der Wert, den ich gelesen
hab, wenn der Wert unterhalb von, wenn der Wert größer als Sensor Max ist oder alternativ,
wenn der Wert kleiner als, äh, wenn der Wert kleiner ist, äh, größer gleich diesem Wert
oder kleiner diesem Wert, dann gehen wir direkt, dann machen wir direkt Exit. Zwei Bits Schiften
Division, jaja, gucken wir mal. Wie man eine Schleife macht, hab ich keine Ahnung da drin,
das Ding hat, das Ding hat eine extra, hat extra Instruktionen für Schleifen, dass es
ein bisschen einfacher ist, also sprich, normalerweise müsste man eine Schleife im Prinzip Label,
ein Label machen, am Ende ein Jump, zurück, wenn, ähm, der Counter quasi größer als
ist oder irgendwie sowas. Ich versuch mal zu gucken, ich such mal in der, in dem Hersteller
Dokument, ob da irgendwie ein Beispiel drinne ist, wie man eine Schleife macht. Hier, oder?
Hier machen sie eine Schleife, hier machen sie eine Schleife, genau, Label, genau, Label,
dann haben sie hier unten, wird der Counter eins hochgezählt und dann wird geguckt, ob
der Counter eins? Ich bin verwirrt. Also, äh, warum steht hier eins? Hier sollte doch
R0 stehen, oder? Ach ne, das bezieht sich immer auf, ah, ne, ne, ne, das ist die Labelnummer,
also das bezieht sich immer, also wenn R0 kleiner 64 ist, dann macht er das immer weiter.
Ja gut, das kriegen wir auch so hin, oder? Also, probieren wir das mal aus. Ok, wie nennen
wir das Label? Das wird Label eins, ADC Loop, Label, ADC Loop. Boah, ob das funktioniert
oder ist das so 3? So, ja, das können wir behalten, allerdings nicht, allerdings nicht,
64, Moment, wir wollen dann gar nicht exiten, wir wollen, haha, wir wollen nicht exiten,
wir wollen den Wert einfach nur wegwerfen, das muss ich mir gleich mal überlegen. Also,
sag mal viermal, hm? Viermal ADC auslesen und mittleren Wertbilden reicht, oder? Dann machen
wir das hier. So, wir machen das aber nicht in R0, sondern wir machen, warum machen die
das hier eigentlich alles in R0? Also, das heißt, wir machen hier R1, ok, das heißt,
als erstes müssen wir, oh je, oh je. Also, als erstes schreiben wir mal in R1, schreiben
wir 0 rein. So. Das ist das erste, was wir machen, das ist in unserem Counter, in unserem
Counter schreiben wir 0 rein. Kann man das eigentlich schön formatieren lassen? So,
in unsere Counter schreiben wir 0 rein. So, wir adden, wir adden eins dazu. Eieiei, Leute,
ich bin ja mal gespannt, ob das funktioniert. Haben wir den Kram mal raus. Wir lassen es
jetzt erstmal so, das heißt, wir müssen das Ganze ja viermal haben. Ob das jetzt funktioniert?
Ich meine, unser Counter wird hochgezählt, wenn der Counter dann nicht mehr kleiner 4
ist, probieren wir mal aus. Gucken, was da rauskommt. Meiner ist funktioniert. Sieht
nicht so aus, als würde es funktionieren, oder? Ach so, Moment, ich habe das addieren
vergessen. Ich muss ja R0, ich muss ja R0, äh, Dingsen hier. Muss es ja zusammenrechnen.
Muss es ja zusammenrechnen. Ich meine, wir machen jetzt zwar eine Schleife, aber wir
rechnen es ja nicht zusammen. Also, will ich add? Register zusammenzählen, R0 mit R0 plus
R0. Ne, Moment. Moment. Äh, ne, ne. Ja, keine Ahnung. Alter, was ist das für eine. R2,
nehmen wir das mal. R2 ziehen wir. Ne, initialisieren wir den Kram auch mal auf Null. So. Das ist
Ziel in R2. Soll R2 mit R0 zusammengerechnet werden. Ja, genau. So. Ähm, und jetzt moveen
wir noch mal. Jetzt moveen wir noch mal das wieder. R2 nach Null. Ey, ob das jetzt funktioniert,
ich bin da echt mal gespannt. Das funktioniert irgendwie nicht, oder? Was mache ich denn verkehrt?
Was mache ich denn verkehrt? Ich addiere den Kram hier. In R2. Und das Ganze mache ich
so lang. Ah, Moment. Haha. Das funktioniert nicht. Mein adden funktioniert nicht. Das bezieht
sich ja immer auf Null. Ne, Moment. Null muss ich das machen. Oder? Ich bin, ich bin echt
kaputt. Das ist jetzt wirklich hirn, hirn. Kaputt. Genau, ich kann, ich muss R0, darf
ich ja nur für diesen Jump hier unten verwenden, weil das immer auf Register Null geht. Hast
du eigentlich eine englische Tastatur? Nö, nö. Das geht auf Register Null. Das heißt
mein, mein. Willst du was mit Java programmieren? Nein, will ich nicht. Also kann ich den Kram
hier nicht verwenden. Also dann readen wir das mal in 1. Haha, was auch immer ich hier
betreibe. Dann lesen wir das in 1. Und dann adden wir 2 mit 1 plus 2. Und am Ende, wenn
wir fertig sind, dann moveen wir 2 zu Null. Ok. Guck mal, ob das jetzt funktioniert. Ah,
das sieht doch schon besser aus. Das sieht doch ungefähr aus wie 4 mal 2.000, oder?
Ha, funktioniert. Krasse Assembler. Loopzor. Das kann man auch bestimmt schöner machen.
Raids OV tut zuerst. Oh, nee. Jetzt Leute, mir reicht's. Genug. Ich mein, was man daran
schon mal schön sieht ist, wie schnell so was ausatmen kann von der Länge her. Max,
gib zu, dass du mit Iron Age unter einer Decke steckst. Ich muss tatsächlich sagen, dass
das Board, was ich hier programmiert hab, ist ein bisschen davon inspiriert. Gut, ja,
die ganzen Assembler-Pros, kann man die Schleife irgendwie ein bisschen schöner machen? Das
ist schon ein bisschen... Das muss ich mir in Ruhe da noch mal angucken. Aber ich glaub,
ich werd jetzt erstmal in Ruhe meine Pizza füttern. Aber ich find's echt cool, dass
das funktioniert. Achso, ja, wir müssten ja noch teilen, ne? Ich würde gerne wissen,
wer das während dem Spiel macht. Der hat wahrscheinlich Shortcuts. Ich hab hier für
mein Mist hier auch Shortcuts. Das kannst du ja einfach während dem Spielen drücken.
Macht er ja meistens, wenn er gestorben ist. Ja, gut. Und noch mal ein Sensor aus dem Glas
raus. Bäm! Ha, das ist schön, wenn das funktioniert. Den Jebaited Song. Das hab ich nicht hinterlegt
hier, den Jebaited Song. Ich hab aktuell nur das Jebaited-E-Mode. Und die koreanische Sprachausgabe
natürlich. Was zum Teufel ist der Jebaited Song? Ich kopiere normalerweise nix. Aus
dem Chat. Aber wenn's ein Mod macht, glaub ich, war das doch nix Schlimmes. Oh, du Scheiße.
Oh, das tut ja weh. Ist das dämlich. Ach, du Scheiße. Das ist ja Twitch pur, ey. Das
war das pureste Twitch, was wir heute hatten. Jetzt, jetzt wird ja eigentlich nur noch hier,
jetzt würde eigentlich nur noch er hier fehlen, oder? Wobei, war da er hier. Ist jemand gestorben
oder was geht mit der Musik ab? Speichern wir mal. Ist schön entspannend. Wisst ihr,
was ich doof finde? Diese Bookmark-Bar vom Chrome, die funktioniert irgendwie schlechter
als die im Firefox. Weil du kannst im Firefox, kannst du Tabs in die Bookmark-Bar ziehen,
das kannst du im Chrome nicht machen. Und wenn die Bookmark-Bar voller wird, so wie hier,
was eigentlich bescheuert ist, weil es eine Bar sein soll, musst du dann immer erst hier
runter scrollen und dann das irgendwie hochtreppen, droppen. Hast du schon größere Projekte in
Assemblern gemacht? Nein, habe ich nicht. Zu diesem Vergnügen, oder besser gesagt, das
Vergnügen blieb mir bisher verwehrt. Aber wirklich scharf drauf will ich auch nicht
größere Sachen in Assemblern machen. So Leute, ich hoffe, das hat für die tägliche Low-Level-Tippe
Dosis heute gereicht. Übelsthunger. ASMR-Eating-Sounds. Und, ähm, mal gucken, ob ich weiter on-Stream
mache. Das war die Frage. Hat euch das gefallen? Wird mich jetzt mal interessieren, weil das
ist jetzt schon eine etwas abgedrehtere Geschichte, als das, was wir sonst machen. Und ich glaube,
ähm, die normalen Sachen sind schon abgedreht genug. Okay, krass. War mir nicht Low-Level
genug. Nächstes Mal musst du eine Hardware-Schaltung für das Bauen, für Effizienz. Das, auch wenn
du es nicht ernst gemeint hast, aber das ist gar keine schlechte Idee. Ich weiß nur nicht,
wie ich das, ähm, gescheit streamen sollte. Weil wir müssten hier theoretisch schon zumindest
ein paar Sachen auf einem Predboard stecken. Zum Beispiel den Antennen-Anschluss, den Antennen-Connector
für das LoRa-Modul müsste man ordentlich drauf decken. Und das LoRa-Modul auch. Und
dann müsste man es verbinden und so Dinge auch. Ich hab extra dafür, für so kleine
Projekte, wie bei Amazon, so Mini-Predboards gekauft. Die sind, keine Ahnung, so lang wie
mein Daumen oder so. Aber das ist wirklich praktisch für so Kleinscheiß, der in eine
Box rein soll. Predboard, Predboard. Ja, die kleinen Dinger hier. Die sind echt praktisch.
Die sind klein. Guck mal, die sind hier. Steht da irgendwie eine Größe drin? Ja, 14x7cm.
Die sind richtig klein und kompakt. Die normalen Predboards sind ja eher in der Größe oder
die Hälfte davon. Die sind schön klein, weil man nicht viel Platz braucht, weil man
einfach nur ein paar Sachen miteinander verbinden will, ohne dass man da irgendwie viel Matching
hat. Sind die kleinen Dinger wirklich praktisch? Weil die passen auch in so eine kleine Box
rein. Ich hab mir nämlich letztens eine Ladung hier gekauft. Nee. Das könnten die sogar
sein. Nee, 20x20, glaube ich nicht. Ich hab mir letztens so eine Zehner-Bestellung-Boxen,
ich glaube, die hier sind das. Irgendwie gut. Die gab es aber, glaube ich, auch mal im Pack.
Und, ähm, das ist eigentlich ganz gut. Das ist eine IP65-Box, also sprich, die ist zumindest
mal relativ wasser-, also staubdicht und wasserfest-, staub-, wasser-, staub-, nee, Staubwasser,
ne? Also staubdicht und spritzwasserdicht bis irgendwie sonst was. Also kannst du bloß
nicht unter Wasser verwenden im Endeffekt. Ähm, und die sind halt nicht groß und dafür
passen halt die kleinen Prep-Boards ganz gut. Die passen da nämlich rein, inklusive, ähm,
Controller und inklusive Modul. Joa. Und sowas könnte man eigentlich mal zusammenstöpseln
im Stremen, aber es ist halt schwierig sowas zu filmen. Nee, CPUs auf Web-Boards kannst
du vergessen. Ich mein, die, selbst die ersten paar CPUs, die waren halt auf großen Karten
im Endeffekt, aber auch schon eine ganze Ecke komplexer als das, was man sich da so zusammen-,
was man halt machen kann, ist sich, ähm, Teile, die quasi integriert sind, äh, zusammenstöpseln
mit Sachen, die halt auf einem anderen Chip integriert sind, ne? Also zum Beispiel, dass
man ein WLAN-Modul kauft und dann irgendwie ein ESP-2-, äh, den brauchen wir nicht,
da brauchen wir kein WLAN-Modul. Keine Ahnung, dass man sich eine CPU kauft, ein WLAN-Modul
kauft, oder dass es zusammenstöpseln ist, könnte man machen, ähm, weil das auch nicht
so ohne ist. Aber wozu? Ich mein, man kauft sich ein ESP-32-Board, man hat Bluetooth,
man hat WLAN, man hat zwei CPUs, ich mein, man muss sich mal überlegen, die Technik,
die auf so einem Ding draufsitzt, ist halt schon übelst nice, ne? Ich mein, die Technik,
die da draufsitzt, ist schon mal echt nice, und zwar muss ich mal überlegen, was da alles
drauf ist auf so einem Controller. Du hast drei CPU, äh, du hast drei CPU-Kerne, drei,
wohlgemerkt, auf so einem Micro-Controller, der als Modul so groß ist, wie man Daumennagel,
also man muss ja sagen, dieses Board hier ist ja gar nicht das, was groß ist, das ist
das raus für den GPIOs, oder ein bisschen Flash und sonst was drauf. Das da ist der
ESP-32, das ist Daumennagel-groß, das Ding. Ja, das ist keine reine CPU, na klar, ist
halt mit dabei. Ich mein, du hast alles möglich dabei, das ist wirklich ultra nice, das Ding,
muss ich mir überlegen. Drei CPU-Kerne, du hast zwei 32-Bit mit, äh, was auch immer
hier das da ist, wahrscheinlich der Hersteller oder irgendeine Technik, mit 240 MHz, sind
8 MHz Low-Power-Prozessor, ähm, du hast relativ viel RAM für sowas und Speicher, steht
leider nicht drauf, wie viel. Das Schöne an diesem Memory, ich blick hier auf dem Bild
grad nicht so ganz durch, ist halt auch, dass es Deep Sleeps überlebt, du hast, das ist
richtig nice, du hast die verbreitetsten Krypto-Geschichten als Hardware auf dem Chip,
das heißt, du kannst AES-Verschlüsseln, also Synchron-Verschlüsseln, du kannst RSAA-Synchron-Verschlüsseln und du kannst
Haschen, wahrscheinlich das Shard 256 oder sowas, und das Hardware beschleunigt, auch
so ein kleines scheiß Ding drauf. Hat der auch noch einen Funk-Dings drauf? Nee, das
ist wahrscheinlich für WLAN. Äh, du hast WLAN drauf und Bluetooth drauf. Und man, genau,
so, so, so, so, wie, ich mein nicht, dass die Namen jetzt falsch, aber, Python, Node-Deal,
Python-Idea, Python-O-Idea, ich weiß nicht, so wie er das sagt, man muss sich überlegen,
20 Euro. Und bei AliExpress noch billiger. Das Einzige, was du nicht machen kannst, doch
Multi-Swerding kannst du auch machen, du hast zwei Kerne. Es gibt sogar Multi-Swerding-Libraries
für. Ja, 20 Euro, der Kram kostet dann viel. Also, nicht die CPU, sondern das Board. Okay,
vergess 10 Euro, nicht 20 Euro. 10 Euro. Und bei China, in China noch weniger. Ja, in
China noch 5, vergiss, was ich gesagt hab. Die bisschen Strom-sparende Variante sind
teurer, genau. Und Firebeetle kostet 20, weil man das billiger kauft wahrscheinlich auch.
Aber, ich mein, der Preis ist halt echt unschlagbar. Also, Multi-Swerding kannst du. Du hast zwei
CPU-Kerne und es gibt eine fertige, also, eine fertige Task-Library dafür vom Hersteller.
Alternativ kannst du auch eine andere verwenden. Also, funktioniert. Standardmäßig ist es
so, dass der Arduino-Code wird auf CPU-Kern 1, glaube ich, ausgeführt und alle Timer
und so gedönnt. Also, ich könnte zum Beispiel auch einen Timer anlegen, der mir jede Sekunde
auslöst und in dem ich irgendwie einen PING schicke oder so. Irgendwas bescheuertes. Oder
LED blinken lasse, ja, LED blinken lasse zum Beispiel. Der Timer läuft dann auf CPU 0,
wenn ich das jetzt richtig im Kopf hab. Also, der macht standardmäßig schon ein bisschen
Multi-Swerding, aber es gibt eine komplette Task-Library, wo man Multi-Swerden kann. Kommt
nicht von ungefähr, weil es gibt ESP32-Kamera-Module, die gar nicht so eine schlechte Quali haben
und gar nicht so schlechte FPS haben. Und guckt euch das mal an. Ah, das Video kenn ich
von dem, das ist echt nicht schlecht. Der Typ hat sich hier so ein ESP32-Kamera-Modul
gekauft mit einem ESP32 drauf. Das dürfte so von der Kamera her so eine Qualität wie
vom Raspberry ungefähr sein, die Raspberry Zero, diese Mini-Kamera. Und, weiß nicht,
ob er hier irgendwo das Web-Interface zeigt. Sieht man hier, wie viel FPS man einstellen
kann? Gut, ich meine, die Auflösung ist jetzt hier nicht so hoch. Äh, hallo? Ey, ich hab
das Video nicht umsonst auf 1080p stehen. So, guck mal, da hat die Auflösung relativ
runter. Ich weiß nicht, ob man hier die Frames sieht. Sieht man hier die Frames? Aber das
ist gar nichts übel. Und ich meine, allein schon dadurch, dass das überhaupt möglich
ist. Ich meine, der Typ, der macht hier im Video, ähm, macht da mit ganz annehmbarer
Auflösung und ganz annehmbarer, ähm, meine Auflösung ist halt das Problem. Du hast nicht
wirklich viel Speicher auf dem Ding. Und mit annehmbarer FPS-Zahl macht der Bildbearbeitung
live von einem Video-Stream auf einem Mikro-Controller. Was halt echt nice ist. Und, ähm, man kann
sich halt immer fragen, okay, warum soll ich sowas nehmen an Schatz und Raspberry? Das
liegt zum einen mal am Preis. Am Stromverbrauch. Und weil viele Sachen auch durch die einfache,
oder durch die einfache, oder das weniger drum herum ist, sind tatsächlich einfacher.
Ich meine, der Raspberry ist eindeutig das Flexiblere davon. Ja, ganz klar. Ich meine,
du hast im Vergleich zu so einem, äh, zu den CPUs, die da drauf sind, hast du ja mit so
einem Raspberry Pi, das ist ja schon ein Supercomputer dagegen, äh, da hast du irgendwie, was hat
der aktuelle Raspberry in einem Quad-Core mit 1,2 Gigahertz oder so? Und auch der Zero
dürfte das Ding hier schon, auch wenn der Zero nur einen Core hat, ziemlich in die Tasche
stecken. Ähm, aber der Raspberry ist halt ziemlich schnell, aber ist halt im Vergleich
zu einem ESP32 halt auch sehr, sehr flexibel. Das darf man nicht vergessen. Allerdings
für kleine Sachen, die einfach funktionieren sollen, ist so ein ESP32, so die kleinere
Variante, ist das richtig gut. Weil, den juckt's auch nicht, wenn du einfach mal Strom rausziehst
oder irgendwas. Raspberry, da hast du ja immer Schiss, dass er kaputt geht, wenn du einfach
Strom rausziehst. Also, das sind unterschiedliche Anwendungszwecke irgendwo einfach. Und, ich
finde, ich finde beides hat seine Daseinsberechnung. Und dadurch, dass da halt vieles simpler ist,
hat er halt auch viele Aufgaben viel simpler zu erledigen. Da macht er halt nur eins. Und
zwar das, was du ihm gesagt hast. Nicht, wie ein Raspberry, der 30.000 Sachen parallel
macht. Was ist tot? Port tot? Achso, vom Raspberry, ja. Das kann schon sein. Also, wir sind schon
ein paar SD-Karten, ich verreckt, aber war nicht mehr bootbar, weil du Strom rausgezogen
hast. Das kann einem am Raspberry relativ schnell passieren. Strom rausgezogen, zum falschen
Zeitpunkt, blub. Windows, ja. Leg da ran. Normalerweise hätte ich das hätten wir das
jetzt auch heute eigentlich unter Linux gemacht. Leg da ran, dass ich in der Linux-VM ein bisschen
Probleme hab mit dem USB-Controller von dem anderen Board. Der funktioniert unter Linux
nur sehr halbherzig. Das liegt aber am Hersteller vom USB-Controller. Unter Windows funktioniert
er halt. Unter Linux geht die serielle Verbindung. Allerdings geht das Flaschen nicht über
USB. Und so ein Ding musst du ja halt alle paar Minuten flaschen. Okay Leute, ich find
schön, dass es euch so gut gefallen hat. War ja die eindeutige Antwort, dass wir weitermachen
sollen hier on stream. Das nächste Mal, wenn wir die Low-Level-Geschichte fertig haben,
das nächste Mal wird es auch noch ganz interessant, weil dann müssen wir die Übertragung programmieren,
wie wir die Sachen, die wir hier vom ADC ausgelesen haben, quasi per LoRa an den Empfänger schicken.
Wie gesagt, über 1,5 Kilometer läuft das Ganze dann. Und ich hab's schon ausprobiert,
es funktioniert. Ja, und dann werden wir das optimieren lassen, dass möglichst wenig
Batterie verbraucht. Wann wird das nächste Mal ja vielleicht? Aber ich verspreche, ihr
kennt mich ja, ich kann das... Ich würde ja immer gerne am besten gleich noch weitermachen,
immer wenn ich mal gestreamt habe. Wenn ich ein paar Tage wieder nicht gestreamt hab,
dann bin ich irgendwie immer so motivationsmäßig, nicht so... Ja, ich weiß auch nicht. Ich glaube,
zum größten Teil liegt es daran, dass ich auf YouTube nichts mache. Und ich deswegen
überhaupt nicht mehr so in diesem Rhythmus drin bin, was Upload und so Sachen angeht.
Was macht das Alien Links in VS Code? Das startet die Oberfläche von meiner Arduino IDE,
quasi. Beziehungsweise von Platform IO. Das machts programmieren ein bisschen einfacher.
Kannst aber auch einfach das Arduino Plugin nehmen. Also den...
den Raspberry Pi Standalone, ohne Raspberry Zeug drauf zu verwenden, stelle ich mir schwierig
vor, weil der Raspberry Pi ist gar nicht so offen, wie man das denkt. Da ist ganz viel
proprietäre Geschichte von Broadcom drauf. Also die Arm-CPU ist da so eine Sache, quasi
so 3. Klasse, Hardware 3. Klasse drauf auf dem Raspberry. Das fängt ja schon an, dass
der eigentliche Loader proprietär ist. Wird es meinen Discord-Server geben? Ja, aber keine
Ahnung, man. So Leute, schön, dass euch gefallen hat. Ich gehe jetzt mal endlich eine Pizza
futtern. Machts gut, bis zum nächsten Mal. Tschüss, CU.
