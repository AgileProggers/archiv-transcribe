Das war's für heute und wir sehen uns beim nächsten Mal wieder, bis dahin, tschüss, tschüss, tschüss, tschüss.
Das war's für heute und wir sehen uns beim nächsten Mal wieder, tschüss, tschüss.
Das war's für heute und wir sehen uns beim nächsten Mal wieder.
So, da bin ich. Heute brauchen wir noch so 10 Minuten oder so, ich muss erst mal in Bastelstimmung kommen.
So, da bin ich. Heute brauchen wir noch so 10 Minuten oder so, ich muss erst mal in Bastelstimmung kommen.
Und war es auf der Arbeit wieder ein bisschen nervig. Und danach habe ich Sport gemacht, also ich bin noch nicht so wirklich komplett in Bastelstimmung.
Aber das wird sich wahrscheinlich demnächst ergeben, hoffe ich mal. Habt ihr irgendwas Spannendes heute gemacht?
Gibt es irgendwelche wichtigen, interessanten Neuigkeiten? Ich habe gesehen, Game Awards sind, es könnte mich kaum was weniger interessieren gerade.
Game Awards haben mich ehrlich gesagt noch nie interessiert.
Es gab mal eine Zeit, da habe ich total drauf gebrannt, neue Ankündigungen zu haben von Games, sei es irgendwelche Pressekonferenzen oder was vorgestellt wurde.
Aber nachdem das alles mittlerweile so lame und overhyped ist, bis auf ein paar Sachen, mache ich die meisten.
Gestern habe ich auch nicht geguckt. Ich lese mir einfach Zusammenfassungen durch und gut ist.
Tja, siehste.
Leute, was ist die beste Rust DDE, bevor wir loslegen?
IntelliJ mit Rust Plugin, Wishlist Studio Code.
Ich habe mir im Vorfeld nicht viel angeguckt. Ich habe nur ganz kurz mal so ein Hallo Welt Tutorial gelesen, das war es.
NeoWim, ja mit was denn? NeoWim alleine wird es ja kaum sein, oder?
Language Server, oder was?
C-Line mit Rust, na gut, da kann ich auch IntelliJ mit, wobei C-Line habe ich schon installiert, da kann ich auch C-Line verwenden.
Wobei ich weiß gar nicht, ob ich auf dieser vor allem installiert habe.
Das ist genau das gleiche, das ist Wishlist Studio Code, nur glaube ich ohne proprietären Microsoft-Krempel.
Was teilweise gar nicht so einfach ist, weil du beispielsweise für CodeShare und für die C++ Extensions und sowas...
Ja, die Wishlist Studio Code C++ Extensions ist proprietär, die geht nicht.
Ja, also ich habe Rust mal gemacht vor einer ganzen, ganzen Weile. Ich glaube, da war die Sprache noch nicht mal 1.0, als das neu war.
So ganz grob habe ich ein bisschen Ahnung von, aber nicht wirklich viel.
Ah, ich weiß, dass du bei den hinteren Printen ein Ausrufezeichen brauchst, weil es ein Makro ist.
Ich weiß, dass du mit Cargo dein Zeug managst.
Aber ich weiß, dass die Syntax teilweise ein bisschen Painschamp ist.
Sehr viel NumSumOptional.
Das Multithreading damals ziemlich Painschamp gewesen ist, wobei uns das für WebAssembly wahrscheinlich nicht weiter jucken muss.
Ich, keine Ahnung, ich bin mal gespannt.
Ownership, Borrow Checker, genau dieses ganze Zeug, da werden wir heute wahrscheinlich ein bisschen ausflippen.
Aber wir machen simple Sachen.
Ich habe keine Einladung zur Beta, ich habe mich noch nicht mal angemeldet zur Beta.
Warum muss man sich da überhaupt anmelden zu einer Beta?
Warum kann man nicht einfach den Editor in der Beta installieren?
Und das gute, wie irgendwelche neuen Social Plattformen, die sind auch immer mit Einladung am Anfang.
Gibt es eigentlich Clubhouse noch?
Nein, Clubhouse interessiert doch keinen mehr, oder?
Die haben doch mal irgendwelche Daten geleakt und seitdem will da keiner mehr hin.
Nicht Assembler, WebAssembly, das hat wenig zu tun mit wirklich x86 Assembler oder sowas.
Man kann WebAssembly sogar in einer Lisp-ähnlichen Sprache zusammenwursten von Hand.
Habe ich letztes Video drüber gesehen.
Ja, da wurde irgendwas geleakt, ich weiß aber nicht mal was.
Irgendwas wurde geleakt und ach, kein Schimmer.
Ich hatte die App nie installiert.
Ja, Lisp, also Leute, wenn ihr auf Programmiersprachen steht, die im Endeffekt so aussehen, dann mögt ihr Lisp wahrscheinlich.
Ich habe früher mal eine ganze Weile Emacs verwendet, so zu Zeiten noch als Wishful Studio Code noch nicht angesagt,
und auch die ganzen Extensions und ich sage euch, Emacs Lisp ist wirklich das Schlimmste, was es gibt.
Ich weiß gar nicht, warum das so viele abgefeiert haben immer.
Ja, fast.
Ich überlege gerade, wie man das jetzt am besten machen.
Als erstes installiere ich mir mal IntelliJ oder gucken, ob ich Z-Line noch installiert habe.
Erstmal installieren wir den ganzen Krempel und dann schauen wir mal.
Ich muss mich ein bisschen an Rust rantasten, wobei so ein Hallo Welt kriegen wir wahrscheinlich relativ zackig zum Laufen.
Ob wir heute was mit FFmpeg hinbekommen, da habe ich so meine Zweifel.
Weil das ist ja eigentlich das, was ich ausprobieren will.
Ob ich mit FFmpeg was im Browser quasi Transcoden kann.
Und ich will wirklich Low-Level das machen, also AV-Frames rausholen und nicht irgendein fertiges FFmpeg zu WebAssembly-Commando-Zeilen-Tool verwenden.
Ich bin mal gespannt.
Aber ich glaube nicht, dass wir das heute so weit hinkriegen.
So, also, was ist das heute für ein Hintergrund? Das ist das Bing Image of the Day.
Das ist eine Wiese mit roten Flecken.
Alles klar.
Was ist dein Haupt-OS, Windows 10?
Das ist Windows 10 und das ist eine Linux VM.
Sind eigentlich deine Hardware-Komponenten bekannt? Ja, die sind gar nicht sonderlich gut mittlerweile.
Damals waren die ziemlich gut.
Das hier, oder?
Ja.
Hast du 32 GB? Ja, ich habe 32 GB Arbeitsspeicher.
Hier stehen glaube ich nur 16 drin, aber es sind insgesamt 32.
Guck hier, 32 GB.
Aber das brauchst du nicht. Guck mal, also das ist jetzt nicht...
Armour Reforged, nee. Reforger.
Gesehen habe ich das schon, Armour, aber nicht gespielt, nee.
Also guck, du brauchst also, um ein paar VMs ordentlich laufen zu lassen, brauchst du keine 32 GB.
Ich habe es voll übertrieben. Ich meine, ich habe dieser VM...
Äh, hallo?
Ich habe dieser VM 16 GB RAM und 4 CPU-Kerne gegeben. Das braucht die im Leben nicht.
Armour Reforged, nee, das war Warcraft 3 Reforged.
Also der Rechner ist 4 Jahre alt und ist immer noch ziemlich gut.
Hauptsächlich wegen der 1080T.
Das wird sich gleich zeigen.
Nein, nein, das ist nicht die neue VM. Die ist ja noch gar nicht fertig.
Ich glaube bei RAM-Auslastung ist eigentlich weniger mehr.
Madboy Mad Prime Subscriptions hier, Dankeschön.
Massive Prime Subs. Ich habe übrigens vorher noch eine neue Version vom EPG-Champ gepostet.
Der caches das ganze Zeug jetzt ordentlich, jetzt geht es ein bisschen schneller.
Und die Aufnahme funktioniert auch wieder.
Wie heißt noch mal die Terminal-Anwendung?
Das da, CMDR.
Aber mittlerweile, du kannst auch das neue Windows Terminal verwenden, das ist auch ganz okay.
Allerdings, please nicht mit PowerShell.
Na gut, doch mit PowerShell. PowerShell ist okay. Ich mag PowerShell als interaktive Shell nicht, aber PowerShell ist okay.
Was halt Ober-Crap ist, also Hyper-Ultra-Crap ist das CMD-Fenster und dann da drin diese Batch-Shell. Ganz abartig.
PowerShell gibt es übrigens mittlerweile sogar unter Linux. Ich weiß gar nicht, ob ich hier mal Just For Fun installiert habe.
Seit es.NET Core gibt, gibt es den Kram.
Auch für Linux.
So, ich muss mal kurz ein bisschen Platz machen. Wartet mal, Leute, ich muss mal kurz, muss mal kurz was gucken, wo ich hier viel Platz verschwende.
Dart. Ich hab immer noch Dart und Flutter drauf hier. Das könnte man tatsächlich mal löschen.
Mach hinne.
Ich muss ein paar Sachen löschen, dass ich genug Platz hab wieder. Ich glaub, ich hab da schon 160 geht ran.
Oder 80 nur?
Hat nicht denselben Umfang wie unter Windows. Ja, das wundert mich nicht. PowerShell war ja ursprünglich als Windows-Automatisierungs-Ding geplant. Da ist ja auch dieses Ganze.
Wie heißt das unter Windows? Nicht WSL. Ich meine nicht WSL. Ich meine dieses Abfragezeug. WMI heißt das, glaube ich, unter Windows.
Wo du so System-Infos abfragen kannst. Das hat ja eigentlich alles ganz gute PowerShell-Integrationen, aber das gibt es ja unter Linux gar nicht.
So. Oldschooler hier. Guck dir schon lange. Kam nie dazu, im Steam zu sein.
Ja, ursprünglich hatte ich eigentlich gedacht, wir könnten eine Runde Battlefield spielen, wenn jetzt die neue Season rauskommt.
Aber ich hab heute absolut keinen Bock auf Battlefield 2042. Ich bin eh ziemlich im Arsch.
Ich bin ehrlich gesagt auch nur angekommen, weil ich gestern gesagt hab oder gestern extra abstimmen lassen,
was wir heute machen wollen. Zwar mit dem Hinweis vielleicht auch nix, aber ich wollte dann trotzdem jetzt auch nicht den Streamstreak abreißen lassen.
Ich meine, das ist jetzt Premiere. Ich glaube, das hatte ich noch nie. Ich war sieben Tage oder acht Tage in Folge on.
Das ist ja, das kommt ja normalerweise nie vor.
So. Also, Home. Na, da haben wir nicht viel. War. Lip.
Alter.
Snap-Pains-Champ, Alter. Was hab ich denn überhaupt? Snap-List. Snap-List.
WTF? Ah. Wie krieg ich, wie krieg ich, wie krieg ich das überhaupt weg? Snap-Remove.
Okay, okay. Weg, weg damit. Braucht doch kein Mensch.
Bare. Core. Core. Core. Dings. GTK Common Themes. Warum?
LXD. Was hab ich denn hier alles für einen Müll drauf? Was laufen? Warum hast du, ich weiß es nicht.
Ich hab noch, ich hab noch LXD, LXD. Was hab ich denn hier alles für Zeug? Delete. Remove. Ach.
Uninstall. Ach, ich weiß gar nicht, was es ist. Ich hoffe, dass es Remove ist. Nein. Delete. Delete. Vielleicht. Okay.
Delete. Da runnt sogar ein Container standardmäßig. Ich hab keinen platzen Schimmer, was es ist, aber.
Ich lösch das jetzt einfach. Kann nix Wichtiges sein.
Einfach weg damit. So, und dann werde ich, dann werde ich gleich wegschmeißen. Ich muss mal kurz ein bisschen Platz machen. Ja, auf. Ausgehen, please.
Arch, by the way. Ja. Da kann es schonmal sein, dass man über, Arch ist so wahnsinnig advanced und geil.
Da kann schonmal passieren, dass man die Übersicht verliert, was man so alles läuft. Sag mal.
Kann sich das vielleicht mal beenden? Please.
This operation can't be cancelled. Interrupt, ja was denn jetzt? Kann ichs jetzt, kann ichs jetzt canceln oder nicht?
Boss. Weg. Okay. Alles klar. Delete.
Ich weiß nicht, was es ist, aber das muss weg. Muss man bei LXC auch noch Images löschen? Lieber Docker oder ist das danach?
Image. Image List. Ja 200 irgendwas. Image. Delete.
Ubuntu 18. Das läuft schon eine Weile hier, würde ich sagen, oder? Weil wir hier in Ubuntu 1804 laufen haben.
Okay, so und jetzt kann ich Snap remove. Und jetzt habe ich. Was?
Warum ist Snap so ein Crap, Alter? Und jetzt? Snap ist being used. Okay, das kann ich nicht löschen.
Das gehört zu Snap dazu. Alles klar. Nee, auch nicht. Okay.
Coil, Coil auch nicht oder was? Alter, Mann. Okay, Snap List. Darf ich jetzt den Rest löschen? Ja, ja, okay, okay.
Ja, Snap löscht, Snap wird auch gleich gelöscht. Ich weiß gar nicht, warum ich den Müll überhaupt installiert habe.
Keine Ahnung, aber dadurch wird ja nicht alles entfernt. So und jetzt diesen ganzen anderen Mist. Okay, das geht nicht.
Ah, jetzt, jetzt kann ich die Bare löschen. Okay, das Klo muss da bleiben, alles klar. Snap. Weg damit. Yep.
Na, Gott sei Dank. So, jetzt habe ich ein bisschen mehr Platz. Gut. Snap. Alles klar, gelöscht. So und jetzt machen wir noch mal ganz kurz hier ein bisschen Platz.
Max. Cash. Alter, was ist denn hier alles gecashed, Mann? Share. Jet Brands. Okay, ergibt Sinn. Okay, wie, wie klärt man?
Cash. Clearing Cash. Ja, wie geht das? Okay.
Do you want to remove all other packages from cash? Yes. Yes. Do you want to remove all other? Yes. Yes.
So, ich hoffe, ich habe mir jetzt nichts kaputt gemacht, aber schauen wir mal. Sehr gut. So, jetzt haben wir jetzt 75, 45G wieder frei. Excellent. So muss das sein.
Alles klar. Gut. Dann installiere ich mir mal irgendein Jet Brands Ding mit Rust Plugin. Kengi, Moin. Da ist er. Moment, ich wollte nicht weiter. Ich wollte die Toolbox öffnen.
Soll wohl auch für Web-Anwendungen eine gute Alternative. Go ist jetzt, ganz im Ernst, ich glaube nicht, dass Go bei Web-Anwendungen wahnsinnig irgendwie jetzt den hohen Marktanteil hat. Ich meine, es gibt ein paar Web-Frameworks, es gibt Leute, die machen größere Web-Anwendungen mit Go-Backend.
Aber Go ist vor allem im Cloud-Umfeld ziemlich beliebt und für Kommando-Zeilen-Tools und Static Binaries. Also Go ist eine wunderbare Geschichte. Ich habe so ein paar Kritikpunkte an der Syntax und ein paar Sachen, die ich nicht ganz nachvollziehen kann.
Auf der einen Seite hast du zum Beispiel drei verschiedene Sorten, wie du Variablen anlegen kannst, aber sie wollen immer noch, dass du drei Nested Loops machst, um ordentlich durch Arrays durchzufräsen und dort was rauszufiltern.
Wie gesagt, auf der einen Seite irgendwie ein bisschen viel, auf der anderen Seite ein bisschen wenig. Aber insgesamt ist Go immer noch ganz nice. Vor allem, wenn man das an C++-Standards misst, dann ist es hyper nice.
Ja und Go hat jetzt auch Generics, wobei die Syntax wohl auch nicht so geil sein soll.
Ja, Switchbot ist preislich nicht so super attraktiv. Ich habe allerdings noch zwei Stück hier auf Lager, weil man braucht immer mal was, ja auch Sachen zu checken, ob irgendein Key in einem Dictionary drin ist. Der Go-Way ist da auch jetzt nicht so geil.
Das coole ist an den Switchbots, dass du damit alles irgendwie smart machen kannst, was ein Button hat, wo du nicht dran rumbasteln willst. Dafür habe ich auch noch ein paar auf der hohen Halde, also zwei Stück.
So Leute, macht es einen Unterschied, ob ich C-Line installiere oder IntelliJ. Ich installiere wahrscheinlich C-Line, weil vielleicht machen wir ja mal wieder ein bisschen Arduino Zeug.
Ich habe bei mir auf der normalen VM, die ich verwende, wenn wir nicht sind, habe ich im Prinzip auch Goland Rider C-Line drauf, weil ich das teilweise netter finde als Platform I.O. in Visual Studio Code.
Tom, PC, Dankeschön für den Zap. So, C-Line, auf geht's. Nee, auf Vim habe ich jetzt keinen Bock.
Wie gesagt, ich war früher der richtige Vim-Addikt. Ich habe 800 Zeilen Vim-AC oder noch mehr gehabt, keine Ahnung und irgendwie 40 Plugins und sonst was.
Das kenne ich, das habe ich gesehen, aber das machen wir jetzt erstmal nicht. Ich brauche ja kein Web-Framework.
Ich brauche ein paar Funktionen, die ich aufrufen kann im Browser von JavaScript aus. So, ich habe ein Tutorial gefunden für diese ganze Geschichte.
Das war Rust WebAssembly. Das sah eigentlich ganz gut aus, das da. Das machen wir nicht durch, wir machen bloß das Hallo Welt da draus.
Okay, also, Opening. Dann Open mal. Ich finde es immer geil, wenn Java ohne irgendwelche Settings geladen wird, wie schön das Frontrendering ist. Sagt doch mal, das ist doch eine wahre Augenweide.
Plugins. So, Rust, guck mal da. Ist ziemlich beliebt. Erstes Plugin, was empfohlen wird. Rust. Ach so, bevor ich Rust installiere, sollte ich vielleicht mal Rust installieren, oder?
Habe ich Rust 19? Ja, aber Rust alleine bringt mir nicht. Ich brauche Rust Up wahrscheinlich. Ich erinnere mich noch dunkel, dass man sowas... Oh.
Are in Conflict. Ich glaube, ich brauche Rust Up, aber das werden wir gleich sehen.
Weil wir brauchen ja zusätzliche Tool-Chains und Dinger. Vielleicht geht das auch mit Cargo. Ich weiß es nicht. Nee, Conflict sagt er jetzt bloß, weil beide das Rust-Kommando zur Verfügung stellen.
Cargo, Cargo habe ich bestimmt. Ja, ja. Und ich habe auch ein aktuelles Rust. Guck mal hier, Repos, MK, wobei wir machen das irgendwie.
Ja, mit Rust Up kannst du doch so... Also wenn ich mich doch richtig erinnere dran. Mit Rust Up kannst du dann auch zusätzliche Tool-Chains installieren, oder kannst du sagen, ja, ich hätte gern den Rust-Compiler für WebAssembly, ich hätte gern den Rust-Compiler für ARM, ich hätte gern auf Musel-Basis. Ja, das gibt es wirklich. Das ist so eine minimale C-Library.
So, und nun? Wie geht es jetzt weiter? Ich habe jetzt Rust-Plugin installiert. Gibt es ein Plugin für HolySea? Nee. Nicht TempleOS Confirmed. Ok, neues Projekt, Rust. Ok. Language Standard C++14.
Ich... Ist es Procken? Leute, ist das Plugin Procken? Wenn ich hier was anklicke, dann ändert sich was. Wenn ich Rust anklicke, passiert gar nichts. Restarten? Ok, wir Restarten.
Im Zweifelsfall, Reboot tut gut, ne? Hast du schon mal was mit dir im... Nee, aber ich weiß, was es ist. Das ist so ein Stateless Overlay mal Ding für C und C++.
So, und jetzt? Ah, tatsächlich. Ok, wir müssen doch kurz in das Tutorial reingucken, aber ganz wichtig. Ah, yes. Darkreader an. Setup. Erstmal Setup angucken.
Rust-Toolchain. You will need Rust-Toolchain in Rust-Up, Rust-C und Cargo. Ok, Leute, ich brauche Rust-Up. Warum?
NPM zum NPM installieren. MonkaS. Was ist der Unterschied von einer IDE und Vim zu Emacs? Es ist standardmäßig einfach mehr dabei. Bei Vim und Emacs musst du dir sehr viel selbst bauen.
Und viele Sachen gehen da auch jetzt nicht so schön, wobei vieles mit externen Tools gelöst wurde. Also, zum Beispiel eine Sache, die in Vim nie so schön ging, war beispielsweise Auto-Completion-Pop-Ups.
Vim hat zwar eingebaute Auto-Completion-Pop-Ups, aber wenn du beispielsweise ein Pop-Up... zeig dir, was ich meine. Ja, in Mineo-Vim funktioniert das gut. Vielleicht geht es mittlerweile auch, weil die ja vieles übernommen haben.
So. Auf, starte mal. Das ist der Vorteil von Vim, der Startestelle. Also, wenn du sowas hier hast, zum Beispiel so ein Auto-Complete-Pop-Up, was du machen kannst, das ist halt richtig Pain's Jam gewesen, zum Beispiel Vim früher umzusetzen, weil Vim hat halt keine Möglichkeiten gehabt, außer ein Pop-Up zu machen.
Also, wenn du sowas programmieren willst und du hast nur ein Pop-Up, wo du einfach nur Text reinschreiben kannst, ist es halt ein bisschen eklig. Also, du brauchst ja Zusatzinformation. In welchem Namespace ist das? Ist es eine Methode? Ist es ein sonst was anderes Icon?
Mit so Sachen wie Language Server ist es ein bisschen besser geworden, aber sowas ist halt wirklich eklig in Vim. Aber in der Regel kann man sagen, Vim ist halt standardmäßig ein Out-of-the-Box-and-Text-Editor, der in irgendwie 5 Millisekunden gestartet ist.
Wohingegen meine Ideen erst mal 30 Sekunden Booten richtig tun, dafür Out-of-the-Box deutlich mehr Funktionalität haben. Wie ist der aktuelle Stand bei der China-Chinesen-Wetterstation? Die funktioniert, die steht draußen und liefert Zeug.
Ok. Hello World. Cargo Generate. Shit. Ich will kein Game of Life generaten, ich will Hello World generaten.
Oui, Alok. Was für ein Ding. Ok, Leute, ich weiß noch nicht mal, was ich überhaupt installieren muss. Wasumpack.
Get Wasumpack hier. Ja klar. Wie ich das mag. Erst mal schön reinpasten. Jaja, ganz bestimmt. Gibt's Wasumpack? Gibt's das hier? Wasumpack, da ist es doch, sehr schön. Wasumpack. Mach mal so ein Package Manager.
Cargo Generate. Cargo Install, Cargo Generate. Ok, ich mach mal kurz ein neues Repo. Wobei, das installiert man wahrscheinlich einfach so, oder?
Ach nee, jetzt mach ich's in meinem Heimatverzeichnis. Man hätte das, glaube ich, doch im Projekt machen sollen. Oder ist es jetzt global? Ich mach das einfach mal. NPM hab ich installiert. Ok, also Hello World.
Was lädt er da eigentlich? Das ist ja fast schon schlimmer als bei NPM.
Auf Cargo. Steht vor Schanghai rum. Kommt nicht rein.
Warum soll ich? Was ist das eigentlich für ein bescheuertes Tutorial? Ich glaube, das machen wir doch nicht. Ich will doch kein Git Repo klonen von sonst wo. Ich will einfach mit einem simple Hallo Welt anfangen. Ok.
Rust Web Assembly. Gibt's da ein besseres Tutorial?
Introduction. Nee, das ist das gleiche.
Gibt's ein Compiling from Rust? Ok, die Mozilla Dinger sind teilweise gar nicht schlecht.
Was? Ach, das kann man auch über Cargo installieren. Warum schreiben die das nicht gleich?
Oh, es kompiliert. Aho Korrasik wird kompiliert. Alles klar.
Ich weiß sogar noch ungefähr, was das ist. Das war irgendeine String Match Library. Die gab es damals auch schon, wo ich mir Rust eingeschaut habe.
Jetzt habe ich mir gemerkt, weil der Name so weird champ war. Es wird gerade wirklich das halbe Internet runtergeladen. Kann das sein?
Ich weiß noch nicht, ob ich plötzlich Five Head bin. Das muss ich mal sehen. So, und dann macht man neues Cargo Projekt. Und dann macht man It Works.
Ach du Scheiße, das ist ja richtiger Five Head Kram. Was für eine Leitung. 400 MBit drunter. Ich mache das einfach, wie Mozilla das sagt. Mozilla hat Ahnung.
Auf, gib ihm. Ich kompiliere, ja, aber das soll man völlig schneller kompilieren.
Single Threaded Compilation. Weird Champ.
Okay, da brauchen wir anscheinend noch ein bisschen.
Das ist. 33 Minuten. Das ist.
Petalburg City aus Pokemon Omega Ruby und Alpha Sapphire. Alles klar. Jetzt weißt du Bescheid.
Wie ist dein Workflow mit VMWare und der virtualen Maschine, die läuft? Hast du einfach ein extra Bildschirm? Nö.
Mehrere Desktops. Oh, er ist fertig. Hab ich wahrscheinlich.
Ne, hab ich nicht. Okay.
Wo ist mein Path hier?
Ich habe da schon ganz schön viel Müll drin. Okay, bin Cargo. Alles klar.
Cargo. Generate. Alles klar, hat funktioniert. Sehr schön. Ups, jetzt habe ich meine Shell zugemacht. Also auf geht's. CD, Repos.
Macht einen eigenen Ordner. Wenn ich Cargo New mache, macht er einen eigenen Ordner, der Hello Wasm heißt.
Oder oder legt er das im aktuellen. Ach, in der Subdirector. Ja, steht doch da. Hello Wasm.
Alles klar. So, dann öffnen wir das mal. Gucken, ob das Ding was taugt. Was ist denn die? Ich habe keine Ahnung. Das weiß ich auch jetzt nicht mehr. Ich habe wirklich keinen Schimmer mehr.
Also, Repos. Hello Wasm. Nicht der Label-Champ. Cargo-Tommel. Auf geht's. Open Project. Trust. Wir trusten alles. Bei dem Hello World Project kann ich allzu viel falsch.
Okay, was will der von mir jetzt? Genau. CMake? What the fuck? Oh no. Cargo fail. Warum?
Warum? Cannot attach standard lip sources automatically. Okay, also muss ich doch Rust Up installieren. Meine Güte.
Also, Rust Up. Ja, ist in Konflikt. Alles gut. Yes. Und wie stand das jetzt in der Anleitung? Setup Instruction. Okay.
Der hier Rust Up. Und nu? Rust is managed by Rust Up to Rusta63. Blablabla. Rust Up. Und nu? Wie verwendet man das jetzt?
Moment. Rust Up self uninstall? Das Ding kann sich selbst... Nee, Update lädt ja nichts Neues runter. Ich muss ihm wahrscheinlich sagen install oder sowas.
Rust Up. Tool. Chain. Install. Stable. Wahrscheinlich wollen wir auch Stable haben. Vom 18.05. Ja, das ist ja noch nicht so lange her. Okay.
Wunderbar. Stable x8664 unknown Linux GNU. Oh, allow me to interject for a moment. Es ist nicht Linux, es ist GNU Linux.
Da ist es doch, Rust. Wunderbar. Auf geht's. Vielleicht geht's ja jetzt. Go installieren wir einfach? Das tatsächlich, ja. Das ist tatsächlich so.
Go installieren ist easy. Wobei, ganz ehrlich, das Rumgefundene früher mit Go Pass war auch nicht schön. So, er hat's gecheckt. Code with me. Jetzt net. So, wie wär's mit Schrift ein bisschen größer machen?
Und? Pack. Size 16. Immer noch zu klein. Hallo?
18. Es ist exellent. So, it works. Sehr schön. Da bin ich ja froh, dass es worked. Leute, was ist Standard? Was machen die ganzen Rust oder die ganzen Rust, wie Rust Crust Tachians?
Alter, warum müssen sich die Leute bei jeder Programmiersprache irgendwie komische Namen geben? Vier spaces, acht spaces, zwei spaces, tabs, backspace only, reverse indentation, was machen die? Vier spaces, ist das Standard?
Einrückung. So. Ja, was macht denn Cargo FMT standardmäßig?
Format. So, okay. Also, auf geht's. It works. Wunderbarer Test. Bester.
We won't use this test code at all, so go ahead and delete it. Gut, gut, dass wir das überhaupt haben. Ja. Let's write some Rust. Was im Bindgen?
Was für ein Ding? Okay, das wird jetzt einfach, das wird knallhart copy pasted. Was im Bindgen? Was im das? Das bedeutet wahrscheinlich, was er, da kann man bestimmt auch Parameter übergeben oder so. Nee, kann man nicht.
Das bedeutet wahrscheinlich, für was er JavaScript Bindings generieren soll. Sag mal, okay, okay, ich rate jetzt mal was. Das hier ist so was wie ein Import von JavaScript und das hier ist ein Export zu JavaScript.
Vermute ich jetzt einfach mal. Muss ich irgendwelche Dependencies eintragen? Das steht hier aber gar nicht.
Pifat. Using was im Bindgen to communicate. Okay. Calling external functions in JavaScript vom Rust. Okay.
Das steht unten. Werden wir gleich sehen. Ich will jetzt wirklich mal ein minimales Hallo Welt produzieren. Ja, das hatten wir, das hatten wir doch hier gerade schon. Warum macht er dann eigentlich überhaupt eine Zeile draus und nicht zwei?
Das interessiert ihn auch nicht. Compiling our code to WebAssembly. Okay. Cargo Tommel. Ja, Inni war gestern. Jason und Jaml ist auch out.
Rust setzte von Anfang an auf Tommel. Das kann ich mir noch dran erinnern. Das ist quasi so Inni plus in etwas besser. So bla bla bla bla bla bla bla. Das brauchen wir alles nicht. Crate Type cdlib. Alles klar.
Das weiß ich sofort Bescheid. Was im Bindgen Version 2? Muss es wirklich Version 2 sein oder kann es nicht einfach auch was neueres sein? Von wann ist denn das Tutorial? Was im Bindgen GitHub? Was sind die neueste Version davon?
Okay. Installiert er wenn ich 2.0. Ja, der war so schlau. Cargo war nämlich ziemlich ziemlich nice. Da kann ich mich noch dunkel dran erinnern. Der installiert jetzt die letzte Zweier Version. Also 0 2 80 wahrscheinlich.
Fill in your own repository GitHub bla bla bla bla bla. Okay. Was im Pack? Bild Target Web. Okay. Wenn das jetzt funktioniert, dann kacke ich aber eine Runde.
Wie das funktioniert. Smiley face. Was im Package ist? Package ausschreiben war selbstverständlich kein Platz mehr. Das verstehe ich.
Is ready to publish pkg. Hello wasm bg. Hello wasm bg. Guck mal sogar Typescript. Typescript support haben wir sogar.
Okay. Was im Browser will ich das ausführen? Also im Endeffekt brauche ich wahrscheinlich jetzt irgendeine. Genau. Index HTML. Und dann muss man den Krempel hier machen. Alles klar. Dann machen wir das doch mal.
Project. Okay. Ich glaube so ein bisschen HTML kannst du hier darin auch machen. So. Und. Das geht jetzt oder was? Das muss ich jetzt surfen. Gehe ich mal von außer ich brauche. Okay.
Genau das. Ohne Scheiß. Genau das hätte ich auch gemacht. Genau das hatte ich auch gemacht. Make sure to use an up to date web server that supports application wasm.
Alles klar. Application wasm. So und jetzt einfach starten da drin. Port 8000. Na dann. Schauen wir mal. Was da jetzt rauskommt bei. Localhost port 8000.
Hello web. Das war einfach. Das war wirklich easy. So also wenn ich das jetzt richtig gesehen habe passiert jetzt folgendes.
JavaScript. Also. Okay. Hier. Wir importieren unser WebAssembly Modul. Und rufen. Nachdem es geladen wurde. Mit. Ab artigster. Callback Syntax.
Rufen wir jetzt hier unsere Funktion auf. In WebAssembly die dann wiederum eine JavaScript Funktion aufruft. Okay. Das ist ziemlich sinnloser durch die Brust ins Auge. Aber. Why not. Ja.
Was ist der Vorteil davon. Dass du zum Beispiel C Libraries verwenden kannst und sowas. Im Browser. Das ist halt schon recht nice. Oder Rust Libraries.
Hello wasm. Muss man. Da muss das nicht. Du kannst mit JavaScript mehr oder weniger alles machen was du brauchst.
Aber zum Beispiel wenn du sowas wie FFM Pack im Browser haben willst dann kommste da dran nicht vorbei. Was es in Rust gibt was es in JavaScript nicht gibt.
Zum Beispiel FFM Pack bindings. Im Browser funktionieren. Wenn du FFM Pack im Browser verwenden willst kannst du das mit JavaScript alleine ziemlich knicken.
So. Jetzt versuchen wir mal es halbwegs sinnvolles zu machen. Schieben wir mal den Browser dahin. Ich meine es liefert immer das gleiche aus. Dann machen wir mal hier unten ein Terminal auf.
Und. Was musste man nochmal machen. Wasm. Wasm. Build. Target. Web. Musste man machen. Okay. Also damit kompiliere ich den Krempel. Alles klar. So. Das heißt im Endeffekt ich mache jetzt mal dieses Alert daraus.
Das braucht ja keiner. Print. Kann das auf die Konsole printen. Wahrscheinlich nicht oder. Kein Que. Das wird wahrscheinlich nicht funktionieren. Moment. Leute. Rust Semikolon oder kein Semikolon.
Darf ich fragen was FFM Pack ist. FFM Pack. Wobei ich weiß gar nicht ob du das gefragt hast. Ja. FFM Pack. Es hat nichts mit Frankfurter Mind zu tun. Was ich meine ist FFM Pack. Das ist eine Multimedia Library.
Die dir unter anderem erlaubt Streams zu empfangen. Anders zu encoden. Bilder zu extrahieren. Und nachdem das alles relativ low level ist kannst du da ganz abgedrehte Sachen machen. Du kannst zum Beispiel sagen. Ich empfange ein RTSP Stream von der Webcam.
Und extrahiere mir jedes Bild. Also decode jedes Bild. Und dann mache ich alle 5 Sekunden ein Bild was ich beispielsweise als JPEG rendere und dann auch in der Webseite anzeige. Irgendwie sowas. Du kannst ganz wildes wildes Zeug machen mit FFM Pack.
Ja vor allem. Vor allem als Decoder ist FFM Pack. Gut. Ich encode meine Videos übrigens auch mit FFM Pack. Aber gerade. Also was ich eigentlich hauptsächlich bisher verwendet hab immer. Und wo FFM Pack einfach best ever ist.
Wenn du Videos decoden musst. Wir haben schon öfters in Streams mal H264 Streams decoded. Und da kannst du halt FFM Pack verwenden komplett. Vom empfangen über RTSP. Über das extrahieren von einzelnen Bildern und decoden.
In normales. Nicht wirklich RGB. Aber ich sag jetzt mal RGB. Also FFM Pack ist extrem Pog G. Scheiße. Extrem Pog. Macht FFM Pack auch Audio. Macht auch Audio ja.
Du kannst beispielsweise mit FFM Pack wenn du jetzt das nicht als Library verwenden willst. FFM Pack besteht ja auch aus einem ziemlich umfangreichen Command Line Tool.
Kannst mit FFM Pack zum Beispiel sowas machen wie Videos kürzen ohne neu zu encoden oder Videos von TS in MP4 Container packen ohne neu zu encoden und sowas. Also FFM Pack ist wirklich nice.
So. Jetzt wollen wir mal gucken ob Print. Ob Print geht. Ob es auf der Konsole dann rauskommt.
Pfeilen und v. Ne. Ok. Also auf Konsole kann man nicht. Wie würde ich jetzt kon- Ok. Moment. Moment. Wenn ich den Kram doch importiere.
Das wird nicht funktionieren oder?
Rust. Import. Konsole. Log. Wasen.
Ah. Beispiele. Konsole. Log. Pog. Der Chat weiß schon wieder Bescheid.
Ok. Konsole. Konsole. Log.
FN Log. Ach. So. Ah. Ok. Verstehe. Verstehe. Verstehe. Der Name Space. Was ist bloß das Problem jetzt?
Ach. Extern. Extern muss ich machen. Ach. Hier haben sie es schon extern. Ah. Ok. Da kannst du dann so einen größeren Block dran machen.
Aha.
Ok. Ok. Verstehe. So. Das heißt ich kann jetzt von Representive Assembly auch was auf die Konsole loggen. Also Log.
CacW.
Bild.
Und CacW kommt auf der Konsole raus. Ok. Das ist schon mal nice.
Cute. Chat. Ah. Ja. Ja.
Funktioniert. Sehr schön. Pog. Nice. Das ist gut.
Bis jetzt habe ich alles verstanden. Das war zwar noch nicht viel, was wir gemacht haben, aber immerhin.
Das spricht nicht für das. Kommentare sind eh overrated. Das sage ich ja auch immer.
Guter Code dokumentiert sich selbst. Und wenn man dann auch fehlerfrei programmiert, braucht man auch keine Tests.
Und spart sich Zeit und ist schneller fertig. Easy.
Easy.
Alles overrated, outdated, gebadet.
Debugger und Breakpoints braucht auch keiner.
Command Line. CLI.
Konsole Log Debugging. Beste.
So. Gut. So. Was können wir denn jetzt mal wirklich sinnvolles machen?
Guck mal. Muss man diesen Krampel so Payneschampig aufrufen wie da?
Ich möchte meinen. Eigentlich möchte ich das mit zwei Tabs Einrückung haben.
Ich.
Haltet. Haltet ihr mich für sehr.
Cringe. Wenn ich mein HTML mit zwei Spaces Einrückung mag.
Willst du jetzt Champ oder?
Capsa ist zwei. Zwei.
Hier.
Da bin ich mir jetzt nicht sicher. Warum nicht auch zwei?
Next.
Format.
Wie?
Mich veräppeln.
Alter, lüg halt nicht.
Jetzt. Was ist das denn?
Das scheint nicht zu funktionieren. Ach, das ist wahrscheinlich für JavaScript.
Für JavaScript ist nochmal extra oder wie?
Wahrscheinlich ist für JavaScript nochmal extra.
So. Ja, genau. Wir wollen wir wollen auf jeden Fall das erwarten.
Irgendwie wie auch immer genau. Also sprich.
Gibt es eigentlich Top Level Await mittlerweile in JavaScript? Also.
So was da.
Wow, wow, wow.
Ich will nichts kommenden. Ich will auskommen kommentieren.
Geht Top Level Await wahrscheinlich nicht, oder?
Quatsch, das ist ja hier.
Oder doch?
Oder doch?
Wie ist denn standardmäßig in C-Line das?
Ach Mensch, Shortcuts.
Nee, wo geht das? Alter, warum ist das immer so versteckt?
Short.
Was muss ich noch mal gucken?
Comment? Ich meine, so kann ich, ich meine, ich kann auch sagen Comment.
Aber schön ist es nicht.
So, jetzt muss ich mir am Kopf überlegen. JavaScript.
Also das wäre dann quasi.
Warte mal, nee.
Ich würde einfach sagen Await in it.
Und dann sage ich Creed.
Das müsste doch funktionieren dann, wenn er ordentlich Awaited hat.
Funktioniert auch.
Ja, dann können wir uns dieses komische, dieses ekliche Callback Zeug sparen.
Okay, nice. Also.
So, jetzt lass mal in mich gehen.
Was könnte man dann irgendwie Sinnvolles machen da jetzt?
Was sagt denn das Mozilla Tutorial weiter?
So ein bisschen üben.
Ja, also Konsolok funktioniert Marco rules Konzo.
Alter, das nimmt ja fast C++ Ausmaße an mittlerweile.
Was ist denn das?
Was bin ich sehend?
Das erinnert mich ja wirklich fast schon ein bisschen an C++ Template, wenn ich sowas hier sehe.
Was ist das? Was macht das? Was tut es?
Es ist ein Template Argument, Funktionen und Lock.
Ist das, dass man beliebig viele Argumente locken kann?
Ist das, dass man möglichst viele?
Next, let's define a Marco like this.
Only it works for console lock.
Okay, das brauche ich nicht.
Das tut auch so.
Let JS JS value 4 into.
Alter, jetzt wird es aber.
JS value. Wo kommt denn das her?
Ist das standardmäßig hier einfach verfügbar?
Let JS value.
Okay, da kann ich quasi direkt JavaScript Variablen anlegen oder sowas.
Okay, dann müssen wir mal probieren, wie man Return Werte von Konsolen macht.
Also sprich, wie kriege ich einen Return Wert hier von zurück nach JavaScript?
Ich glaube nämlich, wenn ich später mal tatsächlich es hinbekomme, FFmpeg zu verwenden und Bild decoded habe.
So, und da kann man jetzt sagen Log.
Wobei das das geht jetzt ja nicht, oder?
Wenn ich sage JS.
Das ist ja kein String. Das mag er ja nicht.
Dann brauche ich dann brauche ich doch den Moment. Was macht er hier?
Into into was?
Boah, Alter, die die Rastzündung ist schon krasser Shit.
Lock 2.
Ach nee, Using Web Sus.
Ach so.
Warte, das gibt es schon.
Ja, warum habe ich das denn dann überhaupt selbst gemacht?
Ups.
Muss das Krait noch installieren?
Use of Undeclared Krait. Aha.
Das heißt, das muss ich erst in meine.
Tommelfile schreiben.
Benutzt einfach was im Logger zum Logger. Was im Logger?
Was im Logger Krait Github.
Mach ich.
Welches davon ist es denn?
GitLab, MonkaS.
Leute hosten wirklich jetzt auf GitLab.
Zwei Jahre ago. Nee.
Das will man wahrscheinlich nicht, oder?
Zwei Jahre.
Und das ist das ist noch älter.
Will man das?
Und was war das andere, was die hier hatten?
Web Sus Console.
Web Sus Console.
Was ich noch nicht ganz gecheckt habe, ist, Leute, wie installiere ich was?
Also da kann ich mich nicht mehr dran erinnern.
Ja, man kann das hier in seine Cargo Datei schreiben.
Aber woher weiß ich denn welche Versionen und so?
Kann ich nicht einfach immer sagen?
Gibt es nicht wie bei NPM beispielsweise ein Cargo install für die letzte Version?
Krait's I.O. OK.
Gratis Punkt.
Da kann ich mich noch dran erinnern.
Web Sus Console.
Das heißt aber ganz anders, woher weiß ich denn jetzt, dass es das ist?
Web Sus.
Ach nee, das brauche ich wahrscheinlich.
Das brauche ich wahrscheinlich.
Web Sus brauche ich wohl.
OK, also sprich, das muss ich in meinen Cargo schreiben.
Am besten schreibe ich doch so, oder?
Da mache ich immer die neueste 3er Version rein.
Ah, jetzt ergibt es schon.
No Console.
OK.
Klick auf die Kiste daneben.
Was?
Welche Kiste?
Den C-Line?
Ach hier.
Ah, das ist ja cool.
OK, nice.
Console.
Warum gibt es das jetzt angeblich nicht?
Und warum kriege ich kein Autocomplete davon?
Tja, so einfach ist das nicht.
Ähm, ja und du?
No Console in root.
Was soll mir das jetzt sagen?
Da steht es doch, dass es das gibt.
Und vor allem, warum gibt es kein Autocomplete?
Muss man das oben importieren vielleicht?
Irgendwie da?
OK, das triggert mich schon wieder.
Warum funktioniert das nicht, obwohl das eindeutig so da steht?
Und warum kriege ich kein Autocomplete dafür?
Ich hab das bei mir drinne stehen.
Features gleich Console.
Wo steht das denn?
Aha.
Und woher weiß man das jetzt?
Console.
Wohin soll man das wissen?
Also.
Features.
Console.
OK.
What?
Alter, was will das von mir?
Das muss in eine eigene Dependency.
OK, ich copy paste das jetzt einfach aus dem Chat.
Das ist sowas.
OK, da wäre ich ohne euch nicht drauf gekommen.
Keine Ahnung.
Alter, wo ist denn das Problem, was will das von mir?
Warum ist das angeklärt?
Ach so, weil ich es rausgeschmissen habe.
Ich habe nichts gesagt.
Kriege ich denn jetzt?
Kriege ich jetzt Autocomplete?
Ach, jetzt kriege ich Console.
OK.
Ah, das ist doch schon besser.
Jetzt funktioniert es.
OK, jetzt können wir wirklich auch Zeug loggen.
Das ist schon mal nicht verkehrt.
OK, also, wie macht man Return Werte?
Da muss ich jetzt mal schauen.
Also, haben die das hier drinnen stehen?
Nee, aber wie macht man Return Werte?
Also quasi, das nennen wir jetzt nicht Creed.
Das nennen wir jetzt irgendwie Pog.
Return Pog.
Heißt das?
So, und wir machen mal was einfaches.
Wenn ich das jetzt noch richtig in Erinnerung habe,
musste man doch Return Code in Rust irgendwie so machen.
Ibi32 oder so.
Ja, so ging das.
Hab ich noch im Hinterkopf, dass das irgendwie so funktioniert hat.
OK, so, jetzt wird das hier abkacken, weil es gibt es nicht.
Und wir rufen jetzt nicht Creed auf,
sondern Return...
Oh, guck mal, sogar Autokomplete im HTML.
Das ist cool.
Return Pog.
So, Return Pog.
Brauchen wir eigentlich gar kein String übergeben.
Return Pog kriegt einfach nur Return Wert von 1.
OK, und jetzt?
Let E gleich?
Nee, so einfach wird das nicht sein, oder?
So einfach wird das doch nicht sein.
Doch.
Tatsächlich.
Chat bisschen höher.
Ja, ja, ja, hast recht.
Ich mach den Chat oben rechts hin.
Oben rechts ist ja sonst nichts Wichtiges.
Hier oben, das muss man glaube ich nicht sehen.
Wobei doch, da ist es über dem Browser.
Oben links?
Wo braucht man einen Chat gerade am wenigsten?
Gar keinen Chat, nee.
Nein, nein, wir plätten den Chat nicht aus.
Der Chat ist Pog.
Direkt über die Katze?
Ich weiß, was ich mache.
Der Chat bleibt hier unter Chico.
Wie habe ich den Chat sonst immer so hier, glaube ich.
Und wir machen was anderes.
Wir machen was anderes.
Ach, Quatsch.
Moment, das muss ich so machen.
Wir machen einfach so, guck mal.
Nur kurz schauen, ob das jetzt hinhaut.
Und da unten, zur Entspannung, kann Chico Fische fangen.
Das reicht von der Quatsch.
Kann Chico Fische fangen.
Sehr gut.
Alles klar.
So, weiter im Text.
Okay, Inns sind tatsächlich relativ einfach.
Wie returnt man einen String?
Ich erinnere mich, das war in Rust generell ein bisschen painstamp mit Returnwerten, weil
du musstest immer sagen, returnst du eine Referenz, returnst du quasi das Ownership
oder nur, nur, nur, wird das nur ausgeborgt oder sonst was.
Das ist ganz kompliziert gewesen.
Also einfach nur String geht wahrscheinlich nicht, weil String immer eine Referenz ist
oder warum ist das so?
Ich kann mich noch dran erinnern, in Rust gab es auch sowas.
Da habe ich, da habe ich aber dann damals aus, bin ich damals ausgestiegen.
Keine Ahnung, was das macht.
Das ist irgendwas für Lifetime.
Fail to execute.
Jetzt geht's schon los.
Jetzt geht's schon los.
Und warum?
Error.
Ach, weil dann ein Warning an ist oder was?
Das ist ja schon fast, das nimmt ja schon fast Go Ausmaße an.
Ne, das will ich ausschalten.
Wie macht man solche Flags aus?
One unused defaults, bloß nicht.
Das erinnert mich fast an Go-Generfe.
Ja, wie macht man das?
Ok, Agnus, disable Rust.
Allow dead code klingt gut.
Das ist das schönste.
Ok, das geht schon mal nicht.
Compiling your create to WebAssembly failed.
Weil cannot return borrowed ref.
Ok, das ist jetzt diese typische Rust Geschichte.
Rust ist äußerst korrekt darin, wenn du Sachen machst, die out of scope gehen können.
Weil es ist jetzt ja so, ich returne hier eine Referenz zu einem String.
Aber sobald ich hier rausgehe, ist der String ja eigentlich schon wieder gelöscht.
Das heißt, ich returne eigentlich was, was es gar nicht geben sollte.
Kann man einfach String machen?
Geht sowas?
Ne, oder?
Ok, jetzt hab ich keine Ahnung, wie ich den String returne.
Ehrlich gesagt, sodass es funktioniert.
Rust String.
Ich hab wirklich keine Ahnung, wie es funktioniert.
Ich erinnere mich dran, man musste glaube ich String new oder sowas machen, oder?
String from?
Sowas muss man glaube ich machen.
Oder new?
Irgendwie sowas war das doch, oder?
Wie gesagt, ich hab Rust vor Jahren mal gemacht, oder?
From?
Oder into String?
Ne.
Und jetzt keine Referenz, sondern direkt in String, oder wie, oder was, oder wo?
Aha, nein.
Das geht auch nicht.
Method not found in Static String.
Das stimmt, Patrick, das ist wirklich so, true String.
Ok, das hat jetzt funktioniert.
Ich hab keine Ahnung, was der Unterschied ist zwischen...
Ah, das eine ist bloß eine Referenz oder so?
Ne.
Hä?
Ok, das eine gibt ein Box String und das andere gibt ein String.
Alles klar.
Ok, also Strings hin und her geht auch relativ einfach.
So, jetzt, jetzt...
Also, die Sache ist die, wenn wir irgendwie mal...
Raw Daten returnen wollen, brauchen wir einen Byte Array.
Ähm, wann war das?
Let?
Das war auch Let.
Let Mut?
Boah, mein Rust ist lange her.
Und jetzt U8?
Ne.
U8?
Ach du große Güte, was ist denn das?
Hardware Instructions?
Ne.
Also, also.
Byte Array Rust.
Ich hab keine Ahnung.
Ich mein, das heißt einfach Byte Array?
Wirklich?
Ne, das ist, das ist irgendein, das ist irgendein Create.
How do I create an empty Byte Array?
Genau das will ich wissen.
Weg, weg war's.
Ich erinnere mich wieder.
Wobei, ne, ne.
Byte Array, ach so war die, war die Array sonntags.
Wie nimmst du Underscore Result?
Ne.
Okay, also das ist ein I32.
Und konnte man das an U8 oder so hinten dran machen?
Ja, genau.
So, das ist jetzt ein Byte Array mit 24 Stellen.
Das ist doch richtig so, ne?
So, okay.
Mutable muss es nicht sein.
Und das kann ich jetzt aber höchstwahrscheinlich nicht einfach so return.
Ist das hier der return Wert?
Ne.
Okay.
How to return a Byte Array.
Rust.
How return Byte Array.
Ach, muss man, muss man.
Und U8 ist es.
Ah.
Aber Und U8 kann doch nicht funktionieren, weil sobald das hier aus dem Scope geht,
und das geht hier aus dem Scope beim return, ist es doch undify, das erlauben die mir doch garantiert nicht.
Das geht mit Vektors, geht das wahrscheinlich.
Okay, das funktioniert.
Okay.
Und die Rust-Logik ist jetzt folgendes.
Solange ich keine Referenz returne, ist das okay, weil dann returne ich ja Ownership zum Aufrufer von diesem Ding.
Also quasi, dass der Aufrufer übernimmt das dann quasi.
Ich, wie gesagt, ich hab Verurteil...
Ach, fick dich, Alter.
Was willst du denn?
Oh.
Das funktioniert nicht.
Okay.
Das kann man nicht returnen.
Das muss man irgendwie anders machen.
Kann man den Vektor returnen?
Wahrscheinlich auch nicht.
Äh.
Moment, wie ging das nochmal?
Weg.
Einfach weg, Ausrufezeichen.
Und jetzt ist er leer, oder?
Leerer Vektor?
Ne.
Eins.
Konnte man sowas machen?
Eins.
U8.
Oh.
So, und jetzt muss ich was returnen?
Into?
Rockslice.
Alter, das ist so ein Fiveheader-Kram, diese Sprache, ist der Wahnsinn.
Äh, und jetzt müssen wir wahrscheinlich einen Vektor returnen.
Wobei, mit einem Vektor kann ja JavaScript nichts anfangen.
Das kann ja, das kann ja eigentlich gar nicht funktionieren.
Doch, das geht.
Ah.
Der macht da gleich einen kompatiblen JavaScript-Typ draus.
Der macht ein U8-Array draus.
Das ist, das ist sehr gut.
Das ist sehr gut, dass der das macht.
Weil so kriege ich mein Zeug von FFmpeg, die codet in Frames, auch zurück nach JavaScript.
Okay, das ist Fiveheader-Time.
Das ist cool, dass sie das unter der Haube machen.
Ich stelle mir vor, wenn man das von Hand machen muss, ist eklig.
Ich stelle mir vor, wenn man das von Hand machen muss, ist eklig.
Das können wir jetzt theoretisch sogar auslesen.
Kann man sagen, keine Ahnung.
I, 0, das sollte 1 sein.
Ja, ist 1, passt.
Sehr cool, das ist nice.
Dein Returnvent muss den Into Wasom Abitrade implementieren.
Ich hoffe, dass alles, das schon standardmäßig, was ich brauche, drin ist.
Okay, das ist tatsächlich äußerst spannend.
Das finde ich cool.
Ich will jetzt nicht gleich mit FFmpeg hier draufhauen, weil FFmpeg ist eigentlich das, was ich ausprobieren will.
Weil ich gehe davon aus, wir werden noch ganz viele Probleme rennen, um überhaupt FFmpeg zum Laufen zu bekommen.
Man kann es ja mal probieren.
Direkt nach dem Hallo Welt und Print 1 gleich mal FFmpeg included und auf geht's.
Ich meine, warum nicht?
Scheiß drauf.
Was soll FFmpeg überhaupt machen?
Also, ich, wartet mal.
Also ich habe mir folgendes überlegt, rein um sich mal ein bisschen mit Rust und WebAssembly zu beschäftigen.
Wir haben noch den EPG-Champ programmiert.
Allerdings, also ich will das nicht releasemäßig in den EPG-Champ einbauen.
Wer den EPG-Champ nicht kann, ich zeige den EPG-Champ nochmal.
Das ist ein Webfrontend für TV-Headend, dass man auch ordentlich auf dem Tablet und überall sein EPG angucken kann.
So, und ich habe mir jetzt gedacht, und wie gesagt, nicht releasefertig einbauen.
Man könnte doch beispielsweise einbauen, dass man sich ein Video streamen kann von TV-Headend.
Das geht standardmäßig schon. FFmpeg kann das auf TV-Headend-Server-Seite transcoden für ein.
Weil der Browser kann ja kein mpeg2h263, ist das glaube ich dann.
Der Vorgänger von H264.
Also das, was man heute so zum größten Teil des Videos hat.
Das können Browser nicht. Und deswegen habe ich mir gedacht, warum Server-seitig machen,
wenn ich mir das Video schicken lassen kann und on the fly mit FFmpeg im Browser transcoden kann.
Nicht, dass das irgendwie produktionsreif mal werden würde.
Aber mich interessiert einfach, ob das performanstechnisch möglich wäre.
Also kann man mit FFmpeg im Browser ein SD-Video, also PAL hat ja nur 720x580 oder sowas.
Ich brauche was im FFmpeg. Richtig.
Und von der Idee her würde ich es dann so machen.
Du lässt dir von einem Endpunkt, von einem Web-Server-Endpunkt streamen mir das Video-File runter.
Übergebe das häppchenweise an FFmpeg in Wasm und krieg einen decodeten Frame zurück.
Soweit die Idee.
Das hört sich jetzt abstrakt gesehen relativ easy an.
Aber ich glaube praktisch ist das durchaus ziemlicher Abfuck und gar nicht so easy, wenn man sich das vorstellt.
Das heißt mein Ziel wäre jetzt erst mal zwischenzeitlich, ob ich überhaupt FFmpeg eingebunden kriege
und ob ich vielleicht ein Test-Bild aus FFmpeg raus bekomme.
FFmpeg kann ja Test-Bilder generieren, da brauche ich keinen Input.
RGB, RGB, Test-Bilder.
Also guckt, FFmpeg kann FFmpeg Generate, Test, Test-Pattern, Test-Pattern.
Ja ne, ne, das ist besser.
Oh fuck, das musst du mit Filter machen. Mit Filter ist schonmal eklig.
Filter will man eigentlich nicht, nicht.
Ja, da kommt so ein Test-Bild raus.
Oder wir nehmen einfach, wir nehmen einfach einen PNG oder irgendwas.
Irgendwie etwas. Aber wie kriegen wir denn jetzt überhaupt FFmpeg?
Rust da rein.
Safe FFmpeg Wrapper, das brauchen wir nicht.
Simple and Safe Rust Interface, das brauchen wir schon eher.
Rust AC FFmpeg.
Also ich brauch was, wo ich wirklich Raw Zugriff auf FFmpeg habe.
Und zwar Wasm.
Nicht einfach nur Rust FFmpeg, Rust Wasm FFmpeg.
Rust FFmpeg Wasi, das klingt doch schonmal gut.
Letztes Jahr reicht mir immer noch.
FFmpeg Libraries pre-compiled for WebAssembly Wasi als...
Ach du Scheiße, ich hab keine Ahnung.
Null?
Ey, das klappt doch im Leben nicht.
Das klappt doch im Leben nicht.
MonkaS
Ist das...
Source
AV Codec RS
Geh auf.
Okay, das sieht nach...
Das sieht nach FFmpeg aus.
Das sieht nach FFmpeg aus, ja.
Alter, der hat sich aber einer Mühe gegeben.
Ich mach das jetzt einfach rein, ich hab keine Ahnung, was ich da treibe.
Weil mein Ziel ist eigentlich wirklich, ich will FFmpeg reinkriegen.
Ne, so.
Version 0, alles klar.
Bild.
Das kackt wahrscheinlich schon beim Bild ab gleich.
Ne, ne, ne.
Help.
Convert identifier to snake case.
Aha, okay.
Also, Rust Style ist nicht Return Pog, sondern Return Pog.
So macht man das, so machen das also die coolen Rust-Leute.
Snake Case.
Nicht Pascal, nicht Kebab Case, Snake Case.
Return Pog.
Noch funktioniert's, noch geht's, alles gut.
Okay, und wie würd ich jetzt...
Okay, ich hab keine Ahnung, wie ich FFmpeg verwenden würde.
So, immer include und gucken, ob's immer noch kompiliert.
Nein.
Unknown Instruction Block.
Na, geil.
Ich glaub, das kann ich vergessen.
Ich mein, ist ja auch geil.
Die Fehlermeldung ist jetzt nicht so das geilste, oder?
Rust Backtrace 1.
What the fuck?
Rust Begin Unwind.
Okay, also...
Das funktioniert nicht.
AV Codec brauch ich, wenn überhaupt.
Nee, Leute, also FFmpeg krieg ich da nicht so einfach rein, wie ich mir das gedacht hab.
Hat irgendjemand einen Plan, was ich jetzt überhaupt gucken könnte, wo der Fehler ist?
Ich glaub, man hat einfach gelitten, hör.
Exited Status Code 101, super, da weiß man Bescheid.
X Autist Prime, Dankeschön für den Sub.
Nee, das kannst du vergessen, sobald ich diesen Krempel hier einbinde, dann ist... dann kackt der ab.
Ohne geht's.
Issues, Closed.
Document Build Process.
Ich hab legit keine Ahnung, was ich machen soll.
Gibt auch FFmpeg was im Jahr, das bringt mir aber nichts.
Das ist quasi der Kommandozahlen-Rapper.
Ich brauch Low-Level-Access, oder hat FFmpeg was im wirklich Low-Level-Access, dass ich sagen kann, ich will AV-Packages haben und sowas?
Ich glaube nicht, das ist das Kommandozahlen-Tool gerappt.
Also das hab ich mir nämlich letztes Mal auf dem Handy angeguckt.
Es gibt zwei Sachen, es gibt FFmpeg was im und es gibt noch ein anderes Projekt.
Und die machen dann bloß so Sachen, wie zum Beispiel sowas hier, die quasi aufrufen von der FFmpeg Kommandozahlen-Dings und...
Das will ich nicht.
Okay, also dieser Krempel funktioniert, also schauen wir mal nicht.
Rust FFmpeg war so...
Da find ich bloß das.
Das sagt.
Okay, dann weiß ich nicht, was ich jetzt machen soll.
Ich mein, das ist ja komplett nichts sagen, vor 15 Monaten irgendwann mal aktualisiert.
Das geht wahrscheinlich einfach in der aktuellen Rust-Version schon gar nicht mehr.
Sobald ich das einbinde, ist F angesagt.
Kann er nicht, kann er nicht binden.
Und ich mein, ich hab das gemacht, was der Typ geschrieben hat.
Exakt das eingetragen.
Geht nicht.
Tja.
Dann wird das mit irgendwelchen FFmpeg Sachen heute schon mal erst nichts.
Unknown Instruction Block.
Wirklich, keine Ahnung, keine Ahnung.
Das wäre aber auch zu schön gewesen, wenn das einfach funktioniert hätte.
Schau mal die Fehlermeldung näher.
Es gibt keine wirkliche Fehlermeldung zu googlen.
Das ist alles so Generic Zeugs, wo du nichts mit wirklich anfangen kannst.
Ja.
Ja gut, ich hab es halt rausgeschmissen.
Naja.
Aber von der Idee her wäre ja jeder Krempel drinnen gewesen, den ich haben will.
AV Packet.
Genau, diesen Krempel will ich haben.
AV Packet zum Beispiel.
AV Packet und dann will ich den Stream lesen und sonst was.
Ja, keine Ahnung, wie das funktioniert.
Es gibt ja auch, es gibt ja anscheinend auch keine ordentlichen Anleitungen dafür.
Wir können mal suchen, ob wir dazu was finden.
Docs, ES.
Usage.
Tja.
Normalerweise muss man auch sowas wie FFM Pack.
Load.
Gibt es aber nicht.
FFM Pack.
Load.
New AV Package.
Ne, das geht ja nicht.
Normalerweise machst du AV Packet, A-Log und so Dinger.
Wobei das Rustbindings sind, wer weiß wie das funktioniert.
Call unsafe function requires unsafe function.
Alles klar, unsafe.
Ne.
Unsafe.
Unsafe.
Aha, einfach mal geraten, wo das unsafe hin muss.
Ne.
Aha, das geht nicht.
Aha, aha.
Das müsste ich dann rappen in irgendeine Rust Funktion oder so.
Aber ganz ervernehmt, es kompiliert ja eh nicht.
Also, kann ich jetzt sagen, quasi FM.
Hat es kein Makro oder so für die IDE?
FM.
CACW.
Eigentlich egal, weil es funktioniert nicht.
Unsafe.
Unsafe.
Ok, wie gesagt, es funktioniert nicht.
Wo ist das Problem?
Warum könnte er das nicht mal aufrufen?
Ah, call to unsafe.
Ok, das ist nicht winzig sharp.
Das einmal unsafe reicht und das zieht quasi unsafe mit.
Ok, das würde funktionieren.
Ne, also das funktioniert nicht.
Funktioniert anscheinend, ja.
Ja, aber du musst unsafe verwenden, wenn du raw ffmpeg verwenden willst.
Aber ganz ervernehmt, es funktioniert ja eh nicht.
Er ist der Meinung, äh, ja, panicked.
Block.
Und man findet dazu auch nichts.
Wasm.
Und ansonsten, es gibt da keine README dazu.
Das ist halt sehr...
Ok, Rust, ffmpeg, github.
Ich will keinen safe wrapper haben.
Wasm.
Äh, ich...
Es wird nichts großartig gebastelt.
Ich versuche mir gerade Rust mit WebAssembly anzugucken.
Also irgendwann mal will ich...
Kann man Features hinzufügen vielleicht?
Irgendwann mal will ich ffmpeg ausprobieren im Browser damit.
Aber das ist nicht wirklich Ziel.
Ich hab' bloß gedacht, es ist einfach.
Package einbinden und es geht.
Aber so einfach ist es nicht.
Also ich hab' keine Ahnung, wie man das bildet.
Kann man jetzt aber...
Rates?
Was ist, wenn man da jetzt mal nach Web... nach, ähm...
ffmpeg sucht?
ffmpeg.
ffmpeg.
Ja, die bräuchte ich, aber ich brauch das für die WebAssembly Version.
Du hast dein Browser zugemacht.
Nee, du hast irgendeine Electron Anwendung zugemacht.
Wasm.
Wasi.
Wasi?
Da gibt's nur eins.
Ja, das sucked.
Okay, das funktioniert nicht.
Es war Java, war es.
Okay.
Ja, also wie der Shit funktioniert, weiß man nicht.
Document Build Process closed.
Okay.
Was zum...
Es ist einfach ein Link.
Random auf irgendwas.
Was ist...
Was ist zig?
Will der Typ uns irgendeinen Crypto-Miner-Dingsen, oder was?
Geile Bild-Documentation.
Ganz, ganz grandios, ja.
Da weiß man Bescheid.
Bild zig.
Mhm.
Super.
Jetzt versteh ich alles.
Was zum...
Ich hab keine Ahnung, was der Typ will.
Okay, das ist mir zu pfeifert.
Ich glaub, das ist nicht so sinnvoll, damit anzufangen.
Das ist mir zu hoch.
Wir machen erst mal zum Üben ein bisschen was anderes.
Kein Schimmer, wie das funktionieren soll.
Ich mein, er schreibt ja explizit, ich muss es nicht kompilieren.
Es ist schon fertig.
Aber das ist anscheinend nicht so.
Hat da nicht mal irgendeiner einen Blogpost oder so zugeschrieben?
Alter, wir verwenden hier wieder ganz obskure Dinger.
Dank Dennis weiß bestimmt Bescheid.
Nee, also mit FFM Back wird das so und auf die andere Weise nix.
Chat, jemand eine gute Idee, was wir ausprobieren könnten?
Was könnte man in Rust laufen lassen und dann im Process...
Wie ist das denn?
Moment, ich hab eine Idee.
Wie ist das denn mit Multithreading?
Wie ist das denn mit Multithreading in Rust und in...
Das wird doch nicht funktionieren, oder?
Also ich werde doch nicht irgendwas Multithreading können und dann...
Damit irgendwie JavaScript mit JavaScript interagieren.
Oder geht das?
Rust, Wasm, Multithreading.
Multithreading, Rust und Wasm.
Okay.
MonkaS.
Alter.
Okay, das ist advanceder Shit.
Das ist einfach alles so krasser Fiveheader Kram.
Ja, alles klar, alles klar, easy.
Kein Ding, ja.
Raytracing Demo.
Helps you create and execute webworkers based threads.
Okay, ja, nice.
Nee, Webworkers kann ich auch so machen.
Okay, ich glaube Multithreading ist keine allzu gute Idee.
Ja, ich dachte man könnte aber das...
Also man hätte ja das Rendern im Hintergrund machen können.
Also das Video rendern, also das Video transconen.
Ja Leute, ich weiß jetzt gar nicht, was ich gescheit machen soll.
Ich meine, das mit FFmpeg funktioniert nicht.
Ich brauche irgendwie einen Mini-Anwendungscase so.
Irgendwas kleines, wo man ein bisschen basteln könnte.
Was gibt denn diese Mozilla Anleitung noch her?
Einfach mal Raytracing selber machen, ja, easy.
Gibt es vielleicht einen Rust-Decoder?
Da brauche ich kein FFmpeg.
Vier Jahre.
Der To-Do-App ist da glaube ich nicht das Richtige.
Oh nee, dann lieber FFmpeg.
In FFmpeg weiß ich, wie der Kram funktioniert.
Leute, ich habe keine Ahnung, was ich machen soll.
Okay, gibt es?
Wie gesagt, To-Do-App, Ich muss mal gucken, was die Mozilla Anleitung macht.
Nee, das ist...
Ach, das war so ein Pac-Da-Projekt.
Ja, vielleicht steht da irgendwas interessantes drin, was man ausprobieren könnte.
Wobei Examples Hello World...
What?
Ja, das haben wir schon gemacht.
Flashbang sei der.
Ja, die Anleitung haben wir schon durchgemacht.
Google in Dark Mode, Pog.
Leute, mir fällt gerade wirklich nichts ein, als Anwendung.
Das war jetzt ausnahmsweise mal echt so.
Ich habe mich absolut gar nicht darauf vorbereitet.
Ich habe gedacht, wir basteln einfach ein bisschen.
Aber ich weiß echt nicht, was ich basteln soll.
Ich meine, wir haben Sachen returned.
Das ist garantiert nur ein ganz kleiner Bruchteil von dem, was man machen muss.
Aber es fehlt gerade so eine kreative Eingebung, was wir ausprobieren könnten.
Ich meine, wir haben Bites returned.
Und das funktioniert erstaunlich gut.
Was kann Rust WebAssembly besser als JavaScript?
Ich muss fragen, was WebAssembly besser kann.
WebAssembly ist ja quasi das Target, in das du übersetzt.
Also egal, ob das jetzt von C++ oder von Rust oder von sonst wo aus ist.
Das ist quasi eine Zwei-Mobility-Runtime, kann man das nicht nennen.
Das hat sich seit ein paar Jahren etabliert im Browser als JavaScript-Alternative.
Allerdings weniger, um JavaScript abzulösen.
Sondern eher als Compiled-Target für andere Programmiersprachen.
Das heißt, du kannst C++ nehmen, nach WebAssembly übersetzen und im Browser laufen lassen.
Dementsprechend kannst du auch C++-Libraries verwenden.
Crypto-Minor zum Beispiel.
Deswegen kannst du auch C++-Libraries verwenden oder Rust-Libraries verwenden.
Ich will mir jetzt nicht WebAssembly in C++ noch angucken.
Da dreh ich am Rat.
Nur mal just for fun.
Was im Tutorial.
So, und nachdem du quasi jetzt eine eigene Low-Level-Sprache im Browser hast,
von der du, also in die du kompilieren kannst, von anderen Sprachen aus,
kannst du halt mehr oder weniger fast alles im Browser laufen lassen.
Ich meine, du hast immer noch Beschränkungen, nämlich das, was Browsern nicht erlauben.
Also zum Beispiel, du kannst es nicht einfach in TCP-Socket aufmachen und sagen,
ich lausche da jetzt mal auf neue Requests und sowas.
Das funktioniert nicht.
Weil das geht alleine durch die Browser-Sandbox nicht.
Zu Recht, weil ansonsten hättest du ganz andere Probleme.
Oder aufs lokale Filesystem zugreifen oder so.
Das funktioniert nicht.
Was im Tutorial.
Oh nee, nein Leute, ich mach garantiert kein C++ jetzt.
Das fängt schon äußerst Paynes-Champi an.
Wenn ich das schon sehe.
Linux-Könnel in Wasm.
Mich würd's nicht wundern, wenn einer irgendeinen Mini-Mini-Könnel in Wasm schon übersetzt hätte.
Ich meine, das ist reines C, das sollte wahrscheinlich sogar irgendwie funktionieren.
GC, Wasm und FFmpeg.
Also du brauchst FFmpeg auf jeden Fall.
Also mit meinen x86 FFmpeg Libraries kommt man hier glaube ich nicht weit.
Ich glaube, man braucht wirklich dann eine Web-Assembly FFmpeg-Lib,
dass ich die ansprechen kann und ich weiß nicht, ob es sowas gibt.
Also Windows 98 könnte ich mir vorstellen, dass es das gibt.
Die Grafik-Ausgabe kannst du halt nicht in Web-Assembly machen.
Das ist Browser, das ist JavaScript.
Es gibt FFmpeg Wasm, ich weiß, aber was genau soll mir das bringen?
Das ist ein Command-Line, das ist das FFmpeg Command-Line-Tool.
Es sei denn, es gab noch zwei.
Es gibt FFmpeg Wasm und FFmpeg JS.
Genau.
Es sei denn, die erlauben einem irgendwie auf die internen Sachen zuzugreifen.
Das glaube ich aber halt nicht.
Das ist doch garantiert nicht der Source.
Wo ist denn der Source?
Äh, hier.
Den Port?
Wo ist denn der Source-Code für FFmpeg Wasm?
Nein, das ist es ja nicht.
Hier.
Get Create FFmpeg Core.
Patch?
Ja, wo ist es denn?
Also hier ist es nicht.
Der FFmpeg Source-Code ist ein bisschen größer.
FFmpeg Core JS
Ist das ein eigenes Projekt vielleicht?
Ach, kommt mal hier.
Das ist eine gute Sache.
Ach, hier.
Aber das kann man nicht in WebAssembly direkt verwenden, oder?
FFmpeg Wasm Core
Where we transpiled C++-Code of FFmpeg to Java.
Why?
Specify Media-File.
Wenn ich Bild-Files in C++ schon sehe, drehe ich am Rad wieder.
Alter.
Ich meine, vielleicht.
Ich meine, das wird theoretisch mit Rust auch alles funktionieren, ne?
Aber...
Nee, das Übersetzen wird da nicht funktionieren.
Okay Leute, ich habe legit keine Ahnung.
Also das mit FFmpeg taugt wahrscheinlich erstmal so nicht.
Ich muss mir irgendwas überlegen.
Ich habe heute keine Idee, was wir machen können.
Das müssen wir verschieben.
Weil ja, so PASIC-Sachen gehen, aber der Teufel liegt da im Detail.
Also man muss bestimmt vieles machen, wovon ich jetzt auch keine Ahnung habe.
Aber auch dadurch, dass ich keine Ahnung habe und ich weiß, was es ist.
Wasm Game of Life.
Nee, ich weiß, das ist das Tutorial davon.
Das muss ich mir mal überlegen.
Fallback auf zweite Stream-Idee.
Nee, Fallback auf, ich gehe jetzt aufs Klo.
Müssen wir alle mal weitermachen, keine Ahnung.
Fällt mir gerade nichts zu ein.
Wir machen morgen weiter.
Also wir machen morgen vielleicht was anderes.
Also zu dieser WebAssembly-Geschichte muss ich mir erst ein Anwendungsbeispiel überlegen,
dass wir was Gescheites machen können.
Das kann ich jetzt nicht aus dem Ärmel schütteln.
Nee, das hat nicht funktioniert, Leute.
Kann ich immer klappen.
Ich gehe jetzt auf.
Wir gucken uns heute auch keine Videos an.
Wir sehen uns im nächsten Stream.
Macht's gut.
CO.
