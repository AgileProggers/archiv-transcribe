Hallo?
Hallo?
Hallo?
Hallo?
Hallo?
Oh, der Ori-Sound-Rektor schlägt sich ein, weil...
Oh, ich höre mich doppelt, ich muss auf der anderen Seite ausmachen.
Nein, nein, nein, ich spiele nicht heute, Ori, ich hab nur den Soundtrack an, aber,
ha?
Big Brain.
Wobei, hatten wir den nicht auch als Emote?
Ah, ich muss den erstmal auf Twitter posten.
Twitter bestes Social Network, oder bestes Social Plattform, ist ja kein Social Network.
Aber Twitter ist beste Social-Gedöns-Plattform.
Und wisst ihr woran das liegt?
Warum Twitter die beste Social Plattform ist?
Oh, jetzt hab ich meinen Stream zugemacht hier auf der anderen Seite, jetzt seh ich
den Chat gar nicht.
Lull.
So, erstmal posten.
Twitter ist die beste Social Plattform, weil das irgendwie eine gewisse Einstiegshürde
hat und die Idioten das nicht checken.
Also die Deppen checken Twitter nicht, deswegen sind sie nicht auf Twitter und deswegen ist
Twitter besser.
Sollte ich den Titel vielleicht noch schreiben, weiter programmieren oder sowas?
Das ist richtig, das ist richtig, Big Brain.
Was zum Teufel ist Master Don, hab ich noch nie gehört.
Was ist Master Don?
The Invisible Darkness, da ist der EQ nicht Big Brain genug für mich.
So, ich wollte das jetzt noch auf Twitter posten.
Oh, ich weiß nicht, was ich hier gesagt habe…
So, wieder, Twitter ist raus, Tweet ist raus, kann sein losgehen, so, also, ähm, 17 Uhr,
denke ich, sind die meisten glücklicherweise schon daheim.
Max ist Anwendungs-Entwickler geworden, statt System-Indikator.
Eigentlich, äh, eigentlich war ich da schon immer.
Deswegen mache ich auf der Arbeit eigentlich auch kaum noch Admin-Geschichten.
Es haben mich in letzter Zeit öfters Leute gefragt, was ich auf der Arbeit mache.
Ich habe mir da ein bisschen Gedanken zugemacht, wie ich das erklären kann, aber ich versuche
das mal zu zeigen.
Also, schwierig zu zeigen, weil wir haben bloß einen Pull-Request.
Ich versuche das euch mal so ein bisschen zu erklären.
Was zum Teufel ist Master Dawn, das habe ich ja noch nie gehört.
Ah, yet another social network, ein dezentralisiertes Microplogging-Netzwerk, ja, jetzt schauen
wir mal die richtigen BuzzBuds am Start, aber beste, beste BuzzBuds, also beste Bullshit-Bingo-Sache
war gar nicht auf der E3, sondern die Apple Keynote, die er da gehalten hat, wo er dann
angefangen hat zu erzählen, Deep Technology Accelerated Workflow, das könnte auch in
irgendeinem Hip-Hop-Song vorkommen, so, weißt du, Deep Technology Accelerated Workflow,
mit Bitches oder so.
Ah ja, gleich da, gleich da, wäre nicht schlecht.
Siehste, deswegen, es fragen ja auch immer Leute im Stream, warum, Max, warum willst
du die Overlays sehen?
Genau aus so einem Grund will ich die Overlays sehen, weil ich sie sonst vergesse rauszumachen,
das suckt.
Genau, also nachdem ich ja in der letzten Zeit ein paar Leute gefragt habe auf der Arbeit,
was ich denn mache, ich versuche das mal hier an unserem GitHub-Repo für das Memboard
zu demonstrieren, das ist ein bisschen klein, ja, und außer einem Pull-Request haben wir
nix, aber eine der Sachen, die ich auf der Arbeit mache, und das ist immer schwierig,
wenn ich einfach sage, ich kümmere mich um Software-Repos und sonst was, da kann man
sich immer so schwer, so schwer was drunter vorstellen, meine Tür klappert, das ist ja
nervig, aber zum Beispiel, das ist das GitHub-Repo, wo sich jeder hier das Tool angucken
kann, was ich, was ich programmiere gerade.
Und einer der Hauptgründe, warum GitHub so beliebt ist, und warum das so viele Leute
benutzen ist, weil man da zusammenarbeiten kann, ganz gut, und das heißt, jeder kann
sich jetzt diesen Code hier neben den Showclan haben, was ändern, und wenn er möchte, dass
seine Änderung quasi in das Hauptprojekt wieder rein kommen, macht er ein Pull-Request.
So ungefähr in der Richtung, das ist ja nix GitHub-spezifisches, das ist eigentlich eher
Basket-spezifisches, also was Versionsverwaltung-spezifisches, dass man eben sagt, hey, ich mach mir den
eigenen Branch auf, entwickle da neue Dinger drinnen, und dann reiche ich das Ganze wieder
ein.
So, und so machen wir das auf der Arbeit auch, plus, dass wir da nicht ein Mini-Repo haben,
sondern ein paar ziemlich große, mit Source-Code von verschiedenen Software-Projekten drin,
ein riesengroßes und der Rest ein bisschen kleiner.
So, und dementsprechend kommt da nicht ein Merch-Request, beziehungsweise nicht ein Pull-Request,
wie es bei GitHub heißt, sondern, sag mal mal so, im Monat ungefähr 60, so über den
Daumen gepeilt jetzt mal, so ungefähr, ja, das schwankt immer ein bisschen, aber ich
kann es euch jetzt auch schlecht nicht zeigen, weil dann müsste ich ja mehr oder weniger
was, ja, revealen, leak, expose, und so ungefähr 60 für das große, für das große Repo.
Kommt ungefähr 60 neue Features oder, ja, zum größten Teil tatsächlich irgendwelche
neuen Sachen.
So, und ich kümmere mich drum, ich gucke mir das dann an, was die Leute gemacht haben,
gucke mir das an, also hier ist jetzt beispielsweise eins offen, bei uns sind es 260 Stück, mit
auch ein bisschen umfangreicheren Änderungen als das hier, ach wobei, ne, das kommt sogar
ungefähr hin.
Die Dinger bei uns auf der Arbeit sind ungefähr ähnlich umfangreich wie der Pull-Request
hier, so zumindest von Zeilen geändert.
Wobei dies oftmals ein bisschen komplizierter ist durchzublicken.
So, dann nehme ich mir das, gucke mir das an, gebe da mal einen Senf dazu ab, dann haben
wir noch so einen, das gibt es hier glaube ich auf GitHub nicht, dass man quasi noch
Daumen hoch geben kann, so nach dem Motto, ja, ich hab mir das angeguckt, ich find das
gut, dann müssen mindestens zwei Leute Daumen hoch gegeben haben, dass bei uns das überhaupt
bis zu dem Punkt kommt, dass ich das mir angucke und das gemercht werden kann, gucke mir das
Ganze an, gebe hier noch ein bisschen mal einen Senf dazu, wenn ich das nicht verstehe
oder wenn ich überhaupt nicht checke um was es geht, frage ich den Typ nochmal was er
gemacht hat, und dann kommt der Knackpunkt, entweder es passt zu den Änderungen die andere
gemacht haben oder es passt nicht, und das ist immer so ein bisschen das komplizierteste,
und das ist eigentlich auch das wo die meiste Zeit, wo die Hälfte der Zeit rauf geht, wenn
man sich vorstellt mal ein großes Software repo und da arbeiten, sagen wir mal es kommen
60 relativ umfangreiche Changes pro Monat, da kann das durchaus sein, dass die eine Änderung
nicht unbedingt so gut mit der anderen harmoniert, drücken wir das mal so aus, das kann so vorkommen,
also meistens ist es relativ unabhängig, aber das kommt schon ab und an mal vor, ja,
und da muss ich mit die Leute schlappen und sagen, guck mal was hast du da gemacht, guck
mal was hast du da gemacht, dass dann irgendwie so ein Best-of rauskommt am Ende, dass das
alles funktioniert, und wenn das dann fertig ist, dann machen wir eine Beta-Version aus
der ganzen Sache, dann probieren wir das aus, testen das, dann irgendwann machen wir mal
so eine Art Release Candidate-Version draus, man darf dann mal die Qualitätssicherung
und alle anderen Abteilungen, die ihr selbst noch dazu abgeben, und irgendwann wird dann
diese Version, geht das live, und dann geht das ganze wieder von vorne los, so, ungefähr
das mache ich auf der Arbeit, zur Erklärung, ja, das klingt jetzt vielleicht ein bisschen,
hat man das verstanden, hat man verstanden was ich mache, ich habe mir nämlich ein bisschen,
ich habe mir überlegt, wie kann ich das jetzt sinnvoll erklären, das hat kaum noch was
mit Administrator an sich zu tun, also gar nicht mehr, ich habe Systemintegrator gelernt,
das ist was aber auch, so, und das mache ich schon im Endeffekt jetzt seit, mal überlegen,
seit 2012, nee, ja doch, so, so 2012 rum, würde ich sagen, mache ich das schon, in
dem Dreh, dementsprechend kenne ich mich mit Git auch ganz gut aus, und ich kann euch
sagen, man kann mit Git alles machen, ob es eine sinnvolle Idee ist, ist was anderes,
aber man kann alles machen, noch so bescheuert, die bescheuertsten Sachen, ja, dementsprechend
programmiere ich in letzter Zeit relativ wenig selbst, bis auf so ein paar kleine Hobbydinger,
also nee, ich nenne es zwar Hobbydinger, ja, also es sind schon sinnvolle Sachen auf
der Arbeit, Arbeit ist nichts großartiges oder so, hast du dir ein paar Bitcoins gekauft,
während die zurzeit noch günstig sind, nee, habe ich nicht, das muss jeder selber wissen,
ob er sich Kryptowährung oder sowas holen will, Moment, was, was macht denn eigentlich,
Alter, okay, abbrechen, diese Programmingkategorie auf Twitch, das ist mega fail, das ist mega
fail, ist Git Turing complete, nee, kannste ja schlecht sagen, Git, kannste keine Logik
programmieren, und nachdem du Git Hooks in allen Sprachen machen kannst, die natürlich
schon, so, also, nachdem schon wieder die Frage kam, sag mal, können wir, mal Frage an die
Mods, können wir noch ein Kommando machen für das Memetool, was das macht, dass ich
das dann immer erklären muss, das Screenshot Tool ist ja erstmal auf Eis, das wird erst
wieder aktuell, wenn ich aktiv anfange mit der BDO zu spielen, also was ich mache ist
folgendes, ich meine, ihr habt ja im Prinzip schon gerade in Auktionen gesehen, ne, das
hat vielleicht gar nicht aufgefallen, aber die, die dabei sind, die kennen das natürlich,
das Memetool macht sowas hier, das Overlaid, transparente PNGs und animierte Gips, und
es Overlaid die nicht nur, also, es zeigt die nicht nur an, das ist ein richtiges Overlaid,
also sprich, man kann durchklicken, also sprich, das ist transparent, das Bild, ist über
allen anderen Anwendungen drüber, das war gar nicht so einfach, und man sieht, es nimmt
sich auch keinen Fokus, also wenn ich hier, ne, ihr seht es im Hintergrund, das Strakentrop
bleibt aktiv, selbst wenn ich es ein- und ausblende, ne, Big Brain, das macht das, und
wir haben das das letzte Mal eigentlich auch ganz gut hingekriegt, es fehlen jetzt noch
ein paar Sachen, also es fehlen noch eine wichtige Sache, die machen wir heute, wo ich
der Meinung bin, dass es essentiell, dass die geht, und das nächste Mal, also da werden
wir heute wahrscheinlich auch ein bisschen für brauchen, so, und das nächste, was wir
machen ist, das ist aber in einem der nächsten Streams, wir machen ein Dashboard, was übers
Netzwerk funktioniert, weil aktuell ist es ja so, das liest hier, ich zeig's mal, ist
die Ori Musik zu laut, oder passt das so, sag mal, ob die Musik passt, ähm, aktuell
ist es so, das liest hier hardcoded noch aus einem Ordner die Bilder ein, so, ich zeig's
mal, so, und hier liegen die Bilder drinne, also alle Bilder, die ich hier als Auferlay
anzeigen kann, ne, zum Beispiel, ich starte das ganze nochmal, zum Beispiel hier mein
Plon, bam, mein Plon, zeigt da an, so, das ist natürlich nicht schön, wenn man hier
wie hardcoded irgendwelche Pfade drin hat, oder so, und eine Sache, die ich, bisschen
leiser, ok, ja, was denn, Ju, Just Marv sagt etwas lauter, Hype sagt, passt, White Tiger
Sinon sagt, bisschen leiser, so, ich hab jetzt drei Antworten, und drei Leute sagen was
Unterschiedliches, lull, ich glaub, das kommt auch ein bisschen auf den Soundtrack an, was
gerade läuft, das, das ist glaube ich jetzt gerade recht angenehm, guck mal mal, also,
wenn es irgendwie zu laut ist, sagt einfach Bescheid, so, ich muss da gleich mal was zu
trinken holen, ja, jetzt wirklich ein bisschen laut, wir machen mal einen Tickenleiser,
so, das ist ganz gut, denke ich, hallo, this is Snax, Agis, moin, so, was wollte ich gerade
sagen, genau, eine ganz wichtige Funktion, die noch fehlt, die noch unbedingt sein muss,
ist, dass man hier Bilder, während das läuft, hinzufügen kann, und auch entfernen kann,
aber das kommt so dann mit, also zum Beispiel, wenn ich mal angenommen, ich hab das jetzt
laufen im Hintergrund, ich hab irgendeinen Stream an, oder sonst was in der Richtung,
ich denk mir jetzt so, ey, guck mal, ich hätte jetzt hier gerne noch ein paar Bilder dabei,
dann kann ich das Bild hier einfach reinziehen, und kann es benutzen, ohne dass ich den ganzen
Scheiß neu starten muss, das finde ich ganz praktisch, vor allem auch in Kombination,
was wir dann nächsten Streams machen, ist, dass wir das Ding noch netzwerkfähig machen,
dass man es quasi von einem zweiten Rechner aus fernsteuern kann, das ist dann quasi
so ein Elgato Stream Deck Light selbst gemacht, wobei ich mir nicht sicher bin, hat jemand
von euch das Ding hier? Hat das jemand? Mich würde nämlich mal interessieren, wie das
funktioniert, ich hab es nicht ausprobiert, ob das quasi die Bilder wirklich als Overlay
anzeigt, sodass es der Streamer auch sieht, oder ob das nur die Bilder im OBS anzeigt,
so wie den Text hier zum Beispiel, das würde mich interessieren. A Pavilion Man fragt,
ob ich mal drüber nachgedacht hab, die Watts auf YouTube hochzuladen, nö, weil man kann
die, erstens kann man die Sachen angucken auf Twitch, oder aber, du gehst auf die Archivseite
vom Sebaro, da hast du keine Werbung, du hast allerdings auch kein Twitch Chat dabei, und
du hast alle Aufzeichnungen seit September. Ich kann euch das mal zeigen, hat er nämlich
sehr schön gemacht, hat das Sebaro gebastelt hier, www.wobblers.tv, so, und da kann man
jetzt nämlich sagen, Archiv Twitch, ja, es stand sich schnell, ist die Seite, nett, das
stimmt, aber ist doch egal, so, und dann geht man hier auf Archiv, da, nicht auf Twitch,
auf Archiv, und dann sieht man, da sind fast alle Streams drin, ah, das ist der E3 Stream,
das ist alles drin, könnt ihr hier rumscrollen, sogar Tooth the Moon ist drinne, Bible Thump,
Bidiorio, jetzt Overwatch, geht jetzt alles drinne, seit, hier sogar, sogar, ich hab's
gehabt, ich hab's gesehen, sogar der Übertakter-Stream ist drinne, furchtbar neuer Rechner-Übertakter,
alles seit September, fehlen ein paar Streams davor, aber das ist nicht so, nicht weiter
wild, könnt ihr euch angucken, wer es sehen will, also wer ein Archiv braucht, so, auf
geht's, also, wie gesagt, ich halte es für wichtig, dass man Bilder hinzufügen kann,
so, und da ich nicht vergess auszumachen, will ich die Overlays halt selbst sehen, genau,
und ich will das, ich will es so machen, dass ich beispielsweise sagen kann, hier, während
das läuft, will ich einfach auch ein paar Bilder entfernen, vielleicht will ich manche
nicht verwenden oder so, und vor allem will ich neue reinziehen, aktuell ist das auch
noch ein bisschen umständlich, weil man kann Bilder, also die Overlays hier, kann man nur
mit Shortcuts aufrufen, das ist super, wenn man quasi spielt und zwischendrin irgendwie
sagen will, null, also sprich, wenn ich jetzt irgendwas am Spielen will und will mal kurz
null machen, das ist mit Shortcuts natürlich am besten, aber wenn man dann irgendwann
32 hat und sich theoretisch 32 Shortcuts vergeben muss, ist das vielleicht ein bisschen viel,
aber irgendwann gehen an mir auch die Shortcuts aus, ne, deswegen werden wir auch noch einbauen,
dass man einfach Bilder reinlegen kann, ohne Shortcuts, und die kann man dann halt über
das Dashboard, was wir in einem der nächsten Streams programmieren werden, dann aufrufen
vom zweiten Rechner aus, ist dann ganz praktisch, ich weiß jetzt nicht, hat jemand das Elgato
Streamdeck, ich hab's jetzt nicht gesehen, so, dann fangen wir mal an, und wir haben aufgehört
mit, genau, wir haben das letzte Mal rausgekriegt, dass es relativ einfach ist, das hat mir
sogar jemand im Chat erzählt, ich wusste gar nicht, dass es das gibt, wer braucht schon
32 Memes, das ist sogar noch viel zu wenig, da muss da eigentlich noch viel mehr rein,
aber das ist alles kein Ding, man kann sich dann nämlich die wichtigsten, kann man sich
dann einfach auf irgendwelche Shortcuts legen, die man halt nicht so oft braucht, die man
halt auch nicht aus versehen, während man ein Spiel drückt, du musst das nicht vom
zweiten Rechner aus starten, du kannst es natürlich auch vom zweiten Monitor aufmachen,
vom gleichen Rechner, geht natürlich auch, man kann es auch auf dem gleichen Monitor
aufmachen, das ist aber ein bisschen schwierig, auf dem gleichen Monitor was zu spielen,
plus das Dashboard zu bedienen, also wenn du das hinkriegst, kannst du das machen, das
ist überhaupt kein Problem, das funktioniert, kannst du im Prinzip starten, wo du willst,
das geht über das Netzwerk, du kannst das auch auf dem Tablet starten, wenn du mir
das Programm ausführen kannst, aber ja. So und wir haben es jetzt mal herausgefunden,
es ist relativ einfach, einen Ordner zu überwachen auf Änderungen, also sprich, ob hier Bilder
unbenannt werden, ob hier Bilder hinzugefügt werden oder gelöscht werden, ich war mir
das letzte Mal bloß nicht so ganz sicher, wie wir das jetzt gescheit einbauen, das ganze,
was wir heute auch noch machen ist, wir machen, das machen wir als erstes, wir machen einen
Tray-Icon, einen Tray-Icon, wo man das ausschalten kann, weil im Prinzip ist es ja so, dass
ich jetzt hier eine Konsole habe, das ist ja nur zu Debug-Zwecken, die Konsole, das heißt
in der Konsole kann ich zuklicken, aber normalerweise habe ich ja gar keine Konsole, das heißt
ich habe nichts, wo ich das Programm ausmachen kann, und ein Programm, was man nicht ausmachen
kann, ist vielleicht nicht die benutzerfreundlichste Sache, das heißt wir machen uns einen Tray-Icon,
wenn man da rechts draufklickt und sagt exit, dann geht es aus, also auch nichts großartiges,
kompliziert das, das machen wir zuerst, weil das ist simpel, zumindest glaube ich das,
weil ich habe das in WPF noch nicht gemacht, WPF selbst hat keinen Tray-Icon, fragt mich
nicht warum, Microsoft hat sich gedacht, ja das Tray-Icon gucke ich mir auch bei deinem
Pull-Request ab, weil ich habe keine Ahnung, wie das funktioniert, aha, das Elgato-Ding
kann OBS-Overlays, das wird aber auf dem Knopf angezeigt, ja da finde ich Mines dann noch
viel besser, deine Stream Deck ist outdated, overrated, gebaited, meme board activated,
so, dann machen wir das mal, gucken wir uns wirklich bei seinem Pull-Request ab, wie das
mit dem Tray-Icon funktioniert, aber ich habe mal im Vorfeld schon geguckt, also das ist
auch nicht sonderlich schwierig, wir müssen bloß gucken, was wir für einen Icon machen,
genau das gibt es hier nämlich diese komische Tray-Icon Library, die nehmen wir dafür, die
verwendet ihr hier glaube ich in seinem Pull-Request auch, ja, du kannst transparente PNGs overlayen
mit GIFs und nicht transparente GIFs und halt Bilder, alle möglichen Bilder die du willst,
also sprich du hast den Vorteil dadurch, du siehst die Dinger halt selbst und kannst
die per Shortcut, das heißt du brauchst keine Software wo du Bilder anklickst oder sowas,
kannst die per Shortcut dann overlayen, das ist halt für Streamer und Leute die Videos
machen ganz praktisch, stell dir vor du spielst was und willst dann kurz, gehst in Deckung,
hast voll auf den Sack gekriegt und willst hier mal das einblenden, das geht halt sonst
nicht so einfach und das Schöne daran ist, du siehst das, das heißt du vergisst sie
auch nicht auszumachen, ein weiterer Vorteil ist, es ist zwar ein eigenes Fenster aber das
haben wir geschickt gefaked, man kann nämlich komplett durchklicken und das ist das geilste,
das crappt auch beim aufmachen keinen Fokus, also sprich wenn ich jetzt hier im Hintergrund
etwas spiele und das overlay an und aus mache, hat es überhaupt keine Auswirkungen drauf,
das macht das.
So und was wir heute machen ist, wir basteln Tray-Icon dafür, dass man das Programm natürlich
auch mal an und ausschalten kann, was nicht schlecht ist und dass man automatisch Bilder
und Memes hinzufügen kann und löschen kann während das läuft.
Ach es ist Triggered, Triggered, eventuell wenn man das Numpad als Shortcut-Plattform
nutzt, Umschaltbar-Aktionsleisten, ja sowas in der Richtung zum Beispiel, ja das ist keine
schlechte Idee.
Das finde ich ist eine super Idee, also Crypto84 wenn ich das richtig verstehe, meinst du
man könnte das Numpad quasi für Shortcuts verwenden, dass man dann quasi sagt, man
belegt halt seine Bilder mit Numpad 0-9 und dann hat man mehrere Ebenen, sprich wenn man
plus auf Numpad drückt, dann schaltet es in Profil 2 und in Profil 2 sind dann 0-9
und wieder andere Bilder, das muss ich mir mal aufschreiben, Profiles, das finde ich
sehr nice, das ist sehr praktisch, das finde ich gut, das finde ich cool, da bräuchte
man auch irgendwie so eine, das war richtig BigBrain, da bräuchte man auch irgendwie
so eine Anzeige, was das, in welchem Profil man ist, das kann man theoretisch auch einfach
im Tray anzeigen oder so, oder man hat, ah übrigens noch eine Sache, die ich mir überlegt
habe, was wir machen können, ich habe was gefunden, auf GitHub, zeige ich euch mal,
ich habe hier so eine special RGB-Tastatur und ich glaube das ist eine richtig coole
Funktion für Leute, die auch sowas haben, also ich habe hier dieses bunte Teil, so und
da kann man einstellen, dass einzelne, einzelne Tasten leuchten, so und ich habe mir gedacht,
ich habe hier nämlich was gefunden, und zwar gibt es eine, gibt es eine.net Library,
um die RGB-Beleuchtung von Corsair-Tastaturen zu steuern, das heißt, man könnte jetzt
das verbinden mit dem, was Chris84 geschrieben hat, man, man zeigt einfach an, welches Profil
aktiv ist mit RGB-Beleuchtung, das ist dann quasi, das ist dann richtig Trick 17, ja
genau, Ex-Shadow-Ghost, so werde ich es wahrscheinlich auch machen, Pop-Up will ich nicht machen,
weil es geht ja darum, dass man den Cremple verwenden kann, ohne dass es Einfluss auf
das Game hat, was man spielt, und so ein Pop-Up geht dann richtig auf den Sack, Tray-Anzeige
kann die Ebene, also ich würde sagen, die Tray-Anzeige zeigt an 1, 2, 3, 4, 5 oder
irgendwie sowas, mal gucken, mal gucken, wie man das, wie man überhaupt ein Tray macht,
und wenn man eine RGB-Tastatur hat, kann man sich das dann quasi auch noch, da wird dann
einfach das Numpad, wird dann, keine Ahnung, blau, grün oder rot, dann weißt du, welche
Ebene du hast, und für die Leute, die es richtig advanced wollen, unter 32 Memes drin
haben, die können sich dann einfach auch auf dem zweiten Monitor oder auf dem zweiten
Rechner über das Netzwerk das Dashboard installieren, was man das nächste Mal bastelt, wo man dann
einfach draufklicken kann, und die Bilder aktivieren kann, oder auch Bilder aktivieren
kann, die kein Shortcut haben, das finde ich nice, sehr, sehr nice, so, wir machen jetzt
mal ein Tray-Icon, das kann ja nicht allzu schwer sein, die Musik, die Musik ist richtig
monochrisch gerade, so, wie verwenden wir das Ding, wir copy-pasten es einfach mal, vorher
müssen wir das Ding natürlich noch importieren, oder es leuchtet einfach die Zahl auf dem
Numpad entsprechend der Ebene, oh, das ist auch, das ist, das ist auch eine coole Idee,
dass dann quasi 1, 2, 3, 4, oh, das ist auch cool, siehste, siehste, Big-Prain-Chat, ich
hab Biggest-Prain, 900 IQ-Chat haben wir hier, ich schreibe mir das mal auf, mach das Memboard
als Abo-Modell, ne, ne, ich, ich mach meine Heizungs-App, die Bitcoins meint, ich hab
das auch ein bisschen ausgebaut, die Idee schon von der Android-App, die werden wir
dann auch hier irgendwann programmieren und streamen, aber in der Android-App, die, also
die Heizungs-App, die verkaufen wir als Heizungs-App, wo die Leute sich im Winter die Hände dran
werben können und um Hitze zu generieren, meinen wir Krypto-Werbung da drauf und das
wird dann dazu führen, dass wir super Bewertungen im App-Store kriegen, weil wir bieten das
kostenlos an, ohne Werbung und die App macht das, was sie soll, sie heizt das Smartphone
auf, d.h. die Leute freuen sich, weil sie das genau kriegen, was sie wollen und wir
meinen auf den Smartphones Krypto-Werbung und alle finden es geil, so machen wir das
und man kann natürlich dann auch für alle noch ein bisschen was einbauen in diese App,
z.B. kann man dann schön, z.B. könnte man dann schön animierten Kamin einbauen, den
man dann quasi per Microtransactions upgraden kann, unterschiedliche Knister-Sounds oder
sowas und um die Sache dann auch auf die Spitze zu treiben, kann man dann natürlich auch
noch verschiedene Knister-Sounds und Kamin-Skins, verschiedene Feuerfarben, verschiedene Tageslicht-Farben
und so kann man sich dann auch aus Lootboxen oder aus Kaminboxen, was auch immer holen,
kommt dann der Schornstein-Figur vorbei und bringt das und die kann man aber nicht aufmachen,
die kann man nur mit Schlüsseln aufmachen und jetzt kommt wieder Big Brain, der Bogen
zum eigentlichen, wir wollen ja Krypto-Werbung meinen, die Schlüssel für diese Boxen kriegt
man nur durch Laufzeit der App, also sprich auch wenn die Leute sich nicht ihre Hände
wehren müssen, lassen sie die App trotzdem an, weil sie ja Schlüssel-Drops haben wollen
für die Boxen, die sie umsonst kriegen, ja so machen wir das und dann wären wir reich
damit, was sagt ihr dazu, klingt das gut, das machen wir so, das brauchen wir glaube
ich, so was in der Richtung, das ist richtig Big Brain, das dürfen wir aber nicht erzählen,
weil sonst hat Ubisoft demnächst sowas, EA glaube ich, Ubisoft hat sowas dann und die
verstehen das Konzept dann nicht und bauen Türme ein, wo man raufklettern muss, was,
ja ja ist schön, ja dass euch die Idee gefällt war klar, ok jetzt haben wir den Krempel hier
eingebaut, jetzt kann man, wir copypasten das jetzt einfach mal hier, gucken wir wie das
funktioniert, Tray-Icon, Moment, Source, Source kaputt, Beams 2, Lull, das heißt ja auch
Lull, L, Lull, heißt ja auch, so, übrigens der Anteil von Code zu restlichen Fenster
ist mal wieder absolut erstaunlich hier, so, jetzt müssen wir das Tray-Icon mal hier irgendwie
reinhauen, so, das machen wir erstmal, also ganzen Events weg, jetzt gucken wir mal, ob
das funktioniert, dann kriegen wir jetzt wahrscheinlich erstmal ein leeres Tray-Icon, hier unten,
so, was nichts macht, Fallback für Windows XP brauchen wir nicht, Windows XP in 2k18,
das ist ja, das ist nicht mal Lull, das ist Omega-Lull, so, 3, Tray-Icon visible, bla bla
bla, so, geht nicht, warum geht das nicht, achso, ha, weil mir jetzt nur einmal Content
geben darf, ach ne, ich hab die Namespace vergessen, ja ich bin ja auch so ein alter
GPF-Pro, kein Wunder, dass das nicht geht, funktioniert jetzt nicht, weil jetzt ist Content
doppeldefiniert, ne, genau, das heißt da machen wir jetzt mal irgendwie einen Stack-Panel,
bo, was hab ich hier gemacht, so, zack, so, zurück, wenigstens rückt Twizzle Studio das
Zeug immer schick ein, so, gucken wir mal, ob ich jetzt einen Task-Icon kriege, ah, da
ist es, guckt hier, da ist es, Poggers, ein leeres Tray-Icon, was nichts tut, was nichts
macht, es geht kein Popup auf oder sonst was, aber es ist da und das ist das wichtigste,
so, ähm, wie kriegen wir denn da jetzt ein Menü rein, das guck ich mir jetzt mal ab
hier, wie er das gemacht hat, wie hat er das gemacht, aha, Kontext-Menü, da ist es doch,
Kontext-Menü, ja, so machen wir das, warum macht GitHub, warum, warum, lassen die mich
nicht Copy-Pasten ohne den Schmodder hier vorne dran, warum, was ist das, ja, so machen
wir das.
So, ähm, so, jetzt kopieren wir den Krempel mal hier rein, wie geht das jetzt, ja, so,
jetzt kopieren wir den Krempel mal hier rein, wie geht das jetzt, ähm, das muss man wahrscheinlich
erstmal so machen und das hier irgendwie rein kopieren, ha, ne, ok, so geht das schonmal
nicht, wie hat er das denn gemacht, ah, da bindet das irgendwie, das ist ja, das ist
mir zu hoch, ich hab von XAML und WPF keine Ahnung, das ist mir zu hoch, man kann das
doch garantiert hier auch irgendwie, irgendwie reinschreiben, so inline, was gibt's denn
da so zu auswahlen, gibt's da irgendwie ein Menü, ha, Kontext-Menü, bam, jetzt machen
wir das da rein und jetzt geht's, oder auch nicht, ok, das Zeug machen wir hier mal alles
weg, also auch wenn es vielleicht so aussieht oder den Anschein erweckt, also WPF-Technik
hab ich nicht so wirklich Ahnung, was ich mache, aber dafür funktioniert's erstaunlich
gut, so, machen wir den Krempel mal weg, wir wollen eigentlich bloß so was haben, header,
irgendwie exit, ganz, ganz billig und dann wollen wir das auch nicht über Commands
machen, sondern wir machen das richtig oldschool Windows-Form-Style, sondern wir machen Click-Event,
das meinetwegen, dann heißt es halt Menü-Item-Click, wobei das nennen wir, das benennen wir um,
das ist dumm, Menü-Item-Click, wo ist es denn, Menü-Item-Click, Menü-Item-Click nennen
wir um in J-Exit, so, und wenn das geklärt, jetzt gucken wir erstmal, ob das funktioniert,
ja, funktioniert, auch wenn es mit Link am Ausschuss ein bisschen leckt, aber ok, aber
es exited noch nicht, das ist natürlich blöd, aber das lässt sich ja einfach beheben, oh,
raus, und dann geht es zu, wenn ich auf exit drücke, ah, exit, bam, weg ist es, wunderbar,
jetzt brauchen wir noch, jetzt brauchen wir noch ein Icon, was wir nehmen, weil so ein
leeres Icon ist doof, das ist halt leer, jetzt haben wir eine schizze Auswahl, oh, wir wollen
auf alle Clicks reagieren, ja, wunderbar, jetzt brauchen wir noch ein cooles Keksbild
für den Tray, Keks oder Dance Game, Link, nein, wir können Trays unterstützen, glaube
ich, keine Animationen, das wäre zu kompliziert für Microsoft, Keks, ok, dann machen wir
jetzt hier, ne, den da nicht, schon den normalen Keks, nicht den Weihnachtskeks, den da, den
nehmen wir jetzt, ist das auch die transparente Variante, oh man, ist das die transparente
Variante, das ist die transparente Variante, guck mal, soweit sind wir schon, ich muss
mir meinen eigenen Avatar im Internet herunterladen, lol, so, Desktop, mein Vater hat immer gesagt,
der wusste nicht, dass man Desktop, Desktop ausspricht, er hat immer gesagt, Descope,
ich packe mir das jetzt auf Descope, ich mache das auf Descope, ich habe das jetzt auf Descope
abgelegt, so, so, und wie macht man daraus jetzt ein Icon-File, weil Windows, weil Windows
ist ja so fortschrittlich und erlaubt hier unten keine ordentlichen Bildformate, sondern
das muss in Icon-Format sein, Convert, PNG, Icon, das war klar, dass es da ein Online-Convert
dafür gibt, also wir haben zur Auswahl Convert, Ico oder Ico Convert, tja, nehmen wir mal
das erste, easy, das sieht aus wie irgendeine Seite, wo ich mir ein Virus einfange, wenn
ich es runter lade, ich muss mal gucken, nee, go, Upload, so, Upload, wollen die mich verarschen,
File was 502 Kilobyte, so, und jetzt Upload Max 2 MB each, der widerspricht sich ein bisschen,
was denn du, 500 KB oder 2 MB, Kackseite, sucked, was ist das, nächste, das sieht besser
aus, man könnte auch mal gucken, wie man den Scheiß selbst konvertiert, aber warum, warum
selbst konvertieren, wenn man doch einfach irgendwelche Online-Services verwenden kann,
so, Upload, bam, nein, ich will das, wow, was ist das, kann das croppen, ok, dann croppen
wir das noch, oder auch nicht, ok, wir croppen das nicht, das lässt sich nicht croppen,
ich schalte, sucked, alter, drop, wer hat sich das wieder ausgedacht, die Bedienung von
der Seite ist echt abenteuerlich, so, Styles, wat, ok, wir bauen das als Icon für Windows
7, meinetwegen, Multisize in one Icon, nee, so, 690 x 6, ach nee, Icon, ach du Scheiße,
das kompliziert gemacht, convert, wie siehts mit einer VR, mal gucken, was ich mir jetzt
hier runter lade, ach nee, es funktioniert, ok, der Windows Betrachter, der Windows Bilder
Betrachter ist anscheinend nicht in der Lage das zu öffnen, ok, da haben wirs, bilden
wir erstmal um, in, ach immer, Meme, Board, Icon, so, und dann direkt dropen wir das hier
rein und versuchen das mal hinzuzufügen, da bin ich mal gespannt ob das klappt, wo
ist es denn, da, mal gucken ob das funktioniert, Icon Source, Board Punkt Ico, ich bin ja gespannt
ob das tut jetzt, mal richtig einrücken alles, hey, guck mal, es klappt, Poggers, Poggers,
ich hab hier eine Lade, oh da ist es, wir haben einen Keks als Trey Icon und können
das exiten, so muss das sein, eats as fuck, Koggers schon, ja genau, sowieso wieder sehbar
war das als easy clap Koggers, so, das war jetzt ja nicht sonderlich schwer, also muss
man sagen das Teufel funktioniert, sehr schön, ich mag Libraries die einfach, die ein schönes
Beispiel haben dabei und was dann auch einfach funktioniert, das ist schick, das ist wirklich
easy, ok, weiter im Text, wir haben den Trey Icon und können exiten, das heißt wir können
jetzt anfangen mit der eigentliche Sache die wir heute machen wollten, das Lick E-Mode
scheint euch zu gefallen oder, oh mein geht das Soundtrack grad wieder von vorne los,
das ist das Main Theme quasi, ok, was auch immer hier changed machen soll, keine Ahnung,
das schmeißen wir mal raus, das brauchen wir nicht, das schmeißen wir auch raus, das
schmeißen wir auch raus, also ich hab mir ein bisschen Gedanken dazu gemacht, aktuell
ist es ja so, wir laden das einmal statisch, also sprich wenn ich das Programm starte,
dann lädt das einmal alle Bilder und merkt sich das und fertig, das heißt wenn ich ein
Bild hier lösche, wird es abkacken wenn ich versuch anzuzeigen und wenn ich ein neues
Bild reinziehe, dann wird es nicht mitkriegen dass es da ist, das ist natürlich blöd, deswegen
tauschen wir diesen Campbell den wir jetzt das letzte Mal gebastelt haben hier, dass
es sich quasi das einmal statisch lädt am Anfang, übrigens das müssen wir auch noch
dynamisch machen den Fahrt, da ist mir noch nichts gescheites zu eingefallen wie ich
das ohne Config Datei irgendwie, keine Ahnung, weil ich will eigentlich keine Config Datei
haben, so, aktuell laden wir das hier einfach und schreiben es hier rein und arbeiten dann
permanent halt mit dieser statischen Liste von Bildchen, bzw. eigentlich ist es keine
statische Liste von Bildchen, sondern es ist eine Liste halt mit dieser Meme Klasse wo
dann drinnen steht wo das Bild liegt, welches Shortcut es bekommen soll das Bild und halt
ob es ein GIF ist oder nicht, Relativer Fahrt zu Exe, das ist eine gute Idee, das gefällt
mir, hallo, howdy, das gefällt mir, das ist eine gute Idee, genau, dann machen wir Relativer
Fahrt und man muss es halt einfach neben das Programm legen, das ist ja kein Ding, so
und ich habe mir überlegt wir machen das folgendermaßen, wir nehmen diesen File System
Watcher, sagen dem, beobachte dieses Verzeichnis und immer wenn du feststellst, dass sich das
was hinzugefügt wurde, unbenannt wurde oder gelöscht wurde, dann updaten wir diese Liste,
so nachdem, da fängt es aber schon an ein bisschen problematisch zu werden, denn Leute
die schon ein bisschen was mit Multisoldin gemacht haben, denen ist das wahrscheinlich
sofort klar, dass es keine gute Idee ist, aber ich versuche das mal noch ein bisschen
auszuführen warum das keine gute Idee ist so zu machen, weil das ist ein Fehler in den
jeder früher oder später läuft und sich fragt warum geht denn das nicht, also wenn ich jetzt
im Hintergrund was habe, was guckt, ob sich hier drin etwas aktualisiert und sobald sich
etwas aktualisiert, dann hier in meiner UI was ändere, dann hast du ein Problem, nämlich
dass die Oberfläche, also im Endeffekt das unsichtbare Fenster, wo das Bild angezeigt
wird, die Oberfläche läuft in einem eigenen Thread und das hier, was im Hintergrund den
Ordner überwacht läuft in einem eigenen Thread, so und dann kann es natürlich passieren,
dass ich Sachen mache, die halt nicht parallel funktionieren, zum Beispiel das Bild wird
unbenannt und ich versuche es anzuzeigen oder aber ich lese die Liste hier gerade aus, während
ich sie update und der Index den ich ausgelesen habe ist danach was anderes, also das ist
keine gute Idee auf jeden Fall, also quasi auf UI Elemente zuzugreifen, auch von einem
anderen Thread aus ist selten eine gute Idee. Es gibt Frameworks, ich glaube in Qt ist es
so, das verbietet das prinzipiell, wenn ich da versuche von irgendeinem anderen Thread
außer dem UI Thread darauf zuzugreifen, dann gibt es einen Fehler und es kackt ab, ich
glaube WPF macht es auch so, bin ich mir aber nicht sicher, wie man das ganze umgehen kann
ist, man muss beim updaten sagen, dass er das nicht in dem Thread machen soll, der läuft
wo er das Verzeichnis überwacht, sondern in die Eventwarteschlange werfen soll für
den UI Thread, dann funktioniert das und das macht man folgendermaßen und ja auch wenn
es, Tommy schreibt es gerade, WPF würde abkacken wenn ich das mache, andere Sachen, die haben
den Check halt nicht, die kacken nicht ab, die haben dann bloß ganz merkwürdige Fehler
oftmals, also man muss aufpassen, also immer wenn man quasi von mehreren Sätzen auf einen
Speicherbereich irgendwie drauf zugreift und vor allem wenn man von mehreren Stellen aus
diesen Speicherbereich ändern kann, also wenn man den ändert von verschiedenen Stellen
ist meistens das Problem, also an einer Stelle schreiben und an mehreren Stellen lesen, wenn
man da ein bisschen aufpasst gibt es eigentlich kaum Probleme, aber spätestens wenn man von
mehreren Stellen ausschreibt, was jetzt hier nicht der Fall ist, aber dann gibt es definitiv
Probleme, da muss man sich was überlegen und selbst hier kann es Probleme geben, wenn
ich im Hintergrund quasi diese Liste ändere und quasi gerade hier im Vordergrund irgendwas
updatet, drauf zugreife oder sonst was in der Richtung ist, ich meine es ist im Prinzip
ja auch ganz logisch, wenn ich jetzt sage gib mir Element 5, also in diesem Thread, in
meinem UI Thread würde ich sagen gib mir Element 5 aus der Liste, während gerade im
Hintergrund das Ding erkennt, oh es gibt ein neues Bild, pusht das rein und auf einmal
ist Element 5 nicht mehr Element 5, sondern keine Ahnung Element 4 oder Element 8 oder
irgendwie ist ja egal, also man sieht es gibt, kann auf jeden Fall immer Probleme geben,
sobald ihr da mit mehreren Stellen rumwurstet, so die einfachste Variante, dass WPF zumindest
nicht meckert ist wenn man sagt, wenn man eben quasi sagt hier, wow wow der Soundtrack,
ja ronkar ist, als käme jetzt hier gerade die ultraepische Ansage, nicht Credo, hi,
aber wenn man das hiermit macht kann man eben quasi sagen, mach das nicht in dem ursprünglichen
Thread, sondern mach das in dem Thread von dem GUI, so aber jetzt müssen wir natürlich
erstmal basteln, dass diese Ordner über Wachung im Hintergrund überhaupt richtig funktioniert,
so und das letzte Mal, aber ich bin nicht ganz sicher wo wir das hinschreiben, weil
hier in dieser Klasse hat das eigentlich überhaupt nichts verloren und wir machen uns, warte
mal ich muss mal den Soundtrack eben ein bisschen leiser machen, zu der Musik fällt mir eigentlich
gerade nur das hier ein, wozu das Add vor dem Fahrt, das Add sorgt dafür, dass da hier
nichts escapt, guck wenn ich das Add weg, woops, what the fuck, was hab ich jetzt gedrückt,
wenn ich das Add weg mache, dann sind die Backslashes Escape Zeichen, man sagt ja auch
hier, aber Backslash U ist keine Escape Sequenz, ich könnte alternativ auch jeden Backslash
doppelt escapten, aber nachdem ich da, das ist das gleiche im Endeffekt, aber nachdem
ich da keinen Bock drauf hab, mach ich einfach ein Add davor, hallo da Woodface, ja Backslash
kann man auch machen, Flo 690, aber mit Add ist das angenehmer und ich hab im Hinterkopf,
dass es irgendwie, sei es C-Sharp 7 noch eine dritte Variante gibt, wie man das schreiben
kann, hab ich irgendwo mal gelesen, so fangen wir mal an, also was wir auf jeden Fall nicht
mal machen wollen ist, statisch das einmal am Anfang zu laden und nicht mehr zu updaten,
das heißt mit der internen Liste in unserem UI, in unserer Fensterklasse bringt das das
ganze schon mal nicht, was wird das für ein Tool, du hast es gerade gesehen, guck mal,
kannst Overlayen, Bilder Overlayen und GIFs, transparente PNGs und GIFs, wobei es müssen
nicht mehr transparente PNGs sein, also Bilder und GIFs, Format ist fast burscht, außer
wenn es animiert ist, muss es halt ein GIF sein, so also mit einmaligen Liste laden am
Anfang ist es nicht getan und ihr habt mir gedacht, wir lagern das aus in irgendwie
in so eine eigene Klasse, die dafür zuständig ist, wir machen das mal ganz korrekt, wir
machen da eine eigene Datei, ich bin mir nicht ganz sicher, wie wir das nennen sollen das
ganze, wir machen mal so ein bisschen 0815 Standard Benamung, die man immer schön nehmen
kann, wenn ab sonst nichts einfällt, wenn man irgendeine Sammlung hat, es gibt eigentlich
zwei Varianten, wenn man eine Sammlung hat von Elementen, dann macht man entweder was,
was sich sowas wie, das ist auch in dem einen Pull Request drin, was sich sowas wie meme
Collection nennt, was dann im Hintergrund irgendwelche Dinger macht, wobei Collection
heißt eigentlich für denjenigen, der es liest, dass es halt im Prinzip mehr oder weniger
ja eigentlich sowas wie eine Liste ist, ja eine Liste, wo du dann eine Schleife drum
machen kannst und sonst was, so und das zweite Ding, was sich so eingebürgert hat, wenn
man eine Sammlung oder ne, ne, das ist keine Sammlung, das heißt eine Ansammlung von Objekten
hat, die man dann quasi auch mal rausgeben will und man durchlaufen kann und sowas, dass
man sowas macht wie ein, da stehen die Java Programmierer übrigens mega drauf, normal
meme repo machts, also Java Programmierer stehen unglaublich auf Klassen, die Manager
heißen, die Factory heißen und die Repository heißen, wenn ich es richtig schreiben könnte,
da stehen, ich weiß nicht genau warum ehrlich gesagt, aber jedes mal, wenn ich mir irgendwie
Java Source Code angucken muss, da besteht die Hälfte aus Sachen, die Manager Factory
Repository heißen und das nimmt dann ganz abstruse Ausmaße an, dass es dann in Java
den, die Manager Factory of Repository Manager Factories oder sowas gibt, dann hast du teilweise
in Java solche Klassen, die über einen halben Bildschirm gehen, die macht dann zwei Zeilen
oder so, da stehen die Java Leute halt drauf, so und das Ding ist jetzt dafür zuständig,
dass wir im Hinter, dass wir den Ordner überwachen und halt eben Sachen, Änderungen erkennen
plus, dass er immer eine aktuelle Liste zur Verfügung stellt von zur Zeit aktuellen Objekten,
also von aktuellen Bildern, so wie es gerade ist, also das heißt, ich muss auch gucken,
ob der EJX mittlerweile da ist, der ist auch nicht da, das heißt wir brauchen auf jeden
Fall sowas, was wir auf jeden Fall brauchen, weil sowas haben wir hier ja auch drinne,
wir brauchen immer eine aktuelle Liste mit allen gültigen Meme Bildchen, die brauchen
wir, dass wir sie anzeigen können, das ist ja der Kern, das ganze, also das heißt wir
brauchen auf jeden Fall irgendwie mal die Möglichkeit da eine immer aktuelle Meme Liste
raus zu holen aus der ganzen Sache, so und nachdem wir jetzt ja sicherstellen wollen,
dass die Liste, die wir rausgeben, nicht dazu führt, dass irgendwie unsere interne Struktur,
die wir haben, unsere interne Ordnung irgendwie kaputt gemacht werden kann, müssen wir sicherstellen,
dass das was hier rausgegeben wird eigentlich nur eine Kopie ist von unserer internen Liste,
die noch nicht mal so aussieht wie unsere interne Liste mit allen Meme Bildchen drinne,
sondern einfach nur dazu da ist, dass man eben eine aktuelle Auflistung bekommt.
Was ist da, eins, drei, drei, sieben, what the fuck, krieg ich Lied alle hier, so das
heißt wir brauchen noch Private, wir brauchen auch intern irgendeine Struktur, wo wir dann
die tatsächliche Zuordnung drinne speichern und dazu werden wir, hab ich mir überlegt,
dazu nehmen wir ein Dictionary und zwar ein Dictionary aus String und dem jeweiligen
Memeobjekt, String ist der Filename, ja also das hier, das bietet sich in dem Fall an,
weil den kann es tatsächlich nur einmal geben und nachdem wir den Filename immer brauchen
um zu gucken, ob das da ist oder ob es sich geändert hat oder ob es gelöscht wurde, ist
das eine super Sache für einen Key, da finden wir es auch schnell und müssen nicht immer
die Liste durchsuchen.
Was bei 32 Memes im Prinzip scheiß egal ist, 32 Dinge hat es in ein paar Nanosekunden wahrscheinlich
durchsucht, so und das Ding nennen wir dann einfach auch klein, nur für internen Gebrauch.
So und wie ich hier schon gesagt hab, die Liste, die wir rausgeben, die sollte eigentlich
im Prinzip immer nur eine Kopie sein von unserer internen Liste, was meckert der hier eigentlich,
nicht only, immer nur eine Kopie von unserer internen Liste, weil wenn wir jetzt quasi
unsere interne Liste, das ist das Dictionary hier, wo wir uns hier die Zuordnungen speichern,
so Dateiname zu Memebild und sowas, wenn wir das rausgeben, dann könnte einfach irgendjemand
dann sagen, blablabla repo, Memes, clear und dann ist alles weg, sprich da macht er quasi
unsere internen Ordnungen in der Klasse kaputt, deswegen müssen wir sicherstellen, dass wir
im Prinzip nur eine Kopie davon rausgeben.
Da machen wir sowas, das ist jetzt neu, das kann man seit C Sharp 7 kann man das machen,
und zwar gibt es da so eine, euer Property Syntax, kann man quasi direkt sagen, ich leite
das quasi auf einen Funktionsaufruf um, dann ist gut und dann kopieren wir uns einfach
alle Werte in den Array und geben das dann als Kopie raus, ich hoffe das macht eine Kopie,
aber muss es ja, ich mein wir brauchen von den Memes keine Kopie, wir brauchen einfach
eine neue Collection, die nicht unsere Diction, ja das passt so, das muss so gehen, genau
und jetzt kann ich das verwenden, extra, also von außen und ich mach hier nicht meine interne
Collection kaputt, oder kann ich nicht kaputt machen, so, das bringen wir uns allerdings
noch nicht allzu viel, jetzt müssen wir erstmal einen Konstruktor anlegen und wir brauchen
natürlich einen Pfad, nämlich den Pfad von dem Verzeichnis, den wir überwachen wollen,
anders funktioniert das ganze nicht, so, dann brauchen wir noch einen Private File System
Watcher, der heißt dann einfach mal Cal Watcher, New, so, das will er wahrscheinlich wieder
Read-Only machen, nein wir können gerne Read-Only machen, so, dem sagen wir jetzt, dass er
das übergebende Verzeichnis überwachen soll, wir interessieren uns für Dateien, die erstellt
werden, Dateien die unbenannt werden und Dateien die gelöscht werden, hier drinnen, also es
kann ja sein, dass ich ein Bild unbenenne, dann muss ich hier im Zweifelsfall die Shortcuts
noch einlesen, es kann sein, dass ich ein neues Bild reinkopiere, es kann sein, dass ich eins
lösche, dann muss es weg, und dann wollen wir die Überwachung einschalten, so, dann
brauchen wir noch eine Funktion, die das ganze macht, so, da werden die Argumente jetzt nicht
passen denke ich mal, das heißt wir brauchen dann, und was war das, Event, File Event Arcs
oder sowas, File System Event Arcs, genau, wunderbar, so, jetzt probieren wir mal ob das
prinzipiell funktioniert, Test, nein machen wir irgendwie File Changed, einfach mal kurz
gucken ob das funktioniert, was wir hier fabriziert haben, so, und das sollte jetzt ausspucken
wenn ich starte, sollte das ausspucken wenn ich irgendwie was hier an den Bildern ändere
oder unbenenne oder was auch immer, sollte das jetzt was ausgehen, probieren wir das
mal aus, erstmal muss ich das Ding noch laden, das sind hier meine Load Window, das ist ja
nur testweise, Fahrt ist dann der da, so, jo das wars, ok gucken wir mal ob das klappt,
so, benennen wir das mal um, wow, ach nee, das ist ja schon geöffnet, also Bild was ich
grad drauf zugreife kann ich natürlich nicht unbenennen, benennen wir mal Poggers um, wow,
hat funktioniert, ich hab es aus Versehen gelöscht, aber er hat es mitgekriegt dass
ich es gelöscht habe, und er hat auch wieder mitgekriegt wenn es Created wird, ok, das
funktioniert prinzipiell, das ist schon mal gut, sehr, sehr nice, Musik ist vorbei, so,
das klappt, das heißt ich kriege jetzt mit, wenn sich hier Bilder drinne ändern, gut, jetzt
kann ich noch auswerten, jetzt muss ich ja je nachdem was genau passiert, muss ich da
unterschiedlich drauf reagieren, so, juckt mich net, changed juckt mich auch net, mich
juckt plus Created, Deleted und Renamed bei den Bildern, so, wenn was Created wird ist
das relativ einfach, dann will ich das hinzufügen, dann ist es neu, da muss ich keine Sperenzien
machen, einfach hinzufügen und gut ist, fertig, so, wenn es gelöscht wird muss ich eigentlich
auch keine große Aktion machen, sondern, und deswegen habe ich hier oben auch als Key
den Pfeil, den Dateinamen genommen, weil das ist das eindeutigste an so einem Bild, und
jetzt muss ich das löschen, das ist auch einfach, ein bisschen komplizierter wird jetzt
wahrscheinlich Renamed, weil bei Renamed muss ich quasi das alte Bild hier oben draus entfernen
und das neue Bild mit dem neuen Namen dazu hängen, der Desmond hat eine Frage, ist vielleicht
ziemlich doof, aber ist mir gerade wieder auffallend, wofür genau steht das E-Punkt,
ach das da, meinste hier, na mit dem Punkt greifste auf die Methoden von dem Objekt zu,
das Ding hat bestimmt auch irgendeinen Namen, wahrscheinlich irgendwie Referenzoperator
oder so was, ich weiß gar nicht wie das Ding genau heißt, in C++ machst du so, was aus
irgendwelchen Gründen, die es sogar angibt, als Vervollständigung, aber das funktioniert
nicht.
Wir sagen jetzt ja, wenn der File System Watcher erkennt, dass sich das Bild ändert,
soll er in dem Fall, dass das Bild quasi erstellt wurde, diese Funktion aufrufen, und übergeben
quasi, wer das Event ausgelöst hat und was sich geändert hat.
Genau in dem Fall ist E ein File System Event.
So sieht es aus.
Und E Punkt Changed ist halt, deswegen da ist Visual Studio ganz praktisch, weil es hier zu allem was anzeigt.
E Punkt Changed, also Changed sagt ihr halt in dem Fall, zeigt ihr an was sich genau geändert hat.
Dementsprechend können wir auch gucken, wenn wir einen Switch auf diesen Typ machen, können wir dann quasi gucken,
wenn eben E Punkt Changed Created ist, dann machen wir das, wenn es Deleted ist, dann machen wir das, wenn es Renamed ist, dann machen wir das.
Jetzt habe ich es verschoben.
Kein BDO mehr, doch ich hole noch Daily Rewards.
Oh, Press of the Wild Musik, ich weiß nicht.
Ich muss euch ja sagen, so gut ich Press of the Wild fand, der Soundtrack hat mir nicht gefallen.
Der Soundtrack hat mir nicht gefallen, der war mir zu minimalistisch.
Und ja, ich weiß, dass das Absicht ist, aber es hat mir trotzdem nicht gefallen.
So, wie machen wir jetzt Renamed, was haben wir denn zur Auswahl?
Moment, da muss ich mal nachgucken.
Ha, ja, wusste ich doch.
Genau, das war nämlich nicht das.
Stimmt, das war das einzige, Renamed war das einzige Event, was andere Event-Arcs übergeben hat.
Aber das können wir schön machen, wir können nämlich einfach sagen, das ist jetzt auch neu, seit C Sharp 7.
Also wir wissen jetzt, dass es immer im Prinzip ein Filesystem Event-Arc Objekt gibt hier, bei einem Update von diesem Ordner.
Außer bei Renamed gibt es einen Renamed Event-Arcs.
Allerdings ist Renamed Event-Arcs abgeleitet von Filesystem Event-Arcs.
Das heißt, wir können ein schönes neues C Sharp 7 Feature verwenden.
Und zwar kann man das inline jetzt, wie nennen sie das, Pattern matchen.
Also man kann quasi sagen, ok, wenn jetzt der Change Typ Renamed ist, dann ist das hier kein Filesystem Event-Arc,
sondern das ist ein Renamed Event-Arc, das nennen wir mal R.
Also der castet das im Endeffekt, also ne, was heißt der castet das, der guckt, ob der Typ von E Renamed Event-Arcs ist,
und castet das quasi dann für mich schon.
Und mit R habe ich dann quasi das auf Renamed Event-Arcs gecastete Filesystem Event-Arcs.
Das ist ein bisschen schöner inline. Und wenn ich jetzt hier reingucke, sehe ich auch, ich habe mehr Sachen, nämlich bei einem Renamed Event,
bei einem Renamed Event brauche ich nämlich den alten Namen und den alten Fahrt und den neuen Fahrt.
Sonst geht es logischerweise nicht.
So, und deswegen kann ich jetzt hier sagen, bisschen lauter.
Stfu.
Ja, ich nehme hier, was Invisible Darkness geschickt hat. Das ist ein schöner Soundtrack.
So, ähm, remove. So, wenn die Datei entfernt wurde, müssen wir im Prinzip den alten Namen löschen, den neuen Namen hinzufügen.
Im Prinzip das und das hier zusammen. Das heißt, wir wollen jetzt erstmal den alten entfernen und den neuen hinzufügen.
Das kann man bestimmt irgendwie schöner machen, aber das muss ich jetzt erstmal tun.
So. Ach, Quatsch. So.
Wie wäre es denn mit der Metal Gear Rising Revengeance Ost als Hintergrundmusik?
Können wir das auch nochmal. Aber ich glaube, so lange brauchen wir heute nicht.
Ich zeige dir, was das macht. Marcilein. Und zwar, ich hoffe, es läuft gerade, weil wir haben rumgebastelt.
Es zeigt dir Bilder als Overlay. Allerdings hast du halt Tastatur-Shortcuts.
Also wenn ich jetzt Steuerung M einmal drücke, gibt es eine Runde MonkaS.
Wenn ich Steuerung M nochmal drücke, ist es wieder weg.
Drück ich L, ist LUL, drück ich 3, ist LUL 3D, drück ich 1.
Und passend für den EA Livestream haben wir extra noch das eingefügt.
Das kannst du damit machen. Transparente Overlays über allen anderen Anwendungen einplanten.
Und das ist halt auch wirklich Overlay, du kannst durchklicken.
Was wir jetzt gerade programmieren ist, dass du während das läuft auch Bilder hinzufügen kannst und löschen kannst,
ohne das Ganze neu starten zu müssen.
Sieht man das selbst auch oder nur das Stream? Das sieht man selbst auch.
Das ist gerade der Witz daran, weil OBS kann das zwar auch.
Und Elgatos Stream Deck und so können das auch.
Aber dort sieht man nur im Stream die Bilder. Das heißt, man sieht die selbst nicht.
Und ich habe nach einem Tool gesucht, wo man die Bilder selbst sieht.
Weil, stellt euch mal vor, man macht im OBS, definiert man sich einen Shortcut für LUL.
Dann blendet man das einmal ein, man sieht es selber nicht, man hat keine Ahnung, dass es an ist.
Und das Stream muss ich 10 Minuten LUL im Fullscreen angucken.
Und natürlich kannst du ja auch die ganzen Bilder definieren, was du halt, die Shortcuts kannst du dir halt selbst definieren,
je nachdem, wie du das Bild nennst. Wenn du also sprichst, wenn du das Bild F4 Gaben Scary nennst,
oder wichtig ist, dass das Bild halt F4 Unterstrich heißt, dann drückst du jetzt Steuerung F4 und dann ist der Gaben am Start.
Der schlecht freigestellte Gaben wohlgemerkt ist am Start.
Was hältst du von einer Soundboard-Funktion? Na, das sind Sachen, die man in Zukunft vielleicht mal einbauen kann.
Aber das ist keine schlechte Idee.
Also, ich denke mal, Otsaru, die Frage ist auch jetzt beantwortet damit.
Ich hab's ja gerade mehr oder weniger schon gezeigt, bevor ich das gelesen hab von dir.
Was passiert, wenn man zwei Bilder mit der gleichen Taste übernacht? Das ist eine gute Frage, dann kackts ab.
Das haben wir noch nicht behandelt, den Fehler. Aber das machen wir noch.
Das kackt ab mit, wie hieß das, Key Already In Use.
Kackts ab, wenn du versuchst, den gleichen Shortcut zweimal zu registrieren.
Und es funktioniert auch nicht, wenn du Shortcuts verwendest, die schon Windows verwendet. Das geht nicht.
Also sprich, wenn du jetzt irgendwie Alt-Tab oder so verwenden willst, dann sagt dir die auch Shortcut Already In Use.
Morgen hast du frei oder arbeitest du 80%? Nee, ich hab montags frei, nicht freitags. Morgen muss ich arbeiten. Montags hab ich frei.
Kennst du Ahead In Time? Ja, kenn ich. Ist ein sehr, ein nicees Game ist das.
So, ähm, ich will das nochmal fertig bauen.
So, von der Idee her ist es ja, von der Logik her, viel mehr brauchen wir jetzt ja an der Stelle gar nicht.
So, jetzt wollen wir was Neues. Haben wir noch nie gemacht. Ich glaub, ich glaub, in noch keinem Programm oder in keinem Stream bisher, auch nicht beim Screenshot Tool, haben wir Events verwendet.
Hab ich aber noch nirgendswo gemacht. Aber jetzt brauchen wir welche.
Denn, wenn dieses Ding hier, wenn ich das hier starte und das kriegt mit.
Das ist jetzt ein bisschen laut, das Soundtrack wieder. Ai.
So, ähm, wenn das jetzt mitkriegt, das läuft da im Hintergrund und checkt, ob sich hier in dem Ordner was ändert.
Wenn sich was geändert hat, dann muss ich das ja hier mitkriegen.
Das bringt mir ja nichts, wenn sich das einfach ändert im Hintergrund.
Da hab ich nichts davon. Ich muss ja darüber benachrichtigt werden, dass sich was geändert hat.
Und darauf reagieren. Das heißt, wenn mir das hier Bescheid sagt, mit einem Event, dass sich in diesem Ordner was geändert hat,
dann muss ich mir quasi die Liste hier neu holen und die Shortcuts neu anlegen.
Weil, mal angenommen, ich ziehe jetzt hier ein neues Bild rein.
Ähm, keine Ahnung, f12.blub.png, dann muss ich ja einen neuen Shortcut registrieren, nämlich Steuerung f12.
Das heißt, wenn das hier erkennt, dass es ein neues Bild gibt, muss ich das ja in meinem UI mitkriegen.
Dazu brauchen wir einen Event.
Ähm, overlayt das auch Games im Fullscreen? Nein, das geht nicht.
Window, Borderless Window Fullscreen geht.
Das ist das aktuelle Game, die Funktion für Borderless Window. Aber Fullscreen geht technisch nicht.
Wir haben schon das Maximale gemacht, was geht, dass die Bilder halt, dass man durchklicken kann,
dass die immer on top sind und dass du quasi nie den Fokus verlierst im Endeffekt.
Guck hier, ich track und drop im Hintergrund weiter, obwohl ich Overlay-Dinger ein- und ausblende.
Da passiert halt nichts. Aber Fullscreen geht nicht.
Weil Fullscreen ist exklusiv und das geht aus einem logischen Grund auch nicht.
Ähm, das hier, das Bild, man kann auch ganz einfach erklären, warum das im Fullscreen nicht geht,
im exklusiven Fullscreen nicht funktioniert.
Das hier ist ja im Endeffekt ein transparentes Fenster hier drum herum.
Ein transparentes Fenster, wo dann ein Transparent, ein GIF mit Transparenz drin ist.
So, und damit man mehr als ein Fenster quasi gleichzeitig rendern kann, muss der Windows,
wie heißt das Ding, DWM, dieser, der Windows, der von Windows, der Window Manager muss die Fenster rendern.
Ja, also sprich, der macht halt auch so Dinge wie dieses Window, überlappt dieses Window
und durch Transparenz gucke ich da so durch und sowas.
Ähm, das heißt der Windows, Window Manager muss das rendern, dass es funktioniert.
Und bei einer exklusiven Fullscreen-Anwendung rendert nicht der Windows, Window Manager den Inhalt.
Dementsprechend kann es nicht funktionieren.
Wenn man ein Overlay machen möchte in einem exklusiven Fullscreen, in einem Fullscreen-Spiel,
was exklusiv diesen Fullscreen-Modus hat, dann bleiben dir im Prinzip, bleiben dir eigentlich zwei Möglichkeiten.
Du verwendest irgendwelche Nvidia-Hacks, die haben da irgendwas für.
Ja, also so wie Steam zum Beispiel dann auch irgendwelche Bilder abgreift und sowas.
Ähm, was Normalsterbliche nur mit Quadro-Karten dürfen, darf Steam auch mit Geforce-Karten machen.
Also entweder verwendet man irgendwelche Nvidia-Hacks oder aber man muss das in das jeweilige 3D-Rendering irgendwie injecten.
Sein Overlay, so macht das, so macht das FRAPS zum Beispiel für seinen FPS-Counter, den es oben anzeigt.
Ja, oder Steam für den FPS-Counter und sowas.
Allerdings ein komplettes Overlay mit Bildern und so, das ist so eine Sache.
Zumal das Injecten in diese Diode-X-Rendering-Geschichte, da springen natürlich auch mal Anti-Cheat-Tools ganz gern drauf an.
Weil in der Vergangenheit haben das halt viele Hacks gemacht.
Wenn du früher einen Wall-Hack hattest, da musstest du ja irgendwie quasi anzeigen, wo der Gegner hinter der Wand ist.
So, und wenn du das quasi so gemacht hast, dass du in das Rendering vom Spiel eingekrippten hast, um dann quasi deinen Wall-Hack da rein zu rendern,
das war halt ziemlich easy zu bemerken für den Hersteller.
Das heißt auch die krassen Hacksore sind mittlerweile darauf umgestiegen, das mit Overlays zu machen.
Weil das merkst du nicht. Das kannst du im Prinzip nicht feststellen.
Zumindest nicht so einfach. Weil der Windows Display Manager, wie auch immer dieses Ding da genau heißt, ist ja für das Rendern zuständig.
Und dein Spiel rendert ganz normal und du siehst ja nicht, dass jetzt der Benutzer noch ein Fenster davor geschoben hat.
Das muss dich ja auch überhaupt nicht interessieren.
Das heißt Hacks haben heute auch eher so einen Overlay und hängen sich nicht mehr in das Spiel rein fürs Rendern.
Deswegen funktioniert das exklusiv Fullscreen nicht.
Und ohne Hacks, also offiziell funktioniert das bei exklusiven Fullscreen-Spielen nichts.
Nur halt mit irgendwelchen komischen Hacks, wie das zum Beispiel in FRAPS und Steam natürlich auch machen, dass du einen FPS-Counter hast.
Die einzigen quasi legit FPS-Counter sind halt die, die ein Spiel selbst zur Verfügung stellt, weil das rendert es halt selbst.
Ja, Desktop-Screenshots als Anti-Cheat ist auch gar nicht so blöd.
Wenn man quasi das Gleiche macht, was im Endeffekt Drucken bzw. Alt-Print und so macht, da kannst du ja auch nichts verstecken.
So, Events. Ich war bei Events.
Nun müssen wir jetzt ein Event einbauen, was uns hier in unserem UI Bescheid sagt, sobald sich im Hintergrund was geändert hat.
Gucken wir mal, wie wir das jetzt am besten machen. Eventhenge, brauchen wir da überhaupt einen für... Ich würde euch ganz sicher was machen.
Wir machen jetzt ein Event, das ich abonnieren kann aus meinem GUI, was mir Bescheid sagt, sobald sich was in diesem Ordner geändert hat.
Und das nennen wir einfach Updated. Updated, Gebated, Activated, Overrated. Updated heißt das Ding.
Und man sieht es jetzt auch schon.
Ich habe jetzt hier ein neues Event Updated. Und da kann ich mich jetzt dranhängen und sagen, wenn dieses Event auftritt, also sprich, wenn sich was geändert hat an den Bildern, dann ruf folgende Funktion auf.
Der klassische Weg ist, dass man das so macht, sprich, man muss dann eine eigene Funktion anlegen, die aufgerufen wird und hin und her.
Ich finde das mit Lambdas einfacher, weil wir müssen ja nicht viel machen im Endeffekt an der Stelle.
Jetzt muss man sich überlegen, was will man dann updaten, wenn sich eine Datei ändert. Im Prinzip sind das ja eigentlich nur die Shortcuts.
Also sprich, wenn das Programm läuft und ich lösche jetzt LUL, dann will ich das Shortcut für Steuerung L entfernen.
Wenn ich jetzt ein neues Bild rein mache, was F12 Blub heißt, will ich das neue Shortcut F12 anlegen.
Das heißt, ich brauche eine Funktion, die quasi ganz billig beim Aufruf alle Shortcuts löscht und alle Shortcuts neu anlegt.
Das ist die billige Variante, wo du am wenigsten Probleme hast.
Die legen wir jetzt mal erstmal leer an, ohne dass er was macht.
Refresh, ich weiß nicht, ob das ein schöner Name ist, aber das passt schon.
Refresh Keybindings macht erstmal nichts. Wir werden gleich basteln, dass die was macht.
Und wenn das Event aufgerufen wird, also sprich, sobald sich hier was ändert im Hintergrund, dann wollen wir diese Refresh Keybindings aufrufen.
Ich überlege gerade, wie wir das jetzt gescheit machen.
Was hat er für Schmerzen? Warum geht es nicht?
Okay, es funktioniert nicht, weil ich sage hier ja, dass dieses Event möchte Event-Arcs übergeben, aber diese Funktion hier nimmt keine Event-Arcs.
Aber eigentlich will ich überhaupt keine Event-Arcs. Das brauche ich ja auch nicht.
Updated reicht. Updated heißt, ich muss mir die Liste neu abrufen und gut ist.
Ganz schnell mal eine Frage. Man könnte sich für LoL einen Overlay machen und solange man es in Windows Fullscreen hat, sollte das klappen, oder?
Ja. Richtig.
Wenn du in Borderless Windout Mode oder irgendwie sowas hast, dann geht das.
Das funktioniert ja auch, was wir hier haben. Also die Bilder kannst du in LoL, wenn Windout Modus ist, kannst du anzeigen.
Hallo Max 3 Elmuth, Max Selmuth, Max Elmuth. Das funktioniert in LoL.
So, wir sind stehen geblieben. Okay, gucken wir mal, ob das prinzipiell tut.
Okay, das wird funktionieren, wenn man das richtig aufruft.
Das ist auch so was, als kleiner Tipp. Wenn ihr mal irgendwo Parameter kriegt, die ihr übergeben bekommt, die ihr eigentlich gar nicht braucht, kann man einfach hier underscore underscore schreiben.
Also Variable dürfen halt so heißen. Das ist so ein bisschen inoffizielle Konvention für, dass man es wegwirft.
LoL blockt Hotkeys von den meisten Programmen. Bin mir nicht sicher, ob das bei Memeboard geht.
Na ja, doch. Also je nachdem, wie sie es gemacht haben, müsste das funktionieren.
Das einzige, was sein könnte, wenn die einen eigenen Tastaturtreiber haben, so ein Low-Level-Ding, wie das VMWare zum Beispiel hat, und exklusiv die Tastendrücke abgreifen, bevor die quasi überhaupt bei Windows ankommen sozusagen.
Dann könnte das sein, dass es nicht funktioniert.
Allerdings würde damit ja LoL auch alle anderen Funktionen aushebeln.
Also sprich, wenn du eine, keine Ahnung, da kannste nicht mal Windows switchen gescheit, wenn die sowas blocken.
Es kann sein, dass die da was dagegen gebaut haben, weil die wollen ja wahrscheinlich auch gegen Makrosoftware vorgehen.
Wir können irgendwann mal ausprobieren, ob es in LoL funktioniert. Ich habe LoL noch nie installiert, aber wir können es ja mal ausprobieren.
Machen wir nichts bestreben.
Also wenn AutoHotkey nicht funktioniert in LoL, dann spricht das für ihren eigenen Tastaturtreiber, wie das VMWare auch macht.
Wobei, Moment, es ist ein Unterschied, geht es jetzt um Shortcuts senden an das Programm, ohne einfach nur Shortcuts durchlassen, dass ein anderes Programm darauf reagieren kann.
Dass Key Inputs senden an LoL nicht funktioniert, kann ich mir vorstellen, das wäre bescheuert, wenn sie das machen würden.
Aber ob die Shortcuts blocken, sodass sie auch bei anderen Programmen nicht ankommen, das kann ich mir kaum vorstellen.
Da würde ja Discord-Muten nicht mehr funktionieren. Stellt euch vor, LoL würde Shortcuts blocken, dann könnte ich mich im Discord nicht mehr muten.
Also sprich, wenn ich jetzt im Discord ein Shortcut für Alt-GR und M anlege, dass es mich jetzt mutet im Discord, und es würden die blocken, dann könnte es das glaube ich nicht.
So, übrigens, wir machen mal kurz weiter. Also wir wollen im Prinzip, sobald sich hier irgendwas ändert, die Key Bindings refreshen.
Ja, das wollen wir machen. Bloß das Key Bindings Refreshen halt gerade noch nichts macht, aber prinzipiell wollen wir das machen.
Jetzt müssen wir natürlich noch dafür sorgen, dass das Event, er meckerte ja schon, dass es nicht benutzt wird, dass das Event auch getriggert wird, sobald sich was ändert.
Und im Prinzip müssen wir das Event hier am unteren Ende von dieser Funktion triggern.
Also im Prinzip, sobald das hier durchgelaufen ist und alles richtig einsortiert wurde, können wir sagen, hallo an alle da draußen, es hat sich was geändert.
So, dann sagen wir es dis, update, invoke, invoke. So, und die ganzen Event-Arcs-Scheiß brauche ich nicht, die brauche ich eh nicht, will ich eh nicht auswerten.
Das ist übrigens auch schönes neues C sharp 7 Feature. Früher musste man immer sowas hier machen.
Dis, updated, ungleich Null, ungleich Null und dann, und dann konnte man sagen, dis, updated, ausführen.
Oder, ging das überhaupt so? Ja, genau. Doch, das ging so. So musste man das früher machen.
Weil es könnte ja sein, dass es niemand gibt, der das Event haben will. Und wenn es keinen gibt, der das Event haben will und ich rufe das Event auf, dann gibt es einen Fehler, weil er versucht was aufzurufen, wo halt nichts ist.
Das kann man jetzt schon umgehen mit diesem Null-Gedöns-Operator in C sharp 7. Fragt mich nicht, wie das Teil heißt, genau.
Der ruft das also nur auf, wenn da mindestens einer ist, der das Event haben will.
So, was mir jetzt echt auch krankkeks geht hier, dass ich hier irgendwelche komischen Event-Arcs und Geschiss brauche, das will ich nicht.
Das ist bescheuert, brauche ich nicht. Ich will einfach nur update wissen.
Du musst doch auch nicht, dass die... Das stimmt. Kann ich einfach einen normalen Event-Händler verwenden?
Naja, da muss ich aber auch so einen Scheiß angeben.
Nee, eine eigene Delegate will ich nicht, das ist doof. Sucked. Da muss doch jemand anderes geben. Da gibt es was schöneres für. 100 Pro.
Stack Overflow. C sharp. Empty Event-Händler. Ich habe keine Ahnung, was ich suchen soll. Krass.
Die wichtigsten Sachen, die wichtigsten Sachen, alle schon mal angeguckt.
Gecheat. Exposed. Max revealed. Ich habe gecheatet, ich habe schon mal nachgeguckt.
Nee, das will ich nicht, ich will kein eigenen. Ja, das ist kacke, das will ich nicht.
Ich will kein eigenen, das ist doof.
Das ist eine gute Idee, laubpetin. Das ist eine wirklich nice Idee.
Wir nehmen einfach kein Event-Händler, wir nehmen eine Action.
Und da können wir wahrscheinlich die Funktion sogar direkt... Oh, das ist sehr nice, das gefällt mir.
Da können wir nämlich die Funktion wahrscheinlich direkt hier dran hängen.
Oh, das ist schick. Das ist schick. Oh ja, das ist das, gefällt mir.
Das ist sehr nice. So mag ich das. Kein überflüssiges Geblubber, einfach nur das Nötigste.
Das Einzige, was wir jetzt noch nicht gemacht haben, obwohl ich am Anfang des Streams da irgendwie 20 Minuten drüber gelabert habe, ist,
wenn ich jetzt eben aus diesem Thread komme und in meinem UI-Thread etwas aufrufe, und je nachdem, was ich hier mache, kann es knallen.
Dementsprechend muss ich sicherstellen, dass es im richtigen Thread aufgerufen wird.
Das heißt, ich brauche noch einen Invoke. So, und dann funktioniert das nämlich auch nicht mehr so einfach.
Aber, weißt was, drauf geschissen. Es sieht halt ein bisschen hässlicher aus, aber es funktioniert.
Jetzt ist nämlich sichergestellt, dass RefreshKeyBindings immer im UI-Thread aufgerufen wird und nicht hier von diesem Background-Filesystem.
Watcher. So, das Ding hier ist jetzt eigentlich fertig. Mehr muss ich da nicht mehr dran machen.
Das funktioniert. Das finde ich sehr nice. Achso, doch, eine Sache muss ich noch machen, fällt mir klar.
Ich muss das Ding ja einmal initial befüllen. Also quasi das, was ich hier mache, muss ich hier einmal am Anfang machen.
Komm, wir machen das klassisch mit irgendeiner Schleife. Vorfile in Files, und jetzt sagen wir einfach this add.
So, jetzt haben wir nämlich den ganzen Campbell drin, und das ist einmal initial befüllt. Alles gut, alles toll.
Dann tauschen wir jetzt den Campbell erstmal aus. Und zwar, wir wollen jetzt keine interne Liste mehr mit Memes haben,
sondern wir wollen ein internes Memerepo haben, was jetzt einfach mal ganz willig hardcoded mit dem Fahrt aufgerufen wird.
Load brauchen wir auch nicht mehr. Load können wir hier rausschmeißen. Ah, das Ganze wird gleich schon ein bisschen übersichtlicher.
Das da verschieben wir mal in eine eigene Datei. So, jetzt gibt es aber doch irgendwelche Fehler.
Genau. Jetzt muss ich mal meinen bestehenden Code umstellen, der ja auf die interne Liste zugegriffen hat, dass der jetzt dieses Repo verwendet.
So. Updaten wir einfach nur, dass die Fehler weggehen. Und dann arbeiten wir uns da mal langsam vor.
Okay, jetzt sollte die gleiche Funktionalität wie vorher auch noch tun. Genau, aber das Updaten und so funktioniert natürlich noch nicht.
Aber Bildchen und so funktionieren alle. Also das klappt prinzipiell schon mal.
So. Ach ja, das müssen wir auch noch machen, dass Bild hoch und runter die Kreiselanimation triggert.
So. Ich meine, von der Idee her muss ich jetzt einfach bei einem Refresh...
Also sobald sich was geändert hat in dem Ort, dann muss ich ja meine Keybindings refreshen. Das heißt doch, von der Idee her, dass ich sowas hier machen muss.
Keybindings, clear. So. Und danach haben wir mal irgendwie eine Schleife über die neuen.
So. Nachdem das auch immer eine Kopie vom aktuellsten Stand ist, habe ich da auch gar nicht Gefahr, dass irgendwas kaputt geht.
So. Und jetzt fügen wir einfach das neu ein. Also im Prinzip nehmen wir einfach die Funktion, die wir schon mal gemacht haben hier.
Set Keybindings. So. Jetzt bin ich ja mal gespannt, ob das funktioniert.
So. Okay. Wir kopieren jetzt mal was. Wir kopieren jetzt mal was. Mal gucken, ob das funktioniert.
Wir kopieren jetzt da ein neues Bild rein, was den Shortcut F11 registrieren will.
Kaputt. Funktioniert nicht. Was habe ich denn verkehrt gemacht?
Fuck. What? Hä? Moment, gibt es das schon? Warum ist der already in use? Ich clear den Scheiß hier.
Ah, ich habe eine Idee. Das könnte sein, dass ja, die Dinger werden wahrscheinlich erst regulär geklärt, wenn das nächste Mal der Garbage-Collector läuft.
Hier verlieren sie alle Keybindings quasi ja nur ihre Referenz. Das heißt, ich muss die Dinger selbst aufräumen vorher.
Hallo Jonas Nils. Wir probieren jetzt mal aus, ob das daran liegt. Also quasi sowas wie... Keine Ahnung, ich probiere das jetzt einfach mal aus.
Keybindings. So. Und jetzt muss man aufpassen. Was keine gute Idee ist, wäre jetzt sowas hier zu machen.
Ich könnte mir vorstellen, dass es Probleme gibt, wenn ich for each über eine Liste mache und im Lauf vom for each quasi den Inhalt dieser Liste kaputt mache.
Das ist glaube ich keine gute Idee. Deswegen machen wir mal vorher uns irgendwie eine temporäre andere Liste und machen das dann dann kaputt.
So. Gucken wir mal, ob es jetzt funktioniert. Jetzt wird es spannend.
Ich hoffe, heute kommt keiner wieder und sagt, Max, drück doch Steuerung C zum Kopieren.
Sollte offensichtlich sein, warum das nicht funktioniert gerade, wenn das Programm gestartet ist.
Bäm. Funktioniert.
Poggers, Alter. Poggers. Omega Poggers. Monka Giga Poggers. Okay, das war es. Das war das Problem.
Oh, ich habe eine Idee. Wir können jetzt den übelst krassen Hack machen. Also, naja. Das war jetzt... Okay, die Ankündigung war ein bisschen übertrieben.
Aber ich habe eine Idee. Wir könnten jetzt mal... Also, es wird jetzt hässlich. Ich will bloß mal ausprobieren, ob das funktioniert.
Man könnte noch eigentlich sagen... Also, jetzt mal, wenn ich mir die Schleife sparen will, ich könnte jetzt quasi sowas hier in der Richtung machen.
Ähm, guck mal, ob das funktioniert. For each, ähm, äh, äh, key, key dispose.
Das geht. Was findet ihr schöner, so oder mit Schleife? Das sollte eigentlich das Gleiche machen.
So oder mit Schleife. Und vielleicht sogar noch kürzer. Einfach nur so.
Einfach nur so. Ich habe halt meine Bedenken, wenn ich quasi die Sachen kaputt mache in der Liste, während ich quasi drüber laufe.
Probieren wir es einfach mal aus. Scheiße, aber das sehen wir jetzt dann gleich. Ob das was bringt oder nicht.
Ich kann es jetzt löschen. Geht genauso. Nö. Okay, wir können uns das zu Listen sparen.
Da war ich ein bisschen übertrieben. Vorsichtig jetzt wahrscheinlich. Ja, so ist doch viel schicker. So ist es doch wirklich nice.
Wir löschen alle Keybindings, werfen danach unsere Liste mit Keybindings weg. Also den Inhalt der Liste mit Keybindings.
Und machen neue Keybindings. Eats as fuck, würde ich sagen. So und wir können das Ganze übrigens noch ein bisschen verkürzen.
Also ein Switch kann auch mal ein infinitendes Ding nicht in Bindingkey, sondern in Prefix. Weil an der Stelle ist es kein Key oder sonst was.
Es ist einfach nur ein String-Prefix. Key wird es erst hier drinnen, wenn man daraus ein Hotkey macht. So wir nennen das Ding Prefix.
Und nachdem wir ja gerade irgendwie schon den leichten Hang zu 1-Heilern haben, ich benenne das hier auch nochmal um.
Das heißt nicht change me, sondern zählen wir mal. Toggle me. Weil es zeigt ja auch das gleiche an und lässt es verschwinden.
So, nachdem ich gerade den Hang zu 1-Heilern habe, was haltet ihr denn von?
Achtung, ich bin noch nicht fertig. Ich bin noch nicht fertig. Was haltet ihr denn von sowas hier?
Okay, das ist vielleicht ein bisschen übertrieben an einen Zeiler jetzt, oder?
So oder eine Funktion mit bisschen kürzeren Zeilen. Moin, naturedief, def.
Wir können einfach noch einen Zeilenobbruch rein machen. Ach so schlimm sieht das doch gar nicht aus mit einem Zeilenobbruch, oder?
Das ist doch eigentlich ganz schick.
Eigentlich ist das das so ganz schick.
Bitte nehm geschweif- ne, ne, ne. Wenn wir es schon in einen Zeiler rein kriegen, dann machen wir das einfach ohne geschweifte Klammern.
Die ganze Klasse in eine Zeile.
Ach, ich finde das sieht gar nicht so schlecht aus jetzt. Es sieht schon ein bisschen hässlich aus. Ja, das muss man schon zugeben.
Egal. Ach ja, und das machen wir übrigens auch noch, fällt mir gerade auf. Man konnte dem Ding hier nämlich übergeben, ob case-sensitive oder nicht.
Das heißt, der interessiert sich jetzt dafür, ob es ein großes L ist oder ein kleines L hier und wir sagen ihm jetzt mal scheiß drauf. L ist L.
Ich lasse das jetzt mal so. Ich finde das eigentlich ganz schick. Es ist schon- also es ist jetzt nicht unbedingt das Schönste, aber dafür ist es kurz und knackig.
Mach das for each auch zu einem Lamm. Hab ich doch. Also hier innen drinnen.
So, fertig jetzt. Weiter, weiter im Text.
Gibt es überhaupt noch was weiter im Text? Ich meine, im Prinzip geht jetzt nicht das, was wir machen wollten.
Was mache ich hier eigentlich gerade? Das ist doch vollkommener Blödsinn.
Ich muss einmalig, einmalig, einmalig muss ich beim Start alle Keybindings anlegen und danach macht er das automatisch.
Danach macht er das automatisch immer, wenn sich was ändert.
Nee, da gibt es doch nichts drüber zu meckern.
Ja, das passt doch eigentlich. Eigentlich ist es genau das, was wir wollen. Mehr müssen wir doch gar nicht machen.
So, alles gut, alles nice.
So, was wir jetzt noch machen ist, dass das Bild sich dreht. Das brauche ich auf jeden Fall wieder.
Also sprich, dass das Bild muss sich drehen, sonst geht es nicht.
Die ursprüngliche Implementierung war ja, man klickt rechts auf das Bild, dann fängt es sich an zu drehen.
Das Problem ist, seitdem wir durch das Bild durchklicken können, ist halt mit Rechtsklick nichts mehr.
Dementsprechend müssen wir diese komischen Events da wieder weg machen.
What? Ah, ist das kompliziert. Warte, Window, da, Window.
Nein, geh weg. Piss dich alle. Das da weg, das da weg, gut, zack.
Das da weg, rumtracken ist eh nicht mehr angesagt.
Right Mouse Button ist auch nicht mehr angesagt.
Sondern wir registrieren uns jetzt einen neuen Hotkey für Page Up, Page Down.
Und hauen die Logik da rein. Und wir benennen das mal um.
Double Rotation. Und sagen jetzt hier, wir wollen den neuen Hotkey.
New Hotkey, äh, wieder Steuerung, Control, Key, äh, Page Down.
Page One mit Page Up an. Page Up. Und zwar...
Double Rotation. Ah ja, das kann ich jetzt hier natürlich so nicht direkt übergeben.
Ich bin mit euch ganz sicher, wie wir das jetzt hier machen.
Hab ich verschrieben?
Was, was, was hab ich vertan? Ah, ja, ich hab das unbenannt, obwohl es Blödsinn.
Brauchen wir doch alles gerne mehr. Okay, das funktioniert.
Äh, Key Up, Page, Page Down. Äh, Rosarota, Panther, ich zeig's dir gleich.
Schauen wir mal, ob das funktioniert mit der Rotation. Ha! Oh, nice! Jetzt haben wir einen richtig geilen Lull-Effekt noch.
Omega-Lull.
Monka-Shake. Monka-Shake. Also, das kann ich sehr zeigen.
Äh, Rosarota, Panther, was hier programmiert wird, äh, ist eigentlich das, was du hier siehst.
Du kannst Bilder transparent overlayen über alle anderen Programme.
Ohne, dass es das Programm da drunter stören wird, weil guck hier, du siehst, du kannst sogar durchklicken durch das Bild.
Das ist quasi gar nicht da im Endeffekt. Das ist Big Brain, das Programm, nicht Big Brain.
So, mir ist gerade etwas eingefallen, wir können uns diese ganze Funktion hier umsparen.
Wir können uns die ganze Funktion hier ersparen. Weil im Prinzip das einzige, was wir hier drin machen ist,
Storyboard, Start, Stop, Begin, Begin, Stop. Wir brauchen den ganzen Scheiß nicht.
Wir können einfach hier sagen, begin und end. Fertig.
Ups, ne, Stop, Stop war es, ne, Stop. So, wisst ihr, wieder was gelöscht.
Wenn man versucht, ein Meme auf Page Up und Down zu legen, stürzt er ab. Ja.
Das würde er aktuell noch machen.
Das finde ich ist ein geiler Effekt irgendwie, oder?
Ok, Page Down zum Rotation Stoppen, Page Up für Rotation Starten.
Das hat irgendwie was. Geht das auch mit Omega Null?
Oder kriegst du es ja mit Angst zu tun, ey.
Freust du dich auf Battlefield 5?
Ich bin, ne, ehrlich gesagt, freue ich mich nicht auf Battlefield 5.
Ich will mich von dem Game diesmal überzeugen lassen.
Ich gehe da mit keinen Erwartungen ran. Battlefield 1 hat mir ja, wie gesagt, ich habe es ja oft erzählt, überhaupt nicht gefallen.
Hallo, Schrecken. Es. Ich gehe da mit gar keinen Erwartungen dran. Ich will, dass das Spiel mich überzeugt diesmal.
Das kriegt keinen Vorschuss-Hype von mir, Battlefield 5.
Black Ops 4 übrigens auch nicht.
So.
Was hältst du von variabler Rotationsgeschwindigkeit? Ja, ich finde das eine gute Idee.
Und zwar, man sollte nicht nur links rotieren können, sondern man könnte vielleicht auch rechts rotieren.
Also man könnte quasi sagen, ok, ich drücke Page Up, er rotiert links, ich drücke Page Down, er stoppt.
Ich drücke Page Down und er rotiert in die andere Richtung.
Also man könnte nicht nur links rum rotieren, man könnte auch rechts rum rotieren.
Aber dazu muss ich mir erstmal Gedanken machen, weil dazu brauchen wir irgendwelche WPF-Magie, wo ich überhaupt keine Ahnung von habe.
Ich habe es ja mit Ach und Krach geschafft, diese Rotation das erste Mal mir zusammen zu Copy-Pasten von Stack Overflow.
Aber das nehme ich gerne als Pull-Request.
Also ich werde nach dem Stream wieder pushen, falls sich irgendjemand dazu berufen fühlt oder gerne daran mitwirken möchte.
Und das einbaut, dass man quasi nicht nur links rotieren kann, sondern auch rechts rotieren kann mit Bild hoch und runter.
Plus eventuell noch variable Rotationsgeschwindigkeit, wenn er richtig sophisticated langsam.
Den Pull-Request werde ich dann beim nächsten Stream gucken wir uns den zusammen an und Merchandise.
Gibt es jetzt noch etwas zu machen? Wir können noch den Krempel hier oben mal umbenennen.
Der meckert auch schon die ganze Zeit.
In was möchte er denn umbenannt werden? In SB.
Ne, bevor wir den SB nennen, nennen wir den Storyboard in groß.
Ja, okay.
Ja, also ich würde mal sagen, im Prinzip haben wir alles gemacht, was wir machen wollten.
Gibt jetzt eigentlich nichts mehr Großartiges zu tun in dem Stream heute, was Programmieren angeht?
Nächsten Stream bringen wir dem Ding Netzwerkfunktionen bei.
Dann wird es spannend, weil das habe ich auch noch nicht gemacht mit SignalR.
Wie heißt denn das überhaupt? Wie spricht man das aus?
SignalR, SignalIR, IR, IR, IR, wie spricht man das aus?
Habe ich nämlich mal einen Guide zugelesen und damit probieren wir das dann.
Da bringen wir dem Ding Netzwerkfunktionen bei, dass man quasi ein Dashboard hat,
ein bisschen wie diese Ordnerübersicht eigentlich, aber halt auf einem zweiten Monitor oder auf einem zweiten Rechner,
wo man halt quasi in diesem Dashboard anklicken kann und das, was man anklickt, erscheint dann, wird dann hier eingeplendet.
Also sprich, ich kann dann auf einem zweiten Rechner übers Netzwerk sagen,
hey, ich möchte jetzt gerne dieses Bildchen hier aktivieren und dann erscheint es auf dem anderen Rechner.
Das ist Pflicht, wenn man eine gewisse Anzahl hat, weil erstens, es soll ja nicht alles Shortcuts kriegen,
wenn man jetzt zum Beispiel irgendwas spielt oder irgendwie einen Livestream oder irgendwie
nehmen wir die E3 Pressekonferenz kommentiert, ein bisschen blödes Zeug dazu erzählt,
dann brauche ich ja nicht für alles Shortcuts, ich brauche hier so 3-4 Bildchen, die brauche ich laufend
und die anderen kann ich dann quasi über das Dashboard aktivieren vom anderen Rechner,
weil wenn ich hier jedes Mal die ganzen Shortcuts mir merken muss bzw. hier mit Steuerung C jetzt ja auch wichtige Shortcuts belege,
ist ein bisschen blöd. Das heißt, das nächste Mal gucken wir uns mal an,
wie wir dem Ding Netzwerkfunktionen beibringen, dass ich das fernsteuern kann, das Ganze noch.
Und wenn das fertig ist, werde ich das auch als erste Version dann zum runterladen für Nicht-Entwickler veröffentlichen
auf GitHub, dass man sich direkt runterladen kann. Aktuell kann man sich ja auch hier angucken auf
Systema, wichtige Shortcuts belegen, GitHub, Inboard und sich selbst kompilieren, wenn man das will.
Wenn die Netzwerkfunktion fertig ist, dann werde ich das auch direkt einmal zum Download anbieten,
dass das kann dann jeder verwenden, der will.
So, da wirklich langsam mal mit Programming heute fertig.
Ich gucke mal, ob der Ehex da ist. Wenn der Ehex da ist, spielen wir jetzt noch eine Runde.
Oder werden wir jetzt noch 1-2 Stunden, eher 2,5 Stunden, bis 22 Uhr spielen wir noch Realm Royale.
Oh, der Meshed streamt auch gerade Realm Royale. Da müssen wir jetzt mal gucken.
Der Meshed streamt Realm Royale.
Gucken.
Outer?
Sieht man nicht richtig. Er ist zumindest gleich tot.
Reckt. Schreckt.
Hast du mal in Quake Champions reingeguckt? Nee.
Ich kenne das von Streams, ja, aber etwas gespielt habe ich es noch nicht.
So, sind wir jetzt hier fertig? Ist ja noch irgendwas offensichtliches, was wir noch machen müssen.
Sollte Mist drinne stehen, quasi hier vorne, sollte hier einer sagen, ich möchte als Shortcut
irgendwie irgendeine Taste haben, die es nicht gibt.
Also ich möchte als Shortcut jetzt blub. Es gibt ja offensichtlich die Taste blub auf der Tastatur nicht.
Dann wäre er abgekackt und jetzt kackt er nicht mal ab, weil jetzt versucht er zu erkennen,
was das für ein Key ist und wenn er den Key nicht erkennt, dann legt er es einfach nicht an.
Das ist insofern eigentlich schon mal recht fehlertolerant jetzt dadurch geworden.
Was er nicht abfängt bis jetzt ist, wenn es das schon gibt.
Das könnten wir theoretisch noch einbauen.
Also ich finde bei Realm Royale ist gerade, dass es verschiedene Helden mit Fähigkeiten gibt,
auch das was es zu anderen Spielen irgendwo unterscheidet, zu anderen Battle Royale Spielen.
Ich meine, es hat ja schon im Vergleich zu Pupke, hat er den Realismus Faktor,
Inventory Management, relativ viel Mikro Management, Fortnite hat das Bauen
und Realm Royale hat halt Klassen mit Fähigkeiten.
Wenn du jetzt dem Spiel Klassen mit Fähigkeiten wegnehmen würdest,
dann ist es nur noch ein halbes Game im Endeffekt.
Hat dich der Mesh eigentlich mal real gesehen? Ja.
Wir kennen uns schon seit ein paar Jahren.
Also ich überlege gerade, wer kennt mich eigentlich in echt von YouTube Leuten?
Also länger als fünf Minuten mal gesehen.
Der Mesh kennt mich.
Wen kenne ich denn länger als fünf Minuten? Der kennt mich ja auch länger als fünf Minuten.
Der Mesh, der Lost, der Kanbum, der Self-Owned, der Krieger, der Gaming-Clerks, Nico.
Wen kenne ich denn noch? Wobei, den Nico habe ich auch nicht länger als fünf Minuten gesehen.
Wen kenne ich denn noch länger als fünf Minuten?
Ja, die ganze Call of Duty, die ganzen ehemaligen Call of Duty Leute.
Also den Marcel, Montana Black, die ehemaligen Call of Duty Leute.
Wen kenne ich denn noch? Dr. Banks kenne ich noch.
Also ich kenne ein paar Leute, aber so wirklich gut,
also länger und mit denen ich auch wirklich schon eine längere Zeit gelabert habe.
Von denen die noch aktiv sind, ist das eigentlich hauptsächlich der Mesh.
Der Lost auch noch ein bisschen, aber ansonsten hält sich den Grenzen,
wo ich da großartig Kontakt habe mit YouTube Leuten.
Ja, der Friseur, der ist jetzt keine YouTube Leute. Den Friseur kenne ich schon Jahre vor YouTube.
Der ist der, ich kann es ja nicht dabei erzählen.
Ah ja, der, äh, der, ähm...
Ich überlege gerade, kenne ich den Danny in Echt eigentlich?
Er stimmt in Solution noch, genau.
Kenne ich, ich überlege gerade, ob ich den Danny in Echt mal gesehen habe, keine Ahnung.
Nee, ich glaube nicht.
Ah, was auch immer.
Ich habe mich ja aus diesem ganzen YouTube Deutschland Zeug schon vor Jahren irgendwie ein bisschen rausgezogen,
weil mir das immer, immer, immer, weil das alles irgendwie, keine Ahnung,
immer weiter von dem weg entwickelt, wo ich mit was zu tun haben will.
Ich habe, ich habe, äh, irgendwo letztens einen Streamausschnitt gesehen,
wo sich Montana Black eine Rolex gekauft hat im Livestream.
Gut, wenn man, wenn man das halt unbedingt jedem zeigen muss,
dann warum nicht, aber das jetzt sein muss, sei mal dahingestellt.
Das Trash-TV-YouTube.
Ja, das Problem dabei ist ja gar nicht mal, dass es nichts Gescheites gibt.
Es gibt ja genug Gescheites, aber es wird einfach geflutet von Bullshit auf YouTube.
Und die Empfehlungen sind halt erst mal, wenn du da drauf kommst, so breit angelegt,
dass die gucken, dass die, wenn die dich noch nicht kennen, ne?
Denkt YouTube halt, aha, guckt mal, wir gucken, guckt es euch doch mal an.
Guckt es euch doch mal an.
Wenn ich hier, das haben wir das letzte Mal schon gemacht, das haben wir jetzt noch mal.
Ähm, ach nee, Moment, ich muss mal, ich muss nen, nen, nen, nen.
Ah ja, Git, äh, Committen muss ich noch.
Committen muss ich noch und pushen.
Mal gucken wir uns nochmal YouTube an.
Ich mach gleich mal ein Inkognito-Tab auf.
Ähm, Commit, ähm, Feinschliff.
Das wäre beispielsweise so ein Commit, wo ich auf der Arbeit sagen würde,
schreib nochmal ein ordentliches, aber ich darf das jetzt hier.
So.
Push.
Was kann der mal schreiben?
Master.
Wat?
Ich hab doch mein Key, ich hab doch mein Key hochgeladen.
Warum geht denn das nicht?
Was, was, was spackt denn das so rum?
Ist wieder Gefahr laufen mein Passwort zu exposen.
Okay, ist gepusht, Leute.
Wer sich dran beteiligen will, so zum Beispiel dieses, dieses Animationsding, Bild hoch, Bild runter.
Pull-Requests sind immer willkommen.
Auch der Pull-Request, der hat uns schon mal was gebracht.
Wir konnten nachgucken, wie das mit dem Tray-Icon funktioniert.
Leider ist das, passt das halt überhaupt nicht mehr zu unserem aktuellen
und auch nicht mit XML-Dateien, so wie im XML-Files, wie ich's haben wollte.
Aber trotzdem, schön, dass du das eingereicht hast.
Ich werd das jetzt mal...
Wie lehnt man hier auf GitHub überhaupt ab?
Ich close das mal, ne?
Wir haben es uns ja zusammen jetzt im Stream angeguckt,
auch ein paar nützliche Sachen jetzt rausgezogen,
aber in der Form passt es nicht mehr und ich will auch kein XML-Config.
Bible-Thump.
Was hast du für eine Tastatur?
Eine, hab's vorhin schon mal gezeigt, eine K95, eine Corsair K95 RGB Platinum.
Das Ding da.
Was wollen wir im nächsten Stream machen?
Es gibt ja im Prinzip zwei Sachen noch zur Auswahl.
So zwei größere, größere Dinger noch zur Auswahl.
Und zwar das Dashboard zum Fernsteuern von den Programmen.
Das ist halt ne Sache, die brauch ich selbst, weil wenn ich,
beispielsweise wo ich den E3-Stream gezeigt hab,
ich hab mir so ne rudimentäre Sache ja schon mal gebaut,
da kann ich mir die Shortcuts nicht alle merken.
Also hab ich mir einfach auf dem zweiten Bildschirm das Ganze aufgemacht
und konnte es dann dort anklicken und es wurde halt hier angezeigt.
Das war echt praktisch.
Also wollen wir die Fernsteuerung machen vom zweiten Rechner
oder vom zweiten Monitor aus, nächsten Stream,
wollen wir uns mal angucken, wie man Corsair RGB Tastaturen ansteuern kann.
Sodass man zum Beispiel anzeigen lassen können,
wenn man einen Shortcut gedrückt hat, dass der gerade aktiv ist.
Ich hab keine Ahnung, wie das geht.
Ich hab nur auf GitHub gesehen, dass es eine Library gibt, die das macht.
Wir könnten uns auch mal in dem Stream angucken,
wie man Corsair Tastaturen RGB Beleuchtung programmiert.
Was wollen wir denn im nächsten Stream machen?
Netzwerk, Fernsteuerung oder Corsair RGB?
Auch die Musik ist weg.
Beides ist eine größere Geschichte.
Und ich kann mich keine fünf Stunden konzentrieren.
RGB, okay.
Also mir ist egal.
24 Stunden Programming Stream.
Ich bin ja immer noch begeistert, dass das so gut ankommt.
Netzwerk.
Stimmt.
Und ich bräuchte dann wahrscheinlich eine Kamera für den Schreibtisch.
Dass man sieht, dass die Tastatur leuchtet.
Und sieht es ja langweilig aus.
Dann machen wir erstmal Netzwerk.
Dann machen wir erstmal Netzwerk.
Ihr hört einfach gerne zu.
Ein Tastatur-Cam.
Ich habe es gepusht.
So, ich mache mal kurz ein Release-Bild.
Guck mal, ob das auch schön unabhängig läuft, alles.
Weil ich glaube nämlich, dass das gar nicht die...
Das kopiert das nicht mit, oder?
Doch.
Hä?
Leute, das muss mir jetzt mal jemand erklären, das Cheggie-Nut.
Warum findet denn...
Wow!
Wir haben ordentlich viele Trey-Eikens erzeugt.
Warum findet ihr denn das Trey-Eiken?
Das liegt doch hier überhaupt nicht.
Das Trey-Eiken liegt hier.
Warum findet ihr das überhaupt?
Aber eigentlich ist es mir egal, dass es funktioniert.
Das ist eine Ressource in der Exe?
Ah!
Also, mag sein.
Ich habe das nicht eingestellt.
Ich habe sie einfach nur reingetrocknet.
Guckt.
Einfach nur da.
Also, wenn es eine Ressource ist, ist es auch gut.
Nice.
Wird es mit in die Exe gepuckt?
Keine Ahnung.
Das habe ich nicht eingestellt, dass es mit in die Exe gepackt wird.
So, ich würde sagen, ich esse jetzt was.
Und wenn der Ex am Start ist, spielen wir dann noch 2-2,5 Stunden Realm Royale.
Mittlerweile, muss ich sagen...
Zeige ich euch das mal kurz.
Steam.
Geh auf.
Mittlerweile haben wir sogar schon ein paar Games gewonnen.
Alter, geh mal auf.
Ich würde eigentlich nur kurz was zeigen.
Zack, zack, kein Bock.
Also, immer Discord da macht.
Discord, piss dich mal.
Komm mal.
Diamond Noob bin ich jetzt.
Jetzt können wir mal gucken.
Guck mal.
Jetzt machen wir mal das Memetool an.
Ups.
Memetool machen wir mal an.
Und Nu sollte hier eigentlich...
Guckt.
Man kann durchklicken.
Es ist Overlay in Game.
Was natürlich sehr, sehr nice ist.
So, und um das mal zu demonstrieren.
Weil es vorher in der Diskussion darüber gab.
Es funktioniert nur in Borderless-Window.
Wir können uns mal angucken, was passiert, wenn ich es auf Fullscreen stelle.
Und versuche einzublenden.
Passiert nichts.
Also man sieht, es wird angezeigt.
Aber es ist weg.
Also das kann nicht funktionieren.
Weil es halt exklusiv, ohne über den Windows DWM-Render-Dings zu gehen, auf den Bildschirm kommt.
Es funktioniert nur in Borderless-Windows und dann ist es halt direkt am Start.
Jetzt haben wir hier in Game.
In Game unsere Meme-Action.
Ja, ihr seht das Spiel nicht, weil es Fullscreen war.
Aber es hat nicht funktioniert.
Ja, für Fullscreen hätte ich Game Capture machen müssen.
Irgendwie hat Breath of the Wild schon ziemlich nervigen Soundtrack gehabt an manchen Stellen.
So, und nachdem wir jetzt...
Jetzt seht ihr es auch.
Jetzt habe ich kein Fenster zum Beenden.
Und jetzt ist es ja auch gut, dass wir unser Tray-Icon haben, wo ich sagen kann, Exit.
Dann ist es weg.
Kirby-Gummy-Race.
Die Musik ist aber geil.
Die Musik ist aber geil.
Also man sieht doch, es kackt nicht ab, wenn man schnell die Sache durchswitcht.
Die Musik ist aber geil.
Die Musik ist aber geil.
Wenn man genau dazu einschaltet, ist das irgendwie verstörend.
Das verstehe ich schon.
Also nochmal angemerkt, nur weil ich das dafür verwende, um irgendwelche Minenbildchen durchzuklicken und anzuzeigen,
heißt das nicht, dass man es dafür verwenden muss.
Man könnte das auch für deutlich seriösere Zwecke verwenden, indem man einfach passende Einblendungen macht.
Und der Vorteil ist halt einfach, ich sehe sie selbst, was bei reinem Overlay in OBS nicht so ist.
Wow, Gachi-Buzz.
Gibt es das eigentlich als ordentliches Skip? Das brauchen wir auch noch.
Ich weiß gar nicht, was jetzt kommt, wenn ich weiter runter scroll. Ich will es gar nicht wissen.
Das ist aber eine ziemlich schlechte Variante davon.
So Leute, ich gehe jetzt was essen. Danach, je nachdem, ob der Erex da ist oder nicht, spüren wir noch zwei Stunden Renin Royale.
Ich hoffe, euch hat's gefallen. Nächstes Mal werden wir uns dann die Netzwerkfunktionen widmen. Macht's gut. Bis denn. Tschüss.
See you.
