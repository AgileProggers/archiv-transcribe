WEBVTT

00:00.000 --> 00:22.560
Das war's für heute und wir sehen uns beim nächsten Mal wieder!

00:30.000 --> 00:38.000
Das war's für heute und wir sehen uns beim nächsten Mal wieder!

01:00.000 --> 01:08.000
So, exzellent! Da is er!

01:12.000 --> 01:16.000
So, ähm...

01:17.000 --> 01:20.000
Hört sich ein schlimmer an als das andere.

01:20.000 --> 01:30.000
Das kannst du mir nicht geben, das ist ja eklig.

01:31.000 --> 01:43.000
Das ist ja einschlimmer als das andere.

01:44.000 --> 01:47.000
Ja, meinetwegen.

01:47.000 --> 01:51.000
Moin, Leute! Jetzt sind wieder viele am Start.

01:52.000 --> 01:56.000
Ist quasi das Gegenstück zum Subbox-Kämpfer auf YouTube.

01:57.000 --> 02:00.000
Wir machen heute mal ein bisschen was anderes.

02:01.000 --> 02:02.000
Wir programmieren mal wieder was.

02:03.000 --> 02:06.000
Ich will nämlich was ausprobieren und zwar...

02:07.000 --> 02:09.000
Was ist das hier auf Domain-Check?

02:10.000 --> 02:13.000
Magenta.Gay! Stimmt, das hab ich ja ganz vergessen.

02:13.000 --> 02:17.000
Ich hab Magenta.Gay übrigens nicht registriert.

02:18.000 --> 02:22.000
So, ich muss mal kurz hier eine Runde Updates machen.

02:23.000 --> 02:25.000
Weil ich weiß nicht, ob ich die aktuelle.NET Core-Version hab.

02:26.000 --> 02:27.000
Danke schön für die Zaps! Wer gibt's?

02:28.000 --> 02:29.000
KlokxHD! 13 Monate!

02:30.000 --> 02:32.000
Massive! 13 Monate, das ist ja quasi schon.

02:37.000 --> 02:38.000
Exzellent!

02:39.000 --> 02:40.000
So, dann haben wir noch den Jatz...

02:40.000 --> 02:43.000
Ach nee, JET SQL.

02:44.000 --> 02:45.000
Ich hab doch irgendeinen Flag!

02:46.000 --> 02:47.000
Nee, doch nicht SQL.

02:48.000 --> 02:50.000
Ich hab nämlich genau an der Stelle einen Flag auf dem Monitor.

02:51.000 --> 02:53.000
Ich seh jetzt nicht, ob das ein I, sondern ein L ist.

02:54.000 --> 02:55.000
Ich muss mal kurz scrollen.

02:56.000 --> 02:57.000
Nee, das ist doch Jatz-Key eher.

02:58.000 --> 03:00.000
Nicht JET SQL oder so.

03:01.000 --> 03:03.000
So, danke schön für den Sub.

03:04.000 --> 03:05.000
Der Taser ist 16 Monate am Start.

03:06.000 --> 03:08.000
Jetzt wird's langsam echt schon hier.

03:08.000 --> 03:11.000
Unangenehm langsam.

03:12.000 --> 03:13.000
Wobei eigentlich...

03:14.000 --> 03:16.000
Also fürs Geld, ja.

03:17.000 --> 03:19.000
Danke schön für die ganzen 16 Monate.

03:20.000 --> 03:22.000
Massive! Big Brain Subscription.

03:23.000 --> 03:25.000
So, das soll man updaten hier.

03:26.000 --> 03:27.000
Machen wir mal auf.

03:28.000 --> 03:30.000
Ich zeig euch mal, was ich gefunden habe heute.

03:31.000 --> 03:33.000
Ich guck ab und zu mal bei GitHub, was so trendet, was so neu ist, was ihr nicht gesehen habt.

03:34.000 --> 03:36.000
Und ihr wisst ja, ich interessier mich für...

03:36.000 --> 03:44.000
Oder ich bastel schon eine Weile an einer Video-Streaming-Software für Überwachungskameras.

03:45.000 --> 03:46.000
Allerdings rein für den Heimbereich.

03:47.000 --> 03:49.000
Also sprich, die soll komplett im Browser funktionieren.

03:50.000 --> 03:51.000
Ich hab ja auch schon was gebastelt.

03:52.000 --> 03:53.000
Wir haben auch schon im Stream was gebastelt.

03:54.000 --> 03:57.000
Die aktuelle Version, die ich laufen hab, ist mit.NET und mit Go.

03:58.000 --> 04:03.000
Go für die Video-Streaming-Geschichte, weil es da für.NET nichts Gescheites gibt bis jetzt.

04:03.000 --> 04:05.000
Und ich hab jetzt was gefunden.

04:06.000 --> 04:08.000
So, haben wir jetzt einmal ordentlich geupdatet?

04:09.000 --> 04:10.000
Erstmal eine Runde...

04:11.000 --> 04:12.000
Oh, was ist denn hier alles drinne?

04:13.000 --> 04:14.000
Ja, komm, update mal, update mal, alles gut.

04:15.000 --> 04:18.000
So, machen wir mal kurz unsere Idee auf und ich zeig euch das jetzt mal.

04:20.000 --> 04:20.000
Ups.

04:21.000 --> 04:22.000
Ah!

04:26.000 --> 04:27.000
Placer!

04:28.000 --> 04:29.000
Was ist denn hier los?

04:30.000 --> 04:31.000
Was ist denn hier los?

04:31.000 --> 04:34.000
Äh, oh, 2019, das ist ja uralt.

04:35.000 --> 04:37.000
Ok, ich muss mal kurz...

04:38.000 --> 04:39.000
Ihr dürft jetzt nicht hingucken.

04:40.000 --> 04:42.000
Ich muss mal kurz die Idee kaufen.

04:48.000 --> 04:50.000
Ups, nein, ich will nicht Plant aufmachen.

04:51.000 --> 04:52.000
Geh weg.

04:53.000 --> 04:54.000
Ich hatte Plant noch nicht einmal auf.

04:55.000 --> 04:56.000
Ich weiß gar nicht, was ich mit dem Müll machen soll.

04:57.000 --> 04:58.000
Geh weg, Plant.

04:58.000 --> 05:00.000
Yes.

05:01.000 --> 05:02.000
So.

05:03.000 --> 05:05.000
Evaluation Feedback, no thanks.

05:06.000 --> 05:07.000
So, wir machen jetzt erstmal ein Update.

05:08.000 --> 05:09.000
Hab mich die Chatbrains Toolbox...

05:10.000 --> 05:11.000
Komm, wir machen erstmal ein Update.

05:12.000 --> 05:13.000
Will it Plant?

05:14.000 --> 05:15.000
Ey, die Typen machen wieder Videos.

05:16.000 --> 05:17.000
Die machen wieder Videos.

05:18.000 --> 05:19.000
Die haben vier Jahre keine Videos gemacht, der Dude.

05:20.000 --> 05:21.000
Und hat letztens wieder eins hochgeladen.

05:22.000 --> 05:23.000
Vor einer Woche.

05:24.000 --> 05:25.000
Guck mal, die haben ewig...

05:25.000 --> 05:27.000
Der macht so wenig Videos wie ich.

05:28.000 --> 05:29.000
Und die sind wieder am Start.

05:36.000 --> 05:37.000
Äh, ja, komm, mach Update.

05:38.000 --> 05:39.000
Auf geht's.

05:40.000 --> 05:41.000
Einmal Toolbox starten.

05:44.000 --> 05:45.000
Toolbox startet nicht.

05:46.000 --> 05:47.000
Exzellent.

05:50.000 --> 05:51.000
Hallo Mom, startet meine Chatbrains...

05:52.000 --> 05:53.000
Ach, die update gerade, deswegen startet die net.

05:53.000 --> 05:54.000
Das ist ja okay, das ist logisch.

05:55.000 --> 05:59.000
Ja, äh, während das Update kann ich euch ja mal erklären, um was es geht.

06:00.000 --> 06:05.000
Und zwar, äh, wie gesagt, ich verwende ja gerade, oder ich bin ja schon seit langer Zeit dabei,

06:06.000 --> 06:11.000
so eine Webcam, also Security-Kamera-Überwachungssoftware zu programmieren.

06:12.000 --> 06:15.000
Allerdings nichts großartig ausgefallenes, jetzt nicht sowas wie Blue Iris oder sowas,

06:16.000 --> 06:21.000
sondern im Prinzip einfach nur aus der Notlage heraus,

06:21.000 --> 06:26.000
weil ich nichts Gescheites gefunden habe, was das macht, was ich, was ich machen will.

06:27.000 --> 06:31.000
Und ich, Problem ist, ich kann's euch jetzt nicht wirklich zeigen, weil da die Kameras von mir drin sind.

06:32.000 --> 06:35.000
Ähm, guckt grad mal.

06:38.000 --> 06:39.000
Ob man das vielleicht sieht.

06:42.000 --> 06:45.000
Äh, ne, dann soll ich nicht zeigen.

06:45.000 --> 06:50.000
Ne, egal, also ihr müsst mir, ihr müsst mir das jetzt glauben, wobei doch, ich kann euch, ich kann euch den,

06:51.000 --> 06:53.000
kann euch den oberen Teil zeigen, ne.

06:54.000 --> 07:01.000
Also wenn man hier im Browser draufgeht auf die Webseite, dann, ähm, kriegt man halt Kameras angezeigt, wenn's lädt.

07:02.000 --> 07:03.000
Also, oh.

07:04.000 --> 07:05.000
Okay, das ist jetzt, das ist schlecht.

07:06.000 --> 07:11.000
Ah, sieht man das Hoftor, sieht man hier hinten das Zimmer von der Katz, sieht man hier unten den, den Bürgersteig ein bisschen

07:12.000 --> 07:13.000
und da unten sieht man die Treppe, aber das ist jetzt...

07:13.000 --> 07:20.000
Ähm, genau, und da, wie gesagt, das kann auch ein bisschen was aufnehmen und zumindest ist es aus der Notlage herausgeboren,

07:21.000 --> 07:29.000
weil ich nichts anderes gefunden hab und meine Anforderung ist, dass ich das im Browser verwenden kann.

07:31.000 --> 07:36.000
Face League, ja, genau, also das natürlich, ich hab hier keine Kamera drin, aber definitiv Face League.

07:37.000 --> 07:41.000
So, und das Problem ist halt, es gibt nichts Gescheites, was im Browser funktioniert.

07:41.000 --> 07:44.000
Zumindest nichts, was im Browser Low Latency funktioniert.

07:45.000 --> 07:49.000
Ich hab das vor einer ganzen Weile schon mal hier, wir haben sogar im Stream schon mal ein bisschen rumgebastelt.

07:50.000 --> 07:54.000
Hast du Dezember wieder frei? Ja, ich hab kompletten, kompletten Dezember frei.

07:55.000 --> 08:00.000
So, und, ähm, die Sache ist die, wie ich das jetzt aktuell gemacht hab, ist folgendes,

08:00.000 --> 08:11.000
dass das Late, also Latency-Frei bedeutet bei mir, ich will im Browser, sag mal so, nicht wirklich mehr als eine Sekunde durch Verarbeitung drauf kriegen,

08:12.000 --> 08:19.000
was bei Security-Kameras irgendwo ein wichtiger, oder generell bei Kameras generell ein wichtiger Aspekt ist.

08:20.000 --> 08:22.000
Dezember-Frei, das gibt's doch, klar, wenn man sich Urlaub nimmt, gibt's das.

08:22.000 --> 08:29.000
Und, so, genau, also, ähm, es gibt verschiedene Varianten, wie man Video-Streams im Browser kriegt.

08:30.000 --> 08:34.000
So, die bekannteste ist, glaub ich, äh, hier MJPEG, aber das suckt.

08:35.000 --> 08:39.000
Das kann so gut wie jede Kamera in irgendeiner Art und Weise, und das sind einfach Snapshots,

08:40.000 --> 08:43.000
also der macht einfach Bilder, einzelne Bilder, und überträgt die dann.

08:44.000 --> 08:48.000
Das ist erstens ziemlich groß, von der Bandbreite, das ist lokal nicht so schlimm,

08:48.000 --> 08:54.000
das ist sehr ressourcenintensiv, und es ist lahm, und es suckt, also, MJPEG ist übelster Crap.

08:55.000 --> 08:58.000
So, das nächste, was es gibt, um Sachen in Browser zu streamen, ist HTS.

08:59.000 --> 09:02.000
Das ist das, was Twitch früher gemacht hat.

09:03.000 --> 09:06.000
Mittlerweile macht Twitch da moderneres HTS.

09:07.000 --> 09:11.000
Das, äh, ne, genau, das ist, hat Sache, die ursprünglich sich Apple ausgedacht hat,

09:11.000 --> 09:18.000
HTS-Live-Streaming, das ist eigentlich was total Simples.

09:19.000 --> 09:23.000
Das besteht aus einer Playlist und aus kleinen Schnipseln Video.

09:24.000 --> 09:27.000
Und man kriegt einfach immer eine aktualisierte Playlist geschickt,

09:28.000 --> 09:30.000
mit so zwei bis drei Sekunden Videoschnipsel.

09:31.000 --> 09:35.000
Vielleicht habt ihr euch schon mal gefragt, warum, wenn ihr Twitch reloadet, die Seite,

09:35.000 --> 09:41.000
ihr manchmal ein bisschen hinten dran seid und das noch mal seht, was ihr gerade schon gesehen habt.

09:42.000 --> 09:45.000
Und das liegt an diesen kleinen Schnipseln von HTS.

09:46.000 --> 09:49.000
Also sprich, ihr bekommt eine Playlist, da ist ein 3-Sekunden-Schnipsel drin,

09:50.000 --> 09:53.000
oder ein 4-, oder ein 5-Sekunden-, oder ein 0-, oder ein 0-, 500-millisekunden-Schnipsel,

09:54.000 --> 09:55.000
das kann man sich aussuchen.

09:56.000 --> 09:59.000
Und, ähm, sagen wir mal, ihr bekommt einen 3-Sekunden-Videoschnipsel geschickt,

09:59.000 --> 10:04.000
und ihr, äh, nicht HTS, ich meine HLS, ich komme nicht auf HTS, Schwachsinn.

10:05.000 --> 10:07.000
So, und ihr kriegt einen Videoschnipsel geschickt,

10:08.000 --> 10:11.000
so, und dann guckt ihr den Videoschnipsel, zwei Sekunden, refreshed,

10:12.000 --> 10:14.000
und dann bekommt ihr, weil das noch kein neues Videoschnipsel ist,

10:15.000 --> 10:16.000
weil das gerade noch aktuell ist, bekommt ihr das gleiche noch mal,

10:17.000 --> 10:19.000
und dann guckt ihr euch die zwei Sekunden, die ihr schon gesehen habt, noch mal an.

10:20.000 --> 10:24.000
So, äh, so, das ist eine Sache, die funktioniert äußerst zuverlässig mittlerweile,

10:25.000 --> 10:26.000
das ist ziemlich gut.

10:26.000 --> 10:31.000
Ähm, allerdings, sagt das, auch, weil es hat Latency,

10:32.000 --> 10:34.000
ihr müsst euch überlegen, so eine Playlist hat vielleicht 5 Einträge,

10:35.000 --> 10:36.000
und jeweils 2-Sekunden-Schnipsel,

10:37.000 --> 10:39.000
und selbst wenn man das runterdreht auf 500-millisekunden-Schnipsel,

10:40.000 --> 10:43.000
sehen wir noch mal 5, man hat ordentlich Latency.

10:44.000 --> 10:45.000
So, das Beste, was man machen kann, ist,

10:46.000 --> 10:50.000
also, Neba, Neba HTTP 2 Live-Streaming und Geschütz, was Twitch mittlerweile macht,

10:51.000 --> 10:53.000
das Beste, das Beste, was man machen kann, ist WebRTC.

10:53.000 --> 10:58.000
Und, äh, meine aktuelle Software, das war ich euch gerade gezeigt im Browser,

10:59.000 --> 11:00.000
die macht das Ganze auch per WebRTC,

11:01.000 --> 11:03.000
die ist, äh, funktioniert ungefähr so,

11:04.000 --> 11:05.000
ich habe einen FFmpeg laufen, also,

11:06.000 --> 11:09.000
FFmpeg als Library, kein Kommando-Zeilen-Programm.

11:10.000 --> 11:14.000
Und, äh, übrigens, weil ich im Chat jetzt ein paar Mal WebRTC gelesen habe,

11:15.000 --> 11:17.000
WebRTC ist ziemlich beliebt für so Videokonferenz-Calls,

11:18.000 --> 11:19.000
die meisten Videokonferenz-Sachen werden über WebRTC gehen,

11:19.000 --> 11:23.000
WebRTC ist auch ziemlich easy, wenn man von Browser zu Browser das Ganze machen will,

11:24.000 --> 11:25.000
weil die Implementierung gut ist.

11:26.000 --> 11:28.000
Wenn man von einem Server-Backend zu einem Browser streamen will,

11:29.000 --> 11:30.000
ist das schon ein bisschen komplizierter,

11:31.000 --> 11:33.000
und glaubt mir, ich spreche aus Erfahrung, ich habe den Gramm selbst programmiert.

11:34.000 --> 11:36.000
Also, ich, das ist nicht so schön.

11:37.000 --> 11:39.000
So, es gibt auch nicht so viele Libraries zur Auswahl.

11:40.000 --> 11:43.000
Weil die ursprünglichen WebRTC-Bindings von Chrome,

11:44.000 --> 11:47.000
das ist irgendwie, fragt mich nicht, 50 Milliarden Zeilen C++-Code,

11:47.000 --> 11:48.000
und das gebe ich mir nicht.

11:49.000 --> 11:51.000
Aber WebRTC ist so ziemlich die beste Übertragungssache,

11:52.000 --> 11:53.000
wenn man Low-Latency im Browser haben will.

11:54.000 --> 11:57.000
So, und, ähm, aktuell verwende ich

11:59.000 --> 12:02.000
diese WebRTC-Library, das ist in Go programmiert.

12:03.000 --> 12:04.000
Allerdings ist meine Anwendung in sich in.NET Core,

12:05.000 --> 12:08.000
und, ähm, deswegen suche ich die ganze Zeit schon nach einer.NET Core-Library,

12:09.000 --> 12:10.000
die das Ganze machen kann.

12:11.000 --> 12:14.000
Aber das ist so ziemlich die beste WebRTC-Library, die ich kenne,

12:14.000 --> 12:16.000
äh, deswegen habe ich die halt verwendet.

12:17.000 --> 12:21.000
Aber muss halt sagen, dass es ein bisschen eklig ist,

12:22.000 --> 12:26.000
Go und.NET zusammen zu bringen.

12:27.000 --> 12:31.000
Das geht nur über den Umweg von irgendwelchen C-Export-Geschichten und so.

12:32.000 --> 12:34.000
Es geht, ich meine, sonst hättet ihr das Video eben im Browser nicht gesehen,

12:35.000 --> 12:36.000
aber schön ist das Ganze nicht.

12:37.000 --> 12:39.000
Deswegen war ich die ganze Zeit auf einer Suche nach einer.NET-Library,

12:40.000 --> 12:42.000
die das kann, und ich habe vorhin, äh,

12:42.000 --> 12:46.000
was entdeckt auf GitHub, das muss ich unbedingt mal ausprobieren,

12:47.000 --> 12:50.000
nämlich den ganzen Kram hier, Moment, den da.

12:51.000 --> 12:55.000
ZIP-Sorcery heißt ZIP, kann ZIP, interessiert mich aber nicht,

12:56.000 --> 12:58.000
kann auch WebRTC, und WebRTC ist eigentlich das Interessante.

12:59.000 --> 13:03.000
So, und wie das aktuell funktioniert, wie ich das mache mit der aktuellen Software,

13:04.000 --> 13:07.000
ist folgendermaßen, ich nehme FFmpeg als Library,

13:07.000 --> 13:12.000
ruf RTSP von den Kameras ab, das machen wir jetzt auch gleich im Stream.

13:13.000 --> 13:15.000
Insgesamt wird das heute vielleicht 1-200 Zeilen, das wird nicht viel.

13:16.000 --> 13:19.000
Einfach so mal testen, ob's geht, wenn's geht, ist gut, wenn's nicht geht, hab ich Pech.

13:20.000 --> 13:26.000
Das ruft den Stream von den Webcams ab und decoded den Stream aber nicht.

13:27.000 --> 13:29.000
Das ist grad der Witz an dem, was ich gebastelt hab.

13:30.000 --> 13:34.000
Die ganzen anderen Video-Streaming-Lösungen, die machen erstens nix über WebRTC oder die wenigsten,

13:34.000 --> 13:38.000
und die decoden und encoden den ganzen scheiß Bild rum.

13:39.000 --> 13:42.000
Was heißt, du kannst da gar nicht mal wirklich viele Kameras auf so was wie einen Raspberry Pi laufen lassen.

13:43.000 --> 13:47.000
Sondern was ich mache ist, ich nehm den Stream von der Kamera,

13:48.000 --> 13:52.000
empfange den mit FFmpeg, aber ich decode den Stream nicht.

13:53.000 --> 14:01.000
Ich kopiere mir einfach nur die einzelnen Pakete und schreib die dann quasi über WebRTC in den Browser rein.

14:01.000 --> 14:07.000
Das setzt natürlich zwei Dinger voraus, dass die Kamera einen Codec verwendet, den der Browser versteht.

14:08.000 --> 14:11.000
Und umgedreht, dass der Browser einen Codec unterstützt, den die Kamera verwendet.

14:13.000 --> 14:16.000
Okay, so war's, wie es aktuell funktioniert.

14:17.000 --> 14:28.000
Und mir geht's halt auf den Keks, dass ich so eine übelste Hybridgeschichte hab aus relativ viel Go und.NET Core, ASP.NET für die Web-Anwendung.

14:28.000 --> 14:31.000
Das ist nicht schön, macht auch ab und zu mal irgendwelche MemoryLeak-Probleme.

14:32.000 --> 14:36.000
Ich glaube, ich hab bei dieser Geschichte mehr MemoryLeaks gesucht, als die letzten zehn Jahre zusammen.

14:38.000 --> 14:42.000
Weil gerade Go an sich ist ja kein Problem,.NET an sich ist auch kein Problem.

14:43.000 --> 14:47.000
Aber wenn man da in Top macht, gibt's ein paar Problemchen ab und zu mal.

14:48.000 --> 14:51.000
Manchmal crasht's auch random und man weiß nicht warum.

14:52.000 --> 14:54.000
Das hab ich jetzt soweit alles hingekriegt, das läuft jetzt ziemlich stabil.

14:54.000 --> 14:57.000
Aber es wär natürlich schön, wenn ich.NET Library verwende.

14:58.000 --> 15:01.000
So, was ist eigentlich der Unterschied zwischen WebRTC und WebSockets?

15:02.000 --> 15:04.000
Das sind zwei komplett unterschiedliche Paar Schuhe.

15:05.000 --> 15:10.000
WebSockets ist... ist quasi... da muss ich jetzt erstmal...

15:11.000 --> 15:14.000
Also normalerweise ist HTTP ist ja Response.

15:15.000 --> 15:17.000
Also du schickst was hin und kriegst eine Antwort, fertig.

15:18.000 --> 15:20.000
Also HTTP ist nicht... hat kein State in dem Sinn.

15:20.000 --> 15:23.000
So, und da haben sie sich gedacht, okay, es wäre ja auch nicht schlecht,

15:24.000 --> 15:28.000
wenn man quasi eine konstante Verbindung vom Server zum Client haben könnte.

15:29.000 --> 15:31.000
Nicht nur Client Request Server antwortet, sondern auch,

15:32.000 --> 15:36.000
dass der Server den Client benachrichtigen könnte, wenn sich was ändert.

15:37.000 --> 15:39.000
So, irgendwelche Live-Notifications oder sowas.

15:40.000 --> 15:43.000
So, und dafür ist WebSocket da. WebSocket ist eigentlich nur so ein Message-Protokoll,

15:43.000 --> 15:49.000
was über lang laufende TCP-Sessions unter der Haube, die quasi ermöglicht,

15:50.000 --> 15:53.000
dass du vom Server den Client benachrichtigen kannst, wenn sich was getan hat.

15:54.000 --> 15:56.000
Das ermöglicht... das geht HTTP nicht.

15:57.000 --> 16:00.000
Hat Max seinen WebSock schon gehört? Nee, was?

16:01.000 --> 16:04.000
Das funktioniert... das ist so nicht gedacht mit HTTP.

16:05.000 --> 16:07.000
Und mit WebSockets geht das Ganze.

16:07.000 --> 16:13.000
So, und WebRTC ist noch was anderes. WebRTC ist in der Hauptsache

16:14.000 --> 16:21.000
ein Protokoll für Audio-Video-Übertragung mit relativ geringer Latenz

16:22.000 --> 16:25.000
vom Browser zu einem anderen Browser. Oder von einem Client zum anderen Client.

16:26.000 --> 16:30.000
WebRTC kann zwar auch Messages übertragen,

16:31.000 --> 16:33.000
das ist aber ziemlich große Überschneidung mit WebSockets,

16:33.000 --> 16:36.000
wenn man da einfach nur Data-Channel-Text überträgt.

16:37.000 --> 16:42.000
Dafür würde ich auch kein WebRTC verwenden. WebRTC ist eigentlich hauptsächlich für Audio-Video-Kram.

16:45.000 --> 16:49.000
DollyJoker, fünf Monate. Dankeschön. Excellent Subscription.

16:54.000 --> 16:58.000
Hast du schon mal was mit XMPP? Das ist Dings, wie heißt es?

16:59.000 --> 17:01.000
Jabber, ne? XMPP. Nee, habe ich schon nichts gemacht.

17:01.000 --> 17:04.000
Also, ich habe schon welche benutzt, aber nicht verwendet.

17:05.000 --> 17:08.000
Genau, und das ist die Library, die ich aktuell benutze für WebRTC-Kram.

17:09.000 --> 17:12.000
Das, was ich euch gerade im Browser gezeigt habe. Für die Kameras.

17:13.000 --> 17:18.000
Und Interop sagt halt go.net. Deswegen habe ich mich sehr gefreut,

17:19.000 --> 17:21.000
vorhin, als ich diesen Kollege hier entdeckt habe.

17:22.000 --> 17:25.000
Nämlich, die Library scheint es noch gar nicht so lange zu geben, ehrlich gesagt.

17:25.000 --> 17:30.000
Zumindest nicht mit WebRTC-Support, weil die ganzen Beispiele sind doch erst ein paar Tage alt.

17:31.000 --> 17:36.000
So, und das ist wieder so ein komischer Livestream an Musik,

17:37.000 --> 17:39.000
der sich nicht entscheiden kann, wie laut was ist.

17:40.000 --> 17:42.000
Ich mache jetzt irgendwie mal sowas da an.

17:42.000 --> 17:51.000
Okay, das wäre fast ein bisschen viel gechillert.

17:52.000 --> 17:57.000
Okay, guck mal, ob das was taugt.

17:58.000 --> 18:00.000
Deswegen habe ich mich echt gefreut, als ich vorhin die Library gefunden habe.

18:01.000 --> 18:04.000
Die hat seit noch nicht allzu langer Zeit, würde ich sagen, WebRTC-Support.

18:05.000 --> 18:08.000
Das sieht man nämlich daran, dass, wenn man sich die Beispiele anguckt,

18:09.000 --> 18:10.000
die sind teilweise nur 5 oder 4 Tage alt.

18:10.000 --> 18:16.000
So, und es gibt wirklich nur ziemlich wenig WebRTC-Libraries, mit denen man das machen kann.

18:17.000 --> 18:20.000
Die besten sind im Browser eingebaut. Die funktioniert nämlich auch.

18:21.000 --> 18:24.000
So, dann gibt es die eigentliche Chrome WebRTC-Implementierung.

18:25.000 --> 18:28.000
Das ist, was weiß ich, eine Millionenzeile C++ oder sowas.

18:29.000 --> 18:30.000
Dann gibt es noch das hier.

18:31.000 --> 18:37.000
Es gibt irgendeine Python-Implementierung, die aber total viele Probleme hat mit H.264-encoded-Videos.

18:37.000 --> 18:40.000
Und es gibt das hier. Ansonsten gibt es nicht allzu viel.

18:41.000 --> 18:42.000
Also das ist wirklich nice.

18:43.000 --> 18:45.000
Wenn ihr mal was anderes kennt, sagt Pride, ich kenne nur diese paar.

18:46.000 --> 18:48.000
Und das hier ist mit Abstand die beste Implementierung.

18:49.000 --> 18:50.000
Diese haben auch am einfachsten zu benutzen.

18:51.000 --> 18:54.000
Aber wenn man nicht komplett alles in Go macht, ist es ein bisschen eklig.

18:55.000 --> 19:01.000
Dazu kommt, dass man für Audio-Video-Zeug sich Go an sich gar nicht so sehr anbietet,

19:01.000 --> 19:11.000
weil Go ziemlich mies ist, wenn es um Zusammenarbeit mit C-Libraries geht.

19:12.000 --> 19:15.000
Und wenn man Audio-Video-Zeug macht, gibt es zwei Sachen.

19:16.000 --> 19:19.000
Es gibt G-Streamer und es gibt FFmpeg. Und das ist beides in C.

19:19.000 --> 19:31.000
Das heißt, wenn ich Go benutze für Audio-Video, muss ich permanent VLC...

19:32.000 --> 19:34.000
Ja, VLC ist was eigenes, aber mit FFmpeg dabei.

19:35.000 --> 19:39.000
Also die haben FFmpeg noch zusätzlich dabei für das, was sie nicht selbst können.

19:40.000 --> 19:42.000
Aber hauptsächlich ist es G-Streamer und FFmpeg.

19:43.000 --> 19:47.000
Ich glaube mir, außer VLC fällt mir ehrlich gesagt keine Software an, die VLC als Library verwendet.

19:47.000 --> 19:53.000
G-Streamer ist tatsächlich im Profi-Umfeld recht beliebt, habe ich mir sagen lassen.

19:54.000 --> 19:56.000
Keine Ahnung, kann ich weder bestätigen noch was dagegen sagen.

19:57.000 --> 20:00.000
Aber FFmpeg ist ansonsten in so ziemlich jeder Software, die Videos abspielt

20:01.000 --> 20:04.000
und die nicht unter Only-Windows läuft, ist FFmpeg am Werk für Videos.

20:05.000 --> 20:07.000
Oder G-Streamer.

20:08.000 --> 20:13.000
Genau, und der Interop zwischen Go und C ist halt ein bisschen lahm und auch eklig.

20:13.000 --> 20:20.000
Deswegen ist Audio-Video in Go halt doof, weil die größten Libraries eben in C sind.

20:21.000 --> 20:25.000
Excellent, aber bevor ich jetzt lange labere, wir fangen jetzt mal an.

20:26.000 --> 20:28.000
Da wird es glaube ich relativ klar, was ich mache.

20:29.000 --> 20:32.000
Ich brauche wieder mal ein Test-Video.

20:34.000 --> 20:36.000
Wo ist das Test-RTSP hier, den da?

20:36.000 --> 20:42.000
Den verwenden wir wieder zum Testen, den Stream.

20:43.000 --> 20:45.000
RTSP-Stream.

20:46.000 --> 20:51.000
Huge-Quali-Stream, aber ist egal, wenn das Video läuft, dann läuft es.

20:52.000 --> 20:55.000
Also, Go ist eine super Sprache im 079.

20:56.000 --> 20:58.000
Also, bis auf ein paar Sachen, die mir echt auf den Keks gehen.

20:59.000 --> 21:00.000
Aber sicher ist Go cool.

21:01.000 --> 21:03.000
Wenn man aber Interop zu anderen Sprachen braucht, ist Go nicht so gut.

21:03.000 --> 21:08.000
Also, wenn man in Go Libraries verwenden will, die es eben nicht in Go gibt, dann ist es nicht so schön.

21:09.000 --> 21:13.000
Dann ist es sogar in Python theoretisch schneller, wenn du C-Interop machen willst.

21:14.000 --> 21:16.000
Dafür ist der Rest nicht sonderlich gespint.

21:18.000 --> 21:19.000
So, also.

21:20.000 --> 21:25.000
Ach nee, Moment, ich wollte ja noch die IDEs aktualisieren.

21:26.000 --> 21:27.000
Coolbox.

21:28.000 --> 21:30.000
Oh, excellent.

21:30.000 --> 21:32.000
Excellent. 1KS, was ist das jetzt?

21:36.000 --> 21:39.000
Warum startet meine Jetplanes Toolbox nicht? Was ist denn das?

21:41.000 --> 21:43.000
Hallo? Toolbox starten, please.

21:45.000 --> 21:47.000
Ich bin verwirrt, warum geht das nicht?

21:51.000 --> 21:53.000
Ich will einfach nur mein Zeug updaten.

21:56.000 --> 21:58.000
Weil ich, what?

21:58.000 --> 22:02.000
Und, ah, ich habe bestimmt Kernel updaten. Ich reboote mal. Reboot hilft immer.

22:03.000 --> 22:04.000
Excellent, Reboot.

22:07.000 --> 22:10.000
Das ist fast schon Windows-Taktik. Geht es nicht dran, Rebooten für eine Runde?

22:11.000 --> 22:13.000
Ich glaube, ich habe ein Kernel-Update gemacht, ja.

22:14.000 --> 22:16.000
Deswegen meckert er auch wegen irgendwelchen Modulen.

22:21.000 --> 22:25.000
Also, ich muss dir ehrlich sagen, also das, was ich, ich muss mal den Chat aufmachen,

22:25.000 --> 22:27.000
dass ich dann zwischenzeitlich mal ein paar Sachen besprechen kann.

22:28.000 --> 22:32.000
Also, das, was der Imp schreibt, ist auch eine Sache, da steht man öfters mal davor.

22:33.000 --> 22:37.000
Wenn man eine Weile aktiv ist, hat man sich so die einzelnen Sachen schon zusammengescriptet,

22:38.000 --> 22:42.000
die man öfters braucht. Da steht man auch öfters mal davor und muss sich überlegen,

22:43.000 --> 22:46.000
programmiert man das irgendwie mal ordentlich neu in einer anderen Programmiersprache.

22:47.000 --> 22:50.000
Und ich bin für mich bisher zu dem Schluss gekommen, nee, ich lasse alles, wie es ist.

22:50.000 --> 22:57.000
Weil ich habe schon viele Sachen versucht, neu zu basteln und bis die neu gebastelten Sachen so gut sind wie die alten Sachen,

22:58.000 --> 23:00.000
der Aufwand lohnt sich meistens nicht.

23:01.000 --> 23:06.000
Deswegen lasse ich meine eklichen, gehackten Sachen auch ekliche, alte, gehackte Sachen sein

23:07.000 --> 23:13.000
und mache manche Sachen vielleicht mal neu, aber nur, wenn mir neue Ansätze zu einfallen, sonst lasse ich es dann.

23:14.000 --> 23:17.000
Außerdem ist das schöne an Bash, du kannst halt überall drauf ausführen.

23:17.000 --> 23:20.000
Alles Geschmackssache. So, mal gucken, ob jetzt das mit der Toolbox geht,

23:21.000 --> 23:26.000
ob ich jetzt updaten kann. Ah, jetzt, jetzt. Java, geht.

23:33.000 --> 23:39.000
So. Die können sich nicht entscheiden, wie laut der Stream ist hier.

23:41.000 --> 23:43.000
Ich lasse es jetzt einfach mal so.

23:43.000 --> 23:47.000
Browser Extension, nein. Also wir aktualisieren mal die ganzen Ideen.

23:49.000 --> 23:52.000
Und dann legen wir los, weil es ist schon 22 und 22.

23:53.000 --> 23:58.000
Aber wie gesagt, es gibt nicht viel. Also es gibt nicht viel Code da.

23:59.000 --> 24:05.000
Ich denke mal, es gibt am Ende vielleicht, was weiß ich, 50 Zeilen HTML und irgendwie 200 Zeilen.NET.

24:06.000 --> 24:08.000
Mal gucken, mal gucken. Schauen wir mal.

24:08.000 --> 24:14.000
Guck mal bitte im Discord unter Memes, da hat hier mal ein Beat unter einen Soundschwipsel von dir gepackt.

24:15.000 --> 24:16.000
Okay, das gucken wir gerade nochmal kurz.

24:17.000 --> 24:21.000
Aber Chat, ich muss euch schnell ausmachen, nicht, dass ich im falschen Channel bin.

24:24.000 --> 24:28.000
Man weiß ja nie. Und Discord geht ja immer in den Channel.

24:29.000 --> 24:33.000
Nicht, dass ich da oft gucken würde oder so, aber ja, man weiß nie.

24:33.000 --> 24:39.000
Man weiß nie. Okay, also ich bin im richtigen Channel.

24:40.000 --> 24:43.000
What the fuck ist denn das hier? Warum ist hier Pokémon am Start?

24:44.000 --> 24:45.000
So, wo muss ich hin?

24:48.000 --> 24:51.000
Das mache ich mal kurz zu hier. Wie kann man das nicht zu machen?

24:54.000 --> 24:55.000
Wo muss ich hin? Memes?

24:55.000 --> 24:56.000
Memes?

25:02.000 --> 25:03.000
Das hier?

25:03.000 --> 25:18.000
What the fuck ist das?

25:18.000 --> 25:33.000
So schnell? Oh Gott.

25:49.000 --> 25:53.000
Ein wahres Meisterwerk.

26:03.000 --> 26:05.000
Oh Mann, kommt da noch was anderes?

26:05.000 --> 26:21.000
Kommt da noch was anderes? Ja, das ist ja nice. Ein wahres Meisterwerk.

26:23.000 --> 26:26.000
So, wir haben geupdated. Gut, jetzt können wir loslegen.

26:26.000 --> 26:32.000
Oh, das ist doch so bescheuert. Evaluate, wir evaluieren.

26:33.000 --> 26:37.000
Zum Glück, zum Glück kann ich meine, meine Trial fortsetzen.

26:39.000 --> 26:41.000
Okay, also, what?

26:41.000 --> 26:55.000
What?.NET Core Web Application. Eine Web API Application. Die nennen wir, wie nennen wir die jetzt? Monac-S.

26:58.000 --> 27:03.000
Oh, komm wursch, wieder Kram-HR-Store, bla, bla, bla, bla, noch Authentification, alles gut, alles richtig.

27:03.000 --> 27:11.000
Anlegen, Terminal mal aufmachen, hier ohnehin schieben. So, zack.

27:12.000 --> 27:22.000
Warum ist der Schrift so klein? Das ist ja, da sieht es ja gar nichts. Hat er meine, hat er meine Settings vergessen oder so?

27:22.000 --> 27:32.000
Font? Wo ging das nochmal? Font, Appearance, Font Size?

27:33.000 --> 27:40.000
Ich finde das voll versteckt. Editor Font?

27:40.000 --> 27:53.000
Font? Ah ja, hier. Ich finde das übelst versteckt bei diesen JetBrains Sachen, immer die für Farben und Schriftgröße und so.

27:54.000 --> 28:01.000
Hack brauchen wir. Hack 16. Hack 18? Hack 18, Hack 18, ist gut. Ja, okay.

28:01.000 --> 28:15.000
Warte mal, bitte. Ja, exzellent. Wir können es nochmal, wir können es nochmal eine Stufe größer machen.

28:15.000 --> 28:30.000
Und mal 19. Ja, okay, ja, jetzt erkennt man es doch eigentlich ganz gut. So, Rider Projects Monarchs.net Watch Run.

28:30.000 --> 28:44.000
Ach so. So, jetzt machen wir mal hier einen Browser auf. Ich mache mal einen Chrome auf und gucke, ob die Seite da ist.

28:44.000 --> 28:59.000
Local Host 5000. Ach, das hat Redirect auf, hat SSL. Okay, das müssen wir erstmal alles abstellen. Also, Authorization weg, KTPS Redirection weg. Brauche ich keinen Mensch.

29:00.000 --> 29:07.000
Dann legen wir noch einen Ordner für die Webseite an und machen schon mal eine leere Webseite rein. Dann können wir loslegen.

29:07.000 --> 29:21.000
Directory www root. So, dass der die Fileserver, dass er die Webseite ausliefert, aus dem, statische Webseite aus dem Ordner ausliefert.

29:22.000 --> 29:28.000
Gibt es denn was zu den Grafikkarten von AMD? Ich weiß nicht, ob sich, ich meine, soll ich? Ich meine, kann ich machen.

29:28.000 --> 29:48.000
Ich weiß nicht, ob das so spannend wird, ehrlich gesagt. Kann ich, ich meine, kann ich machen. Wann ist denn das? Donner, Mittwoch? Der Stream? AMD?

29:48.000 --> 30:10.000
AMD? AMD gerade ein bisschen blablabla. Radiant Reveal. Da, 28.10. Um wie viel Uhr? 17 Uhr. Ja, können wir machen, aber ich weiß nicht, ob es so spannend ist.

30:10.000 --> 30:19.000
Ich habe da nicht so große Hoffnung, ehrlich gesagt, drin, dass die bei AMD da was vorstellen, was Nvidia Konkurrenz macht. Aber man weiß ja nicht.

30:20.000 --> 30:33.000
So, legen wir erstmal eine Webseite an. Irgendwas. Index html. Und da schreiben wir jetzt drauf. Test 0w. So, und gucken, ob das funktioniert.

30:33.000 --> 30:46.000
Live Server starten. Da ist er. Eine Runde 0w. Beste hübscheste Seite aller Zeiten. So, da können wir einmal anfangen.

30:46.000 --> 31:02.000
Ich würde sagen, als erstes müssen wir die Library einbinden, dass wir das ausprobieren können. Also wir brauchen als Library einmal das da. Das brauchen wir nämlich für WebRTC und wir brauchen FFmpeg für die Webcam Videos.

31:02.000 --> 31:19.000
Exzellent. Da. Jawoll. Aktuelle Testversion. Von was lesen die? Testversion? Releases? Wo stehen Releases? Manchmal finde ich mich auf GitHub irgendwie nicht zurecht.

31:19.000 --> 31:33.000
Sollten nicht die Releases drunter stehen? Hier, guck mal. Also die sind wohl gerade ganz aktuell dabei, was das angeht. Wenn es die letzte Testversion vor 5 Tagen gegeben hat, dann ist auch der WebRTC Support noch relativ neu.

31:34.000 --> 31:41.000
Ich bin auch übelst verwirrt. Wisst ihr, was mich bei GitHub, bei dem GitHub, die es sein am meisten verwirrt? Das Releases manchmal rechts stehen und manchmal unten.

31:41.000 --> 31:52.000
Früher war das relativ einfach, da hast du Releases immer hier oben in der Leiste gehabt. Musstest du früher noch auf Code klicken? Ich weiß, du hast die Releases immer in der Leiste gehabt. Die hast du einfacher gefunden.

31:53.000 --> 32:08.000
So, also installieren wir mal die Library. Install. Das ist die, die ich ausprobieren will. So, und dann brauchen wir noch FFmpeg. Ohne FFmpeg geht nichts, was Video, Audio und Webcam angeht.

32:08.000 --> 32:19.000
Zack, FFmpeg. Gut, da haben wir unsere Abhängigkeiten dabei. Die Murke ist gut, na dann. Ich habe die mal auf gut Glück angemacht, das ist hier der Stream.

32:19.000 --> 32:38.000
Ich hoffe, ich komme jetzt nicht gleich hier DMC, Dingsbums, Takedowns oder so, weil ich irgendeinen Stream laufen habe. Aber ich glaube, das ist Musik, die ist nicht so im Fokus der Stonks anwältend.

32:38.000 --> 32:50.000
So, also wir machen jetzt erstmal die Webseite, soweit, dass ich was sehen würde. Also wir brauchen einen Videoplayer ohne Stonks, weil die Stonks setzen wir später aus dem JavaScript raus.

32:50.000 --> 33:10.000
Da kann ich wieder meine Huge Massive JavaScript Skills walten lassen. Übrigens, das hier wird sich wahrscheinlich jeder JavaScript Mensch, wird sich sagen, Max, was macht er da? Aber ich kenne keinen besseren Weg, wie ich in JavaScript, in meinem Script Tag eine Assungfunktion verwenden kann.

33:10.000 --> 33:20.000
Wenn da einer von euch eine Ahnung hat, dann sagt mir Bescheid, ich weiß nix besseres. Ich weiß, dass das nicht sonderlich JavaScript Style ist.

33:20.000 --> 33:46.000
So, also, wir haben einen Videoplayer, der macht Autoplay, der kriegt Controls und ist standardmäßig Muted. Wenn ihr mal eine Anwendung, oder wenn ihr mal was programmieren solltet, mit dem Videoplayer Element, und ihr wundert euch, dass ihr, par auf, Leute, jetzt kommt Massive Tip, das Problem hatte ich nämlich auch schon öfters.

33:46.000 --> 33:53.000
Und ihr wundert euch, dass auf mobilen Geräten euer Video nicht funktioniert, dann liegt das daran, dass ihr es nicht gemuted habt.

33:53.000 --> 34:19.000
Weil die ganz alle Mobile Browser, oder mir fällt jetzt kein Mobile Browser an und weder Android noch IOS macht das so. Die spielen nur Videos ab, wenn sie gemuted sind. Wenn Videos nicht, also wenn Video Element nicht gemuted ist, spielt es weder Android noch IOS ab. Also wenn ihr mal was bastelt und ihr fragt euch, warum irgendwelche Sachen nicht abgespielt werden, dann weil ihr es nicht gemuted habt.

34:19.000 --> 34:29.000
Ansonsten funktioniert's, aber ist ja auch verständlich, weil keiner will auf eine Webseite gehen, erst mal angeschrien werden von 30 Werbesachen.

34:29.000 --> 34:48.000
SQL WebSockets Lego, was soll denn SQL WebSockets sein? Also SQL ja, WebSockets ja, aber WebSockets haben doch mit SQL gar nichts zu tun.

34:48.000 --> 35:00.000
Wie gesagt, wenn ihr keine Library findet, um direkt auf eure Datenbank zugreifen zu kommen, macht GraphQL davor, das ist das einfachste, was du machen kannst mit Webrequests.

35:00.000 --> 35:17.000
Aber WebSockets ist für Kommunikation vom Server zum Client gedacht, um dass der Server den Client benachrichtigen kann. Inwieweit das jetzt was bringt bei eurer Datenbank, kann ich schlecht beurteilen.

35:17.000 --> 35:29.000
Oh, der Tanzer hat BigBrain. Leute, ich hab mir übrigens was überlegt für den Chat. Wir haben ja manchmal schon richtig krasse BigBrain Antworten im Chat gehabt.

35:30.000 --> 35:41.000
Und ich werd das jetzt so machen, wenn es irgendwelche exquisite BigBrain Antworten gibt. Es gibt jetzt so einen VIP-Tag, hab ich gesehen, auf Twitch.

35:41.000 --> 35:50.000
Da hab ich mir überlegt, dass ich für einen Monat einfach den BigBrain Antwort Leuten einen VIP-Tag gebe. Man hat da nix von, aber es sieht cool aus.

35:51.000 --> 36:00.000
Und vielleicht hat man ja Glück und man kann diesen VIP-Tag sogar customisieren, dann kriegen die einen BigBrain Emote.

36:00.000 --> 36:11.000
So, also Moment, der Chat hat gerade Folgendes geschrieben, ich soll das hier machen.

36:12.000 --> 36:28.000
Ok, das klingt logisch, dass das funktioniert. Das klingt, es sieht zwar ein bisschen hässlich aus, aber das sollte funktionieren. Guck mal mal in die Konsole rein, ob das, ja das funktioniert.

36:28.000 --> 36:35.000
Also ich versuch jetzt mal zu erklären, was das macht und dann sagt ihr mir, ob ich richtig liege.

36:36.000 --> 36:42.000
Also das da ist einfach nur ein Block quasi in JavaScript, der keine tiefere Funktion hat.

36:43.000 --> 36:49.000
Also wahrscheinlich brauch ich das, um das zu gruppieren irgendwie, oder geht das auch so? Nee, das geht nicht.

36:50.000 --> 36:54.000
Also das ist irgendwie so eine Blockgeschichte in JavaScript oder sowas, was auch immer.

36:54.000 --> 36:59.000
So, das hier ist der Async-Keyword. Das da ist, dass das eine Funktion ist, die keine Parameter kriegt.

37:00.000 --> 37:06.000
Das hier ist ganz normales Lambda-Arrow-Dingsgedöns. Das ist der Body von der Funktion.

37:07.000 --> 37:17.000
Und der macht Log 1, 2, 3, Kappa 1, 2, 3 in Chat auf die Konsole. Und das hier ist, dass die Anonyme Funktion direkt ausgeführt wird, wenn ich das richtig verstehe.

37:17.000 --> 37:19.000
Wenn ich das richtig verstehe.

37:22.000 --> 37:26.000
Es sieht aber nicht gerade schön aus, muss man sagen.

37:28.000 --> 37:30.000
Ist korrekt.

37:31.000 --> 37:33.000
Nice.

37:33.000 --> 37:44.000
Liko, dafür ist WebSockets das Beste, was ihr machen könnt. Ich kann dir noch was, je nachdem, was ihr als Backend verwendet.

37:45.000 --> 37:54.000
Solltet ihr mal.NET verwenden als Backend, würde ich euch empfehlen, anstatt WebSockets gleich das dazu verwenden.

37:54.000 --> 38:08.000
Das ist quasi der Microsoft-Aufsatz auf WebSockets. Die ein paar Sachen abnimmt. Aber ansonsten ist WebSockets absolut Standard und funktioniert wunderbar.

38:08.000 --> 38:26.000
Unsere Webseite ist schön hässlich und funktioniert. Eine Sache machen wir nochmal. Style für das Videotag. Höhe 100, Breite 100. Das reicht.

38:26.000 --> 38:37.000
Das reicht. Exzellent. Fullscreen Video-Player. Vielleicht soll ich die Höhe mal weg, gleich mal nur die Breite. Nee, das geht gar nicht. Die Höhe. Nur die Höhe.

38:42.000 --> 38:44.000
Na ja, was auch immer.

38:44.000 --> 39:09.000
Das wird schon passen. Was? WV habe ich doch. Ah, VW. Jaja, richtig.

39:09.000 --> 39:17.000
Ah ja, jetzt passt es. Jetzt ist es auch nicht breiter. Okay, exzellent. Jetzt haben wir unsere Videoplayer da.

39:18.000 --> 39:25.000
Ja, also mit Blazer, da bin ich ja mal gespannt. Wir haben das mal ausprobiert vor einem Jahr oder so. Da gab es noch richtig viele Probleme.

39:26.000 --> 39:32.000
So mit JavaScript aufrufen und sonst was. Mittlerweile gibt es weniger Probleme. Ich habe letztens erst einen Webcast drüber gesehen.

39:32.000 --> 39:38.000
Aber die haben immer noch das Problem, dass halt die.NET Runtime runtergeladen werden muss. Und das ist halt irgendwie 8 MB.

39:39.000 --> 39:44.000
Und wenn du 8 MB runterladen willst, dann ist es ja schon quasi wie als letzter Halb Facebook inklusive einem JavaScript runter.

39:45.000 --> 39:54.000
Was möchtest du programmieren? Also ich habe ja aktuell so eine Videoüberwachungssoftware gebastelt mit WebRTC,.NET und Go zusammen.

39:54.000 --> 40:02.000
Go, weil die einzig sinnvolle WebRTC Library, die gut funktioniert hat, in Go programmiert ist..NET und Go Interop suckt allerdings.

40:03.000 --> 40:09.000
Und ich habe heute eine Library entdeckt, die WebRTC in.NET macht. Und da bin ich aber echt gespannt drauf.

40:10.000 --> 40:17.000
So, jetzt müssen wir folgendes machen. Als erstes machen wir mal den FFmpeg-Teil, weil der FFmpeg-Teil ist easy.

40:17.000 --> 40:25.000
Den FFmpeg-Teil habe ich schon oft gemacht, da weiß ich, wie es funktioniert. Wir brauchen unseren RTSP-Teststream, den da.

40:30.000 --> 40:45.000
Normalerweise, by the way, macht man das nicht so. Ich sage es gleich. Normalerweise macht man nicht hier in diesem Startup-File von der Web-Anwendung irgendwelche großartigen Background-Io-Audio-Video-Geschichten.

40:45.000 --> 40:49.000
Da machst du normalerweise einen eigenen Background-Dienst, den du hier nur startest.

40:51.000 --> 40:59.000
Kann ich auf die Test-Seite? Das können wir tatsächlich machen. Ich habe doch noch irgendwo einen Hetzner-Server rumstehen, da kann ich das mal draufpushen.

41:00.000 --> 41:03.000
Da könnt ihr dann drauf gehen und gucken, wie toll Latency-Free das funktioniert.

41:04.000 --> 41:09.000
So, also. Wir machen mal eine Funktion hier für FFmpeg.

41:09.000 --> 41:14.000
Wieso ist Kappa Gold? Oh, das ist ein ganz schlechter Chebat.

41:26.000 --> 41:29.000
Ich glaube, das ist eine FFZ-Geschichte, oder?

41:29.000 --> 41:36.000
Dass Kappa Gold ist.

41:43.000 --> 41:49.000
Mein Kappa ist wirklich Gold. Warum ist... Warum ist der...

41:50.000 --> 41:55.000
Also, es gibt ja manchmal einen goldenen Kappa, aber ich glaube nicht, dass ich den abkriege.

41:55.000 --> 42:06.000
Es gibt ja manchmal goldenen Kappa, random in irgendwelchen Channels, aber ich glaube nicht, dass der bei mir gerade im Channel wirklich ist.

42:11.000 --> 42:13.000
Golden Kappa.

42:16.000 --> 42:20.000
Der ist gerade überall, ja. What? Okay, wir müssen jetzt mal hier loslegen.

42:20.000 --> 42:25.000
Okay, also wir machen jetzt erstmal den FFmpeg-Part. Den FFmpeg-Part weiß ich, wie es halbwegs funktioniert.

42:26.000 --> 42:31.000
Ich sage halt nur dabei, normalerweise macht man einen Background-Service. Ich mache es jetzt testweise hier einfach mal im Start-up.

42:32.000 --> 42:40.000
Also, wir starten den Hintergrund-Thread, weil diese Audio-Video-Geschichte, die muss natürlich im Hintergrund laufen.

42:41.000 --> 42:45.000
Ich kann jetzt nicht einfach hier in meinem Programm nebenbei Webcams abrufen.

42:45.000 --> 42:53.000
Also, wir starten jetzt hier mit irgendwas. Wobei, nee, wir machen es ganz anders.

42:54.000 --> 42:59.000
Wir machen hier unten irgendeine Funktion. Public... Public...

43:04.000 --> 43:07.000
Cube. Bester Name aller Zeiten.

43:07.000 --> 43:14.000
Loop. So, und dann starten wir das hier in einem eigenen Thread und gut ist Loop. Bester Name.

43:15.000 --> 43:19.000
Also, wenn das nicht mal hier Expressive hoch 10 ist, dann weiß ich auch nicht.

43:20.000 --> 43:22.000
Was? Enter Completed Insert Newline.

43:27.000 --> 43:31.000
Ja, okay, was auch immer. Also, ich finde Loop ist ein sehr guter Name dafür.

43:31.000 --> 43:39.000
Excellent. Exquisite Name. So, und den müssen wir den mal mal Private und den mal mal Unsave, weil...

43:40.000 --> 43:51.000
Unsave. Wir müssen das Ganze Unsave machen, weil das ist C-Code und C-Code aufrufen ist Unsave.

43:52.000 --> 43:58.000
Und damit das Ganze funktioniert, müssen wir dem hier sagen, irgendwo hier... Oh, wo ist das denn Rider versteckt?

43:58.000 --> 44:01.000
Hier Allow Unsave Code. Excellent.

44:02.000 --> 44:11.000
Normalerweise erlaubt das C-Sharp nicht, weil da kann es ja alles Mögliche machen und Sachen kaputt machen und Speicher kaputt machen und sonst was machen im Hintergrund.

44:12.000 --> 44:24.000
Aber das muss halt einschalten. Normalerweise ist es so gedacht, dass man Unsave nicht in seinem Hauptprogramm verwendet, sondern dass man Unsave quasi in der eigenen Library rappt.

44:24.000 --> 44:28.000
Aber gut, wir müssen FFmpeg verwenden, da bleibt einem nichts anderes übrig.

44:29.000 --> 44:33.000
Also, jetzt legen wir... Das ist die Adresse zum Stream.

44:40.000 --> 44:42.000
Wie ich es noch im Clipboard-Manager habe.

44:42.000 --> 44:54.000
So, also das ist die Uhr von unserer Testwebcam. Ich sag mal stellvertretend Webcam. Es ist zwar ein Video-Stream, aber es ist ein RTSP-Video-Stream. Das ist das, worauf es ankommt.

44:57.000 --> 45:03.000
Ich hab doch irgendwo was, wo ich ein bisschen abgucken kann. Da muss ich den Kram nicht neu machen, weil FFmpeg hab ich schon öfters gemacht.

45:03.000 --> 45:11.000
Genau, ha, ich hab was, ich hab was gefunden. Exquisite, da kann ich jetzt abkopieren. Nice.

45:12.000 --> 45:15.000
Ich cheat jetzt, ich kopiere was aus einem anderen Projekt. Bam.

45:17.000 --> 45:20.000
Da weiß ich nämlich, dass es funktioniert mit Video-Abrufen.

45:24.000 --> 45:27.000
So, also das Ganze müssen wir starten, das haben wir gestartet.

45:27.000 --> 45:33.000
FFmpeg, Context. So, also ich erklär auch gleich, was es macht.

45:35.000 --> 45:38.000
Also, FFmpeg kennen die meisten von euch wahrscheinlich.

45:40.000 --> 45:44.000
Das kennen die meisten von euch wahrscheinlich als Kommando-Zeilen-Tool, FFmpeg.

45:45.000 --> 45:49.000
Alternativ kennen vielleicht manche auch FFplay oder FFprobe, aber das ist alles FFmpeg.

45:49.000 --> 45:56.000
Und viele Formate, die VLC abspielen kann, kann VLC auch nur wegen FFmpeg.

45:59.000 --> 46:03.000
Äh, übrigens, ich muss die Einrückung ändern, das ist viel zu viel Einrückung hier.

46:04.000 --> 46:10.000
Wie macht man das im Rider nochmal? Tabs? Tabs? Nee.

46:10.000 --> 46:17.000
Indent? Hier? Nee.

46:18.000 --> 46:20.000
Unten rechts? Ah, exellent, exellent.

46:21.000 --> 46:26.000
Hier, also. Indent, Intent, in zwei und zwei. Zack.

46:27.000 --> 46:31.000
Und jetzt sagen wir Reformat. Haha.

46:32.000 --> 46:34.000
Gleich, oh, das ist doch schon ein FFmpeg.

46:34.000 --> 46:40.000
Und jetzt sagen wir Reformat. Haha. Gleich, oh, das ist doch schon viel besser.

46:41.000 --> 46:45.000
Wie ist bei euch? Vier Spaces oder zwei Spaces?

46:46.000 --> 46:48.000
Aber unabhängig von der Sprache, was ist euch lieber?

46:55.000 --> 46:59.000
Vier? Zwei? Vier? Okay, viel mehr machen vier, hätte ich jetzt gar nicht gedacht.

46:59.000 --> 47:07.000
Aber gerade in so Sprachen wie C-Sharp, wo halt auch öfters mal mit Curly Braces um sich geschmissen wird,

47:08.000 --> 47:11.000
dann spart das unglaublich Einrückungstiefe. Also ich finde zwei viel praktischer.

47:12.000 --> 47:16.000
Fünf? Okay, fünf ist exotisch. Oder vielleicht war es auch G-Bait.

47:17.000 --> 47:19.000
Oder wir machen einfach alles in eine Zeile.

47:19.000 --> 47:22.000
Genau, keine Zeile. So, also was das hier macht, ist Folgendes.

47:23.000 --> 47:26.000
Das ist die Uhrl zu unserer Webcam. Zu unserem Testvideo in dem Fall.

47:28.000 --> 47:34.000
Das hier setzt ein Timeout. Wenn fünf Sekunden lang keine Antwort mehr kommt,

47:35.000 --> 47:37.000
dann bricht er das Ganze ab, weil sonst haben wir, bleiben wir hängen.

47:38.000 --> 47:41.000
Sackt. So, das ist FFmpeg-Intent.

47:41.000 --> 47:48.000
Das braucht man nicht. Und das hier startet den Stream von dieser Uhrl.

47:49.000 --> 47:51.000
AV-Format Open Input, da übergibt man einen Kontext.

47:52.000 --> 47:56.000
Das ist so ein internes FFmpeg-Ding und die Uhrl für den Stream.

47:57.000 --> 48:01.000
Und das war es im Endeffekt, was man in FFmpeg machen muss, um Stream zu öffnen.

48:02.000 --> 48:04.000
Jetzt muss man, das war natürlich jetzt ein bisschen zu spät.

48:04.000 --> 48:10.000
Man muss natürlich den Stream noch auslesen.

48:11.000 --> 48:13.000
Brauchst du noch Rainbow-Prakets? Gibt es das für Ryder?

48:14.000 --> 48:19.000
Also in Visual Studio Code habe ich Rainbow-Prakets.

48:20.000 --> 48:23.000
Ich habe keine Ahnung, ob es hier Rainbow-Prakets gibt, aber wahrscheinlich als Addon.

48:24.000 --> 48:25.000
Aber brauche ich nicht unbedingt.

48:26.000 --> 48:29.000
So, okay. Was der macht, ist, der guckt, ob er den Stream öffnen kann.

48:30.000 --> 48:32.000
Wenn er den Stream öffnen kann, dann kann er den Stream öffnen.

48:32.000 --> 48:36.000
Wenn er den Stream nicht öffnen kann, dann wirft er einen Fehler.

48:37.000 --> 48:38.000
So, next.

48:39.000 --> 48:41.000
Jetzt gucken wir erstmal, ob das ein gültiger Stream ist.

48:42.000 --> 48:46.000
Ich copy-paste, das ist nicht so, dass ich hier der ultra-mega-schnell-Hackster bin.

48:47.000 --> 48:52.000
Ich copy-paste das gerade aus einem anderen Projekt, weil ich bilde mir ein, das hat funktioniert.

48:53.000 --> 48:54.000
So, weiter.

48:55.000 --> 48:59.000
Jetzt gucken wir erstmal, ob der irgendwelche Metadaten vom Stream lesen kann.

48:59.000 --> 49:01.000
Wunderbar, ich glaube, das brauchen wir gar nicht.

49:02.000 --> 49:06.000
So, und jetzt kommt was, was ich immer gerne vergesse, wenn ich das neu bastle.

49:07.000 --> 49:20.000
Und zwar, man muss schauen, ob es einen Videostream überhaupt gibt.

49:21.000 --> 49:24.000
Weil es gibt ja durchaus RTSP-Streams, die audio-only sind.

49:25.000 --> 49:26.000
Deswegen muss man gucken, ob es einen Videostream gibt.

49:26.000 --> 49:28.000
Und das hier guckt, ob es einen Videostream gibt.

49:29.000 --> 49:35.000
Der loopt alle Streams durch, die es gibt, und guckt, ob der Media-Type Video ist.

49:36.000 --> 49:42.000
Und wenn es einen Videostream gefunden hat, dann setzt den, und ansonsten sagt er, no Videostream-Forten geht raus.

49:43.000 --> 49:44.000
Was wird das?

49:45.000 --> 49:48.000
Ich probiere eine Web-RTC-Library aus, die ich heute auf GitHub gefunden habe,

49:48.000 --> 49:55.000
mit der man zum Beispiel Webcams oder Überwachungskameras sich mit ziemlich niedriger Latenz in den Browser streamen kann.

49:56.000 --> 50:01.000
Ich habe sowas schon mal gebaut, allerdings in.NET und das Web-RTC-Zeugs in Go.

50:02.000 --> 50:07.000
Und nachdem der Interop zwischen Go und.NET nicht so schön ist, wollte ich mal so eine.NET-only-Lösung ausprobieren.

50:08.000 --> 50:09.000
Mal gucken, wie gut das funktioniert.

50:10.000 --> 50:14.000
Ok, also Videostream haben wir. Jetzt muss man das da machen.

50:14.000 --> 50:18.000
Alles klar. Also wir gucken jetzt, ob es in dem RTSP-Stream einen Videostream gibt.

50:19.000 --> 50:21.000
Wenn es einen Videostream gibt, machen wir weiter.

50:22.000 --> 50:26.000
FFPlay, ich glaube, das kann man sich an der Stelle auch sparen, wenn man Open gemacht hat, aber machen wir mal.

50:27.000 --> 50:32.000
So, und jetzt sagt er mir Connected zur URL von der Webcam oder zum Videostream.

50:33.000 --> 50:36.000
Und jetzt kommt das eigentliche Auslesen dran.

50:36.000 --> 50:46.000
Da braucht man nämlich eine... Ups, ich habe etwas vergessen.

50:47.000 --> 50:51.000
Und hier unten muss ich noch Unref machen, dass es wieder weg ist.

50:52.000 --> 50:57.000
Und hier ist dann Zeug machen mit Videoframes.

50:57.000 --> 51:05.000
So, genau, also hier öffnet er den Stream und sucht sich den Videostream raus aus dem RTSP-Stream.

51:06.000 --> 51:11.000
Und hier macht er eine Endlosschleife, die immer wieder ein neues Paket anlegt.

51:12.000 --> 51:15.000
Das kann man übrigens auch optimierter machen, man muss das gar nicht immer neu initialisieren, kann es darüber schreiben.

51:16.000 --> 51:19.000
Und hier liest er jetzt quasi ein Frame nach dem anderen von der Quelle.

51:19.000 --> 51:26.000
Ist es eigentlich irgendwie möglich Twitch-Streams als RTC oder ähnliches zu bekommen?

51:27.000 --> 51:33.000
Direkt wahrscheinlich nicht, aber ich meine, du kannst... Kann FFmpeg Twitch?

51:34.000 --> 51:39.000
Müssen wir mal schauen. Kann FFmpeg Twitch? Wahrscheinlich nicht.

51:39.000 --> 51:56.000
Ich meine, Twitch war mal HLS, aber ich glaube mittlerweile ist Twitch irgendein HTTP2-Streaming.

51:57.000 --> 52:04.000
Nein, okay, FFplay kann kein Twitch. Wenn FFmpeg das gekonnt hätte, dann hätte es das umwandeln können.

52:04.000 --> 52:15.000
So, und der liest jetzt endlos lang diesen Input hier von diesem Stream, von diesem Test-Video.

52:16.000 --> 52:19.000
Und liest quasi ein Frame nach dem anderen aus und wirft ihn wieder weg.

52:20.000 --> 52:23.000
Und hier kann ich dann später den Kram... Guck mal, es funktioniert! Habt ihr das gesehen?

52:24.000 --> 52:28.000
Ganz nebenbei, das Connecten zum Stream funktioniert schon mal.

52:29.000 --> 52:31.000
Ich kann euch ja sogar mal beweisen, dass es funktioniert.

52:31.000 --> 52:35.000
Wir lesen jetzt mal ein paar Sachen aus den einzelnen Video-Frames aus.

52:36.000 --> 52:40.000
Zum Beispiel... PTS.

52:41.000 --> 52:46.000
Übrigens, Audio-Video-Sachen ist wirklich eine richtige Wissenschaft für sich.

52:46.000 --> 53:05.000
WTF? PTS sollten niemals negativ sein?

53:05.000 --> 53:16.000
Und wie geht das? Ich guck doch, ob es kleiner Null ist und wenn es... Ach nee, oder muss ich hier machen.

53:17.000 --> 53:21.000
Das ist ja schon erst ein Bug gefunden.

53:22.000 --> 53:28.000
Aber der Timestamp sollte immer positiv sein. WTF?

53:29.000 --> 53:32.000
Okay, der buggt einfach nur am Anfang ein bisschen rum, glaube ich.

53:32.000 --> 53:39.000
Aber... Also, um immer ein bisschen Licht ins Dunkel zu bringen, wie das unter der Haube mit Videos funktioniert.

53:40.000 --> 53:44.000
Jeder Video-Frame hat zwei Timestamps drin.

53:45.000 --> 53:49.000
Es ist jetzt Big Brain und muss man wahrscheinlich eigentlich gar nicht wissen, es sei denn, man macht was mit Audio-Video-Kram.

53:50.000 --> 53:54.000
Jeder Frame von einem Video hat zwei Timestamps. PTS, DTS.

53:55.000 --> 53:58.000
Meine Frage an den Big Brain Chat, hat irgendjemand eine Ahnung, was der Unterschied ist?

53:58.000 --> 54:06.000
Ich werde es auch gleich erzählen. Aber nur, man würde mich interessieren, ob vielleicht irgendwelche Leute haben, die das zufälligerweise wissen.

54:07.000 --> 54:14.000
Also, wenn du Audio- und Video-Coding studierst, dann musst du das wissen.

54:15.000 --> 54:20.000
Oder sollte man das wissen? Müsstest du das wissen, was der Unterschied ist zwischen PTS und DTS?

54:20.000 --> 54:27.000
Also, P steht für Presentation Timestamp und DTS steht für Decoding Timestamp.

54:28.000 --> 54:38.000
Das bedeutet, es kann sein, dass Frames decoded werden, zu einer Zeit, wo sie noch nicht angezeigt werden sollen.

54:39.000 --> 54:43.000
Wenn das der Fall ist, muss man irgendwie einen eigenen Buffer konstruieren.

54:43.000 --> 54:49.000
Von, sagen wir mal, 2-30 Sekunden oder von, was weiß ich, 100 Frames oder was auch immer, wie viel man braucht.

54:50.000 --> 54:54.000
Und dann muss man quasi decoden. Also, DTS muss eigentlich immer fortlaufen sein.

54:55.000 --> 55:02.000
Aber es kann durchaus sein, dass man Frames decoded, bevor sie angezeigt werden sollen, in der unterschiedlichen Reihenfolge.

55:03.000 --> 55:11.000
Das heißt, man muss dann quasi erstmal ein bisschen buffern und gucken, dass man quasi die Timestamps bekommt für die Presentation-Time.

55:11.000 --> 55:19.000
Also, PTS-Presentation-Timestamps ist das, was der Videoplayer anzeigen soll und DTS ist, was der Decoder decoden muss.

55:20.000 --> 55:25.000
So, und meistens ist das das Gleiche, aber das muss nicht so sein.

55:28.000 --> 55:30.000
Wieso heißt das Projekt Startup? Nein, das Projekt heißt nicht Startup.

55:31.000 --> 55:34.000
Das ist das Standard ASP.NET Core-Template. Die Datei heißt halt einfach so.

55:34.000 --> 55:41.000
Und wir können mal gucken, ob die hier bei dem Video immer gleich sind. Wir machen mal tolles Printline-Debugging.

55:42.000 --> 55:47.000
Und schauen wir mal, ob die Presentation-Decoding-Timestamps immer gleich sind hier.

55:48.000 --> 55:51.000
Ja, guck, hier sind die immer gleich.

55:51.000 --> 56:03.000
Aber das muss nicht so sein. Das hier heißt im Prinzip nur, dass sobald ich den Frame decoden bekomme, kann ich ihn auch weiter schicken, weil der ist dann schon in der richtigen Reihenfolge.

56:04.000 --> 56:15.000
Sollte Decoding-Timestamp und Presentation-Timestamp abweichen, dann muss ich erstmal ein bisschen sammeln, bis ich alles beisammen habe, was ich brauche, um es in der richtigen Reihenfolge anzuzeigen.

56:15.000 --> 56:22.000
Aber das soll heute nicht unser Problem sein. Ich mach das auch mal wieder raus.

56:23.000 --> 56:29.000
So, also Video Decoding funktioniert schon nochmal. Jetzt kommt das nächste.

56:30.000 --> 56:36.000
Muss ich mal kurz abgucken, wie man so einen komischen ASP.NET Controller genau macht.

56:37.000 --> 56:43.000
Also, jetzt müssen wir eine WebRTC-Verbindung aufbauen vom Browser zu meinem Backend hier.

56:43.000 --> 56:48.000
Was macht eigentlich deine Heizungssteuerung? Der geht's gut.

56:56.000 --> 57:01.000
Ich weiß, ich hab euch auch noch nichts von meiner Heizungssteuerung erzählt, aber versprochen, das mach ich nächstes Mal.

57:02.000 --> 57:05.000
So, lass mal überlegen, was brauchen wir denn sonst noch?

57:05.000 --> 57:19.000
Wir machen mal eine Sache. Ich will mal gucken, ob ich Memory Leaks hab. Leute, verwendet jemand von euch Rider und hat irgendeine Ahnung, wie man dort anzeigen lassen kann, während man hier ein Programm drüber laufen lässt, wie viel Speicher das gerade verwendet?

57:20.000 --> 57:24.000
In Virtual Studio ist das immer rechts oben. In Rider hab ich keine Ahnung, wo das steht.

57:25.000 --> 57:31.000
Wenn ich hier zum Beispiel Debuggen anmache, ich bin zu doof für den Speicherverbrauch zu sehen.

57:31.000 --> 57:40.000
Keine Ahnung, wo der ist. Deswegen machen wir einfach mal was anderes.

57:41.000 --> 57:45.000
Ich mach mir einfach nen Task, der mir alle 5 Sekunden den Speicherverbrauch ausgibt.

57:46.000 --> 57:50.000
Aber das ist bestimmt nicht Sinn und Zweck, da sag ich, ich bin bloß einfach zu dumm, zu wissen, wo das im Rider ist.

57:51.000 --> 57:54.000
Übrigens kann ich das auch mal rauskopieren, das hab ich ja auch schon zufälligerweise.

57:54.000 --> 58:00.000
Ach nee, Mist. Wunderbar.

58:01.000 --> 58:07.000
Was macht der Rider? Memory? Ja, der zeigt, wenn du Breakpoints hast, zeigt der Variablen an.

58:08.000 --> 58:15.000
So, jetzt krieg ich alle 5 Sekunden mein, okay, Programm braucht 149 MB. Das ist für ne Web-Anwendung backend okay.

58:16.000 --> 58:21.000
Stand da nicht rechts beim Debug-Fenster? Was? Echt? Moment, wo?

58:21.000 --> 58:36.000
Hier, das? Nee, also da ist nix drin.

58:37.000 --> 58:43.000
Ich seh, also ich seh hier wirklich, in Visual Studio ist es hier rechts oben immer, aber in Rider, keine Ahnung.

58:43.000 --> 58:56.000
Letztendlich ist auch wurscht, ich lass es einfach hier unten ausgeben. Printline, also wir haben jetzt hier 148 MB.

58:57.000 --> 59:05.000
Ist ein extra Plugin, den sich dottrace, ernsthaft, er braucht ein extra Plugin für? Aber das reicht jetzt erst mal.

59:05.000 --> 59:12.000
So, gut, jetzt kommen wir nämlich mal zur eigentlichen Geschichte. Wir müssen eine WebRTC-Verbindung aufbauen, um das Video zu übertragen.

59:13.000 --> 59:23.000
Ich überleg grad, ich glaube, wir haben alles, was wir brauchen, erst mal eingerichtet. Ach nee, eine Sache, ich sehs hier nämlich grad in meinem, in meinem anderen Projekt, das ist ne Sache, die mach ich immer gerne.

59:23.000 --> 59:43.000
Die haben es ja so gemacht, früher haben die für ASP.NET immer diese Newtonsoft-JSON Library verwendet, die haben sie nicht mehr drinne, sie haben jetzt ne eigene, die schneller ist, aber irgendwie verwende ich die trotzdem noch lieber, deswegen füg ich die jetzt einfach mal wieder hinzu.

59:43.000 --> 59:56.000
Da kann ich auch einstellen, dass E-Names keine Zahlen sind, sondern richtige Namen und sowas, das mach ich immer gerne. Und ich glaub, die Performance, da kommt's jetzt echt nicht drauf an.

59:57.000 --> 01:00:03.000
Oh, was hat er für Schmerzen? Ach genau, ich muss ja erst mal adden. Äh, Moment.

01:00:03.000 --> 01:00:22.000
Ja, auf JSON. Nee, Moment, was, was muss ich adden? Äh, ähm, MVC, JSON, das da muss ich glaub ich adden, aber keine Testversion, sondern ne echte.

01:00:22.000 --> 01:00:40.000
Ne echte. Okay, exellent. Gut, jetzt können wir loslegen. Also, wir missbrauchen mal diesen Standard-Wetter-Vorhersage-Controller und benennen den um.

01:00:40.000 --> 01:00:53.000
Den nennen wir mal ein Signal-Controller und machen diesen ganzen anderen Schmodder hier unten weg. Wetter-Vorhersage löschen wir auch, braucht kein Mensch. So, und das machen wir auch leer.

01:00:53.000 --> 01:01:09.000
So. Also, das funktioniert folgendermaßen, eine WebRTC-Verbindung aufzubauen. Das ist ja was, da kenn ich mich ein bisschen mit aus, weil das hab ich jetzt schon ein paar Mal gemacht.

01:01:10.000 --> 01:01:15.000
Also, ich krieg das ungefähr gebacken, wie man eine WebRTC-Verbindung aufbaut aus dem Browser.

01:01:15.000 --> 01:01:24.000
Das erste, was man machen muss, ist, das hier ist quasi unser Main in die AVA-Skript. Also, unser Ziel ist jetzt, wir bauen eine Verbindung zum Backend auf.

01:01:25.000 --> 01:01:36.000
Ähm, und das Backend schickt uns dann die Videoframes von der Kamera, die es hier unten abruft, in den Browser. Soweit die Theorie, wenn alles funktioniert.

01:01:36.000 --> 01:01:45.000
Ich, ich hab ja meine Zweifel, weil ich weiß noch, was es für ein unglaublich ekliges Rumgefuddel war, bis ich das das erste Mal zum Laufen gebracht habe.

01:01:46.000 --> 01:01:54.000
Aber ein Vorteil hat's, ich weiß jetzt, was man machen muss, so ungefähr. Vielleicht krieg ich das hier besser, krieg ich das besser hin.

01:01:54.000 --> 01:02:05.000
Aber krieg ich das besser hin. So, was ist der Unterschied, was ist der Unterschied in AVA-Skript, ob ich var, let oder gar nichts verwende oder const.

01:02:06.000 --> 01:02:13.000
Mein const kann ich mir vorstellen, const kann ich nicht mehr ändern. Let und var. Das eine ist lokal, das andere ist irgendwie global.

01:02:13.000 --> 01:02:23.000
Aber guck mal, ich kann den AVA-Skript, ich kann die Variablen so anlegen. Ich kann sagen l gleich das da. Ich kann sagen let l gleich das da.

01:02:24.000 --> 01:02:31.000
Ich kann sagen var l gleich das da oder ich kann sagen const l gleich das da. Warum gibt's in AVA-Skript denn eigentlich vier Varianten, wie ich Variablen anlegen kann?

01:02:31.000 --> 01:02:48.000
Man kann's auch kompliziert machen. Allerdings, wenn man's richtig kompliziert machen will, macht man's in C++. Dann versteht's keiner mehr. Selbst die Standardersteller verstehen's da nicht mehr.

01:02:48.000 --> 01:03:02.000
Okay, also um eine WebRTC-Verbindung aufzubauen, muss man Folgendes machen. Als erstes brauch ich auf der Gegenstelle irgendeine Möglichkeit Informationen mit meinem Client auszutauschen.

01:03:03.000 --> 01:03:15.000
Das mach ich über normale HTTP-Requests, machen wir das einfach. Weil WebRTC ist zwar ein Protokoll, das geht in beide Richtungen.

01:03:15.000 --> 01:03:29.000
Ich kann Videos von einem Client zum anderen schicken und der Client zu mir. Das ist beidseitig. Aber für den Verbindungsaufbau brauche ich irgendeinen anderen Kommunikationskanal, weil die bidirektionale Verbindung gibt's ja noch nicht.

01:03:29.000 --> 01:03:52.000
Deswegen muss ich das einmalig von Hand machen. Das heißt, ich mach jetzt einen Request, so stelle ich mir das so vor, nach Slash Signal. Dieser Controller heißt der so. Und wenn der Controller so heißt, dann registriert ASP.NET Core automatisch eine Uhrl, die Slash Signal signaligen oder wie auch immer heißt.

01:03:52.000 --> 01:04:07.000
Also mach ich mal einen Fetch da drauf. Await, wie es sallt oder so. So, das gibt's ja noch nicht. Achso, Moment, Moment mal. Ich bin ja auch ganz falsch. Ich muss ja, das ist ja der Proxy, äh, Sekunde.

01:04:07.000 --> 01:04:21.000
Local Host 5000. Okay. Die Sound-Lautstärke kann sich auch nicht entscheiden, oder? Ob's jetzt mal laut oder leise wird.

01:04:21.000 --> 01:04:41.000
Jetzt wieder leise. Let ist Block Scope nicht kompatibel mit allem ECMAScript 6. Ah. Ha. Ich hab nix verstanden. Also ECMAScript sind die JavaScript-Standardisierungsleute.

01:04:41.000 --> 01:05:00.000
Was, es leckt? Oh, Vodafone wieder am Start. Nö, leckt nix. Ah, leckt nix. Okay, also, ähm, ich schick jetzt dort nen, wie mach ich denn das jetzt am besten?

01:05:00.000 --> 01:05:20.000
Ich muss jetzt ne WebRTC-Verbindung aufbauen. Genau, ich muss erst mal, ich muss erst mal ne WebRTC-Connection anlegen. Also, so, das Ding ist gleich RTC Peer, irgendwas Peer-Connection.

01:05:20.000 --> 01:05:39.000
So, und dann, wie ging das jetzt nochmal weiter? Genau, jetzt muss ich mir, genau, jetzt muss ich mir vom Server abholen, was der Server für Video-Formate unterstützt.

01:05:39.000 --> 01:05:53.000
Genau, das muss ich hier drüber machen, das muss ich jetzt hier auf dem Server programmieren. Also, lock, await, result, JSON. Kommt noch kein JSON zurück, aber das programmieren wir jetzt.

01:05:53.000 --> 01:06:10.000
Warum reloadet das nicht mehr? Warum reloadet das nicht mehr? Ah, weil ich den Proxy nicht drin hab, ich hab die Erweiterung nicht. Beste Browser-Erweiterung, beste Visual Studio Code-Extension.

01:06:10.000 --> 01:06:29.000
Weil, wenn man das installiert hat, ich zeig's euch mal, ist Massive Brained. Your Server Address ist Local Host. Hä, warum wird das nicht angezeigt? Und Live Server Address ist ja Standard. Geht das jetzt schon?

01:06:29.000 --> 01:06:56.000
The Live Server Address is 52. Äh, wohl auch nicht. Was hab ich verkehrt gemacht? Was hab ich verkehrt gemacht?

01:06:56.000 --> 01:07:11.000
Warum reloadet das nicht? Hab ich irgendwas falsch gemacht?

01:07:11.000 --> 01:07:31.000
Äh, nee, warte, das hat mit SIP nichts zu tun, das heißt nur so. Hab ich was vergessen? Ach, ich hab Live Reload nicht angemacht, null. So, jetzt funktioniert's. So, und jetzt ist der Vorteil, guck mal, wenn ich das angeschaltet hab, wenn ich jetzt hier was reinschreibe und speichere, bäm, reloadet der automatisch die Seite. Das ist exzellent.

01:07:31.000 --> 01:07:43.000
Ich hab Live Reload vergessen. Äh, gute Frage im Chat kommt öfters. Und zwar, wo ist es? Wo ist es?

01:07:43.000 --> 01:08:00.000
Kannst du mir helfen? Was kann ich für einen Anfänger lernen? Also mit welcher Programmiersprache man anfangen kann? Hast du irgendwelche Videos oder kennst du einen YouTube, der echt gut erzählt? Äh, gut, da gibt's jede Menge, aber es ist halt die Frage, was du verwenden willst.

01:08:00.000 --> 01:08:25.000
Ja, äh, dankeschön, Kid Ivar, Twitch Prime, huge sub, dankeschön, nice. Also wenn du dich, wie heißt das Plugin-Live-Server? Also wenn du dich in irgendeiner Art und Weise für Web-Entwicklung begeistern kannst, also sprich Webseiten erstellen und Backends für Webseiten, finde ich, ist das der beste Einstieg, weil man visuell sieht, was passiert.

01:08:25.000 --> 01:08:39.000
Wenn das nicht so dein Fall ist, ist halt die Frage, wo so deine Interessen liegen. Möchtest du Windows-Anwendung machen, vielleicht sogar Windows-Desktop-Anwendung, da kommst du an.NET nicht vorbei, C-Sharp.net.

01:08:39.000 --> 01:09:01.000
Willst du vielleicht ein bisschen in Richtung so Cloud-Geschichten gehen, da ist viel in Go programmiert. Und ansonsten, was auch recht hip ist, wenn's Richtung Machine Learning und irgendwelche wissenschaftlichen Sachen gehen soll, dann ist Python übelst angesagt.

01:09:01.000 --> 01:09:09.000
Also, ist halt die Frage, wo so deine Interessen liegen. Da kann ich dir da auch besser was sagen.

01:09:09.000 --> 01:09:31.000
Cobol, Cobol geht immer, Cobol geht immer. Okay, also, wir fragen den Server, was er alles für Video-Formate unterstützt. Das müssen wir jetzt dem Server erstmal beibringen, dass der da drauf antwortet. Ähm, erstmal überlegen.

01:09:31.000 --> 01:09:46.000
Tja, da muss ich jetzt in die Hilfe gucken, da muss ich jetzt in die Hilfe gucken von diesem, von dieser Library, oder?

01:09:47.000 --> 01:09:53.000
Würde ich mal sagen, da muss ich in die Hilfe von der Library gucken, wie das funktioniert.

01:09:53.000 --> 01:10:07.000
Machine oder Web, aber mehr für Maschine. Was verstehst du unter Maschine?

01:10:08.000 --> 01:10:13.000
Meinst du irgendwelche Low-Level-Geschichten? Oder meinst du Microcontroller?

01:10:13.000 --> 01:10:22.000
Also, wenn du irgendwelche, wenn du gerne Microcontroller-Sachen machst, dann nimm deine ESP32 mit Platform-IO. Beste Kombination.

01:10:23.000 --> 01:10:34.000
Also, wenn du so ein bisschen Microcontroller basteln willst, irgendwie so ein bisschen Elektronik-Gramm machen willst, dann ist eine ESP32 mit Arduino-Platform-IO das beste, was du machen kannst.

01:10:34.000 --> 01:10:43.000
Oder meinst du mit Maschine für Desktop? Also Desktop-Anwendung. Also sprich, irgendwelche grafischen Desktop-Anwendungen.

01:10:44.000 --> 01:10:49.000
Also, wenn du grafische Desktop-Anwendungen machen willst, dann ist die nächste Frage, für welches Betriebssystem?

01:10:50.000 --> 01:11:01.000
Windows only, Windows Mac Linux, Cross-Platform. Das ist tatsächlich ein ziemlich kompliziertes Feld, wenn man Cross-Platform-Anwendungen machen will.

01:11:01.000 --> 01:11:07.000
Allerdings, wenn du ein bisschen Web gelernt hast, gibt es Möglichkeiten, dass du das auch auf Desktop überträgst.

01:11:08.000 --> 01:11:16.000
Deswegen gibt es in letzter Zeit so viele Elektron-Anwendungen und Browser in einem eigenen Fenster, die viel RAM fressen, weil das alles Web-Entwickler sind, die jetzt meinen, sie machen Desktop-Anwendungen.

01:11:19.000 --> 01:11:26.000
Hab ich doch eigentlich ganz treffend beschrieben, oder? So, FFmpeg2-WebRTC. Gucken wir jetzt mal, was die hier machen.

01:11:26.000 --> 01:11:36.000
Programmen. Das müssen wir jetzt nachbauen. Also, was machen die hier? WebSocket interessiert uns gar nicht. WebSocket brauchen wir nicht. Machen wir das ohne WebSockets.

01:11:41.000 --> 01:11:47.000
WebSockets, alles egal. WebSockets juckt uns nicht. FFmpeg.

01:11:47.000 --> 01:11:55.000
FFmpeg. Ja, das jetzt kommt das Interessante. Also, was?

01:11:56.000 --> 01:11:58.000
Was?

01:12:04.000 --> 01:12:06.000
Okay, keine Ahnung.

01:12:07.000 --> 01:12:14.000
Ah, hier. Create. Das ist interessant. Das kenne ich. Das kenne ich. Das sind so die Standard-WebRTC-Geschichten. Okay, Create Offer. Sehr schön.

01:12:14.000 --> 01:12:26.000
Also, was muss ich machen? RTC Peer Connection. Die scheinen sich ziemlich gut an der Web-ARP zu orientieren, was gut ist, weil die Web-ARP kann ich. Die SIP Sorcery-ARP kann ich nämlich nicht.

01:12:26.000 --> 01:12:45.000
Also, dann machen wir das doch mal. Also, ja. War PC gleich New. New. Hallo. Import New RTC Connection. Configuration. Brauchen wir da eine Configuration? Was machen die hier?

01:12:45.000 --> 01:12:57.000
Null. Okay, exellent. Null. Ich weiß jetzt nicht genau, was ich da gerade mache, aber mal gucken, ob es funktioniert.

01:12:58.000 --> 01:13:08.000
By the way, ich nehme mal kurz hier aus dem Startup den Start von der Webcam raus, weil sonst blocken die mich noch, wenn ich laufend auf ihren Stream zugreife.

01:13:08.000 --> 01:13:18.000
Das will ich nicht, dass wenn ich dann testen will, dass die auf einmal mich irgendwie IP-Band haben oder sowas. Mein Domain-Anbieter hat mich ja schon IP-Band. Will ich noch mehr IP-Band werden?

01:13:18.000 --> 01:13:34.000
Electron ist das Docker der Frontend-Entwickler. Ich entdecke gewisse Parallelen. Ist beides was, wo jeder meint, das ist das Ding schlechthin, was man benutzen muss.

01:13:35.000 --> 01:13:41.000
Geht Node Share nicht auch mit TypeScript? Doch, doch, klar.

01:13:41.000 --> 01:13:51.000
Also, ich habe es noch nie verwendet, aber es müsste gehen. Ansonsten geht Deno.

01:13:52.000 --> 01:14:03.000
Ich brauche NordExpressVPN, ganz genau. Okay, also Per Connection RTC. So, wie geht es weiter? Ich muss mich ein bisschen beeilen hier.

01:14:03.000 --> 01:14:17.000
Also, Create Offer. Okay, das kenne ich. Das macht man im Browser ganz genauso. Create Offer. Zack. So, das generiert mir jetzt eine Liste mit Codecs, die mein Backend unterstützt.

01:14:18.000 --> 01:14:29.000
Jetzt muss ich dem irgendwie noch sagen, dass ich nur H264 unterstützen will. H264 ist so der Codec, der zu 99% verwendet wird.

01:14:29.000 --> 01:14:39.000
Also, wenn ihr Videos anguckt, ist das zu... na, wobei, kann man gar nicht sagen. YouTube ist mittlerweile, wenn es nicht geforst wird, nicht mehr H264.

01:14:40.000 --> 01:14:51.000
Aber zu 90% wenn ihr Videos anguckt, ist das H264. Und die meisten Kameras liefern ihr Videos auch in H264 aus. Deswegen muss ich sagen, hallo Browser, ich unterstütze nur H264.

01:14:51.000 --> 01:15:10.000
Das ist natürlich die Frage, wie mache ich denn das? Create Offer. Track, gibt es hier was mit Track? Ah, Videotrack. Exzellent, das brauche ich.

01:15:10.000 --> 01:15:25.000
Das brauche ich. Also, Create Offer. Okay, das machen wir jetzt mal. Also Videotrack, ich Copy Paste mir das einfach mal, ohne dass ich weiß, was ich mache.

01:15:25.000 --> 01:15:40.000
Track, Videotrack. Types, Video, Remote, was auch immer. Das ist False. Und hier muss ich jetzt reintragen, was für Videoformate unterstützt werden anscheinend. Okay, machen wir das mal. Wir programmieren das einfach nach, wie die das gebastelt haben.

01:15:40.000 --> 01:15:55.000
Und dann sage ich Add Videotrack. So, ich muss ihm jetzt sagen, ich unterstütze nur H264. Hat Max eine Lizenz? Natürlich. Was meinst du denn?

01:15:55.000 --> 01:16:11.000
Meinst du, ich würde dir was ohne Lizenz verwenden? Das glaubst du doch nicht wirklich. Meinst du jetzt den Codec? Meinst du jetzt den Codec oder meinst du jetzt die IDE?

01:16:11.000 --> 01:16:25.000
By the way, ich sollte das mal umbenennen vom Default Namen. Signal Controller. Das ist hier der. Wo ist denn hier? Rename immer versteckt. Da. Bam. Exzellent.

01:16:25.000 --> 01:16:41.000
Also. Okay, was? Wie sage ich denn jetzt, dass ich nur H264 Video machen will? Aha, Videoformat. Videoformat, Videoformat. Okay, was gibt es denn Videoformat?

01:16:41.000 --> 01:16:54.000
Videoformat. Videoformat. Mal gucken, ob man hier. Weil ich weiß, welche Daten ich angeben muss. Das kann ich aus der anderen Software, die ich ja schon gebastelt habe, abgucken. Ich muss nur gucken, wie ich das hier mit der Library mache.

01:16:54.000 --> 01:17:22.000
Moin, da Twinkos auch am Start. Poggers. So, also. Damit kann ich sogar jetzt was anfangen. Was wird gebaut? Ich habe ja vor einer Weile schon mal für meine Überwachungskameras was gebaut, was die RTSP Streams von den Überwachungskameras abruft mit FFMPEG.

01:17:22.000 --> 01:17:38.000
Und dann über WebRTC in den Browser schickt. Das habe ich aus der Not heraus gemacht, weil ich keine ordentliche Videoüberwachungssoftware gefunden habe, die erstens gescheit auf dem Raspberry Pi läuft, zweitens wenig Latenz hat und drittens nicht alles reencoded.

01:17:38.000 --> 01:17:52.000
So, das habe ich gebastelt. Die allererste Variante war eine Mischung aus C und Go. C, weil FFMPEG und Go, weil die einzig sinnvolle WebRTC Library, die man benutzen kann, das hier war.

01:17:52.000 --> 01:18:09.000
Und dann habe ich das irgendwann nochmal neu gebaut in.NET mit Go, weil ich am liebsten.NET programmiere. Allerdings ist Interop zwischen.NET und Go abgrundtief kacke. Deswegen habe ich mich heute gefreut, dass ich eine Library gefunden habe, die WebRTC angeblich in.NET macht.

01:18:09.000 --> 01:18:21.000
Das wollte ich jetzt gerade mal ausprobieren. Also das Ziel ist, dass ich in 45 Minuten irgendwie es hingekriegt habe, dass ich ein Video, ein Testvideo in den Browser über WebRTC übertrage. Mal gucken, ob das funktioniert. Ich habe nämlich nicht mal allzu viel Zeit.

01:18:23.000 --> 01:18:25.000
So, also.

01:18:25.000 --> 01:18:41.000
Video Format. Gut, da kann ich hier kann ich ja was mit anfangen. Da weiß ich ja, was da rein muss. So, also das Video Codex hat 264. Hat eigentlich derjenige geantwortet mit den mit den Einsteiger, Programmier, Geschichten nochmal?

01:18:41.000 --> 01:18:55.000
Nee, das letzte Mal Maschine oder Web. Auf die andere Sachen nicht. Da kann ich auch nicht mehr sozusagen. Ist das Website Backend eigentlich der direkte Quellcode? Ist das Source auf GitHub? Nee.

01:18:55.000 --> 01:19:11.000
Ich habe, ich habe mal eine Testversion hier im Stream. Wir haben das hier im Stream mal ein bisschen gebastelt. Ich habe meine Testversion irgendwo auf frag mich nicht auf Pastebin oder so hochgeladen vor zwei Jahren oder einem Jahr.

01:19:11.000 --> 01:19:27.000
Nee, ist nicht. Okay, also wir wollen nur 264 Video unterstützen. Format. Da weiß ich glücklicherweise, was man eintragen muss, weil das kann ich jetzt aus meinem anderen abgucken. 102.

01:19:27.000 --> 01:19:40.000
Frag mich bitte nicht, warum 102. Ich habe keine Ahnung, warum 102. Ich weiß nur, dass es mit 102 funktioniert, weil beim anderen steht 102 drinne und das geht.

01:19:40.000 --> 01:19:57.000
Ansonsten habe ich keine Ahnung, warum die Format ID 102 ist. Wahrscheinlich steht das im Standard irgendwo drin. Keine Ahnung. Ich tippe das einfach nur ab, was ich bei der anderen Geschichte drin stehen habe. 102. Weil klar, 264 sieht auch so nach 102 aus.

01:19:57.000 --> 01:20:11.000
Okay, Format. Was, was, was braucht man jetzt noch? Warte mal, das hier hat doch einfach in Format gefressen noch, oder? Format. Okay, das funktioniert. Exzellent. Sehr gut, sehr gut.

01:20:11.000 --> 01:20:29.000
So, und jetzt können wir sagen Create Offer. Und nun gucken wir mal, ob ich im Browser, jetzt ist der Moment der Wahrheit, ob ich im Browser was ordentliches zurückkriege. Moment hier, was? Null, oder? Nochmal. Ja.

01:20:29.000 --> 01:20:56.000
Ja. So. Also ich muss keinen Lizenzcode, ich muss keinen Lizenz für H264 bezahlen, wenn ich das verwende. Irgendwelche Hardware Hersteller müssen das bezahlen oder so. So ist das gemeint mit, dass das nicht Lizenz war. Ich muss da nichts für bezahlen. Ich kann das, es kann ja auch jeder ein Video encoden in H264 mit FFmpeg. Das ist kein Ding.

01:20:56.000 --> 01:21:20.000
Aber wenn du eine Hardware verkaufst, die das benutzt, da musst du Lizenzgebühren irgendwie bezahlen. So. Also. H264 gleich 2 plus 6, 2 plus 6 plus 4 gleich 2 plus 10 gleich 102. Ach so. Ja, deshalb gibt das alles Sinn.

01:21:20.000 --> 01:21:36.000
Exzellenter Chat ist mal wieder Next Level angekommen. So und jetzt schicke ich das hier zurück. Return. Ja Offer. Und jetzt gucken wir, ob es im Browser ankommt und ob der Browser das frisst. Das ist ja noch viel. Ach so. Moment, was geben wir hier zurück?

01:21:36.000 --> 01:21:50.000
Ich mache es jetzt wirklich eklig. Object. Scheiß drauf. Hauptsache es geht. Kommt was zurück. So. Browser. Await. Console. Ok, wir kriegen was zurück. Das schaut mal gut. Jetzt müssen wir nur gucken, ob der Browser das ganze frisst.

01:21:50.000 --> 01:22:18.000
Wie machen wir das jetzt irgendwie? Set Remote. Also man muss dem jetzt sagen, ok, das sind die Sachen, die der Server unterstützt. Und dann muss ich quasi noch eine Antwort generieren, wo drinne steht, das sind die Videoformate, die der Client unterstützt. Und wenn die sich beide einig wären, dann kann ich Video übertragen.

01:22:18.000 --> 01:22:47.000
Ok, Set Remote Description. Geht das einfach so jetzt? Ach, das funktioniert jetzt? Das hätte ich jetzt gar nicht gedacht. Exzellent. So. Set Remote Description und jetzt muss ich den Antwort generieren, den ich an den Server zurückschicke, wo drinne steht, was mein Browser für Videos unterstützt.

01:22:48.000 --> 01:23:01.000
Also, wir nennen das mal ein kleines bisschen ordentlicher. Wir nennen das mal irgendwie.

01:23:01.000 --> 01:23:23.000
Die Confidence Jason ist schon. Ok, das mach ich irgendwie. Und äh. Tja. Passt schon. So, und jetzt muss ich ne Antwort generieren, was der Browser für Videos, Formate unterstützt. So, das geht so.

01:23:23.000 --> 01:23:48.000
Dann sagt man Create Answer. Das sagt, ok, das sind meine lokalen Videoformate. Ach so. Let Await. Irgendwie so. Wird doch eh kein Schöner als Preis gewinnen. So. Also, das passt. Jetzt geb ich das mal aus und schau mal, ob der Browser irgendwie was Sinnvolles da generiert überhaupt.

01:23:48.000 --> 01:24:09.000
Ja, ich hab keine Ahnung, ob das sinnvoll ist, aber das sieht so aus, als kackt das zumindest nicht ab. Ich hab Traffic verwenden für den Docker Reboot as Proxy. Ja. So. Das muss ich jetzt zurück an Server schicken, dass das funktioniert. Await. Fetch.

01:24:09.000 --> 01:24:35.000
An. Ach so. Ha. Ok, ich brauch auf dem Server ne zweite Funktion, die Sachen annimmt. Also. Atttp. Post. Und das wird Bigpray Name. Das heißt jetzt einfach nur Post. Und ähm. Brauch jetzt. Ach so. Oh. Oh. Äh. Jetzt gibt's ein kleines Problem.

01:24:35.000 --> 01:25:02.000
Hier. Oh, da hab ich jetzt gar nicht dran gedacht. Hier erstelle ich quasi die Server-seitige, äh, Server-seitige Ende dieser Verbindung und füge auch den Videotrack hinzu und schicke das dem Client. Das Problem ist aber, äh, wenn ich jetzt dem Server schicken möchte, was mein Browser alles unterstützt, dann weiß ich nicht mehr, zu welcher Verbindung das Ganze gehört.

01:25:02.000 --> 01:25:29.000
Also, deswegen machen wir mal ein Private Static, äh, äh, Private Static, was weiß ich, äh, Dictionary aus irgendeiner ID und einer, äh, Connection. Dass ich das irgendwie zuordnen kann. Das ist jetzt quasi so, irgendwie so ein bisschen Brain Dump. Keine Ahnung, ob das dann tut. So.

01:25:29.000 --> 01:25:53.000
Connections. Jetzt brauchen wir noch irgendeine ID, die ich hochzähle. Private. Äh, ID. Ja, Uint-ID. So, jeder Client kriegt quasi eine neue ID zugewiesen. Das könnte, das könnte tatsächlich funktionieren.

01:25:53.000 --> 01:26:15.000
Okay, äh, mal kurz nebenbei abgucken, ob man welche anonymen Dinger returnen kann. Also, das heißt, neuer Client connectet sich, wir zählen die ID eins hoch. So, und jetzt darf ich nicht, jetzt, okay, okay, ich weiß, was ich mache.

01:26:15.000 --> 01:26:26.000
Ich darf jetzt dem Client nicht einfach nur die Information zurückgeben, welche Videokodex ich unterstütze, sondern ich muss dem Client noch zurückgeben die ID.

01:26:26.000 --> 01:26:46.000
Genau, ID, die eine einzigartige ID durch den Client wieder erkenne. So, das, das muss, und jetzt hier Offer. Okay, und hier übergebe ich ihm jetzt, mal gucken was, weiß ich auch nicht genau.

01:26:46.000 --> 01:26:58.000
Jetzt muss ich das hier neu basteln, dass das klappt. Jason Offer, dann machen wir hier die ID. Die ID müsste jetzt hier drin stehen.

01:26:58.000 --> 01:27:20.000
Ja, oh, oh, ach so. Aha, okay, okay, es scheint, es scheint noch zu funktionieren. Okay, jetzt schicken wir die Information an den Server zurück, was der Browser für Videokodex unterstützt.

01:27:20.000 --> 01:27:38.000
Also, das schicken wir wieder an Signal zurück. Allerdings, diesmal mit einem Postrequest, irgendwie Method gleich Post, Body gleich hier meine, meine Antwort.

01:27:38.000 --> 01:28:00.000
Exzellent. Wie das funktioniert? Ernsthaft? Einfach so? Okay. Ach so, wie kriege ich das jetzt rein? Komm, Dynamic. Hauptsache es geht.

01:28:00.000 --> 01:28:13.000
Kommt da jetzt irgendeine Antwort? Klappt das jetzt? Kommt da jetzt irgendwas auf dem Server an? Oh, Unsupported Media Type.

01:28:13.000 --> 01:28:31.000
Ach so, ich muss ihm noch sagen, dass es Jason ist. Fetch API, wie macht man das? Fetch API Post Jason, wie geht das? Das kann sich doch kein Mensch aus dem Kopf merken.

01:28:31.000 --> 01:28:50.000
Header. Exzellent. Das brauchen wir. Header. Ich gebe dir einen Header, Alter. So, wunderbar. Bad Request. Warum? Warum ist das ein Bad Request?

01:28:50.000 --> 01:29:00.000
Also, ich finde nicht, dass der schlecht ist. Chat wollen wir abstimmen, ist der Request wirklich schlecht? Also, ich finde den eigentlich ganz gut.

01:29:00.000 --> 01:29:21.000
Warum ist das? Ah, ich weiß, ich weiß. Weil ich ja kein JavaScript Objekt an den Server schicken kann, sondern. Ah, viel besser. Okay. Also, ich kriege jetzt schon mal die Antwort vom Browser, was der unterstützt.

01:29:21.000 --> 01:29:34.000
Sehr gut. So. Okay, da ist Type drinne. Ach nee, ich muss die ID noch mit zurückschicken, dass ich weiß, welcher Klein sich connectet.

01:29:35.000 --> 01:29:45.000
Also schicke ich nicht die Antwort zurück, sondern schicke eine ID zurück. Das ist die ID und dann schicke ich die Antwort zurück.

01:29:45.000 --> 01:30:00.000
Okay, das scheint zu funktionieren. Ich kriege die ID wieder zurück. Das heißt, ich mache hier sowas wie int id oder client id gleich Antwort id.

01:30:00.000 --> 01:30:14.000
Und was haben wir dann sonst noch? String oder nennen wir es, nennen wir es irgendwie. Antwort gleich. Ah nee, das habe ich ja schon belegt.

01:30:14.000 --> 01:30:33.000
Temp, immer besser Name, wenn einem sonst nix einfällt. Antwort. Antwort. Ach du große Geil. Stimmt das jetzt, was ich hier mache? Ich muss das mal kurz ausgeben, ob da überhaupt was sinnvolles ankommt, was ich hier schicke.

01:30:33.000 --> 01:30:55.000
Ich schicke. So, zack. Oh, internal. Okay, nein, das hat schon mal nicht funktioniert. Warum? Aha.

01:31:04.000 --> 01:31:21.000
Ah, deswegen vielleicht. ToString? ToString gibt es bestimmt auch. Das sieht besser aus. Excellent. Okay, Antwort. Antwort. Ach du große Scheiße.

01:31:21.000 --> 01:31:41.000
Nee, StPetus. Ich brauche hier nur die SessionDescription, das reicht. So, okay. Gibt es hier SessionDescription? Jawoll. New SessionDescription. Keine Parameter.

01:31:41.000 --> 01:31:59.000
Äh, Session, was haben wir denn sonst noch? SessionDescription? Init? Was ist Session? Ah, ich kenne die API von dem Zeug nicht. Wie machen die das denn hier? SessionDescription. New? Ah, hier, guckt mal. New Session.

01:31:59.000 --> 01:32:13.000
Okay, das brauche ich. Das, das muss ich machen. Excellent. Das da. Das, das brauche ich jetzt. Das und sonst nichts.

01:32:13.000 --> 01:32:28.000
Okay. So, jetzt muss ich mir erstmal die Connections zum Client hier oben wieder aus meinem Dictionary rausholen, weil das ist ja Stateless und das lasse ich mal Temp. Temp ist prinzipiell immer der beste Name für alles.

01:32:28.000 --> 01:32:47.000
So, Connections und zwar die ID. So. Und jetzt da. Was hat er für Schmerzen? Int is not assignable to par uint. Ach so. Ja, das ist richtig. Dann ist es einfach hier oben jetzt mal ein uint.

01:32:47.000 --> 01:33:07.000
Ansonsten, wenn es kein unsite int ist, dann crash es einfach und gut ist. So, also PC, Set, Set, Set. Hab ich hier die Create Offer? Und muss ich noch einstellen, dass der sich das merkt, welche Videoformate er selbst unterstützt?

01:33:07.000 --> 01:33:19.000
Okay. Und jetzt muss ich ihm sagen, welche Videoformate der an die andere Seite unterstützt.

01:33:20.000 --> 01:33:32.000
Schon mal GRPC ausprobiert. Nein, habe ich nicht. So, es ist gleich Temp. Ich hoffe, das funktioniert jetzt. Okay, es kackt schon mal nicht ab. Das ist schon mal nice.

01:33:32.000 --> 01:33:41.000
So, ich muss mich jetzt ein bisschen beeilen, dass ich das bis 22.00 Uhr alles hinkriege. So, Set, Remote Description. Blablabla. Temp. Gucken wir mal, ob es nicht crash, selbst wenn ich hier...

01:33:41.000 --> 01:34:01.000
The given key 1 was not present in the dictionary. Was? 1? Äh, warum nicht? Ach so, ich kack nur, ich füge das gar nicht hinzu da oben.

01:34:01.000 --> 01:34:12.000
Ja, dann kann es ja auch da nicht drinstehen. All die... Das ist übrigens wahnsinnig multithreaded safe, was ich hier alles mache. Also das wird nie kaputt gehen.

01:34:12.000 --> 01:34:33.000
Die connection. Okay, mal gucken, ob es jetzt funktioniert. Ah, ja. Okay, okay, okay. Gut, gut, gut, gut, gut. Set Remote Description. Ich würde sagen, das ist alles, was wir brauchen. Und jetzt können wir ein Video senden.

01:34:33.000 --> 01:34:47.000
Oder? Die settings sind richtig hier, diese Dinger. Die kenne ich von dem anderen Programm, also das passt. So, und jetzt kann ich ein Video senden. Kann ich jetzt... Muss ich noch irgendwas machen?

01:34:47.000 --> 01:35:02.000
Ich setze das hier. Set Description. Also Leute, wenn das klappt, gifte ich 5 subs. Aber ich kann es mir nicht vorstellen, dass es einfach so geht.

01:35:02.000 --> 01:35:17.000
So. Eigentlich... Also mir fällt jetzt erstmal nichts mehr ein, was ich zum Verbindungsaufbau machen muss. Doch, natürlich. Die wichtigste Sache habe ich wieder vergessen, Chat. Die wichtigste Sache habe ich vergessen.

01:35:17.000 --> 01:35:31.000
Also ich habe zwei Sachen vergessen. Erstens müssen wir den empfangenen Stream noch an den Videoplayer übergeben, also dem Videoplayer sagen, dass er das abspielen soll. Und zweitens muss ich den Videostream senden.

01:35:31.000 --> 01:35:47.000
Den Videostream sende ich ja noch gar nicht. Das machen wir jetzt hier. Zeug machen mit den Videoframes. Wir machen jetzt Zeug mit den Videoframes. Und zwar Signal... Das ist übrigens absolut nicht best practice oder sonst was, bevor mir jetzt hier irgendjemand eine ankommt.

01:35:47.000 --> 01:36:03.000
Also man greift normalerweise... Also man macht sowas im Startup schon mal gar nicht. Man greift im Startup nicht auf jeden Fall Static-Controller-mäßiges zu. Was übrigens gar nicht Static ist. Und man hat auch nicht unsafe code direkt im Startup. Aber who cares. Wir gucken einfach, dass das jetzt geht.

01:36:03.000 --> 01:36:18.000
So, Public. Man macht auch nicht Sachen zwischendrin. Einfach mal Public, weil man woanders drauf zugreifen will. Aber hier bleibt jetzt gar nichts anderes übrig. So, Connections. Bar. Und dann hier alle Values. Alle WebITC Connections.

01:36:18.000 --> 01:36:35.000
Prime1994. Dankeschön. Big Brain. Massive Sub. So, und PC. Things Connection. Ach nee, ich brauch den Track. Ich brauch den... Nee, guck mal, was ist das? Send JPEG Frame.

01:36:35.000 --> 01:36:55.000
Oh, das ist ja cool. Ey, das ist nice. Ich wusste gar nicht, dass man über WebRTC JPEG Frames übertragen kann. Das ist richtig nice, wenn das funktioniert. Weil dann kann ich auch Motion JPEG unterstützen. Das ist nice.

01:36:55.000 --> 01:37:18.000
So, Send Audio Video. Was haben wir denn? Send H264 Frame. Duration Payload. Keine Ahnung. Duration RTP Units. Was sind Duration RTP Units?

01:37:18.000 --> 01:37:33.000
Sind das Timestamps? Sind das einfach nur Timestamps? Duration Add. Oder ist das wie lang ein einzelnes Schnipsel ist?

01:37:33.000 --> 01:37:51.000
Was ja im Endeffekt... Letzter Timestamp minus aktueller Timestamp. Ich hab keine Ahnung. Ich übergebe da einfach mal den Timestamp und hoffe, dass es funktioniert. Und zwar den Presentation Timestamp.

01:37:51.000 --> 01:38:10.000
Pts. Vielleicht wäre es besser, wenn ich den DTS nehme. Äh, warum geht das nicht? Was ist das? Ein Long? Long. Ah, komm, easy. Uint. Wir casten das einfach mal ein gutes.

01:38:10.000 --> 01:38:22.000
So, Bites. Ok. Jetzt wird es kriminell. Wie mein Opa gesagt hätte. Der übrigens nicht kriminell war. Aber das war so eine Standardredewendung von ihm. Dann immer gesagt, jetzt wird es kriminell.

01:38:22.000 --> 01:38:43.000
Ähm. Data. Ich kann jetzt ja nicht einfach einen Raw-C-Pointer an diese Funktion übergeben. Das funktioniert ja nicht. Ähm. Ich muss dieses Raw-Pointer-Ding... War mein Opa auch Programmierer? Nein. Mein Opa war Elektrotechniker.

01:38:43.000 --> 01:38:56.000
Also der hätte das hier mit Steckdosen garantiert besser hingekriegt, wie ich daheim. Wir müssen dieses Raw-Bite-Array in ein.NET-Array konvertieren.

01:38:56.000 --> 01:39:18.000
Wir haben hier, es gibt hier die Size davon. Wir können, wir können ein neues.NET, wir können ein neues.NET-Feature verwenden. Und zwar, die haben jetzt in einer letzten, letzten.NET-Version sowas hier eingeführt. Das ist quasi ein Managed, so eine Art, wenn ich das richtig verstanden habe, so eine Art Managed-Pointer auf Raw-Memory.

01:39:18.000 --> 01:39:40.000
Ich hab's noch in keinem Projekt bisher verwendet. Aber dem kann man, ach guck mal, dem kann man einen Pointer übergeben und eine Size. Wunderbar. Genau das brauchen wir. Pointer-Size. Ähm. Mem. Wie auch immer, ich's anders nennen soll.

01:39:40.000 --> 01:40:00.000
So, und kann man daraus jetzt ein Byte-Array machen? Jawoll. Da. Manchmal lohnt sich Webcasts angucken. Excellent. So. Jetzt ist die Frage, ob es crashed. Gucken wir mal. Gucken wir mal, ob es crashed.

01:40:00.000 --> 01:40:17.000
Ähm. Ich muss gucken, dass es noch läuft. Wie guck ich denn, dass es läuft am besten? Ich, ich geb einfach, ich geb, okay, wir machen hier irgendwie mal sowas wie, so keine Ahnung. Und die, bröh, geht sofort. Wir machen irgendwie Cent oder so, schreiben wir mal rein.

01:40:17.000 --> 01:40:36.000
Moment, was ja nicht funktionieren wird, weil, okay. Cent eins und Cent zwei. Okay. Weil die Schleife läuft ja erst, wenn ich mich mit dem Browser registriert hab. Okay. Cent eins funktioniert.

01:40:36.000 --> 01:40:46.000
Äh, wir, wir, okay, wir geben nicht Cent aus, wir geben den Presentation Timestamp aus. Excellent Logging. Ja, richtig. Das ist Next Level Logging hier, was man hier sieht.

01:40:46.000 --> 01:41:14.000
Ah, yes. Ähm, choose my name. Deswegen finde ich, ist C-Sharp eines der besten Sprachen überhaupt. Nicht nur, weil ich die Sprache an sich gut finde, sondern weil die es konstant schaffen seit 15 Jahren, nicht so eine Scheiße zu bauen, wie der C++ Standard, sondern neue Sachen auch zu verbessern und nicht einfach zu sagen, ah ja gut, wir haben jetzt 30 Mal das Gleiche drin.

01:41:14.000 --> 01:41:29.000
Neue Sachen zu verbessern und die, die schaffen seit 15 Jahren sinnvolle Sachen in die Sprache einzubauen, die gut zu der Sprache passen und die Sprache ergänzen. Also da müsste sich das C++ Gremium echt mal eine Scheibe von abschneiden.

01:41:29.000 --> 01:41:49.000
Aber wisst ihr was das Gute ist? Noch crasht nichts. Noch crasht nichts. Aber noch hab ich ja auch den Browser nicht aktualisiert. Also von der Idee her, ich aktualisiere jetzt den Browser. Wenn ich den Browser aktualisiere, registriert er eine neue Verbindung und er sollte was an diese Verbindung schicken, was aber noch nicht funktionieren kann.

01:41:49.000 --> 01:42:12.000
Okay, okay, aber er sendet schon mal, er sendet schon mal Sachen theoretisch an den Browser. Der Browser empfängt aber noch nichts. Auch nicht, weil ich hab das noch nicht verknüpft. Aber er kriegt das zumindest schon mal mit.

01:42:12.000 --> 01:42:32.000
Okay, das heißt jetzt muss ich doch eigentlich nur noch den Videoplayer mit dem Stream verknüpfen. Geht der RAM-Verbrauch hoch? Das ist eine gute Frage, das sieht man nicht so ohne weiteres, weil ich mich voll spamme mit. Wo ist der RAM-Verbrauch?

01:42:32.000 --> 01:42:51.000
Wo ist der RAM-Verbrauch? Wo ist der RAM-Verbrauch? Da! Nee, der RAM-Verbrauch scheint konstant zu bleiben. Okay, schauen wir mal. Also, jetzt verknüpfe ich mal den Videoplayer mit meinem WebRTC-Backend.

01:42:51.000 --> 01:43:13.000
Also, wenn das gehen würde, erstens verschenke ich ein paar Subs, weil ich nicht davon ausgehe. Und zweitens wäre das richtig geil, weil das hier ist mega übersichtlicher kurzer Code für das ganze WebRTC-Zeug. Ich hab allein 400 Zeilen Go für den ganzen WebRTC-Krempel.

01:43:13.000 --> 01:43:28.000
Okay, das macht auch noch ein bisschen mehr, das Go-Gedöns. Aber allein schon das Handling für Verbindungsaufbau und hin und her schicken sind schon wahrscheinlich 200 Zeilen.

01:43:28.000 --> 01:43:43.000
So, also, jetzt muss ich ihm noch sagen, dass er den Videostream an den Videoplayer attachen soll. Also, das ging, wenn ich das...

01:43:43.000 --> 01:43:59.000
Das machen wir ganz hier oben. Man musste dem in Callback einstellen, und zwar Track, irgendwas mit Track. On Track, genau.

01:43:59.000 --> 01:44:14.000
Äh, äh, im Moment, wie ging das Track so? Nee, im Moment, wie macht man das in JavaScript? Event, sagt man, event. Oder das ist wahrscheinlich schon gleich der Track. Wir gucken mal, ob da überhaupt irgendwas ankommt.

01:44:14.000 --> 01:44:28.000
Ja, Track-Event. Okay, Track-Event. Source-Element, Stream.

01:44:28.000 --> 01:44:44.000
Äh, das muss ich jetzt mal kurz abgucken, wie man das, wie man das, äh, attacht. So, okay, also, wir brauchen, wir brauchen auf jeden Fall schon mal das Player-Element. Also, Document, Get-Element, Player.

01:44:44.000 --> 01:45:06.000
So, und jetzt weiß ich nicht, wie ich dort irgendwas attache. Player, sowas wie Source, äh, nee, url, url bringt nichts, ähm, wie, wie übergebe ich einem HTML, wie übergebe ich einem HTML-Player-Element das Source?

01:45:06.000 --> 01:45:18.000
Ich könnte nachgucken, wie ich das bei dem anderen gemacht hab. Aber ich glaube, Google ist schneller. Video, HTML, äh, Source, irgendwie so.

01:45:18.000 --> 01:45:36.000
Okay, gibt's da ein Beispiel? Video, Player, Player, Source, nee, das Kackseite.

01:45:36.000 --> 01:46:04.000
What? Source-Object, Stream. Okay, Player, Source, Ob, gibt's net. Naja, einfach mal dran zur, und jetzt einfach minus Track oder Streams?

01:46:04.000 --> 01:46:09.000
Genau, das kenn ich noch. Genau, Streams Null musste man machen. Jaja, genau. So.

01:46:16.000 --> 01:46:32.000
WTF? Loll, das kam jetzt unerwartet. Das kam jetzt unerwartet. Das funktioniert. Easy, easy as fuck.

01:46:32.000 --> 01:46:38.000
Easy as fuck? Ich wusste von Anfang an, dass das klappt. Mir war das direkt klar, dass das direkt funktioniert.

01:46:38.000 --> 01:47:01.000
Das geht einfach. Wisst ihr, wie lang ich mich abgemüht habe mit dieser Go-Lösung bis, bis ein einfaches, ihr könnt euch vielleicht an den Stream erinnern, bis ein einfaches Test, oh, es ruckelt.

01:47:01.000 --> 01:47:15.000
Es ruckelt, Leute, es ruckelt. Das Video freest. Oh, oh je, MonkaS. Das Video freest zwischendurch. Ja, gut, scheiß drauf, man kann nicht alles haben.

01:47:16.000 --> 01:47:28.000
Was sagt denn der RAM-Verbrauch? Äh, da sind bestimmt, schau mal das Memory, ich würd mir das Memory gerne anschauen, aber äh, ja, ich hab zu viel D-Bank-Ausgabe.

01:47:28.000 --> 01:47:37.000
Wo ist das Memory? Warte, wo ist das Memory, easy? Wo ist das Memory, wo ist die Memory aus? Ich mach mal die D-Bank-Ausgabe kurz aus, das ist ein bisschen viel.

01:47:39.000 --> 01:47:50.000
Äh, beste Antwort, ihr wollt, ich mach den ganzen Krams mal aus. Ähm, Moment, wo sind wir denn hier, da? Ah, es kommt, es kommt mal alles weg, alles weg.

01:47:50.000 --> 01:47:58.000
Alles weg, alles weg. Oh, ich starten. Neko Rock, 14 Monate, Dankeschön. Die Subs gibt's übrigens gleich, Leute.

01:47:59.000 --> 01:48:14.000
Neko Rock. Big Brain Subscription. Gleich gibt's die Subs. So, 149 MB Verbrauch. Jetzt erst mal neu laden, das Video. Das funktioniert einfach, ich fass es nicht.

01:48:14.000 --> 01:48:36.000
Ich fass es nicht. Das funktioniert einfach, das Videostream. Äh, aber wir können auch gar nicht so viel Memory leaken, das ist ein, keine Ahnung, 360 x 240 Video oder so, das kann, selbst wenn das Memory leakt, merk ich das erst in einer halben Stunde wirklich nennenswert.

01:48:36.000 --> 01:48:48.000
Nennenswert. So, ja nice, nice, nice, nice, nice, das funktioniert. Extrem poggers ist das. Da reicht poggers, da muss der französische poggers ran.

01:48:48.000 --> 01:49:04.000
First Mal 4K Videos anmachen. Ihr hat einen RTSP Test Stream? Meine Kameras will ich nicht reinmachen. Erstens liege ich dann vielleicht was. Doch, ich weiß, was ich mach. Die iPhone Kamera. Ich mach die iPhone Kamera an.

01:49:04.000 --> 01:49:21.000
Äh, oh Moment, wo hab ich mein iPhone? iPhone? Wo hab ich mein iPhone? Ah, hier. Ich mach die iPhone Kamera an, die ich immer oben rechts in der Ecke hab. Die guck mal, Moment, das mach ich jetzt mal schnell.

01:49:21.000 --> 01:49:33.000
iPhone Kamera oben, iPhone Kamera einschalten. Mal gucken, ob das das frisst. Kamera, zack.

01:49:33.000 --> 01:50:01.000
Okay. Also wenn jetzt alles funktioniert, müsstet ihr gleich mal den Raspberry Pi sehen. Gucken wir mal. Äh, aber da brauchen wir eine andere, andere Ural RTSP.

01:50:01.000 --> 01:50:18.000
Mein iPhone ist 122161.110. 554 ist die Fallport RTSP. So, mal gucken.

01:50:18.000 --> 01:50:38.000
Oh, aber Connected, Connected ist das schonmal. So, das ist die iPhone Kamera. Da ist einfach, da ist einfach der Raspberry Pi. Oh, einfach, zwar übel schlechte Beleuchtung und in der letzten Ecke wieder, wo die Kamera hängt, aber da ist einfach mal der Raspberry Pi da.

01:50:38.000 --> 01:50:54.000
Äh, wir gucken mal, wie viel Verzögerung das Ganze hat. Übrigens, ich weiß auch, ich hab's hochgekannt, ist egal. Moment, ich mach mal kurz die Hand hin und her. Was ist denn das?

01:50:54.000 --> 01:51:03.000
Was ist denn das? Oh, äh, was ist das?

01:51:03.000 --> 01:51:30.000
Das sieht nicht gut aus, aber nachdem ich schon ein bisschen was mit Audio und Video gemacht hab, sieht das für mich so aus. Das ist nicht so viel für die VF1. Es werden nur die Keyframes angezeigt.

01:51:30.000 --> 01:51:44.000
Das sieht für mich aus, als wären es nur die Keyframes, die angezeigt werden und die dazwischen nicht. Wisst ihr, was das ist? Wisst ihr, was das ist? Das ist genau das, was ich vorhin erzählt hab. Wollen wir mal wetten, das ist genau das.

01:51:44.000 --> 01:52:11.000
Wollen wir mal wetten, das ist genau das. Okay Leute, noch mal, also fünf Gifted-Sub sind schon mal sicher für die ganze Geschichte, die ich hier jetzt, äh, dass es einfach so funktioniert hat. Aber ich gifte noch mal, ich gifte noch mal ein paar, wenn das jetzt stimmt, weil ich vermute, nämlich, ich glaube, jetzt kommt genau das klei, jetzt ist wirklich genau das Problem, was ich vorher angesprochen habe, das ist gut, dass ich das drin gelassen hab, in weißer Voraussicht schon.

01:52:11.000 --> 01:52:33.000
Ich glaube, die Frames kommen in der falschen Reihenfolge. Also was heißt in der falschen Reihenfolge? Die Frames, wie sie decoded werden und wie ich sie anzeigen muss, kommen, also die muss ich erst noch selbst in die richtige Reihenfolge sortieren, wahrscheinlich, weil die iPhone-Kamera-App scheiße ist. Gucken wir mal, ob das stimmt.

01:52:33.000 --> 01:53:00.000
Was? Ja, guckt. Die, die Coding und Presentation Timestamps sind anders. Manchmal, manchmal sind sie gleich, das ist wahrscheinlich ein Keyframe oder so, wenn die gleich sind. Das heißt, ich müsste diese

01:53:00.000 --> 01:53:14.000
sortieren. Oh nee, da habe ich jetzt keinen Bock drauf. Da habe ich jetzt, da habe ich jetzt keinen Bock drauf. Oder ich nehme die Coding, ich nehme einfach die Coding Timestamps und gucke mal, ob es dann funktioniert. DTS.

01:53:14.000 --> 01:53:29.000
Beträgst du das über W-Lan? Klar. Mit DTS könnte es sogar sein, dass es schon funktioniert, weil die sind ja immer aufsteigend.

01:53:29.000 --> 01:53:48.000
Ey, das ruckelt immer noch, Leute, das ruckelt immer noch. Guck mal hier.

01:53:48.000 --> 01:54:02.000
Es ruckelt immer noch. Okay, nee, da bin ich zu low-brain heute Abend dafür, das zu fixen.

01:54:03.000 --> 01:54:16.000
Also das Problem ist tatsächlich, dass die Coding Timestamps und die Presentation Timestamps, die stimmen nicht überein. Das heißt, also von der Theorie her, was ich machen müsste, wäre, ich müsste mir so einen

01:54:16.000 --> 01:54:31.000
Buffer, ich müsste mir einen Buffer anlegen, indem ich die Frames speichere für, sagen wir mal, 2 Sekunden. Und solange warte ich halt, bis ich den nächsten passenden Presentation Frame habe oder so.

01:54:31.000 --> 01:54:50.000
Mach doch ein einfaches If, wo du die größeren ausgibst. Okay, dann ruckelt es aber wahrscheinlich immer noch. Hast du das auf GitHub? Nee, das habe ich gerade hier im Stream erstellt.

01:54:50.000 --> 01:55:02.000
Dann habe ich Delay, doch, doch, doch. Nee, das mache ich jetzt, ich kann das, wir machen im nächsten Stream da mal ein bisschen weiter dran, dann kann ich es auf GitHub pushen.

01:55:03.000 --> 01:55:15.000
Oder, oder, Kengin, willst du jetzt irgendwie da dran mitwursten? Ich mache es nicht auf GitHub, weil das komplett random zusammengewurstet ist, ich kann es dir auf Pastebin machen.

01:55:15.000 --> 01:55:21.000
So, das ist eine gute Idee, probieren wir jetzt mal kurz aus, was hier jemand vorgeschlagen hat, und zwar.

01:55:32.000 --> 01:55:38.000
Also ich kann es, nee, ich würde es sogar auf GitHub machen, aber ich kann es nicht auf GitHub von hier pushen. Ich bin ja gar nicht eingeloggt auf GitHub.

01:55:38.000 --> 01:55:48.000
So, aber wir können die Billig-Variante wirklich mal ausprobieren, irgendwie. Was machen wir da? Last TS oder so, Null.

01:55:48.000 --> 01:56:17.000
So, und jetzt sagen wir, wenn, was machen wir da jetzt, was machen wir da jetzt, also wenn, PTS, if, if, Moment, Package, PTS kleiner, gleich dem, ups, dem letzten ist.

01:56:18.000 --> 01:56:45.000
Dann machen wir nicht weiter. So. So, und jetzt müssen wir noch das setzen. Sagt mir, wenn ich Mist bastle. So. Ah nee, das muss ein Uint sein.

01:56:45.000 --> 01:57:00.000
Aber das wird auch nicht dazu führen, dass es besser funktioniert, weil er überspringt ja immer noch Frames. Ah nee, long muss das sein. So, ergibt das hier irgendwie Sinn?

01:57:00.000 --> 01:57:21.000
Wollen wir hier nochmal abbrechen? Wo habe ich denn diese Ausgabe mit den Timestamps? Moment. Oh, wo habe ich es denn hier? Da. Brauche ich noch mal.

01:57:21.000 --> 01:57:38.000
Jetzt gucken wir mal. Stimmt, ich könnte es nochmal als Release kompilieren. Ich glaube nicht, dass es einen großen Unterschied macht.

01:57:38.000 --> 01:57:57.000
So, jetzt stimmt der Kram zwar immer noch nicht miteinander, aber es sind nur die größeren. Nee, ich glaube nicht, dass es einen Unterschied macht, weil das ist ja kein Performance Problem.

01:57:57.000 --> 01:58:14.000
Das ist ja ein Problem, dass die Frames in der unterschiedlichen Reihenfolge geschickt werden. Wenn es schneller ist, ist es vielleicht sogar noch mehr kaputt.

01:58:14.000 --> 01:58:26.000
Das war eine sehr gute Idee, Chat. Das war eine sehr gute Idee. Es ist immer noch nicht ganz flüssig, es fehlen immer noch Frames. Nee, nee, es fehlen immer noch Frames.

01:58:27.000 --> 01:58:38.000
Aber, okay, wir gucken mal, wie die Verzögerung ist. Moment. Es ist wirklich verdammt wenig Verzögerung. Ich muss euch, wie zeige ich euch am besten, wie die Verzögerung ist.

01:58:38.000 --> 01:58:50.000
Ich mache mal irgendein Geräusch, ich mache mal irgendein Geräusch, so hier. Irgendwie, so, Moment. Ich lege euch mal kurz das Handy neben dran, das Mikrofon hier so neben dran.

01:58:50.000 --> 01:59:19.000
So. Und jetzt mal muss ich mal irgendwie krach machen, so, keine Ahnung. Na, kaum Verzögerung, Leute. Habt ihr es gehört?

01:59:20.000 --> 01:59:31.000
Ja, wenigstens 200 Millisekunden. Leute, wollt ihr mich verarschen? Was interessieren mich 200 Millisekunden? 200 Millisekunden ist nichts für den Übertragungsweg, den das Ganze nimmt.

01:59:32.000 --> 01:59:44.000
200 Millisekunden ist Pock. Ihr werdet kein Video schneller jemals im Browser gesehen haben wie das. Ach so, weniger als, ach ja, sorry. Ich hab mich verguckt.

01:59:44.000 --> 01:59:59.000
Ich hab so gelesen, wie ja, wenigstens 200 Millisekunden, so als wäre das jetzt viel gewesen. Dabei ist das überhaupt nicht viel, aber das ist richtig, richtig nice. Ja, also, äh, Elsa hab ich falsch gelesen.

01:59:59.000 --> 02:00:17.000
Aber exzellent, wie gut das funktioniert. Jetzt mal ordentlich in Go. Nee, warum ich es nicht in Go mache, unter anderem liegt daran, weil C und Go Interop nicht so dolle ist.

02:00:17.000 --> 02:00:29.000
Gerade mit Callbacks aus C raus, das ist richtig eklig. Und, ähm, weil ich Web-Anwendungen am einfachsten in ASP.NET mit dem Backend machen kann, weil ich mich damit am besten auskenne.

02:00:29.000 --> 02:00:47.000
Ich bau da mal was. Mach, mach du mal. Vielleicht, also, vielleicht haben wir ja Glück. Vielleicht krieg ich ja diesmal wirklich was lauffähiges raus, was ich, ähm, auch mal auf Githa pushen kann.

02:00:47.000 --> 02:01:02.000
Und vielleicht haben wir dann Glück und die ein oder andere Leute aus dem Chat beteiligen sich daran, dort was ordentliches dran zu bauen. Also, zusammen, so.

02:01:02.000 --> 02:01:16.000
Okay, ich gucke mal, wie ich das jetzt, ich bin, ich bin hier nicht, bin ich hier irgendwie auf Github eingeloggt? Ich glaube nicht. Kein Github login. Bin ich hier auf Github eingeloggt?

02:01:16.000 --> 02:01:40.000
Kein Github login. Okay, wie krieg ich denn das jetzt auf Github? Ich bin auch am zweiten Rechner in Github eingeloggt. Github Sealer, ich hab doch keinen Account hier drauf.

02:01:40.000 --> 02:01:56.000
Okay, wir machen erstmal einen Commit. Es ist aber halt so eklig, Alter. Eigentlich will ich das gar nicht pushen. Hast du den Key hinterlegt?

02:01:56.000 --> 02:02:09.000
Nee, nee, wahrscheinlich nicht. Ich hab auf dem Streaming-Rechner nix drauf, weil ich nicht aus Versehen irgendwelche Sachen leaken will oder so.

02:02:10.000 --> 02:02:13.000
Okay, ich gucke mal, wie ich das auf Github irgendwie kriege.

02:02:13.000 --> 02:02:28.000
Hast du einen lokalen Git-Server? Ja, hab ich. Okay, aber ist aber so, ich hab jetzt hier auf jeden Fall nichts geleaktes in irgendeiner Art und Weise drinne. Ich mach mal, ich mach erstmal einen Git-Commit.

02:02:28.000 --> 02:02:48.000
Ja, Twinker, ist klar. Erstmal schön alle private Keys raushauen. Git-Init, Git-Status, wir machen mal ein schönes Git-Commit. Achso, Moment.

02:02:48.000 --> 02:03:05.000
Gap's da nicht ne coole Seite für Git-Ignore? Da gab's doch so nen Web-Service, wo man Git-Ignore Sachen... Nee, nee, ich mach nicht Minus-A. Ich will mal ein Projektfolder raus und die Binaries raus und sowas.

02:03:05.000 --> 02:03:20.000
Git-Ignore.io, was? Git-Ignore.io. Äh, C-Sharp. Nee, Moment.

02:03:20.000 --> 02:03:46.000
Was? Was macht das? Ah. Ah ja. Nee, das ist für Rider nicht... Ich mach's mal kurz von Hand. Also, Git-Ignore. Also, ähm, der da kommt raus. Ups.

02:03:46.000 --> 02:03:50.000
Äh.

02:03:50.000 --> 02:04:16.000
Wenn man es im richtigen... Git-Ignore, so. Der da kommt raus und, ähm, und der Bildordner kommt raus. Monarch-S, Bin und Objects können wir noch raus machen, ne?

02:04:16.000 --> 02:04:32.000
Bin und Objects raus. So, ich glaub, das reicht.

02:04:32.000 --> 02:04:46.000
Ja, ja, ja. Äh.

02:04:46.000 --> 02:05:02.000
So, ich hoffe, das ist jetzt richtig, dass ich nicht zu viel einchecke. Also, Git-Add, Git-Status, was hat er jetzt alles einge... Genau, ok, der hat den ganzen Müll rausgelassen. Alles klar, sehr gut.

02:05:02.000 --> 02:05:18.000
Git-Commit, A-M-Init, Git-Git-Log. Ok, ich versuche mal nebenbei, äh, ich leg mal bei GitHub ein neues Projekt an. Hoffentlich bin ich hier noch eingeloggt. Auf dem anderen Pro... Oh fuck, ich bin hier auch nicht eingeloggt.

02:05:18.000 --> 02:05:37.000
Äh. Ähm. Ok. Hab ich GitHub, zwei Faktor-Authentifizierung? Dann log ich mich jetzt hier mal ein. Ich guck mal kurz nebenbei in mein Keypass, was mein GitHub für einen Account hat.

02:05:37.000 --> 02:05:52.000
Git-Hoop. Also. Wir haben Wubblons.

02:05:52.000 --> 02:06:07.000
At gmx.de. Das ist keine geheime Adresse, die steht sogar im Profil. Ach ne, Moment, äh, äh, Sign-In.

02:06:07.000 --> 02:06:35.000
Äh, Passwort. Kacke. Chat, ich mach euch mal kurz aus, da muss ich nicht so viel gucken, ob ich jetzt irgendwas leake oder nicht.

02:06:35.000 --> 02:06:49.000
Ich glaube, ich hab mittlerweile eh zwei Faktor-Authentifizierung. Ja, two Factor-Authentifizierung. Das heißt, es ist eh egal, ob ich was leake. Lul.

02:06:50.000 --> 02:07:02.000
Verify. Ok. Alles klar.

02:07:02.000 --> 02:07:17.000
Mal die Vice-Capture wieder an. Gut, äh, Create. New repo. So, wie nennen wir's? Monarch-S passt wunderbar. Description.

02:07:17.000 --> 02:07:32.000
Check-W-Tests. Nur gepusht, weil mich der Chat sonst geflamed hätte. So. Ai, ai, ai.

02:07:32.000 --> 02:07:49.000
So, ähm, Public. Read me. Alles klar. Choose. Create. So, das da. Äh, Moment, hier, da sind wir.

02:07:49.000 --> 02:08:05.000
Get add. Äh, Main. Geh mal fort. Zu, Lul. Nein, nein, nein, nein. Das Ding, also, Inclusiveness hin oder her. Das Ding heißt bei mir weiter Master.

02:08:05.000 --> 02:08:22.000
Nicht Main. Nein, nein, nein. Master. Ok, also.

02:08:22.000 --> 02:08:45.000
Bobloids. Add gmx.de. Passwort. Wollen mal kurz ins Fullscreen machen wieder.

02:08:45.000 --> 02:09:11.000
Fuck. Was? Bei mir verschrieben. Hä?

02:09:11.000 --> 02:09:27.000
Ist das ohne Adresse? Moment, ist, ist Username? Ach nee, ist das, ah, Moment. Ah, es ist ohne E-Mail-Adresse.

02:09:27.000 --> 02:09:42.000
Es ist ohne E-Mail-Adresse. Siehst du mal, wie oft ich mich da einlogge? Ich logge mich eigentlich so gut wie nie ein über, über HTTP-Authentifizierung. Bobloids ist es. Genau. Das ist richtig. Genau.

02:09:42.000 --> 02:10:04.000
What the fuck? Äh. Geht das nicht wegen Zwei-Faktor-Authentifizierung?

02:10:04.000 --> 02:10:20.000
Kann das sein, dass es wegen Zwei-Faktor-Authentifizierung nicht geht? Mit, mit Login hier. Muss ich über SSH Key machen?

02:10:20.000 --> 02:10:34.000
Ok, Moment. Ich adde mal mein SSH Key von AVM. Dann mach ich euch mal kurz aus, weil ich nicht aus Versehen irgendwelche Sachen leaken will.

02:10:34.000 --> 02:10:51.000
Äh, your profile? Äh, SSH, Moment. Wo waren die Edit Profiles? Nee, wo waren nochmal die SSH Keys versteckt? Settings irgendwo, ne? Settings, SSH Keys, genau.

02:10:51.000 --> 02:11:11.000
Ich hab den Key sogar schon hinterlegt. Passt. Ich hab den Key schon hinterlegt. Was im Endeffekt heißt, ich müsste das eigentlich pushen können, aber ich hab das falsche Remote dafür drinne.

02:11:11.000 --> 02:11:31.000
Ähm, gut, dann ändern wir das Remote nochmal. Rider ONAK-S. Remote. Ok, Git, Remote. Äh, konnte man das irgendwie umbenennen?

02:11:31.000 --> 02:11:51.000
Rename Z-Ul. Genau. Nee, da muss man Remote Z-Ul und da muss man glaub ich den Name machen. Origin und dann die neue Ul. Ähm, die neue Ul ist Git-Doppelpunkter.

02:11:51.000 --> 02:12:15.000
Ah, hier guck mal da. So. Ok, push. Yes. Ah, yes. Exzellent. Da sind wir. Leute, also, nur gepusht, weil mich sonst der Chat geflamed hätte. Ah, ja, ja.

02:12:15.000 --> 02:12:35.000
Da ist es. Exquisite high quality HTML und äh, state of the art best practice, ähm, ASP.NET Core Anwendung mit unsafe code und ähm,

02:12:35.000 --> 02:12:47.000
irgendwelchen komischen Background-Tasks im Startup. Beste. So, so solltet ihr das machen. Ist da Tommy K. eigentlich da? Wie lief's da mit der Bewerbung?

02:12:48.000 --> 02:12:58.000
Ich hab irgendwas im Discord gesehen, aber ich würde mir interessieren, was da rausgekommen ist. So, Chat. Also, wir haben noch einen Bug.

02:12:58.000 --> 02:13:08.000
Also, vielleicht ist ja einer Big Brain von euch und kann hier irgendwie das Reordering programmieren. Also, hier an der Stelle,

02:13:08.000 --> 02:13:30.000
man, wie konnte man, konnte man so kommentieren oder konnte man nur mit einem Issue kommentieren? Nee, einfach so kommentieren geht nicht, ne?

02:13:30.000 --> 02:13:52.000
Ähm, Frames sind in falscher Reihenfolge. ETS, PTS. So. Wenn, wir machen's mal auf Deutsch.

02:13:52.000 --> 02:14:20.000
Genau. So. Excellent. Da ist es. Okay, ähm, ja, vielleicht, vielleicht hat ja einer Zeit

02:14:20.000 --> 02:14:31.000
und Muße, sich da Sachen mal zu widmen. Der beste Projektname übrigens hier wieder, ne?

02:14:32.000 --> 02:14:41.000
Erstmal, Monarch S. Ich kenn mich, ich werd das nie umbenennen. Also, Chat, vielleicht kriegen wir's echt gebacken.

02:14:41.000 --> 02:14:51.000
Also, wenn, wenn von euch ein paar Leute Interesse haben, daran mitzubasteln, das Ziel der ganzen Sache ist, erstens, dass man,

02:14:52.000 --> 02:14:57.000
relativ Latency-free, ich könnte hier, also, wenn wirklich ein paar mitmachen, weil ich kann da ne ReadMe erstellen,

02:14:58.000 --> 02:15:05.000
also, ähm, das soll Latency-free Video in Browser kriegen und auf lange Sicht will ich damit halt mal ne halbwegs benutzbare

02:15:05.000 --> 02:15:13.000
Video-, also, Überwachungskamera-Software basteln. Ja, ne, es ist 2114, ich geh jetzt gleich ins Bett.

02:15:14.000 --> 02:15:23.000
Also sprich, ähm, Recorden ins File, das kann meine andere schon, äh, und eine der wichtigsten Sachen ist kein Re-encoding.

02:15:24.000 --> 02:15:29.000
Kein Re-encoding. Schau mal in GRPC rein, ich weiß, was es ist, ich wüsste jetzt nicht, was es mir hier bringt.

02:15:29.000 --> 02:15:38.000
Ähm, kein Re-encoding, also sprich, ich will den Stream von der Kamera nehmen, in den Browser pumpen oder vielleicht in ein File schreiben.

02:15:39.000 --> 02:15:45.000
Kein Re-encoding. Re-encoding ist so ein optionales Ding, da würde ich drüber nachdenken, wenn wir mal irgendwas haben, was stabil funktioniert.

02:15:46.000 --> 02:15:49.000
Weil eines der Features, die ich hier haben will, ist, ich will nichts re-encoden.

02:15:50.000 --> 02:15:54.000
Ich will einfach nur den Stream nehmen, von der Kamera und in den Browser packen.

02:15:54.000 --> 02:15:59.000
Das hat den Vorteil, man braucht überhaupt keine Leistung, ich mein, guckt euch das mal an.

02:16:00.000 --> 02:16:04.000
Ähm, ich, ich, ich starte das Kart noch mal, hier, Run.

02:16:09.000 --> 02:16:11.000
Ich starte das Kart noch mal.

02:16:13.000 --> 02:16:15.000
So, Run, hier, anmachen.

02:16:19.000 --> 02:16:21.000
Ups, ah.

02:16:21.000 --> 02:16:23.000
Ja, gut, ähm.

02:16:25.000 --> 02:16:27.000
Das bringt jetzt nicht viel, zu gucken.

02:16:27.000 --> 02:16:30.000
Ähm, aber, wenn ich jetzt, ah, warte.

02:16:32.000 --> 02:16:34.000
Das braucht nix.

02:16:39.000 --> 02:16:41.000
Ups, drottnet.

02:16:42.000 --> 02:16:45.000
Boah, das ist, das braucht, das braucht nichts an CPU-Leistung.

02:16:46.000 --> 02:16:47.000
Um das zu streamen.

02:16:47.000 --> 02:16:51.000
Würde der re-encoden, wäre das ein bisschen mehr.

02:16:52.000 --> 02:16:55.000
Und das ist grad der Sinn und der Zweck der Sache, der re-encoded nix.

02:16:56.000 --> 02:17:00.000
Ähm, was dann richtig pro wäre, wenn wir irgendwann es schaffen würden.

02:17:01.000 --> 02:17:05.000
Das habe ich ja schon überlegt und auch schon mal angefangen vor einer Weile so was zu bauen.

02:17:06.000 --> 02:17:12.000
Ähm, man könnte, wenn man eben möchte, der Vorteil davon, wenn man nicht re-encoded ist,

02:17:12.000 --> 02:17:20.000
du kannst auf dem Raspberry Pi das laufen lassen, auf dem Raspberry Pi mit, keine Ahnung, 30 Videokameras.

02:17:21.000 --> 02:17:23.000
Überhaupt kein Problem, weil es eben nicht re-encoded.

02:17:24.000 --> 02:17:32.000
Wenn ihr Software verwendet, die die Sachen decoded, encoded, da ist mit 2, 3 Kameras auf dem Raspberry Pi spätestens Schluss.

02:17:33.000 --> 02:17:37.000
Selbst wenn man die Raspberry Pi Hardware-encoding, Decoding-Geschichte verwendet.

02:17:37.000 --> 02:17:43.000
So, was man noch machen könnte ist, man könnte hergehen und wenn man sagt, okay, man möchte ein bisschen Leistung opfern,

02:17:44.000 --> 02:17:51.000
man könnte jeden Keyframe decoden, so alle 2 Sekunden an ein Frame, schadet nix, jeden Keyframe decoden

02:17:52.000 --> 02:17:56.000
und dort drauf dann Object-Erkennung machen oder sowas.

02:17:57.000 --> 02:17:58.000
Aber das ist Zukunftsmusik.

02:17:59.000 --> 02:18:04.000
Also wer sich dazu berufen fühlt, ein bisschen mit rumzubasteln, äh, wäre nice, jetzt wo ich schon hochgeladen habe,

02:18:04.000 --> 02:18:13.000
denn vielleicht ist das ja für mich die Motivation, diese Software endlich mal ordentlich fertig nutzbar zu bauen,

02:18:14.000 --> 02:18:20.000
über den Status hinaus, dass ich sie bei mir einfach, also wisst ihr, ich benutze bei mir lokal auch unfertiges Zeug,

02:18:21.000 --> 02:18:22.000
was genauso viel enthält, wie was ich brauche.

02:18:23.000 --> 02:18:24.000
Aber für jemand anderes benutzbar ist es nicht.

02:18:25.000 --> 02:18:30.000
Bestes Beispiel ist hier mein Memboard für Bildchen und sowas, das funktioniert für mich wunderbar,

02:18:30.000 --> 02:18:33.000
aber in die Version könnte niemand anderes ordentlich bedienen.

02:18:34.000 --> 02:18:41.000
So und vielleicht, vielleicht wenn die ein oder andere mitmachen, habe ich die Motivation, endlich mal was Gescheites draus zu basteln.

02:18:43.000 --> 02:18:44.000
Mal gucken.

02:18:45.000 --> 02:18:55.000
Also Chat, machen wir Schluss, ich gehe ins Bett, ein nicer Stream heute, richtig viele da gewesen, für Programmer Stream, sehr nice.

02:18:55.000 --> 02:18:59.000
Ähm, wir sehen uns.

02:19:01.000 --> 02:19:07.000
Gifts, ach ne, wir sehen uns nicht, ich muss Saps giften, ich muss Saps giften, stimmt, Leute, das hätte ich ja fast vergessen.

02:19:08.000 --> 02:19:10.000
Ich gifte Saps, easy, wie ging das nochmal?

02:19:11.000 --> 02:19:13.000
Äh, Abos verschenken.

02:19:17.000 --> 02:19:19.000
So, hier 5 Stück, bam.

02:19:19.000 --> 02:19:24.000
Zwar, ich überweise quasi 12 Euro an Amazon, wenn man so will.

02:19:25.000 --> 02:19:28.000
So, mal Chat, mal Chat, mal gucken wer Glück hat.

02:19:29.000 --> 02:19:40.000
Aber ich bin der Meinung, Moment, fuck, aber ich bin der Meinung, das hätte sogar noch ein paar Prime Saps verdient heute.

02:19:40.000 --> 02:19:52.000
Any Primers, das hat so gut funktioniert und es ist echt ein Thema, wo es so gut wie nichts an Beispielprojekten gibt.

02:19:53.000 --> 02:19:55.000
Und das ist auch ein BigBrain Thema.

02:19:56.000 --> 02:20:01.000
Da könnte man schon mal den einen oder anderen Prime Sub noch dalassen, wenn man noch einen Prime Sub übrig hat.

02:20:02.000 --> 02:20:06.000
Nur mal so zur Information für alle, die es noch nicht mitgekriegt haben, wenn ihr einen Amazon Prime Account habt,

02:20:06.000 --> 02:20:14.000
könnt ihr das mit eurem Twitch-Account verknüpfen und dann könnt ihr einen Streamer einer Wahl einmal im Monat kostenlos mit einem Prime Sub unterstützen.

02:20:17.000 --> 02:20:19.000
So, wer hat denn was gekriegt?

02:20:20.000 --> 02:20:28.000
Captain Falcon, Ponky, MB-Dealer, Robot Town und Business Raster, exquisite.

02:20:28.000 --> 02:20:35.000
Wer hat schon Amazon Prime? Wahrscheinlich 90% der Leute, die zugucken am Amazon Prime.

02:20:38.000 --> 02:20:40.000
Sehr schön, sehr schön.

02:20:40.000 --> 02:20:52.000
Äh, Moment, was wollte ich jetzt nachgucken? Irgendetwas wollte ich gerade nachgucken. Achso.

02:20:52.000 --> 02:21:11.000
Achso. Hier. Hier ist es. Monarch S. Exzellent. Gut, wunderbar.

02:21:11.000 --> 02:21:22.000
Ah, nee, das ist, ich hab mich schon gefreut, das ist das Projekt-File. Ja klar, das braucht man.

02:21:23.000 --> 02:21:30.000
Man muss sich mal überlegen, das ist echt nicht übel. Wir haben hier insgesamt, das ist alles Müll, das braucht man nicht.

02:21:30.000 --> 02:21:46.000
Guck mal, wir haben 60 Zeilen HTML, 150 Zeilen C-Sharp. Das ist alles. Ach, nee. Und, okay, für 200 Zeilen C-Sharp, 60 Zeilen HTML.

02:21:47.000 --> 02:21:53.000
Also das ist wirklich top, da kann man echt nichts sagen. Also die Library scheint ihre Sache gut zu machen.

02:21:53.000 --> 02:21:59.000
Chat, wir sehen uns, nächster Stream, machts gut, bis dann, wir sehen uns, CU.

